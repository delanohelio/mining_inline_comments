{"pr_number": 2686, "pr_title": "Support servlet API", "pr_createdAt": "2020-05-03T08:35:47Z", "pr_url": "https://github.com/line/armeria/pull/2686", "timeline": [{"oid": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "url": "https://github.com/line/armeria/commit/2a9d3d0095bc106151ad97fa1427680e13a362aa", "message": "Rename module servlet to servlet4", "committedDate": "2020-07-27T04:51:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3NjE5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419276195", "bodyText": "Because this class is not used, could you remove this?", "author": "minwoox", "createdAt": "2020-05-04T08:16:47Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/AbstractChannelHandler.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.util.internal.TypeParameterMatcher;\n+\n+/**\n+ *  An abstract netty ChannelHandler.\n+ */\n+public abstract class AbstractChannelHandler<I,O> extends ChannelDuplexHandler {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/AbstractChannelHandler.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/AbstractChannelHandler.java\ndeleted file mode 100644\nindex 04be3de6ec..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/AbstractChannelHandler.java\n+++ /dev/null\n\n@@ -1,126 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import io.netty.channel.ChannelDuplexHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.util.internal.TypeParameterMatcher;\n-\n-/**\n- *  An abstract netty ChannelHandler.\n- */\n-public abstract class AbstractChannelHandler<I,O> extends ChannelDuplexHandler {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    private final TypeParameterMatcher matcherInbound;\n-    private final TypeParameterMatcher matcherOutbound;\n-    private final boolean autoRelease;\n-\n-    protected AbstractChannelHandler() {\n-        this(true);\n-    }\n-\n-    protected AbstractChannelHandler(boolean autoRelease) {\n-        matcherInbound = TypeParameterMatcher.find(this, AbstractChannelHandler.class, \"I\");\n-        matcherOutbound = TypeParameterMatcher.find(this, AbstractChannelHandler.class, \"O\");\n-        this.autoRelease = autoRelease;\n-    }\n-\n-    @Override\n-    public final void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n-        final boolean match = matcherInbound.match(msg);\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"ChannelRead({}) -> match({}) \",messageToString(msg),match);\n-        }\n-        if (match) {\n-            final I imsg = (I) msg;\n-            onMessageReceived(ctx, imsg);\n-        } else {\n-            ctx.fireChannelRead(msg);\n-        }\n-    }\n-\n-    protected void onMessageReceived(ChannelHandlerContext ctx, I msg) throws Exception {\n-        ctx.fireChannelRead(msg);\n-    }\n-\n-    @Override\n-    public final void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-        final boolean match = matcherOutbound.match(msg);\n-        if (logger.isDebugEnabled()) {\n-            logger.debug(\"ChannelWrite({}) -> match({}) \", messageToString(msg), match);\n-        }\n-        if (match) {\n-            final O imsg = (O) msg;\n-            onMessageWriter(ctx, imsg,promise);\n-        } else {\n-            ctx.write(msg, promise);\n-        }\n-    }\n-\n-    protected void onMessageWriter(ChannelHandlerContext ctx, O msg, ChannelPromise promise) throws Exception {\n-        ctx.write(msg,promise);\n-    }\n-\n-    @Override\n-    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n-        if (evt instanceof IdleStateEvent) {\n-            final IdleStateEvent e = (IdleStateEvent) evt;\n-            switch (e.state()) {\n-                case READER_IDLE:\n-                    onReaderIdle(ctx);\n-                    break;\n-                case WRITER_IDLE:\n-                    onWriterIdle(ctx);\n-                    break;\n-                case ALL_IDLE:\n-                    onAllIdle(ctx);\n-                    break;\n-                default:\n-                    break;\n-            }\n-        } else {\n-            onUserEventTriggered(ctx,evt);\n-        }\n-        ctx.fireUserEventTriggered(evt);\n-    }\n-\n-    protected void onUserEventTriggered(ChannelHandlerContext ctx, Object evt) {\n-    }\n-\n-    protected void onAllIdle(ChannelHandlerContext ctx) {\n-    }\n-\n-    protected void onWriterIdle(ChannelHandlerContext ctx) {\n-    }\n-\n-    protected void onReaderIdle(ChannelHandlerContext ctx) {\n-    }\n-\n-    /**\n-     * Class name of message.\n-     */\n-    public String messageToString(Object msg) {\n-        if (msg == null) {\n-            return \"null\";\n-        }\n-        return msg.getClass().getSimpleName();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3Nzk4OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419277988", "bodyText": "This could be final.", "author": "minwoox", "createdAt": "2020-05-04T08:20:24Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3ODEzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419278132", "bodyText": "It doesn't look nullable. Is it?", "author": "minwoox", "createdAt": "2020-05-04T08:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3Nzk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 37a4429d2d..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private ServletHttpExchange servletHttpExchange;\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            servletHttpExchange = ServletHttpExchange.newInstance(\n-                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n-            process(res);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3ODYzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419278631", "bodyText": "This must not be a field because of concurrency. How about just passing it when calling process method?", "author": "minwoox", "createdAt": "2020-05-04T08:21:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 37a4429d2d..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private ServletHttpExchange servletHttpExchange;\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            servletHttpExchange = ServletHttpExchange.newInstance(\n-                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n-            process(res);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI3OTIxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419279218", "bodyText": "We use of for this purpose.\nServletHttpExchange.of(...)", "author": "minwoox", "createdAt": "2020-05-04T08:22:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 37a4429d2d..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private ServletHttpExchange servletHttpExchange;\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            servletHttpExchange = ServletHttpExchange.newInstance(\n-                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n-            process(res);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MDMyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419280322", "bodyText": "We don't need to do the type-casting.", "author": "minwoox", "createdAt": "2020-05-04T08:25:02Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(\n+                    servletContext, (DefaultServiceRequestContext) ctx, aReq);", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 37a4429d2d..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private ServletHttpExchange servletHttpExchange;\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            servletHttpExchange = ServletHttpExchange.newInstance(\n-                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n-            process(res);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MDY5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419280698", "bodyText": "Let's handle a case where cause is not null.", "author": "minwoox", "createdAt": "2020-05-04T08:25:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 37a4429d2d..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private ServletHttpExchange servletHttpExchange;\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            servletHttpExchange = ServletHttpExchange.newInstance(\n-                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n-            process(res);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MjQ3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419282473", "bodyText": "Shouldn't we return here if dispatcher is null", "author": "minwoox", "createdAt": "2020-05-04T08:29:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private ServletHttpExchange servletHttpExchange;\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            servletHttpExchange = ServletHttpExchange.newInstance(\n+                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n+            process(res);\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res) {\n+        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n+        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n+        try {\n+            final ServletRequestDispatcher dispatcher =\n+                    servletHttpExchange.getServletContext()\n+                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n+            if (dispatcher == null) {\n+                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxMTEwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419811101", "bodyText": "If dispatcher is null, I think we should return NOT_FOUND. I will add return; command here. Do you have another solution?", "author": "dominhhien", "createdAt": "2020-05-05T00:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MjQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 37a4429d2d..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,85 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private ServletHttpExchange servletHttpExchange;\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            servletHttpExchange = ServletHttpExchange.newInstance(\n-                    servletContext, (DefaultServiceRequestContext) ctx, aReq);\n-            process(res);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4MzIxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419283217", "bodyText": "ctx is not used. Could you remove that?", "author": "minwoox", "createdAt": "2020-05-04T08:30:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NTUwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419285505", "bodyText": "This is not used.", "author": "minwoox", "createdAt": "2020-05-04T08:35:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NjAzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286036", "bodyText": "How about passing and creating(if needed) all parameters so that we can make these all final?", "author": "minwoox", "createdAt": "2020-05-04T08:36:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4NjgzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286835", "bodyText": "I don't see any code calling this what is this for?", "author": "minwoox", "createdAt": "2020-05-04T08:37:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4Njg5NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419286894", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-04T08:37:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4Nzg1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419287859", "bodyText": "It's never null, so we don't need this check", "author": "minwoox", "createdAt": "2020-05-04T08:39:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4ODA3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419288079", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-04T08:40:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4OTA4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419289083", "bodyText": "Is it always use HTTP/1.1?", "author": "minwoox", "createdAt": "2020-05-04T08:42:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n+                                                          AggregatedHttpRequest request) {\n+        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n+        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n+                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyOTk0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419329948", "bodyText": "No, but FullHttpRequest interface use HttpVersion which is not support all HTTP version, and we don't use this HttpVersion information. I set correct Armeria HTTP version to ServletAPI now.", "author": "dominhhien", "createdAt": "2020-05-04T10:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI4OTA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI5MTgxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419291815", "bodyText": "I decided to keep io.netty.handler.codec.http.FullHttpRequest because I don't want to clone all parsing APIs and decoding APIs from Netty project. I reused these APIs. I implemented servlet OutputStream, servlet PrintWriter.\n\nWe have the corresponding parsing and decoding APIs. If we don't we can add the APIs. The Netty HttpRequest is already converted to Armeria HttpRequest before it gets here and changing it back is not reasonable. We should not use that.", "author": "minwoox", "createdAt": "2020-05-04T08:47:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.server.DefaultServiceRequestContext;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.http.DefaultFullHttpRequest;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Servlet object (contains 3 big objects: request, response, TCP channel).\n+ */\n+public final class ServletHttpExchange {\n+    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n+            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n+\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private DefaultServiceRequestContext channelHandlerContext;\n+    private ServletContextImpl servletContext;\n+    private boolean isHttpKeepAlive;\n+\n+    private ServletHttpExchange() {\n+    }\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n+                                                  DefaultServiceRequestContext context,\n+                                                  AggregatedHttpRequest request) {\n+        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n+        final ServletHttpExchange instance = new ServletHttpExchange();\n+        instance.servletContext = servletContext;\n+        instance.channelHandlerContext = context;\n+\n+        //Create a new servlet request object\n+        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n+        //Create a new servlet response object\n+        instance.response = ServletHttpResponse.newInstance(instance);\n+        return instance;\n+    }\n+\n+    /**\n+     * Whether the pipe is active.\n+     */\n+    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n+        return true;\n+    }\n+\n+    /**\n+     * Is http keep alive.\n+     */\n+    public boolean isHttpKeepAlive() {\n+        return isHttpKeepAlive;\n+    }\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public ServletContextImpl getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public DefaultServiceRequestContext getChannelHandlerContext() {\n+        return channelHandlerContext;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return servletContext.getServerAddress();\n+    }\n+\n+    /**\n+     * Get local address.\n+     */\n+    public InetSocketAddress getLocalAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get remote address.\n+     */\n+    public InetSocketAddress getRemoteAddress() {\n+        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n+        if (socketAddress == null) {\n+            return null;\n+        }\n+        if (socketAddress instanceof InetSocketAddress) {\n+            return (InetSocketAddress) socketAddress;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n+     */\n+    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n+                                                          AggregatedHttpRequest request) {\n+        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n+        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(", "originalCommit": "df04b46e91943150374f7889d7be7fe56b8c2fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\ndeleted file mode 100644\nindex 43f79c8903..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpExchange.java\n+++ /dev/null\n\n@@ -1,160 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.server.DefaultServiceRequestContext;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.http.DefaultFullHttpRequest;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.util.AttributeKey;\n-\n-/**\n- * Servlet object (contains 3 big objects: request, response, TCP channel).\n- */\n-public final class ServletHttpExchange {\n-    private static final AttributeKey<ServletHttpExchange> CHANNEL_ATTR_KEY_EXCHANGE =\n-            AttributeKey.valueOf(ServletHttpExchange.class + \"#ServletHttpExchange\");\n-\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private DefaultServiceRequestContext channelHandlerContext;\n-    private ServletContextImpl servletContext;\n-    private boolean isHttpKeepAlive;\n-\n-    private ServletHttpExchange() {\n-    }\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpExchange newInstance(ServletContextImpl servletContext,\n-                                                  DefaultServiceRequestContext context,\n-                                                  AggregatedHttpRequest request) {\n-        final DefaultFullHttpRequest fullHttpRequest = parseHttpRequest(context, request);\n-        final ServletHttpExchange instance = new ServletHttpExchange();\n-        instance.servletContext = servletContext;\n-        instance.channelHandlerContext = context;\n-\n-        //Create a new servlet request object\n-        instance.request = ServletHttpRequest.newInstance(instance, fullHttpRequest);\n-        //Create a new servlet response object\n-        instance.response = ServletHttpResponse.newInstance(instance);\n-        return instance;\n-    }\n-\n-    /**\n-     * Whether the pipe is active.\n-     */\n-    public static boolean isChannelActive(DefaultServiceRequestContext channelHandlerContext) {\n-        return true;\n-    }\n-\n-    /**\n-     * Is http keep alive.\n-     */\n-    public boolean isHttpKeepAlive() {\n-        return isHttpKeepAlive;\n-    }\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public ServletContextImpl getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public DefaultServiceRequestContext getChannelHandlerContext() {\n-        return channelHandlerContext;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return servletContext.getServerAddress();\n-    }\n-\n-    /**\n-     * Get local address.\n-     */\n-    public InetSocketAddress getLocalAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.localAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Get remote address.\n-     */\n-    public InetSocketAddress getRemoteAddress() {\n-        final SocketAddress socketAddress = channelHandlerContext.remoteAddress();\n-        if (socketAddress == null) {\n-            return null;\n-        }\n-        if (socketAddress instanceof InetSocketAddress) {\n-            return (InetSocketAddress) socketAddress;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Convert {@link HttpRequest} to {@link DefaultFullHttpRequest}.\n-     */\n-    private static DefaultFullHttpRequest parseHttpRequest(ServiceRequestContext ctx,\n-                                                          AggregatedHttpRequest request) {\n-        final ByteBuf content = Unpooled.wrappedBuffer(request.content().array());\n-        final DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(\n-                HttpVersion.HTTP_1_1, new HttpMethod(request.method().name()),\n-                request.path(), content, true);\n-        request.headers().names().forEach(s -> {\n-            if (s != null && !s.startsWith(\":\")) {\n-                fullHttpRequest.headers().add(s.toString(), request.headers().get(s));\n-            }\n-        });\n-        return fullHttpRequest;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxNjUwMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r419816500", "bodyText": "I add new class ServletMultipartRequest here because Armeria HttpRequest is not support multipart. I will create another pull request to fix #253 Add HTTP multipart content support and refactor this code later.", "author": "dominhhien", "createdAt": "2020-05-05T01:15:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,1053 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.RequestDispatcher;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.StringUtil;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.CodecException;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.multipart.Attribute;\n+import io.netty.handler.codec.http.multipart.FileUpload;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.handler.codec.http.multipart.HttpPostMultipartRequestDecoder;\n+import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\n+import io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder;\n+import io.netty.handler.codec.http.multipart.InterfaceHttpData;\n+import io.netty.handler.codec.http.multipart.InterfaceHttpPostRequestDecoder;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Locale[] DEFAULT_LOCALS = {Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private ServletHttpExchange servletHttpExchange;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private String sessionId;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean decodePathsFlag;\n+    private boolean decodeCookieFlag;\n+    private boolean decodeParameterByUrlFlag;\n+    private InterfaceHttpPostRequestDecoder postRequestDecoder;\n+    private boolean remoteSchemeFlag;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private AggregatedHttpRequest httpRequest;\n+    private ServletInputStreamWrapper inputStream = new ServletInputStreamWrapper();\n+    private Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest() {}\n+\n+    /**\n+     * Get new instance.\n+     */\n+    public static ServletHttpRequest of(ServletHttpExchange servletHttpExchange,\n+                                        AggregatedHttpRequest request) {\n+        final ServletHttpRequest instance = new ServletHttpRequest();\n+        instance.servletHttpExchange = servletHttpExchange;\n+        instance.httpRequest = request;\n+        instance.inputStream.wrap(Unpooled.wrappedBuffer(request.content().array()));\n+        instance.getParameterMap();\n+        instance.getCookies();\n+        instance.getLocale();\n+        instance.getProtocol();\n+        instance.getScheme();\n+        return instance;\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(Boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get servlet http exchange.\n+     */\n+    public ServletHttpExchange getServletHttpExchange() {\n+        return servletHttpExchange;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse request scheme.\n+     */\n+    private void decodeScheme() {\n+        scheme = httpRequest.scheme();\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody(boolean bodyPartFlag) {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        final HttpDataFactory factory = getServletContext().getHttpDataFactory(charset);\n+        int discardThreshold = 0;\n+        if (multipartConfigElement != null) {\n+            factory.setMaxLimit(multipartConfigElement.getMaxFileSize());\n+            discardThreshold = multipartConfigElement.getFileSizeThreshold();\n+        }\n+\n+        final HttpRequest request = new ServletMultipartRequest(httpRequest);", "originalCommit": "54698fb02e529a7a51ceee92199eb76db6155006", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100644\nindex 5a046eee04..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,1053 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.MultipartConfigElement;\n-import javax.servlet.RequestDispatcher;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletRequestAttributeEvent;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.ServletSecurityElement;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.StringUtil;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.handler.codec.CodecException;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.multipart.Attribute;\n-import io.netty.handler.codec.http.multipart.FileUpload;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.handler.codec.http.multipart.HttpPostMultipartRequestDecoder;\n-import io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\n-import io.netty.handler.codec.http.multipart.HttpPostStandardRequestDecoder;\n-import io.netty.handler.codec.http.multipart.InterfaceHttpData;\n-import io.netty.handler.codec.http.multipart.InterfaceHttpPostRequestDecoder;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final Locale[] DEFAULT_LOCALS = {Locale.getDefault()};\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n-\n-    private ServletHttpExchange servletHttpExchange;\n-    private String protocol;\n-    private String scheme;\n-    private String servletPath;\n-    private String queryString;\n-    private String pathInfo;\n-    private String requestURI;\n-    private String characterEncoding;\n-    private String sessionId;\n-    private SessionTrackingMode sessionIdSource;\n-    private MultipartConfigElement multipartConfigElement;\n-    private ServletSecurityElement servletSecurityElement;\n-    private boolean decodePathsFlag;\n-    private boolean decodeCookieFlag;\n-    private boolean decodeParameterByUrlFlag;\n-    private InterfaceHttpPostRequestDecoder postRequestDecoder;\n-    private boolean remoteSchemeFlag;\n-    private boolean usingInputStreamFlag;\n-    private BufferedReader reader;\n-    private AggregatedHttpRequest httpRequest;\n-    private ServletInputStreamWrapper inputStream = new ServletInputStreamWrapper();\n-    private Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n-    private Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n-            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n-            for (Entry<String,List<String>> entry : entries) {\n-                final List<String> value = entry.getValue();\n-                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n-                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public String[] get(Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            return parameterMap.containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Cookie[] cookies;\n-    private Locale[] locales;\n-    private Boolean asyncSupportedFlag;\n-    private ServletRequestDispatcher dispatcher;\n-\n-    protected ServletHttpRequest() {}\n-\n-    /**\n-     * Get new instance.\n-     */\n-    public static ServletHttpRequest of(ServletHttpExchange servletHttpExchange,\n-                                        AggregatedHttpRequest request) {\n-        final ServletHttpRequest instance = new ServletHttpRequest();\n-        instance.servletHttpExchange = servletHttpExchange;\n-        instance.httpRequest = request;\n-        instance.inputStream.wrap(Unpooled.wrappedBuffer(request.content().array()));\n-        instance.getParameterMap();\n-        instance.getCookies();\n-        instance.getLocale();\n-        instance.getProtocol();\n-        instance.getScheme();\n-        return instance;\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setMultipartConfigElement(MultipartConfigElement multipartConfigElement) {\n-        this.multipartConfigElement = multipartConfigElement;\n-    }\n-\n-    void setServletSecurityElement(ServletSecurityElement servletSecurityElement) {\n-        this.servletSecurityElement = servletSecurityElement;\n-    }\n-\n-    void setAsyncSupportedFlag(Boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get servlet http exchange.\n-     */\n-    public ServletHttpExchange getServletHttpExchange() {\n-        return servletHttpExchange;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse request scheme.\n-     */\n-    private void decodeScheme() {\n-        scheme = httpRequest.scheme();\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final Locale[] locales;\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            final String[] values = headerValue.split(\",\");\n-            final int length = values.length;\n-            locales = new Locale[length];\n-            for (int i = 0; i < length; i++) {\n-                final String value = values[i];\n-                final String[] valueSp = value.split(\";\");\n-                final Locale locale;\n-                if (valueSp.length > 0) {\n-                    locale = Locale.forLanguageTag(valueSp[0]);\n-                } else {\n-                    locale = Locale.forLanguageTag(value);\n-                }\n-                locales[i] = locale;\n-            }\n-        }\n-        this.locales = locales;\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = getServletContext().getRequestCharacterEncoding();\n-        }\n-       this.characterEncoding = characterEncoding;\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody(boolean bodyPartFlag) {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        final HttpDataFactory factory = getServletContext().getHttpDataFactory(charset);\n-        int discardThreshold = 0;\n-        if (multipartConfigElement != null) {\n-            factory.setMaxLimit(multipartConfigElement.getMaxFileSize());\n-            discardThreshold = multipartConfigElement.getFileSizeThreshold();\n-        }\n-\n-        final HttpRequest request = new ServletMultipartRequest(httpRequest);\n-\n-        final InterfaceHttpPostRequestDecoder postRequestDecoder =\n-                ServletUtil.isMultipart(httpRequest) ?\n-                new HttpPostMultipartRequestDecoder(factory, request, charset)\n-                                                                :\n-                new HttpPostStandardRequestDecoder(factory, request, charset);\n-        postRequestDecoder.setDiscardThreshold(discardThreshold);\n-\n-        this.postRequestDecoder = postRequestDecoder;\n-        while (true) {\n-            try {\n-                if (!postRequestDecoder.hasNext()) {\n-                    return;\n-                }\n-            } catch (HttpPostRequestDecoder.EndOfDataDecoderException e) {\n-                return;\n-            }\n-\n-            final InterfaceHttpData interfaceData = postRequestDecoder.next();\n-            switch (interfaceData.getHttpDataType()) {\n-                case Attribute: {\n-                    final Attribute data = (Attribute) interfaceData;\n-                    final String name = data.getName();\n-                    String value;\n-                    try {\n-                        value = data.getValue();\n-                    } catch (IOException e) {\n-                        e.printStackTrace();\n-                        value = \"\";\n-                    }\n-                    parameterMap.add(name, value);\n-\n-                    if (bodyPartFlag) {\n-                        final ServletTextPart part = new ServletTextPart(data);\n-                        fileUploadList.add(part);\n-                    }\n-                    break;\n-                }\n-                case FileUpload: {\n-                    final FileUpload data = (FileUpload) interfaceData;\n-                    final ServletFilePart part = new ServletFilePart(data);\n-                    fileUploadList.add(part);\n-                    break;\n-                }\n-                default: {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-        this.decodeParameterByUrlFlag = true;\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (value != null && value.length() > 0) {\n-            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n-            if (nettyCookieSet.size() > 0) {\n-                this.cookies = nettyCookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        this.decodeCookieFlag = true;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-        this.pathInfo = null;\n-        this.decodePathsFlag = true;\n-    }\n-\n-    @Override\n-    public Cookie[] getCookies() {\n-        if (decodeCookieFlag) {\n-            return cookies;\n-        }\n-        decodeCookie();\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) throws IllegalArgumentException {\n-        final String value = getHeader(name);\n-        if (StringUtil.isEmpty(value)) {\n-            return -1;\n-        }\n-\n-        final DateFormat[] formats = FORMATS_TEMPLATE;\n-        Date date = null;\n-        for (int i = 0; (date == null) && (i < formats.length); i++) {\n-            try {\n-                date = formats[i].parse(value);\n-            } catch (ParseException e) {\n-                // Ignore\n-            }\n-        }\n-        if (date == null) {\n-            throw new IllegalArgumentException(value);\n-        }\n-        return date.getTime();\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    public String getHeader(String name) {\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        final Set nameSet = httpRequest.headers().names();\n-        return new Enumeration<String>() {\n-            private Iterator iterator = nameSet.iterator();\n-\n-            @Override\n-            public boolean hasMoreElements() {\n-                return iterator.hasNext();\n-            }\n-\n-            @Override\n-            public String nextElement() {\n-                return iterator.next().toString();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HttpHeaderConstants.HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n-            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    public String getPathInfo() {\n-        if (!decodePathsFlag) {\n-            decodePaths();\n-        }\n-        return this.pathInfo;\n-    }\n-\n-    @Override\n-    public String getQueryString() {\n-        if (!decodePathsFlag) {\n-            decodePaths();\n-        }\n-        return this.queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        if (!decodePathsFlag) {\n-            decodePaths();\n-        }\n-        return this.requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (this.servletPath == null) {\n-            String servletPath = getServletContext().getServletPath(getRequestURI());\n-            final String contextPath = getServletContext().getContextPath();\n-            if (contextPath.length() > 0) {\n-                servletPath = servletPath.replaceFirst(contextPath,\"\");\n-            }\n-            this.servletPath = servletPath;\n-        }\n-        return this.servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        return null;\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        final Collection collection = httpRequest.headers().getAll(name);\n-        return new Enumeration<String>() {\n-            private Iterator iterator = collection.iterator();\n-\n-            @Override\n-            public boolean hasMoreElements() {\n-                return iterator.hasNext();\n-            }\n-\n-            @Override\n-            public String nextElement() {\n-                return iterator.next().toString();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-                sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(getAttributeMap().keySet());\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return inputStream.getContentLength();\n-    }\n-\n-    @Override\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public ServletInputStreamWrapper getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    public String getParameter(String name) {\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(getParameterMap().keySet());\n-    }\n-\n-    @Override\n-    public String[] getParameterValues(String name) {\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        if (!decodeParameterByUrlFlag) {\n-            decodeUrlParameter();\n-        }\n-\n-        if (postRequestDecoder == null && HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) &&\n-            getContentLength() > 0) {\n-            decodeBody(false);\n-        }\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        if (protocol == null) {\n-            protocol = servletHttpExchange.getChannelHandlerContext().sessionProtocol().uriText();\n-        }\n-        return protocol;\n-    }\n-\n-    @Override\n-    public String getScheme() {\n-        if (scheme == null) {\n-            decodeScheme();\n-        }\n-        return scheme;\n-    }\n-\n-    @Override\n-    public String getServerName() {\n-        final InetSocketAddress inetSocketAddress = servletHttpExchange.getLocalAddress();\n-        if (inetSocketAddress != null) {\n-            return inetSocketAddress.getAddress().getHostAddress();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        final String scheme = getScheme();\n-        if (remoteSchemeFlag) {\n-            if (HttpHeaderConstants.HTTPS.equalsIgnoreCase(scheme)) {\n-                return HttpHeaderConstants.HTTPS_PORT;\n-            } else {\n-                return HttpHeaderConstants.HTTP_PORT;\n-            }\n-        }\n-        return servletHttpExchange.getServerAddress().getPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        final InetSocketAddress inetSocketAddress = servletHttpExchange.getRemoteAddress();\n-        if (inetSocketAddress == null) {\n-            return null;\n-        }\n-        final InetAddress inetAddress = inetSocketAddress.getAddress();\n-        if (inetAddress == null) {\n-            return null;\n-        }\n-        return inetAddress.getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        final InetSocketAddress inetSocketAddress = servletHttpExchange.getRemoteAddress();\n-        if (inetSocketAddress == null) {\n-            return null;\n-        }\n-        return inetSocketAddress.getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        final InetSocketAddress inetSocketAddress = servletHttpExchange.getRemoteAddress();\n-        if (inetSocketAddress == null) {\n-            return 0;\n-        }\n-        return inetSocketAddress.getPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = getAttributeMap().put(name,object);\n-\n-        final ServletContextImpl servletContext = getServletContext();\n-        final ServletEventListenerManager listenerManager = servletContext.getServletEventListenerManager();\n-        if (listenerManager.hasServletRequestAttributeListener()) {\n-            listenerManager.onServletRequestAttributeAdded(\n-                    new ServletRequestAttributeEvent(servletContext,this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletRequestAttributeReplaced(\n-                        new ServletRequestAttributeEvent(servletContext,this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = getAttributeMap().remove(name);\n-\n-        final ServletContextImpl servletContext = getServletContext();\n-        final ServletEventListenerManager listenerManager = servletContext.getServletEventListenerManager();\n-        if (listenerManager.hasServletRequestAttributeListener()) {\n-            listenerManager.onServletRequestAttributeRemoved(\n-                    new ServletRequestAttributeEvent(servletContext,this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        if (this.locales == null) {\n-            decodeLocale();\n-        }\n-\n-        final Locale[] locales = this.locales;\n-        if (locales == null || locales.length == 0) {\n-            return null;\n-        }\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        if (this.locales == null) {\n-            decodeLocale();\n-        }\n-        return new Enumeration<Locale>() {\n-            private int index;\n-            @Override\n-            public boolean hasMoreElements() {\n-                return index < locales.length;\n-            }\n-\n-            @Override\n-            public Locale nextElement() {\n-                final Locale locale = locales[index];\n-                index++;\n-                return locale;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HttpHeaderConstants.HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return getServletContext().getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return getServletContext().getRealPath(path);\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return getServletContext().getServerAddress().getHostName();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return getServletContext().getServerAddress().getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServletContext().getServerAddress().getPort();\n-    }\n-\n-    @Override\n-    public ServletContextImpl getServletContext() {\n-        return servletHttpExchange.getServletContext();\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() throws IllegalStateException {\n-        return startAsync(this,servletHttpExchange.getResponse());\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse)\n-            throws IllegalStateException {\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        if (asyncSupportedFlag == null) {\n-            return true;\n-        }\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        return null;\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        final ServletContextImpl servletContext = getServletContext();\n-        final String contextPath = servletContext.getContextPath();\n-        if (contextPath == null || contextPath.isEmpty()) {\n-            return null;\n-        }\n-\n-        final String pathInfo = getPathInfo();\n-        if (pathInfo == null) {\n-            return null;\n-        }\n-\n-        return servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        final Principal principal = getUserPrincipal();\n-        if (principal != null) {\n-            return principal.getName();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        return true;\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        if (postRequestDecoder == null) {\n-            try {\n-                decodeBody(true);\n-            } catch (CodecException e) {\n-                final Throwable cause = getCause(e);\n-                if (cause instanceof IOException) {\n-                    setAttribute(RequestDispatcher.ERROR_STATUS_CODE,HttpServletResponse.SC_BAD_REQUEST);\n-                    setAttribute(RequestDispatcher.ERROR_EXCEPTION,cause);\n-                    throw (IOException)cause;\n-                } else if (cause instanceof IllegalStateException) {\n-                    setAttribute(RequestDispatcher.ERROR_STATUS_CODE,HttpServletResponse.SC_BAD_REQUEST);\n-                    setAttribute(RequestDispatcher.ERROR_EXCEPTION,cause);\n-                    throw (IllegalStateException)cause;\n-                } else if (cause instanceof IllegalArgumentException) {\n-                    final IllegalStateException illegalStateException =\n-                            new IllegalStateException(\"HttpServletRequest.getParts() -> decodeFile() fail : \" +\n-                                                      cause.getMessage(), cause);\n-                    illegalStateException.setStackTrace(cause.getStackTrace());\n-                    setAttribute(RequestDispatcher.ERROR_STATUS_CODE,HttpServletResponse.SC_BAD_REQUEST);\n-                    setAttribute(RequestDispatcher.ERROR_EXCEPTION,illegalStateException);\n-                    throw illegalStateException;\n-                } else {\n-                    final ServletException servletException;\n-                    if (cause != null) {\n-                        servletException =\n-                                new ServletException(\"HttpServletRequest.getParts() -> decodeFile() fail : \" +\n-                                                     cause.getMessage(),cause);\n-                        servletException.setStackTrace(cause.getStackTrace());\n-                    } else {\n-                        servletException =\n-                                new ServletException(\"HttpServletRequest.getParts() -> decodeFile() fail : \" +\n-                                                     e.getMessage(),e);\n-                        servletException.setStackTrace(e.getStackTrace());\n-                    }\n-                    setAttribute(RequestDispatcher.ERROR_STATUS_CODE,HttpServletResponse.SC_BAD_REQUEST);\n-                    setAttribute(RequestDispatcher.ERROR_EXCEPTION,servletException);\n-                    throw servletException;\n-                }\n-            } catch (IllegalArgumentException e) {\n-                final IllegalStateException illegalStateException =\n-                        new IllegalStateException(\"HttpServletRequest.getParts() -> decodeFile() fail : \" +\n-                                                  e.getMessage(), e);\n-                illegalStateException.setStackTrace(e.getStackTrace());\n-                setAttribute(RequestDispatcher.ERROR_STATUS_CODE,HttpServletResponse.SC_BAD_REQUEST);\n-                setAttribute(RequestDispatcher.ERROR_EXCEPTION,illegalStateException);\n-                throw illegalStateException;\n-            }\n-        }\n-        return fileUploadList;\n-    }\n-\n-    private Throwable getCause(Throwable throwable) {\n-        if (throwable.getCause() == null) {\n-            return null;\n-        }\n-        while (true) {\n-            final Throwable cause = throwable;\n-            throwable = throwable.getCause();\n-            if (throwable == null) {\n-                return cause;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Part getPart(String name) throws IOException, ServletException {\n-        for (Part part : getParts()) {\n-            if (name.equals(part.getName())) {\n-                return part;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass)\n-            throws IOException, ServletException {\n-        try {\n-            final T handler = httpUpgradeHandlerClass.newInstance();\n-            return handler;\n-        } catch (Exception e) {\n-            throw new ServletException(e.getMessage(),e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTYxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185614", "bodyText": "Can remove @Nullable.", "author": "minwoox", "createdAt": "2020-05-07T01:26:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100644\nindex 14bd53605b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link ServletContextImpl} instance.\n- */\n-public class ServletBuilder {\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    private ServerBuilder serverBuilder;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        servletContext = new ServletContextImpl();\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link DefaultServletService}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet of the {@link DefaultServletService}.\n-     */\n-    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n-        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);\n-        sd.addMapping(path);\n-        sd.setLoadOnStartup(1);\n-        sd.setAsyncSupported(false);\n-        serverBuilder = serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTY0Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185647", "bodyText": "nit: final", "author": "minwoox", "createdAt": "2020-05-07T01:26:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100644\nindex 14bd53605b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link ServletContextImpl} instance.\n- */\n-public class ServletBuilder {\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    private ServerBuilder serverBuilder;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        servletContext = new ServletContextImpl();\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link DefaultServletService}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet of the {@link DefaultServletService}.\n-     */\n-    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n-        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);\n-        sd.addMapping(path);\n-        sd.setLoadOnStartup(1);\n-        sd.setAsyncSupported(false);\n-        serverBuilder = serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTY3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421185671", "bodyText": "nit: final", "author": "minwoox", "createdAt": "2020-05-07T01:26:27Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100644\nindex 14bd53605b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link ServletContextImpl} instance.\n- */\n-public class ServletBuilder {\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    private ServerBuilder serverBuilder;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        servletContext = new ServletContextImpl();\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link DefaultServletService}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet of the {@link DefaultServletService}.\n-     */\n-    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n-        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);\n-        sd.addMapping(path);\n-        sd.setLoadOnStartup(1);\n-        sd.setAsyncSupported(false);\n-        serverBuilder = serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NjEwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421186107", "bodyText": "requireNonNull(serverBuilder, \"serverBuilder\");", "author": "minwoox", "createdAt": "2020-05-07T01:28:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100644\nindex 14bd53605b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link ServletContextImpl} instance.\n- */\n-public class ServletBuilder {\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    private ServerBuilder serverBuilder;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        servletContext = new ServletContextImpl();\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link DefaultServletService}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet of the {@link DefaultServletService}.\n-     */\n-    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n-        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);\n-        sd.addMapping(path);\n-        sd.setLoadOnStartup(1);\n-        sd.setAsyncSupported(false);\n-        serverBuilder = serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NjQzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421186435", "bodyText": "requireNonNull(path, \"path\");\nrequireNonNull(httpServlet, \"httpServlet\");", "author": "minwoox", "createdAt": "2020-05-07T01:29:12Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link DefaultServletService}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet of the {@link DefaultServletService}.\n+     */\n+    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100644\nindex 14bd53605b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link ServletContextImpl} instance.\n- */\n-public class ServletBuilder {\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    private ServerBuilder serverBuilder;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        servletContext = new ServletContextImpl();\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link DefaultServletService}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet of the {@link DefaultServletService}.\n-     */\n-    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n-        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);\n-        sd.addMapping(path);\n-        sd.setLoadOnStartup(1);\n-        sd.setAsyncSupported(false);\n-        serverBuilder = serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189172", "bodyText": "Question: Is this class from Servlet spec? or did you implement this class just for convenience?", "author": "minwoox", "createdAt": "2020-05-07T01:38:49Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestEvent;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+/**\n+ * Servlet global event listener.\n+ */\n+public class ServletEventListenerManager {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxMzA3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421413070", "bodyText": "Yes, I implement this class just for convenience.", "author": "dominhhien", "createdAt": "2020-05-07T10:48:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java\ndeleted file mode 100644\nindex 9d1952ba63..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java\n+++ /dev/null\n\n@@ -1,343 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletRequestAttributeEvent;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestEvent;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-/**\n- * Servlet global event listener.\n- */\n-public class ServletEventListenerManager {\n-    private final Object lock = new Object();\n-\n-    private List<ServletContextAttributeListener> servletContextAttributeListenerList;\n-    private List<ServletRequestListener> servletRequestListenerList;\n-    private List<ServletRequestAttributeListener> servletRequestAttributeListenerList;\n-    private List<HttpSessionIdListener> httpSessionIdListenerList;\n-    private List<HttpSessionAttributeListener> httpSessionAttributeListenerList;\n-\n-    private List<HttpSessionListener> httpSessionListenerList;\n-    private List<ServletContextListener> servletContextListenerList;\n-    private Function<Servlet,Servlet> servletAddedListener;\n-\n-    /**\n-     * Event trigger on servlet added.\n-     */\n-    public Servlet onServletAdded(Servlet servlet) {\n-        if (servletAddedListener == null) {\n-            return servlet;\n-        }\n-        try {\n-            return servletAddedListener.apply(servlet);\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            return servlet;\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on add servlet context attribute.\n-     */\n-    public void onServletContextAttributeAdded(ServletContextAttributeEvent event) {\n-        if (servletContextAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletContextAttributeListener listener : servletContextAttributeListenerList) {\n-            try {\n-                listener.attributeAdded(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on remove servlet context attribute.\n-     */\n-    public void onServletContextAttributeRemoved(ServletContextAttributeEvent event) {\n-        if (servletContextAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletContextAttributeListener listener : servletContextAttributeListenerList) {\n-            try {\n-                listener.attributeRemoved(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on replace servlet context attribute.\n-     */\n-    public void onServletContextAttributeReplaced(ServletContextAttributeEvent event) {\n-        if (servletContextAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletContextAttributeListener listener : servletContextAttributeListenerList) {\n-            try {\n-                listener.attributeReplaced(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on initialize servlet request.\n-     */\n-    public void onServletRequestInitialized(ServletRequestEvent event) {\n-        if (servletRequestListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestListener listener : servletRequestListenerList) {\n-            try {\n-                listener.requestInitialized(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on destroy servlet request.\n-     */\n-    public void onServletRequestDestroyed(ServletRequestEvent event) {\n-        if (servletRequestListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestListener listener : servletRequestListenerList) {\n-            try {\n-                listener.requestDestroyed(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on add servlet request attribute.\n-     */\n-    public void onServletRequestAttributeAdded(ServletRequestAttributeEvent event) {\n-        if (servletRequestAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestAttributeListener listener : servletRequestAttributeListenerList) {\n-            try {\n-                listener.attributeAdded(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on remove servlet request attribute.\n-     */\n-    public void onServletRequestAttributeRemoved(ServletRequestAttributeEvent event) {\n-        if (servletRequestAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestAttributeListener listener : servletRequestAttributeListenerList) {\n-            try {\n-                listener.attributeRemoved(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on replace servlet request attribute.\n-     */\n-    public void onServletRequestAttributeReplaced(ServletRequestAttributeEvent event) {\n-        if (servletRequestAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestAttributeListener listener : servletRequestAttributeListenerList) {\n-            try {\n-                listener.attributeReplaced(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Has servlet context attribute listener.\n-     */\n-    public boolean hasServletContextAttributeListener() {\n-        return servletContextAttributeListenerList != null;\n-    }\n-\n-    /**\n-     * Has servlet request listener.\n-     */\n-    public boolean hasServletRequestListener() {\n-        return servletRequestListenerList != null;\n-    }\n-\n-    /**\n-     * Has servlet request attribute listener.\n-     */\n-    public boolean hasServletRequestAttributeListener() {\n-        return servletRequestAttributeListenerList != null;\n-    }\n-\n-    /**\n-     * Add servlet context attribute listener.\n-     */\n-    public void addServletContextAttributeListener(ServletContextAttributeListener listener) {\n-        getServletContextAttributeListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add servlet request listener.\n-     */\n-    public void addServletRequestListener(ServletRequestListener listener) {\n-        getServletRequestListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add servlet request attribute listener.\n-     */\n-    public void addServletRequestAttributeListener(ServletRequestAttributeListener listener) {\n-        getServletRequestAttributeListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add http session id listener.\n-     */\n-    public void addHttpSessionIdListener(HttpSessionIdListener listener) {\n-        getHttpSessionIdListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add http session attribute listener.\n-     */\n-    public void addHttpSessionAttributeListener(HttpSessionAttributeListener listener) {\n-        getHttpSessionAttributeListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add http session listener.\n-     */\n-    public void addHttpSessionListener(HttpSessionListener listener) {\n-        getHttpSessionListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add servlet context listener.\n-     */\n-    public void addServletContextListener(ServletContextListener listener) {\n-        getServletContextListenerList().add(listener);\n-    }\n-\n-    private List<ServletContextAttributeListener> getServletContextAttributeListenerList() {\n-        if (servletContextAttributeListenerList == null) {\n-            synchronized (lock) {\n-                if (servletContextAttributeListenerList == null) {\n-                    servletContextAttributeListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletContextAttributeListenerList;\n-    }\n-\n-    private List<ServletRequestListener> getServletRequestListenerList() {\n-        if (servletRequestListenerList == null) {\n-            synchronized (lock) {\n-                if (servletRequestListenerList == null) {\n-                    servletRequestListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletRequestListenerList;\n-    }\n-\n-    private List<ServletRequestAttributeListener> getServletRequestAttributeListenerList() {\n-        if (servletRequestAttributeListenerList == null) {\n-            synchronized (lock) {\n-                if (servletRequestAttributeListenerList == null) {\n-                    servletRequestAttributeListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletRequestAttributeListenerList;\n-    }\n-\n-    private List<HttpSessionIdListener> getHttpSessionIdListenerList() {\n-        if (httpSessionIdListenerList == null) {\n-            synchronized (lock) {\n-                if (httpSessionIdListenerList == null) {\n-                    httpSessionIdListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return httpSessionIdListenerList;\n-    }\n-\n-    private List<HttpSessionAttributeListener> getHttpSessionAttributeListenerList() {\n-        if (httpSessionAttributeListenerList == null) {\n-            synchronized (lock) {\n-                if (httpSessionAttributeListenerList == null) {\n-                    httpSessionAttributeListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return httpSessionAttributeListenerList;\n-    }\n-\n-    private List<HttpSessionListener> getHttpSessionListenerList() {\n-        if (httpSessionListenerList == null) {\n-            synchronized (lock) {\n-                if (httpSessionListenerList == null) {\n-                    httpSessionListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return httpSessionListenerList;\n-    }\n-\n-    private List<ServletContextListener> getServletContextListenerList() {\n-        if (servletContextListenerList == null) {\n-            synchronized (lock) {\n-                if (servletContextListenerList == null) {\n-                    servletContextListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletContextListenerList;\n-    }\n-\n-    private <T> List<T> newListenerList() {\n-        return new LinkedList<T>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTE5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189192", "bodyText": "Question: Is this class from Servlet spec? or did you implement it just for convenience?", "author": "minwoox", "createdAt": "2020-05-07T01:38:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletRequestAttributeEvent;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestEvent;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+/**\n+ * Servlet global event listener.\n+ */\n+public class ServletEventListenerManager {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java\ndeleted file mode 100644\nindex 9d1952ba63..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletEventListenerManager.java\n+++ /dev/null\n\n@@ -1,343 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.function.Function;\n-\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletRequestAttributeEvent;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestEvent;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-/**\n- * Servlet global event listener.\n- */\n-public class ServletEventListenerManager {\n-    private final Object lock = new Object();\n-\n-    private List<ServletContextAttributeListener> servletContextAttributeListenerList;\n-    private List<ServletRequestListener> servletRequestListenerList;\n-    private List<ServletRequestAttributeListener> servletRequestAttributeListenerList;\n-    private List<HttpSessionIdListener> httpSessionIdListenerList;\n-    private List<HttpSessionAttributeListener> httpSessionAttributeListenerList;\n-\n-    private List<HttpSessionListener> httpSessionListenerList;\n-    private List<ServletContextListener> servletContextListenerList;\n-    private Function<Servlet,Servlet> servletAddedListener;\n-\n-    /**\n-     * Event trigger on servlet added.\n-     */\n-    public Servlet onServletAdded(Servlet servlet) {\n-        if (servletAddedListener == null) {\n-            return servlet;\n-        }\n-        try {\n-            return servletAddedListener.apply(servlet);\n-        } catch (Exception ex) {\n-            ex.printStackTrace();\n-            return servlet;\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on add servlet context attribute.\n-     */\n-    public void onServletContextAttributeAdded(ServletContextAttributeEvent event) {\n-        if (servletContextAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletContextAttributeListener listener : servletContextAttributeListenerList) {\n-            try {\n-                listener.attributeAdded(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on remove servlet context attribute.\n-     */\n-    public void onServletContextAttributeRemoved(ServletContextAttributeEvent event) {\n-        if (servletContextAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletContextAttributeListener listener : servletContextAttributeListenerList) {\n-            try {\n-                listener.attributeRemoved(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on replace servlet context attribute.\n-     */\n-    public void onServletContextAttributeReplaced(ServletContextAttributeEvent event) {\n-        if (servletContextAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletContextAttributeListener listener : servletContextAttributeListenerList) {\n-            try {\n-                listener.attributeReplaced(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on initialize servlet request.\n-     */\n-    public void onServletRequestInitialized(ServletRequestEvent event) {\n-        if (servletRequestListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestListener listener : servletRequestListenerList) {\n-            try {\n-                listener.requestInitialized(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on destroy servlet request.\n-     */\n-    public void onServletRequestDestroyed(ServletRequestEvent event) {\n-        if (servletRequestListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestListener listener : servletRequestListenerList) {\n-            try {\n-                listener.requestDestroyed(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on add servlet request attribute.\n-     */\n-    public void onServletRequestAttributeAdded(ServletRequestAttributeEvent event) {\n-        if (servletRequestAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestAttributeListener listener : servletRequestAttributeListenerList) {\n-            try {\n-                listener.attributeAdded(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on remove servlet request attribute.\n-     */\n-    public void onServletRequestAttributeRemoved(ServletRequestAttributeEvent event) {\n-        if (servletRequestAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestAttributeListener listener : servletRequestAttributeListenerList) {\n-            try {\n-                listener.attributeRemoved(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Event trigger on replace servlet request attribute.\n-     */\n-    public void onServletRequestAttributeReplaced(ServletRequestAttributeEvent event) {\n-        if (servletRequestAttributeListenerList == null) {\n-            return;\n-        }\n-        for (ServletRequestAttributeListener listener : servletRequestAttributeListenerList) {\n-            try {\n-                listener.attributeReplaced(event);\n-            } catch (Exception ex) {\n-                ex.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Has servlet context attribute listener.\n-     */\n-    public boolean hasServletContextAttributeListener() {\n-        return servletContextAttributeListenerList != null;\n-    }\n-\n-    /**\n-     * Has servlet request listener.\n-     */\n-    public boolean hasServletRequestListener() {\n-        return servletRequestListenerList != null;\n-    }\n-\n-    /**\n-     * Has servlet request attribute listener.\n-     */\n-    public boolean hasServletRequestAttributeListener() {\n-        return servletRequestAttributeListenerList != null;\n-    }\n-\n-    /**\n-     * Add servlet context attribute listener.\n-     */\n-    public void addServletContextAttributeListener(ServletContextAttributeListener listener) {\n-        getServletContextAttributeListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add servlet request listener.\n-     */\n-    public void addServletRequestListener(ServletRequestListener listener) {\n-        getServletRequestListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add servlet request attribute listener.\n-     */\n-    public void addServletRequestAttributeListener(ServletRequestAttributeListener listener) {\n-        getServletRequestAttributeListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add http session id listener.\n-     */\n-    public void addHttpSessionIdListener(HttpSessionIdListener listener) {\n-        getHttpSessionIdListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add http session attribute listener.\n-     */\n-    public void addHttpSessionAttributeListener(HttpSessionAttributeListener listener) {\n-        getHttpSessionAttributeListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add http session listener.\n-     */\n-    public void addHttpSessionListener(HttpSessionListener listener) {\n-        getHttpSessionListenerList().add(listener);\n-    }\n-\n-    /**\n-     * Add servlet context listener.\n-     */\n-    public void addServletContextListener(ServletContextListener listener) {\n-        getServletContextListenerList().add(listener);\n-    }\n-\n-    private List<ServletContextAttributeListener> getServletContextAttributeListenerList() {\n-        if (servletContextAttributeListenerList == null) {\n-            synchronized (lock) {\n-                if (servletContextAttributeListenerList == null) {\n-                    servletContextAttributeListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletContextAttributeListenerList;\n-    }\n-\n-    private List<ServletRequestListener> getServletRequestListenerList() {\n-        if (servletRequestListenerList == null) {\n-            synchronized (lock) {\n-                if (servletRequestListenerList == null) {\n-                    servletRequestListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletRequestListenerList;\n-    }\n-\n-    private List<ServletRequestAttributeListener> getServletRequestAttributeListenerList() {\n-        if (servletRequestAttributeListenerList == null) {\n-            synchronized (lock) {\n-                if (servletRequestAttributeListenerList == null) {\n-                    servletRequestAttributeListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletRequestAttributeListenerList;\n-    }\n-\n-    private List<HttpSessionIdListener> getHttpSessionIdListenerList() {\n-        if (httpSessionIdListenerList == null) {\n-            synchronized (lock) {\n-                if (httpSessionIdListenerList == null) {\n-                    httpSessionIdListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return httpSessionIdListenerList;\n-    }\n-\n-    private List<HttpSessionAttributeListener> getHttpSessionAttributeListenerList() {\n-        if (httpSessionAttributeListenerList == null) {\n-            synchronized (lock) {\n-                if (httpSessionAttributeListenerList == null) {\n-                    httpSessionAttributeListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return httpSessionAttributeListenerList;\n-    }\n-\n-    private List<HttpSessionListener> getHttpSessionListenerList() {\n-        if (httpSessionListenerList == null) {\n-            synchronized (lock) {\n-                if (httpSessionListenerList == null) {\n-                    httpSessionListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return httpSessionListenerList;\n-    }\n-\n-    private List<ServletContextListener> getServletContextListenerList() {\n-        if (servletContextListenerList == null) {\n-            synchronized (lock) {\n-                if (servletContextListenerList == null) {\n-                    servletContextListenerList = newListenerList();\n-                }\n-            }\n-        }\n-        return servletContextListenerList;\n-    }\n-\n-    private <T> List<T> newListenerList() {\n-        return new LinkedList<T>();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4OTY1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421189653", "bodyText": "Can remove javax.servlet.ServletRegistration because Dynamic extends it.", "author": "minwoox", "createdAt": "2020-05-07T01:40:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration\n+        implements javax.servlet.ServletRegistration, Dynamic {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\ndeleted file mode 100644\nindex 658fe3a1f3..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ /dev/null\n\n@@ -1,218 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-import javax.servlet.MultipartConfigElement;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletSecurityElement;\n-\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-/**\n- * The servlet supportPipeline.\n- */\n-public class ServletRegistration\n-        implements javax.servlet.ServletRegistration, Dynamic {\n-    private String servletName;\n-    private Servlet servlet;\n-    private ServletConfig servletConfig;\n-    private ServletContextImpl servletContext;\n-    private UrlMapper<ServletRegistration> urlMapper;\n-    private MultipartConfigElement multipartConfigElement;\n-    private ServletSecurityElement servletSecurityElement;\n-    private String roleName;\n-    private boolean asyncSupported = true;\n-    private int loadOnStartup = -1;\n-    private Map<String,String> initParameterMap = new HashMap<>();\n-    private Set<String> mappingSet = new HashSet<>();\n-    private AtomicBoolean initServlet = new AtomicBoolean();\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletRegistration(String servletName, Servlet servlet, ServletContextImpl servletContext,\n-                               UrlMapper<ServletRegistration> urlMapper) {\n-        this.servletName = servletName;\n-        this.servlet = servlet;\n-        this.servletContext = servletContext;\n-        this.urlMapper = urlMapper;\n-        this.servletConfig = new ServletConfig() {\n-            @Override\n-            public String getServletName() {\n-                return ServletRegistration.this.servletName;\n-            }\n-\n-            @Override\n-            public javax.servlet.ServletContext getServletContext() {\n-                return ServletRegistration.this.servletContext;\n-            }\n-\n-            @Override\n-            public String getInitParameter(String name) {\n-                return ServletRegistration.this.getInitParameter(name);\n-            }\n-\n-            @Override\n-            public Enumeration<String> getInitParameterNames() {\n-                return Collections.enumeration(ServletRegistration.this.getInitParameters().keySet());\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Get servlet security element.\n-     */\n-    public ServletSecurityElement getServletSecurityElement() {\n-        return servletSecurityElement;\n-    }\n-\n-    /**\n-     * Get multipart config element.\n-     */\n-    public MultipartConfigElement getMultipartConfigElement() {\n-        return multipartConfigElement;\n-    }\n-\n-    /**\n-     * Get servlet config.\n-     */\n-    public ServletConfig getServletConfig() {\n-        return servletConfig;\n-    }\n-\n-    /**\n-     * Get servlet.\n-     */\n-    public Servlet getServlet() {\n-        return servlet;\n-    }\n-\n-    /**\n-     * Is async supported.\n-     */\n-    public Boolean isAsyncSupported() {\n-        return asyncSupported;\n-    }\n-\n-    /**\n-     * Get load on startup.\n-     */\n-    public int getLoadOnStartup() {\n-        return loadOnStartup;\n-    }\n-\n-    /**\n-     * Is initialization servlet cas.\n-     */\n-    public boolean isInitServletCas(boolean expect, boolean update) {\n-        return initServlet.compareAndSet(expect,update);\n-    }\n-\n-    /**\n-     * Is initialization servlet.\n-     */\n-    public boolean isInitServlet() {\n-        return initServlet.get();\n-    }\n-\n-    @Override\n-    public Set<String> addMapping(String... urlPatterns) {\n-        mappingSet.addAll(Arrays.asList(urlPatterns));\n-        for (String pattern : urlPatterns) {\n-            urlMapper.addMapping(pattern, this, servletName);\n-        }\n-        return mappingSet;\n-    }\n-\n-    @Override\n-    public Collection<String> getMappings() {\n-        return mappingSet;\n-    }\n-\n-    @Override\n-    public String getRunAsRole() {\n-        return roleName;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return servletName;\n-    }\n-\n-    @Override\n-    public String getClassName() {\n-        return servlet.getClass().getName();\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParameterMap.put(name,value) != null;\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParameterMap.get(name);\n-    }\n-\n-    @Override\n-    public Set<String> setInitParameters(Map<String, String> initParameters) {\n-        this.initParameterMap = initParameters;\n-        return initParameterMap.keySet();\n-    }\n-\n-    @Override\n-    public Map<String, String> getInitParameters() {\n-        return initParameterMap;\n-    }\n-\n-    @Override\n-    public void setLoadOnStartup(int loadOnStartup) {\n-        this.loadOnStartup = loadOnStartup;\n-    }\n-\n-    @Override\n-    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n-        this.servletSecurityElement = constraint;\n-        return new HashSet<>(servletSecurityElement.getMethodNames());\n-    }\n-\n-    @Override\n-    public void setMultipartConfig(MultipartConfigElement multipartConfig) {\n-        this.multipartConfigElement = multipartConfig;\n-    }\n-\n-    @Override\n-    public void setRunAsRole(String roleName) {\n-        this.roleName = roleName;\n-    }\n-\n-    @Override\n-    public void setAsyncSupported(boolean isAsyncSupported) {\n-        this.asyncSupported = isAsyncSupported;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190101", "bodyText": "Question: Does this have to be Dynamic? If all parameters are set when it's added, could be just ServletRegistration?", "author": "minwoox", "createdAt": "2020-05-07T01:42:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link ServletContextImpl} instance.\n+ */\n+public class ServletBuilder {\n+\n+    @Nullable\n+    private ServletContextImpl servletContext;\n+\n+    private ServerBuilder serverBuilder;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        servletContext = new ServletContextImpl();\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link DefaultServletService}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet of the {@link DefaultServletService}.\n+     */\n+    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n+        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyNTAwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421425008", "bodyText": "This have to be Dynamic interface, because ServletRegistration interface don't include setLoadOnStartup() method and setAsyncSupported() method.", "author": "dominhhien", "createdAt": "2020-05-07T11:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MzYxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421893614", "bodyText": "Yes, but it seems like we don't set setAsyncSupported as true for now. Also setLoadOnStartup(1) doesn't seem much meaning.\nHow about just using ServletRegistration here and\nadding another method for async such as addAsyncServlet later?", "author": "minwoox", "createdAt": "2020-05-08T01:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4MjY2Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r422482667", "bodyText": "Agree, Armeria has been async already. We don't need servlet async sound like that add more queue + executor thread pool. In this case servlet async make system more complicated and not good performance.", "author": "dominhhien", "createdAt": "2020-05-09T10:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100644\nindex 14bd53605b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link ServletContextImpl} instance.\n- */\n-public class ServletBuilder {\n-\n-    @Nullable\n-    private ServletContextImpl servletContext;\n-\n-    private ServerBuilder serverBuilder;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        servletContext = new ServletContextImpl();\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link DefaultServletService}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet of the {@link DefaultServletService}.\n-     */\n-    public ServletBuilder addServlet(String path, HttpServlet httpServlet) {\n-        final ServletRegistration.Dynamic sd = servletContext.addServlet(path, httpServlet);\n-        sd.addMapping(path);\n-        sd.setLoadOnStartup(1);\n-        sd.setAsyncSupported(false);\n-        serverBuilder = serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDUxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190517", "bodyText": "Please add static final. Also we just use ServleteContextImpl.class.\nprivate static final Logger logger = LoggerFactory.getLogger(ServleteContextImpl.class);", "author": "minwoox", "createdAt": "2020-05-07T01:43:51Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\ndeleted file mode 100644\nindex 35afe98446..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\n+++ /dev/null\n\n@@ -1,617 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.util.concurrent.FastThreadLocal;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class ServletContextImpl implements ServletContext {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout = 1200;\n-    /**\n-     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n-     * is called is exceeded.\n-     */\n-    private int responseWriterChunkMaxHeapByteLength = 4096;\n-    /**\n-     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n-     */\n-    private long uploadMinSize = 4096 * 16;\n-    private Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n-            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n-        @Override\n-        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n-            return new HashMap<>();\n-        }\n-    };\n-    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-\n-    private ExecutorService asyncExecutorService;\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-\n-    private String contextPath;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private String servletContextName;\n-    private InetSocketAddress serverAddress;\n-    private ClassLoader classLoader;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl() {\n-        classLoader = getClass().getClassLoader();\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl(ClassLoader classLoader) {\n-        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        if (sessionTimeout <= 0) {\n-            return;\n-        }\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public ServletContextImpl getContext(String uripath) {\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        final ServletRegistration servletRegistration = null == name ? null : getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName,servlet,this,servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName,newServlet,this,servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        Objects.requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"applicationContext.addListener.iae.wrongType\" +\n-                    listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MDc2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421190762", "bodyText": "Let's rename to DefaultServletContext.", "author": "minwoox", "createdAt": "2020-05-07T01:44:45Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\ndeleted file mode 100644\nindex 35afe98446..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\n+++ /dev/null\n\n@@ -1,617 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.util.concurrent.FastThreadLocal;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class ServletContextImpl implements ServletContext {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout = 1200;\n-    /**\n-     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n-     * is called is exceeded.\n-     */\n-    private int responseWriterChunkMaxHeapByteLength = 4096;\n-    /**\n-     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n-     */\n-    private long uploadMinSize = 4096 * 16;\n-    private Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n-            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n-        @Override\n-        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n-            return new HashMap<>();\n-        }\n-    };\n-    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-\n-    private ExecutorService asyncExecutorService;\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-\n-    private String contextPath;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private String servletContextName;\n-    private InetSocketAddress serverAddress;\n-    private ClassLoader classLoader;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl() {\n-        classLoader = getClass().getClassLoader();\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl(ClassLoader classLoader) {\n-        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        if (sessionTimeout <= 0) {\n-            return;\n-        }\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public ServletContextImpl getContext(String uripath) {\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        final ServletRegistration servletRegistration = null == name ? null : getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName,servlet,this,servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName,newServlet,this,servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        Objects.requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"applicationContext.addListener.iae.wrongType\" +\n-                    listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTU3NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421191574", "bodyText": "Let's add these fields to ServletBuilder so that a user change the values.", "author": "minwoox", "createdAt": "2020-05-07T01:47:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTg2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421191864", "bodyText": "After that. We can get all properties from the constructor and make all properties as final.", "author": "minwoox", "createdAt": "2020-05-07T01:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MTU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\ndeleted file mode 100644\nindex 35afe98446..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\n+++ /dev/null\n\n@@ -1,617 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.util.concurrent.FastThreadLocal;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class ServletContextImpl implements ServletContext {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout = 1200;\n-    /**\n-     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n-     * is called is exceeded.\n-     */\n-    private int responseWriterChunkMaxHeapByteLength = 4096;\n-    /**\n-     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n-     */\n-    private long uploadMinSize = 4096 * 16;\n-    private Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n-            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n-        @Override\n-        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n-            return new HashMap<>();\n-        }\n-    };\n-    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-\n-    private ExecutorService asyncExecutorService;\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-\n-    private String contextPath;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private String servletContextName;\n-    private InetSocketAddress serverAddress;\n-    private ClassLoader classLoader;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl() {\n-        classLoader = getClass().getClassLoader();\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl(ClassLoader classLoader) {\n-        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        if (sessionTimeout <= 0) {\n-            return;\n-        }\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public ServletContextImpl getContext(String uripath) {\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        final ServletRegistration servletRegistration = null == name ? null : getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName,servlet,this,servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName,newServlet,this,servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        Objects.requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"applicationContext.addListener.iae.wrongType\" +\n-                    listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjAzOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421192039", "bodyText": "this.classLoader = requireNonNull(classLoader, \"classLoader\");", "author": "minwoox", "createdAt": "2020-05-07T01:49:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\ndeleted file mode 100644\nindex 35afe98446..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\n+++ /dev/null\n\n@@ -1,617 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.util.concurrent.FastThreadLocal;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class ServletContextImpl implements ServletContext {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout = 1200;\n-    /**\n-     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n-     * is called is exceeded.\n-     */\n-    private int responseWriterChunkMaxHeapByteLength = 4096;\n-    /**\n-     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n-     */\n-    private long uploadMinSize = 4096 * 16;\n-    private Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n-            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n-        @Override\n-        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n-            return new HashMap<>();\n-        }\n-    };\n-    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-\n-    private ExecutorService asyncExecutorService;\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-\n-    private String contextPath;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private String servletContextName;\n-    private InetSocketAddress serverAddress;\n-    private ClassLoader classLoader;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl() {\n-        classLoader = getClass().getClassLoader();\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl(ClassLoader classLoader) {\n-        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        if (sessionTimeout <= 0) {\n-            return;\n-        }\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public ServletContextImpl getContext(String uripath) {\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        final ServletRegistration servletRegistration = null == name ? null : getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName,servlet,this,servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName,newServlet,this,servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        Objects.requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"applicationContext.addListener.iae.wrongType\" +\n-                    listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjQ2Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421192466", "bodyText": "requireNonNull(absoluteUri, \"absoluteUri\");", "author": "minwoox", "createdAt": "2020-05-07T01:50:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODY1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198651", "bodyText": "Please use requireNonNull through out this PR if the parameter is not annotated with @Nullable.", "author": "minwoox", "createdAt": "2020-05-07T02:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\ndeleted file mode 100644\nindex 35afe98446..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\n+++ /dev/null\n\n@@ -1,617 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.util.concurrent.FastThreadLocal;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class ServletContextImpl implements ServletContext {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout = 1200;\n-    /**\n-     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n-     * is called is exceeded.\n-     */\n-    private int responseWriterChunkMaxHeapByteLength = 4096;\n-    /**\n-     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n-     */\n-    private long uploadMinSize = 4096 * 16;\n-    private Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n-            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n-        @Override\n-        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n-            return new HashMap<>();\n-        }\n-    };\n-    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-\n-    private ExecutorService asyncExecutorService;\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-\n-    private String contextPath;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private String servletContextName;\n-    private InetSocketAddress serverAddress;\n-    private ClassLoader classLoader;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl() {\n-        classLoader = getClass().getClassLoader();\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl(ClassLoader classLoader) {\n-        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        if (sessionTimeout <= 0) {\n-            return;\n-        }\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public ServletContextImpl getContext(String uripath) {\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        final ServletRegistration servletRegistration = null == name ? null : getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName,servlet,this,servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName,newServlet,this,servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        Objects.requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"applicationContext.addListener.iae.wrongType\" +\n-                    listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5Mzc3NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421193774", "bodyText": "checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout)", "author": "minwoox", "createdAt": "2020-05-07T01:55:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java", "diffHunk": "@@ -0,0 +1,617 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.handler.codec.http.multipart.HttpDataFactory;\n+import io.netty.util.concurrent.FastThreadLocal;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class ServletContextImpl implements ServletContext {\n+    private Logger logger = LoggerFactory.getLogger(getClass());\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout = 1200;\n+    /**\n+     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n+     * is called is exceeded.\n+     */\n+    private int responseWriterChunkMaxHeapByteLength = 4096;\n+    /**\n+     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n+     */\n+    private long uploadMinSize = 4096 * 16;\n+    private Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n+            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n+        @Override\n+        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n+            return new HashMap<>();\n+        }\n+    };\n+    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+\n+    private ExecutorService asyncExecutorService;\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+\n+    private String contextPath;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private String servletContextName;\n+    private InetSocketAddress serverAddress;\n+    private ClassLoader classLoader;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl() {\n+        classLoader = getClass().getClassLoader();\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletContextImpl(ClassLoader classLoader) {\n+        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n+    }\n+\n+    /**\n+     * Get servlet event listener manager.\n+     */\n+    public ServletEventListenerManager getServletEventListenerManager() {\n+        return servletEventListenerManager;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        if (sessionTimeout <= 0) {", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODc5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198796", "bodyText": "Please validate the parameter through out this PR.", "author": "minwoox", "createdAt": "2020-05-07T02:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5Mzc3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\ndeleted file mode 100644\nindex 35afe98446..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletContextImpl.java\n+++ /dev/null\n\n@@ -1,617 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ExecutorService;\n-\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.handler.codec.http.multipart.HttpDataFactory;\n-import io.netty.util.concurrent.FastThreadLocal;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class ServletContextImpl implements ServletContext {\n-    private Logger logger = LoggerFactory.getLogger(getClass());\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout = 1200;\n-    /**\n-     * The maximum number of bytes written to the outputstream.writer () method of the servlet each time it\n-     * is called is exceeded.\n-     */\n-    private int responseWriterChunkMaxHeapByteLength = 4096;\n-    /**\n-     * Minimum upload file length, in bytes (becomes temporary file storage if larger than 16KB).\n-     */\n-    private long uploadMinSize = 4096 * 16;\n-    private Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private FastThreadLocal<Map<Charset, HttpDataFactory>> httpDataFactoryThreadLocal =\n-            new FastThreadLocal<Map<Charset, HttpDataFactory>>() {\n-        @Override\n-        protected Map<Charset, HttpDataFactory> initialValue() throws Exception {\n-            return new HashMap<>();\n-        }\n-    };\n-    private Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-\n-    private ExecutorService asyncExecutorService;\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-\n-    private String contextPath;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private String servletContextName;\n-    private InetSocketAddress serverAddress;\n-    private ClassLoader classLoader;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl() {\n-        classLoader = getClass().getClassLoader();\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletContextImpl(ClassLoader classLoader) {\n-        this.classLoader = classLoader == null ? getClass().getClassLoader() : classLoader;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        if (sessionTimeout <= 0) {\n-            return;\n-        }\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public ServletContextImpl getContext(String uripath) {\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        final ServletRegistration servletRegistration = null == name ? null : getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = ServletRequestDispatcher.of(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, Object object) {\n-        Objects.requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName,servlet,this,servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName,newServlet,this,servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        Objects.requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"applicationContext.addListener.iae.wrongType\" +\n-                    listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421195408", "bodyText": "Is there any reason to make ServletHttpExchange?\nWe have ServletContextImpl already, couldn't we just make ServletHttpRequest and ServletHttpResponse directly?", "author": "minwoox", "createdAt": "2020-05-07T02:01:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNjkwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421316902", "bodyText": "ServletHttpExchange like a HttpExchange https://docs.oracle.com/javase/8/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpExchange.html in JDK HttpServer. ServletHttpExchange store protocol information, channel or reader/writer API. I think we should separate initialization class (ServletContextImpl) and communication class (ServletHttpExchange) . How do you think?", "author": "dominhhien", "createdAt": "2020-05-07T08:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5NDgxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421894817", "bodyText": "Yes, but it looks like all ServletHttpExchange doing is just calling getServletContext() which we already have.\nHow about introducing it later when we find that it really needs?", "author": "minwoox", "createdAt": "2020-05-08T02:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjYwMzU3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r422603571", "bodyText": "Agree, I will remove it.", "author": "dominhhien", "createdAt": "2020-05-10T07:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5NTQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 678d167817..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private final ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            if (cause != null) {\n-                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n-                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n-                    res.close();\n-                }\n-                return null;\n-            }\n-            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res, ServletHttpExchange servletHttpExchange) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-                return;\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421198343", "bodyText": "If we add the ServletService one by one, https://github.com/line/armeria/pull/2686/files#diff-6b0e2525eb80747c141e9fb8daa2c3adR56, we don't need this dispatcher\nbecause Armeria server will handle the routing.", "author": "minwoox", "createdAt": "2020-05-07T02:12:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final ServletContextImpl servletContext;\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(ServletContextImpl servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res, ServletHttpExchange servletHttpExchange) {\n+        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n+        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n+        try {\n+            final ServletRequestDispatcher dispatcher =\n+                    servletHttpExchange.getServletContext()\n+                                       .getRequestDispatcher(httpServletRequest.getRequestURI());", "originalCommit": "b9cf3d78f4d0df5e8c37ba2c23e49c3e1a62a367", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxNTcyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421415722", "bodyText": "Yes, we don't need routing here. But dispatcher help us insert filter class (interceptor). I think we should keep dispatcher here.", "author": "dominhhien", "createdAt": "2020-05-07T10:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwOTcxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421909718", "bodyText": "@dominhhien Thanks for the explanation. Honestly, I'm not sure if we need this or not. If it's just only for the filter, we can implement our own logic for that. so that we can remove complicated UrlMapper and MimeMappings classes that Armeria server already handles.\nIs there any other usage for the RequestDiscpatcher except for the filter?", "author": "minwoox", "createdAt": "2020-05-08T03:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxMTE1Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r421911157", "bodyText": "Also, is there any chance that a user needs to use RequestDispatcher?", "author": "minwoox", "createdAt": "2020-05-08T03:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDAwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r422440008", "bodyText": "I think we should keep RequestDispatcher interface because it is a part of Servlet API.", "author": "dominhhien", "createdAt": "2020-05-09T01:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5ODM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 678d167817..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private final ServletContextImpl servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(ServletContextImpl servletContext) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            if (cause != null) {\n-                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n-                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n-                    res.close();\n-                }\n-                return null;\n-            }\n-            process(res, ServletHttpExchange.of(servletContext, ctx, aReq));\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res, ServletHttpExchange servletHttpExchange) {\n-        final ServletHttpRequest httpServletRequest = servletHttpExchange.getRequest();\n-        final ServletHttpResponse httpServletResponse = servletHttpExchange.getResponse();\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletHttpExchange.getServletContext()\n-                                       .getRequestDispatcher(httpServletRequest.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-                return;\n-            }\n-            httpServletRequest.setDispatcher(dispatcher);\n-            httpServletResponse.setResponseWriter(res);\n-            dispatcher.dispatch(httpServletRequest, httpServletResponse);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423504165", "bodyText": "There is no way to set these properties.\nHow about adding it to ServletBuilder?\nServletBuilder servletBuilder = ...\nservletBuilder.requestCharacterEncoding(...)\n...\nservletBuilder.build(); // DefaultServletContext is created at this point based on the properties set so far.", "author": "minwoox", "createdAt": "2020-05-12T06:59:30Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletContextAttributeEvent;\n+import javax.servlet.ServletContextAttributeListener;\n+import javax.servlet.ServletContextListener;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletRequestAttributeListener;\n+import javax.servlet.ServletRequestListener;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpSessionAttributeListener;\n+import javax.servlet.http.HttpSessionIdListener;\n+import javax.servlet.http.HttpSessionListener;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    /**\n+     * Default: 20 minutes.\n+     */\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private final MimeMappings mimeMappings = new MimeMappings();\n+    private final ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private ClassLoader classLoader = getClass().getClassLoader();\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;", "originalCommit": "df2377dcecf31a1b82bc4ebed6bb802065c38069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2NDI5NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423564294", "bodyText": "Yes, I know. But I'm not sure if we should support contextPath. If we support context path, all service URLs have to concat context path. Example if context path is (/app), service URL will be (/app/welcome, /app/home) instead of (/wecome, /home) . Should we support context path? How do you think?", "author": "dominhhien", "createdAt": "2020-05-12T08:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3MDgyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423570824", "bodyText": "I think we will support context path later, context path is only useful if we want to deploy multiple apps on one armeria server.", "author": "dominhhien", "createdAt": "2020-05-12T08:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3ODU4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423578584", "bodyText": "If we decide to support contextPath. I will add setContextPath() method to ServletBuilder.", "author": "dominhhien", "createdAt": "2020-05-12T09:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3OTA4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423579087", "bodyText": "Should we support context path? How do you think?\n\nI don't think so. \ud83d\ude04 Please add setters that you think a user might want to customize.", "author": "minwoox", "createdAt": "2020-05-12T09:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYwNjE3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423606171", "bodyText": "Agree, I will add setters.", "author": "dominhhien", "createdAt": "2020-05-12T09:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2MjIwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429062207", "bodyText": "Also could you add tests for the path we discussed using ServerExtenstion?\nFor example:\nWhen contextPath = \"\" and the servletes are added to the path \"/foo\", \"/foo/\" and \"\".\nWhen contextPath = \"/foo\" and the servletes are added to the path \"/bar\", \"/bar/\" and \"\".", "author": "minwoox", "createdAt": "2020-05-22T06:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEwNDAzOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429104038", "bodyText": "Agree, I will add tests code.", "author": "dominhhien", "createdAt": "2020-05-22T08:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100644\nindex f154cd646b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,622 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.FilterRegistration;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletContextAttributeEvent;\n-import javax.servlet.ServletContextAttributeListener;\n-import javax.servlet.ServletContextListener;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.ServletRequestAttributeListener;\n-import javax.servlet.ServletRequestListener;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpSessionAttributeListener;\n-import javax.servlet.http.HttpSessionIdListener;\n-import javax.servlet.http.HttpSessionListener;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-    /**\n-     * Default: 20 minutes.\n-     */\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, ServletFilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private final MimeMappings mimeMappings = new MimeMappings();\n-    private final ServletEventListenerManager servletEventListenerManager = new ServletEventListenerManager();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<ServletFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private ClassLoader classLoader = getClass().getClassLoader();\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath, String servletContextName) {\n-        this.contextPath = contextPath;\n-        this.servletContextName = servletContextName;\n-    }\n-\n-    /**\n-     * Get servlet event listener manager.\n-     */\n-    public ServletEventListenerManager getServletEventListenerManager() {\n-        return servletEventListenerManager;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = ServletFilterChain.of(this, servletRegistration);\n-        final List<ServletFilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (ServletFilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-\n-        final Object oldObject = attributeMap.put(name,object);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeAdded(\n-                    new ServletContextAttributeEvent(this,name,object));\n-            if (oldObject != null) {\n-                listenerManager.onServletContextAttributeReplaced(\n-                        new ServletContextAttributeEvent(this,name,oldObject));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object oldObject = attributeMap.remove(name);\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listenerManager.hasServletContextAttributeListener()) {\n-            listenerManager.onServletContextAttributeRemoved(\n-                    new ServletContextAttributeEvent(this,name,oldObject));\n-        }\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<? extends Servlet>) Class.forName(className).newInstance());\n-        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-\n-        final Servlet newServlet = servletEventListenerManager.onServletAdded(servlet);\n-        final ServletRegistration servletRegistration;\n-        if (newServlet == null) {\n-            servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        } else {\n-            servletRegistration = new ServletRegistration(servletName, newServlet, this, servletUrlMapper);\n-        }\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        Servlet servlet = null;\n-        try {\n-            servlet = servletClass.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return addServlet(servletName,servlet);\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<? extends Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        final ServletFilterRegistration registration =\n-                new ServletFilterRegistration(filterName,filter,this,filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public ServletFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName,filterClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletFilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        requireNonNull(className, \"className\");\n-        try {\n-            addListener((Class<? extends EventListener>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        requireNonNull(listener);\n-\n-        final ServletEventListenerManager listenerManager = getServletEventListenerManager();\n-        if (listener instanceof ServletContextAttributeListener) {\n-            listenerManager.addServletContextAttributeListener((ServletContextAttributeListener) listener);\n-        } else if (listener instanceof ServletRequestListener) {\n-            listenerManager.addServletRequestListener((ServletRequestListener) listener);\n-        } else if (listener instanceof ServletRequestAttributeListener) {\n-            listenerManager.addServletRequestAttributeListener((ServletRequestAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionIdListener) {\n-            listenerManager.addHttpSessionIdListener((HttpSessionIdListener) listener);\n-        } else if (listener instanceof HttpSessionAttributeListener) {\n-            listenerManager.addHttpSessionAttributeListener((HttpSessionAttributeListener) listener);\n-        } else if (listener instanceof HttpSessionListener) {\n-            listenerManager.addHttpSessionListener((HttpSessionListener) listener);\n-        } else if (listener instanceof ServletContextListener) {\n-            listenerManager.addServletContextListener((ServletContextListener) listener);\n-        } else {\n-            throw new IllegalArgumentException(\"Wrong type \" + listener.getClass().getName());\n-        }\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        requireNonNull(listenerClass, \"listenerClass\");\n-        try {\n-            addListener(listenerClass.newInstance());\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            e.printStackTrace();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxODE4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423518187", "bodyText": "Because we are just handling sync servlet (we are going to handle the async servlets later) we must use blockingTaskExecutor.\nctx.blockingTaskExecutor().execute(() -> {\n    ...\n});\n// or we just can do it in handle.\nreq.aggregate().handleAsync((aReq, cause) -> {\n    ...\n}, ctx.blockingTaskExecutor());", "author": "minwoox", "createdAt": "2020-05-12T07:26:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final DefaultServletContext servletContext;\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private ServiceRequestContext serviceRequestContext;\n+\n+    /**\n+     * Get http servlet request.\n+     */\n+    public ServletHttpRequest getRequest() {\n+        return request;\n+    }\n+\n+    /**\n+     * Get servlet context.\n+     */\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    /**\n+     * Get http servlet response.\n+     */\n+    public ServletHttpResponse getResponse() {\n+        return response;\n+    }\n+\n+    /**\n+     * Get channel handler context.\n+     */\n+    public ServiceRequestContext getServiceRequestContext() {\n+        return serviceRequestContext;\n+    }\n+\n+    /**\n+     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n+     */\n+    public DefaultServletService(DefaultServletContext servletContext) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        this.servletContext = servletContext;\n+    }\n+\n+    /**\n+     * handles {@link HttpRequest} and forward to Servlet APIs.\n+     */\n+    @Override\n+    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n+        requireNonNull(ctx, \"ctx\");\n+        requireNonNull(req, \"req\");\n+        serviceRequestContext = ctx;\n+        final HttpResponseWriter res = HttpResponse.streaming();\n+        req.aggregate().handle((aReq, cause) -> {\n+            if (cause != null) {\n+                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n+                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n+                    res.close();\n+                }\n+                return null;\n+            }\n+            process(res, aReq);\n+            return null;\n+        });\n+        return res;\n+    }\n+\n+    private void process(HttpResponseWriter res, AggregatedHttpRequest req) {", "originalCommit": "df2377dcecf31a1b82bc4ebed6bb802065c38069", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex fb11d2ff45..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,124 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private final DefaultServletContext servletContext;\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private ServiceRequestContext serviceRequestContext;\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public ServiceRequestContext getServiceRequestContext() {\n-        return serviceRequestContext;\n-    }\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(DefaultServletContext servletContext) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        requireNonNull(ctx, \"ctx\");\n-        requireNonNull(req, \"req\");\n-        serviceRequestContext = ctx;\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            if (cause != null) {\n-                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n-                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n-                    res.close();\n-                }\n-                return null;\n-            }\n-            process(res, aReq);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res, AggregatedHttpRequest req) {\n-        requireNonNull(res, \"res\");\n-        request = new ServletHttpRequest(this, req);\n-        response = new ServletHttpResponse(this);\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletContext.getRequestDispatcher(request.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-                return;\n-            }\n-            request.setDispatcher(dispatcher);\n-            response.setResponseWriter(res);\n-            dispatcher.dispatch(request, response);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxOTMwOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r423519308", "bodyText": "These three properties can be here. Please imagine a situation that this DefaultServletService handles multiple thousands requests.", "author": "minwoox", "createdAt": "2020-05-12T07:28:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n+    private final DefaultServletContext servletContext;\n+    private ServletHttpRequest request;\n+    private ServletHttpResponse response;\n+    private ServiceRequestContext serviceRequestContext;", "originalCommit": "df2377dcecf31a1b82bc4ebed6bb802065c38069", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex fb11d2ff45..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,124 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private final DefaultServletContext servletContext;\n-    private ServletHttpRequest request;\n-    private ServletHttpResponse response;\n-    private ServiceRequestContext serviceRequestContext;\n-\n-    /**\n-     * Get http servlet request.\n-     */\n-    public ServletHttpRequest getRequest() {\n-        return request;\n-    }\n-\n-    /**\n-     * Get servlet context.\n-     */\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    /**\n-     * Get http servlet response.\n-     */\n-    public ServletHttpResponse getResponse() {\n-        return response;\n-    }\n-\n-    /**\n-     * Get channel handler context.\n-     */\n-    public ServiceRequestContext getServiceRequestContext() {\n-        return serviceRequestContext;\n-    }\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(DefaultServletContext servletContext) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        requireNonNull(ctx, \"ctx\");\n-        requireNonNull(req, \"req\");\n-        serviceRequestContext = ctx;\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handle((aReq, cause) -> {\n-            if (cause != null) {\n-                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n-                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n-                    res.close();\n-                }\n-                return null;\n-            }\n-            process(res, aReq);\n-            return null;\n-        });\n-        return res;\n-    }\n-\n-    private void process(HttpResponseWriter res, AggregatedHttpRequest req) {\n-        requireNonNull(res, \"res\");\n-        request = new ServletHttpRequest(this, req);\n-        response = new ServletHttpResponse(this);\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletContext.getRequestDispatcher(request.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-                return;\n-            }\n-            request.setDispatcher(dispatcher);\n-            response.setResponseWriter(res);\n-            dispatcher.dispatch(request, response);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjYxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425522616", "bodyText": "Let's split this constructor into two:\npublic ServletBuilder(ServerBuilder serverBuilder) {\n    this(serverBuilder, \"\");\n}\n\npublic ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n    requireNonNull(serverBuilder, \"serverBuilder\");\n    requireNonNull(contextPath, \"contextPath\");\n    ...\n}", "author": "minwoox", "createdAt": "2020-05-15T01:51:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex be5344fdd8..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,180 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.Objects;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        if (Objects.isNull(contextPath)) {\n-            contextPath = \"\";\n-        }\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),\n-                          \"Context path have to start with / and contains only one /\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (!\"\".equals(contextPath)) {\n-            path = \"/\".equals(path) ? contextPath : contextPath + path;\n-        }\n-        ServletRegistration sd = null;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyMjk2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425522969", "bodyText": "Please note that the contextPath could be: /x/y/z\nSo we should do contextPath.charAt(contextPath.length() - 1) != '/'", "author": "minwoox", "createdAt": "2020-05-15T01:53:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        if (Objects.isNull(contextPath)) {\n+            contextPath = \"\";\n+        }\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex be5344fdd8..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,180 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.Objects;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        if (Objects.isNull(contextPath)) {\n-            contextPath = \"\";\n-        }\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),\n-                          \"Context path have to start with / and contains only one /\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (!\"\".equals(contextPath)) {\n-            path = \"/\".equals(path) ? contextPath : contextPath + path;\n-        }\n-        ServletRegistration sd = null;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425556981", "bodyText": "I think we can just add one DefaultServletService when ServletBuilder.build() is called.\nserverBuilder.serviceUnder(contextPath, new DefaultServletService(servletContext));\n\nBecause we use context.getRequestDispacher(path) in DefaultServletService to find the corresponding Servlet.", "author": "minwoox", "createdAt": "2020-05-15T04:16:39Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Objects;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        if (Objects.isNull(contextPath)) {\n+            contextPath = \"\";\n+        }\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),\n+                          \"Context path have to start with / and contains only one /\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!\"\".equals(contextPath)) {\n+            path = \"/\".equals(path) ? contextPath : contextPath + path;\n+        }\n+        ServletRegistration sd = null;\n+        if (servlet instanceof String) {\n+            sd = servletContext.addServlet(path, (String) servlet);\n+        } else {\n+            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n+        }\n+        sd.addMapping(path);\n+        serverBuilder.service(path, new DefaultServletService(servletContext));", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzNTk5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425635991", "bodyText": "Probably not, because user can add servlet root path \"/\" or \"\" (It is also context path) :\nsb.servlet(\"/\", new HomeServlet())\nor\nsb.servlet(\"\", new HomeServlet())\nI think user should decide whether to implement servlet root path or not.", "author": "dominhhien", "createdAt": "2020-05-15T08:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY1NDg3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425654879", "bodyText": "sb.servlet(\"/\", new HomeServlet())\nor\nsb.servlet(\"\", new HomeServlet())\n\nWhat's the URL that a user connects to the servlet in those cases?", "author": "minwoox", "createdAt": "2020-05-15T08:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2NDIxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425664216", "bodyText": "URL is http://host:port/contextPath,  contextPath is initialized in DefaultServletContext.\n\tnew DefaultServletContext(contextPath)\n\nServletBuilder.java\n    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n        requireNonNull(serverBuilder, \"serverBuilder\");\n        requireNonNull(contextPath, \"contextPath\");\n        if (!contextPath.isEmpty()) {\n            checkArgument(contextPath.charAt(0) == '/' &&\n                           contextPath.charAt(contextPath.length() - 1) != '/',\n                          \"Context path format is /x/y/z\", contextPath);\n        }\n        servletContext = new DefaultServletContext(contextPath);\n        this.contextPath = contextPath;\n        this.serverBuilder = serverBuilder;\n    }", "author": "dominhhien", "createdAt": "2020-05-15T09:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY2ODQ4Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425668486", "bodyText": "What I meant was what's the difference between URLs when contextPath is \"/\" and \"\"?\nIsn't it http://host:port/ in both cases?", "author": "minwoox", "createdAt": "2020-05-15T09:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4MjA2Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425682063", "bodyText": "Armeria server does not support empty service path (\"\"). But servlet support empty path. If we access http://host:port, server return http://host:port/ => Http response status is 307 (redirect) instead of 200(ok) because URL was changed. If we support both cases \"/\" and \"\", Http response status always be 200 (ok).", "author": "dominhhien", "createdAt": "2020-05-15T09:32:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MDUzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425690535", "bodyText": "Armeria server not support empty service path (\"\")\n\nRight, Armeria does not support the empty path so a servlet on Armeria couldn't have empty path mapping. Isn't that right?\nI was thinking just adding / after contextPath when we call\nserverBuilder.serviceUnder(...); because the contextPath does not end with /\nso that we can just handle the servlets by just adding one DefaultServletService.\nWhen contextPath is /foo:\n\nif a user adds a servlet too /bar, then the url is http://host:port/foo/bar\n\nWhen contextPath is \"\":\n\nif a user adds a servlet too /baz, then the url is http://host:port/baz\nif a user adds a servlet too /, then the url is http://host:port/\n\nWhen contextPath is /:\n\nThis is an exception.\n\nWhat do you think?", "author": "minwoox", "createdAt": "2020-05-15T09:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5ODIzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425698233", "bodyText": "Yes, it's like you explained. I will fix this exception. Do you suggest another solution for this problem?", "author": "dominhhien", "createdAt": "2020-05-15T10:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMDk3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425700970", "bodyText": "I think add available DefaultServletService is not perfect solution. It is very nice if default case return Not found with path / and users can add a customized servlet / when \ufffdthey need it. What do you think?", "author": "dominhhien", "createdAt": "2020-05-15T10:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1Njk4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex be5344fdd8..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,180 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.Objects;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, @Nullable String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        if (Objects.isNull(contextPath)) {\n-            contextPath = \"\";\n-        }\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.charAt(0) == '/' && !contextPath.substring(1).contains(\"/\"),\n-                          \"Context path have to start with / and contains only one /\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (!\"\".equals(contextPath)) {\n-            path = \"/\".equals(path) ? contextPath : contextPath + path;\n-        }\n-        ServletRegistration sd = null;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        serverBuilder.service(path, new DefaultServletService(servletContext));\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzE4MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425557180", "bodyText": "Question: Should we allow to add a servlet after the Server is started?", "author": "minwoox", "createdAt": "2020-05-15T04:17:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,570 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        final List<String> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getName());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {", "originalCommit": "eaab16d84518f0c5fbe702618287fcaaf8ad8a6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzU5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r425557593", "bodyText": "Probably not until there's a demand for such feature? It'd be nice to keep the supported feature set to an essential extent.", "author": "trustin", "createdAt": "2020-05-15T04:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NzE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex d5f6b3a259..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,570 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"oid": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "url": "https://github.com/line/armeria/commit/5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "message": "Fix servlet context path, prevent add servlet, filter after server is started", "committedDate": "2020-05-15T11:10:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427018545", "bodyText": "https://github.com/eclipse-ee4j/servlet-api/blob/master/spec/src/main/asciidoc/servlet-spec-body.adoc#35--request-path-elements\nI don't see any regulation that the path should not end with /.", "author": "minwoox", "createdAt": "2020-05-19T04:08:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (path.isEmpty()) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEzODU0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427138545", "bodyText": "What do you expect? Should /home and /home/ maps to the same servlet or 2 different servlets?", "author": "dominhhien", "createdAt": "2020-05-19T08:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTc5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427189793", "bodyText": "How about auto removing / if there is / at last of path.", "author": "dominhhien", "createdAt": "2020-05-19T10:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNTAxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427715016", "bodyText": "What other frameworks do in this case?", "author": "minwoox", "createdAt": "2020-05-20T03:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MjA3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427762073", "bodyText": "I test some site: facebook, google, confluence. I see both path return the same content. I think we can do that by maps both path to one servlet by ServletRegistration.", "author": "dominhhien", "createdAt": "2020-05-20T06:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex 09b7bcab2b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,197 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-    private boolean rootServletAdded;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        this(serverBuilder, \"\");\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        requireNonNull(contextPath, \"contextPath\");\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n-                          \"Context path format is /x/y/z\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n-        final DefaultServletService servletService = new DefaultServletService(servletContext);\n-        serverBuilder.serviceUnder(path, servletService);\n-        if (rootServletAdded) {\n-            serverBuilder.service(path, servletService);\n-        } else {\n-            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n-        }\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (path.isEmpty()) {\n-            rootServletAdded = true;\n-        } else {\n-            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n-                          \"Servlet path format is /x/y/z\", path);\n-        }\n-        path = contextPath + path;\n-        final ServletRegistration sd;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427018869", "bodyText": "Can remove this line and just do\nserverBuilder.serviceUnder(contextPath + '/', servletService);\nbecause / is always appended if the path prefix does not end with /", "author": "minwoox", "createdAt": "2020-05-19T04:09:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE1OTkwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427159905", "bodyText": "But I not only use path variable in serviceUnder() but also use it in service() method. I think we can keep this line.", "author": "dominhhien", "createdAt": "2020-05-19T09:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MTU2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427171564", "bodyText": "Ah, yes, forget about the comment. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-05-19T09:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxODg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex 09b7bcab2b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,197 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-    private boolean rootServletAdded;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        this(serverBuilder, \"\");\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        requireNonNull(contextPath, \"contextPath\");\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n-                          \"Context path format is /x/y/z\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n-        final DefaultServletService servletService = new DefaultServletService(servletContext);\n-        serverBuilder.serviceUnder(path, servletService);\n-        if (rootServletAdded) {\n-            serverBuilder.service(path, servletService);\n-        } else {\n-            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n-        }\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (path.isEmpty()) {\n-            rootServletAdded = true;\n-        } else {\n-            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n-                          \"Servlet path format is /x/y/z\", path);\n-        }\n-        path = contextPath + path;\n-        final ServletRegistration sd;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAxOTMxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427019315", "bodyText": "context format can be /x/y, /x/y/z/foo or whatever so we should change this.\ncheckArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n\"contextPath must start with / and must not end with /. contextPath: %s\", contextPath);", "author": "minwoox", "createdAt": "2020-05-19T04:11:28Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex 09b7bcab2b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,197 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-    private boolean rootServletAdded;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        this(serverBuilder, \"\");\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        requireNonNull(contextPath, \"contextPath\");\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n-                          \"Context path format is /x/y/z\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n-        final DefaultServletService servletService = new DefaultServletService(servletContext);\n-        serverBuilder.serviceUnder(path, servletService);\n-        if (rootServletAdded) {\n-            serverBuilder.service(path, servletService);\n-        } else {\n-            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n-        }\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (path.isEmpty()) {\n-            rootServletAdded = true;\n-        } else {\n-            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n-                          \"Servlet path format is /x/y/z\", path);\n-        }\n-        path = contextPath + path;\n-        final ServletRegistration sd;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMDc2Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427020766", "bodyText": "Let's remove this method and just add the servlet from the above:\npublic ServletBuilder servlet(String path, HttpServlet httpServlet) {\n    requireNonNull(path, \"path\");\n    requireNonNull(httpServlet, \"httpServlet\");\n    validatePath(path);\n    servletContext.addServlet(path, httpServlet);\n    return this;\n}\n\nPlease note that I didn't do sd.addMapping(path); because the path can be added in ServletContext.", "author": "minwoox", "createdAt": "2020-05-19T04:18:16Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex 09b7bcab2b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,197 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-    private boolean rootServletAdded;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        this(serverBuilder, \"\");\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        requireNonNull(contextPath, \"contextPath\");\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n-                          \"Context path format is /x/y/z\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n-        final DefaultServletService servletService = new DefaultServletService(servletContext);\n-        serverBuilder.serviceUnder(path, servletService);\n-        if (rootServletAdded) {\n-            serverBuilder.service(path, servletService);\n-        } else {\n-            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n-        }\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (path.isEmpty()) {\n-            rootServletAdded = true;\n-        } else {\n-            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n-                          \"Servlet path format is /x/y/z\", path);\n-        }\n-        path = contextPath + path;\n-        final ServletRegistration sd;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMTI5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427021291", "bodyText": "The value can be null, right?", "author": "minwoox", "createdAt": "2020-05-19T04:20:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        final List<String> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getName());\n+        }\n+        return Collections.enumeration(list);\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMTY3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427021671", "bodyText": "How about making a separate PR for filter related code?", "author": "minwoox", "createdAt": "2020-05-19T04:22:02Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"Context path format is /x/y/z\", contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        return addServlet(path, httpServlet);\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        return addServlet(path, servletClass);\n+    }\n+\n+    private ServletBuilder addServlet(String path, Object servlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (path.isEmpty()) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n+                          \"Servlet path format is /x/y/z\", path);\n+        }\n+        path = contextPath + path;\n+        final ServletRegistration sd;\n+        if (servlet instanceof String) {\n+            sd = servletContext.addServlet(path, (String) servlet);\n+        } else {\n+            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n+        }\n+        sd.addMapping(path);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the session timeout in minutes for this ServletContext.\n+     * @param sessionTimeout session timeout in minutes.\n+     */\n+    public ServletBuilder sessionTimeout(int sessionTimeout) {\n+        servletContext.setSessionTimeout(sessionTimeout);\n+        return this;\n+    }\n+\n+    /**\n+     * Set attribute value.\n+     */\n+    public ServletBuilder attribute(String key, @Nullable Object value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setAttribute(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Set init parameter.\n+     */\n+    public ServletBuilder initParameter(String key, @Nullable String value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setInitParameter(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Add filter.\n+     */\n+    public ServletBuilder filter(String filterName, Filter filter) {", "originalCommit": "99fc46d6d382b40c0d8e9221dacef8f235ebc0f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex 09b7bcab2b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,197 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.server.ServerBuilder;\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletBuilder.class);\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-    private boolean rootServletAdded;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        this(serverBuilder, \"\");\n-    }\n-\n-    /**\n-     * Constructor.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        requireNonNull(contextPath, \"contextPath\");\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.startsWith(\"/\") && contextPath.charAt(contextPath.length() - 1) != '/',\n-                          \"Context path format is /x/y/z\", contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n-        final DefaultServletService servletService = new DefaultServletService(servletContext);\n-        serverBuilder.serviceUnder(path, servletService);\n-        if (rootServletAdded) {\n-            serverBuilder.service(path, servletService);\n-        } else {\n-            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n-        }\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        return addServlet(path, httpServlet);\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        return addServlet(path, servletClass);\n-    }\n-\n-    private ServletBuilder addServlet(String path, Object servlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (path.isEmpty()) {\n-            rootServletAdded = true;\n-        } else {\n-            checkArgument(path.startsWith(\"/\") && path.charAt(path.length() - 1) != '/',\n-                          \"Servlet path format is /x/y/z\", path);\n-        }\n-        path = contextPath + path;\n-        final ServletRegistration sd;\n-        if (servlet instanceof String) {\n-            sd = servletContext.addServlet(path, (String) servlet);\n-        } else {\n-            sd = servletContext.addServlet(path, (HttpServlet) servlet);\n-        }\n-        sd.addMapping(path);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the session timeout in minutes for this ServletContext.\n-     * @param sessionTimeout session timeout in minutes.\n-     */\n-    public ServletBuilder sessionTimeout(int sessionTimeout) {\n-        servletContext.setSessionTimeout(sessionTimeout);\n-        return this;\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        servletContext.addFilter(filterName, filter);\n-        return this;\n-    }\n-\n-    /**\n-     * Add filter.\n-     */\n-    public ServletBuilder filter(String filterName, String filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            filter(filterName, servletContext.createFilter((Class<Filter>) Class.forName(filterClass)));\n-        } catch (ClassNotFoundException | ServletException e) {\n-            logger.info(\"Add servlet failed: \", e);\n-        }\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.addMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzQ5Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427023497", "bodyText": "Can remove this it not used.", "author": "minwoox", "createdAt": "2020-05-19T04:30:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxOTY4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427219682", "bodyText": "Yes, It is not used but Servlet API exists getServletContextName() method. I think we should create contextName from contextPath converting.", "author": "dominhhien", "createdAt": "2020-05-19T11:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzY1OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427023658", "bodyText": "if contextPath is /x/y/z, servletContextName will be xyz. Is this what you intended?", "author": "minwoox", "createdAt": "2020-05-19T04:30:57Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyMDU3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427220571", "bodyText": "Yes, but I think xyz is not pretty. I will change to x_y_z", "author": "dominhhien", "createdAt": "2020-05-19T11:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyMzY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNDcwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427024701", "bodyText": "We can set this when we call ServletBuilder.build().\nOf course, the name should be changed such as isInitailized?", "author": "minwoox", "createdAt": "2020-05-19T04:35:33Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTU3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025570", "bodyText": "Let's remove this and setServerAddress.", "author": "minwoox", "createdAt": "2020-05-19T04:39:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTgzOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025838", "bodyText": "return serviceRequestContext.localAddress().toString();", "author": "minwoox", "createdAt": "2020-05-19T04:40:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,871 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                                 DefaultServletContext servletContext,\n+                                 AggregatedHttpRequest request) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(request, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        httpRequest = request;\n+        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n+        if (servletContext.getServerAddress() == null) {\n+            servletContext.setServerAddress(\n+                    serviceRequestContext.remoteAddress());\n+        }\n+        decodeUrlParameter();\n+        decodeBody();\n+        decodeCookie();\n+        decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        decodePaths();\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        requireNonNull(dispatcher, \"dispatcher\");\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            parameterMap = ServletUtil.decodeBody(\n+                    parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    private void decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (value != null && value.length() > 0) {\n+            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n+            if (nettyCookieSet.size() > 0) {\n+                cookies = nettyCookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private void decodePaths() {\n+        String requestURI = httpRequest.path();\n+        final String queryString;\n+        final int queryInx = requestURI.indexOf('?');\n+        if (queryInx > -1) {\n+            queryString = requestURI.substring(queryInx + 1);\n+            requestURI = requestURI.substring(0, queryInx);\n+        } else {\n+            queryString = null;\n+        }\n+        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n+            requestURI = requestURI.substring(1);\n+        }\n+\n+        this.requestURI = requestURI;\n+        this.queryString = queryString;\n+    }\n+\n+    @Override\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) throws IllegalArgumentException {\n+        requireNonNull(name, \"name\");\n+        final String value = getHeader(name);\n+        if (value == null || \"\".equals(value)) {\n+            return -1;\n+        }\n+\n+        final DateFormat[] formats = FORMATS_TEMPLATE;\n+        Date date = null;\n+        for (int i = 0; (date == null) && (i < formats.length); i++) {\n+            try {\n+                date = formats[i].parse(value);\n+            } catch (ParseException e) {\n+                logger.info(\"Cannot parse \" + value + \" to date type\");\n+            }\n+        }\n+        if (date == null) {\n+            throw new IllegalArgumentException(value);\n+        }\n+        return date.getTime();\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);\n+        return value == null ? null : String.valueOf(value);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        final Set nameSet = httpRequest.headers().names();\n+        return new Enumeration<String>() {\n+            private Iterator iterator = nameSet.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = HttpHeaderConstants.HTTP_PORT;\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n+            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        if (this.servletPath == null) {\n+            String servletPath = getServletContext().getServletPath(getRequestURI());\n+            final String contextPath = getServletContext().getContextPath();\n+            if (contextPath.length() > 0) {\n+                servletPath = servletPath.replaceFirst(contextPath,\"\");\n+            }\n+            this.servletPath = servletPath;\n+        }\n+        return this.servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        return null;\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        final Collection collection = httpRequest.headers().getAll(name);\n+        return new Enumeration<String>() {\n+            private Iterator iterator = collection.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (headerStringValue == null) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return getServletContext().getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+                sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(getAttributeMap().keySet());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        if (characterEncoding == null) {\n+            decodeCharacterEncoding();\n+        }\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        requireNonNull(env, \"env\");\n+        characterEncoding = env;\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n+                .replace(\"[\", \"\").replace(\"]\", \"\"));\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        usingInputStreamFlag = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(getParameterMap().keySet());\n+    }\n+\n+    @Override\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        if (protocol == null) {\n+            protocol = serviceRequestContext.sessionProtocol().uriText();\n+        }\n+        return protocol;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        if (scheme == null) {\n+            scheme = httpRequest.scheme();\n+        }\n+        return scheme;\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n+        if (inetSocketAddress != null) {\n+            return inetSocketAddress.getAddress().getHostAddress();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (usingInputStreamFlag) {\n+            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n+        }\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    String charset = getCharacterEncoding();\n+                    if (charset == null) {\n+                        charset = getServletContext().getRequestCharacterEncoding();\n+                    }\n+                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        final InetAddress inetAddress = inetSocketAddress.getAddress();\n+        if (inetAddress == null) {\n+            return null;\n+        }\n+        return inetAddress.getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        return inetSocketAddress.getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        final Locale[] locales = this.locales;\n+        if (locales == null || locales.length == 0) {\n+            return null;\n+        }\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        if (this.locales == null) {\n+            decodeLocale();\n+        }\n+        return new Enumeration<Locale>() {\n+            private int index;\n+            @Override\n+            public boolean hasMoreElements() {\n+                return index < locales.length;\n+            }\n+\n+            @Override\n+            public Locale nextElement() {\n+                final Locale locale = locales[index];\n+                index++;\n+                return locale;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return HttpHeaderConstants.HTTPS.equals(getScheme());\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return getServletContext().getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        requireNonNull(path, \"path\");\n+        return getServletContext().getRealPath(path);\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return getServletContext().getServerAddress().getHostName();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return getServletContext().getServerAddress().getAddress().getHostAddress();", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex 4735cc12b8..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,871 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.MultipartConfigElement;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.ServletSecurityElement;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private String protocol;\n-    private String scheme;\n-    private String servletPath;\n-    private String queryString;\n-    private String pathInfo;\n-    private String requestURI;\n-    private String characterEncoding;\n-    private SessionTrackingMode sessionIdSource;\n-    private MultipartConfigElement multipartConfigElement;\n-    private ServletSecurityElement servletSecurityElement;\n-    private boolean usingInputStreamFlag;\n-    private BufferedReader reader;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n-    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n-            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n-            for (Entry<String,List<String>> entry : entries) {\n-                final List<String> value = entry.getValue();\n-                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n-                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public String[] get(Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Cookie[] cookies;\n-    private Locale[] locales;\n-    private Boolean asyncSupportedFlag;\n-    private ServletRequestDispatcher dispatcher;\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        if (servletContext.getServerAddress() == null) {\n-            servletContext.setServerAddress(\n-                    serviceRequestContext.remoteAddress());\n-        }\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n-        this.multipartConfigElement = multipartConfigElement;\n-    }\n-\n-    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n-        this.servletSecurityElement = servletSecurityElement;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final Locale[] locales;\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            final String[] values = headerValue.split(\",\");\n-            final int length = values.length;\n-            locales = new Locale[length];\n-            for (int i = 0; i < length; i++) {\n-                final String value = values[i];\n-                final String[] valueSp = value.split(\";\");\n-                final Locale locale;\n-                if (valueSp.length > 0) {\n-                    locale = Locale.forLanguageTag(valueSp[0]);\n-                } else {\n-                    locale = Locale.forLanguageTag(value);\n-                }\n-                locales[i] = locale;\n-            }\n-        }\n-        this.locales = locales;\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = getServletContext().getRequestCharacterEncoding();\n-        }\n-       this.characterEncoding = characterEncoding;\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            parameterMap = ServletUtil.decodeBody(\n-                    parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (value != null && value.length() > 0) {\n-            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n-            if (nettyCookieSet.size() > 0) {\n-                cookies = nettyCookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) throws IllegalArgumentException {\n-        requireNonNull(name, \"name\");\n-        final String value = getHeader(name);\n-        if (value == null || \"\".equals(value)) {\n-            return -1;\n-        }\n-\n-        final DateFormat[] formats = FORMATS_TEMPLATE;\n-        Date date = null;\n-        for (int i = 0; (date == null) && (i < formats.length); i++) {\n-            try {\n-                date = formats[i].parse(value);\n-            } catch (ParseException e) {\n-                logger.info(\"Cannot parse \" + value + \" to date type\");\n-            }\n-        }\n-        if (date == null) {\n-            throw new IllegalArgumentException(value);\n-        }\n-        return date.getTime();\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        final Set nameSet = httpRequest.headers().names();\n-        return new Enumeration<String>() {\n-            private Iterator iterator = nameSet.iterator();\n-\n-            @Override\n-            public boolean hasMoreElements() {\n-                return iterator.hasNext();\n-            }\n-\n-            @Override\n-            public String nextElement() {\n-                return iterator.next().toString();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HttpHeaderConstants.HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n-            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (this.servletPath == null) {\n-            String servletPath = getServletContext().getServletPath(getRequestURI());\n-            final String contextPath = getServletContext().getContextPath();\n-            if (contextPath.length() > 0) {\n-                servletPath = servletPath.replaceFirst(contextPath,\"\");\n-            }\n-            this.servletPath = servletPath;\n-        }\n-        return this.servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        return null;\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        final Collection collection = httpRequest.headers().getAll(name);\n-        return new Enumeration<String>() {\n-            private Iterator iterator = collection.iterator();\n-\n-            @Override\n-            public boolean hasMoreElements() {\n-                return iterator.hasNext();\n-            }\n-\n-            @Override\n-            public String nextElement() {\n-                return iterator.next().toString();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-                sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(getAttributeMap().keySet());\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                .replace(\"[\", \"\").replace(\"]\", \"\"));\n-    }\n-\n-    @Override\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(getParameterMap().keySet());\n-    }\n-\n-    @Override\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        if (protocol == null) {\n-            protocol = serviceRequestContext.sessionProtocol().uriText();\n-        }\n-        return protocol;\n-    }\n-\n-    @Override\n-    public String getScheme() {\n-        if (scheme == null) {\n-            scheme = httpRequest.scheme();\n-        }\n-        return scheme;\n-    }\n-\n-    @Override\n-    public String getServerName() {\n-        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n-        if (inetSocketAddress != null) {\n-            return inetSocketAddress.getAddress().getHostAddress();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n-        if (inetSocketAddress == null) {\n-            return null;\n-        }\n-        final InetAddress inetAddress = inetSocketAddress.getAddress();\n-        if (inetAddress == null) {\n-            return null;\n-        }\n-        return inetAddress.getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n-        if (inetSocketAddress == null) {\n-            return null;\n-        }\n-        return inetSocketAddress.getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        final Locale[] locales = this.locales;\n-        if (locales == null || locales.length == 0) {\n-            return null;\n-        }\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        if (this.locales == null) {\n-            decodeLocale();\n-        }\n-        return new Enumeration<Locale>() {\n-            private int index;\n-            @Override\n-            public boolean hasMoreElements() {\n-                return index < locales.length;\n-            }\n-\n-            @Override\n-            public Locale nextElement() {\n-                final Locale locale = locales[index];\n-                index++;\n-                return locale;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HttpHeaderConstants.HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return getServletContext().getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        requireNonNull(path, \"path\");\n-        return getServletContext().getRealPath(path);\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return getServletContext().getServerAddress().getHostName();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return getServletContext().getServerAddress().getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() throws IllegalStateException {\n-        return null;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse)\n-            throws IllegalStateException {\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        if (asyncSupportedFlag == null) {\n-            return true;\n-        }\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        return null;\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        final DefaultServletContext servletContext = getServletContext();\n-        final String contextPath = servletContext.getContextPath();\n-        if (contextPath == null || contextPath.isEmpty()) {\n-            return null;\n-        }\n-\n-        final String pathInfo = getPathInfo();\n-        if (pathInfo == null) {\n-            return null;\n-        }\n-\n-        return servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        final Principal principal = getUserPrincipal();\n-        if (principal != null) {\n-            return principal.getName();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        return true;\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        for (Part part : getParts()) {\n-            if (name.equals(part.getName())) {\n-                return part;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass)\n-            throws IOException, ServletException {\n-        requireNonNull(httpUpgradeHandlerClass, \"httpUpgradeHandlerClass\");\n-        try {\n-            final T handler = httpUpgradeHandlerClass.newInstance();\n-            return handler;\n-        } catch (Exception e) {\n-            throw new ServletException(e.getMessage(),e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNTg1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427025859", "bodyText": "return serviceRequestContext.config().server().defaultHostname();", "author": "minwoox", "createdAt": "2020-05-19T04:40:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,871 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.ServletSecurityElement;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private String protocol;\n+    private String scheme;\n+    private String servletPath;\n+    private String queryString;\n+    private String pathInfo;\n+    private String requestURI;\n+    private String characterEncoding;\n+    private SessionTrackingMode sessionIdSource;\n+    private MultipartConfigElement multipartConfigElement;\n+    private ServletSecurityElement servletSecurityElement;\n+    private boolean usingInputStreamFlag;\n+    private BufferedReader reader;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n+    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n+            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n+            for (Entry<String,List<String>> entry : entries) {\n+                final List<String> value = entry.getValue();\n+                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n+                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String[] get(Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[value.size()]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Cookie[] cookies;\n+    private Locale[] locales;\n+    private Boolean asyncSupportedFlag;\n+    private ServletRequestDispatcher dispatcher;\n+\n+    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                                 DefaultServletContext servletContext,\n+                                 AggregatedHttpRequest request) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(request, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        httpRequest = request;\n+        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n+        if (servletContext.getServerAddress() == null) {\n+            servletContext.setServerAddress(\n+                    serviceRequestContext.remoteAddress());\n+        }\n+        decodeUrlParameter();\n+        decodeBody();\n+        decodeCookie();\n+        decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        decodePaths();\n+    }\n+\n+    void setDispatcher(ServletRequestDispatcher dispatcher) {\n+        requireNonNull(dispatcher, \"dispatcher\");\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n+        this.multipartConfigElement = multipartConfigElement;\n+    }\n+\n+    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n+        this.servletSecurityElement = servletSecurityElement;\n+    }\n+\n+    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n+        this.asyncSupportedFlag = asyncSupportedFlag;\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    public AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private void decodeLocale() {\n+        final Locale[] locales;\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue == null) {\n+            locales = DEFAULT_LOCALS;\n+        } else {\n+            final String[] values = headerValue.split(\",\");\n+            final int length = values.length;\n+            locales = new Locale[length];\n+            for (int i = 0; i < length; i++) {\n+                final String value = values[i];\n+                final String[] valueSp = value.split(\";\");\n+                final Locale locale;\n+                if (valueSp.length > 0) {\n+                    locale = Locale.forLanguageTag(valueSp[0]);\n+                } else {\n+                    locale = Locale.forLanguageTag(value);\n+                }\n+                locales[i] = locale;\n+            }\n+        }\n+        this.locales = locales;\n+    }\n+\n+    /**\n+     * Parsing coding.\n+     */\n+    private void decodeCharacterEncoding() {\n+        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        if (characterEncoding == null) {\n+            characterEncoding = getServletContext().getRequestCharacterEncoding();\n+        }\n+       this.characterEncoding = characterEncoding;\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            parameterMap = ServletUtil.decodeBody(\n+                    parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    private void decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (value != null && value.length() > 0) {\n+            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n+            if (nettyCookieSet.size() > 0) {\n+                cookies = nettyCookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private void decodePaths() {\n+        String requestURI = httpRequest.path();\n+        final String queryString;\n+        final int queryInx = requestURI.indexOf('?');\n+        if (queryInx > -1) {\n+            queryString = requestURI.substring(queryInx + 1);\n+            requestURI = requestURI.substring(0, queryInx);\n+        } else {\n+            queryString = null;\n+        }\n+        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n+            requestURI = requestURI.substring(1);\n+        }\n+\n+        this.requestURI = requestURI;\n+        this.queryString = queryString;\n+    }\n+\n+    @Override\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) throws IllegalArgumentException {\n+        requireNonNull(name, \"name\");\n+        final String value = getHeader(name);\n+        if (value == null || \"\".equals(value)) {\n+            return -1;\n+        }\n+\n+        final DateFormat[] formats = FORMATS_TEMPLATE;\n+        Date date = null;\n+        for (int i = 0; (date == null) && (i < formats.length); i++) {\n+            try {\n+                date = formats[i].parse(value);\n+            } catch (ParseException e) {\n+                logger.info(\"Cannot parse \" + value + \" to date type\");\n+            }\n+        }\n+        if (date == null) {\n+            throw new IllegalArgumentException(value);\n+        }\n+        return date.getTime();\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);\n+        return value == null ? null : String.valueOf(value);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        final Set nameSet = httpRequest.headers().names();\n+        return new Enumeration<String>() {\n+            private Iterator iterator = nameSet.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = HttpHeaderConstants.HTTP_PORT;\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n+            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        if (this.servletPath == null) {\n+            String servletPath = getServletContext().getServletPath(getRequestURI());\n+            final String contextPath = getServletContext().getContextPath();\n+            if (contextPath.length() > 0) {\n+                servletPath = servletPath.replaceFirst(contextPath,\"\");\n+            }\n+            this.servletPath = servletPath;\n+        }\n+        return this.servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        return null;\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        final Collection collection = httpRequest.headers().getAll(name);\n+        return new Enumeration<String>() {\n+            private Iterator iterator = collection.iterator();\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public String nextElement() {\n+                return iterator.next().toString();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (headerStringValue == null) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return getServletContext().getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+                sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        getRequestedSessionId();\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(getAttributeMap().keySet());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        if (characterEncoding == null) {\n+            decodeCharacterEncoding();\n+        }\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        requireNonNull(env, \"env\");\n+        characterEncoding = env;\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n+                .replace(\"[\", \"\").replace(\"]\", \"\"));\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        usingInputStreamFlag = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(getParameterMap().keySet());\n+    }\n+\n+    @Override\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        if (protocol == null) {\n+            protocol = serviceRequestContext.sessionProtocol().uriText();\n+        }\n+        return protocol;\n+    }\n+\n+    @Override\n+    public String getScheme() {\n+        if (scheme == null) {\n+            scheme = httpRequest.scheme();\n+        }\n+        return scheme;\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n+        if (inetSocketAddress != null) {\n+            return inetSocketAddress.getAddress().getHostAddress();\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (usingInputStreamFlag) {\n+            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n+        }\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    String charset = getCharacterEncoding();\n+                    if (charset == null) {\n+                        charset = getServletContext().getRequestCharacterEncoding();\n+                    }\n+                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        final InetAddress inetAddress = inetSocketAddress.getAddress();\n+        if (inetAddress == null) {\n+            return null;\n+        }\n+        return inetAddress.getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n+        if (inetSocketAddress == null) {\n+            return null;\n+        }\n+        return inetSocketAddress.getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        final Locale[] locales = this.locales;\n+        if (locales == null || locales.length == 0) {\n+            return null;\n+        }\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        if (this.locales == null) {\n+            decodeLocale();\n+        }\n+        return new Enumeration<Locale>() {\n+            private int index;\n+            @Override\n+            public boolean hasMoreElements() {\n+                return index < locales.length;\n+            }\n+\n+            @Override\n+            public Locale nextElement() {\n+                final Locale locale = locales[index];\n+                index++;\n+                return locale;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return HttpHeaderConstants.HTTPS.equals(getScheme());\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return getServletContext().getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        requireNonNull(path, \"path\");\n+        return getServletContext().getRealPath(path);\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return getServletContext().getServerAddress().getHostName();", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex 4735cc12b8..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,871 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.MultipartConfigElement;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.ServletSecurityElement;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.HttpHeaderConstants;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault()};\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)};\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private String protocol;\n-    private String scheme;\n-    private String servletPath;\n-    private String queryString;\n-    private String pathInfo;\n-    private String requestURI;\n-    private String characterEncoding;\n-    private SessionTrackingMode sessionIdSource;\n-    private MultipartConfigElement multipartConfigElement;\n-    private ServletSecurityElement servletSecurityElement;\n-    private boolean usingInputStreamFlag;\n-    private BufferedReader reader;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String,Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private LinkedMultiValueMap<String,String> parameterMap = new LinkedMultiValueMap<>(16);\n-    private final Map<String,String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            final HashSet<Entry<String, String[]>> result = new HashSet<>(6);\n-            final Set<Entry<String, List<String>>> entries = parameterMap.entrySet();\n-            for (Entry<String,List<String>> entry : entries) {\n-                final List<String> value = entry.getValue();\n-                final String[] valueArr = value != null ? value.toArray(new String[value.size()]) : null;\n-                result.add(new SimpleImmutableEntry<>(entry.getKey(),valueArr));\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public String[] get(Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Cookie[] cookies;\n-    private Locale[] locales;\n-    private Boolean asyncSupportedFlag;\n-    private ServletRequestDispatcher dispatcher;\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        if (servletContext.getServerAddress() == null) {\n-            servletContext.setServerAddress(\n-                    serviceRequestContext.remoteAddress());\n-        }\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setMultipartConfigElement(@Nullable MultipartConfigElement multipartConfigElement) {\n-        this.multipartConfigElement = multipartConfigElement;\n-    }\n-\n-    void setServletSecurityElement(@Nullable ServletSecurityElement servletSecurityElement) {\n-        this.servletSecurityElement = servletSecurityElement;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final Locale[] locales;\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            final String[] values = headerValue.split(\",\");\n-            final int length = values.length;\n-            locales = new Locale[length];\n-            for (int i = 0; i < length; i++) {\n-                final String value = values[i];\n-                final String[] valueSp = value.split(\";\");\n-                final Locale locale;\n-                if (valueSp.length > 0) {\n-                    locale = Locale.forLanguageTag(valueSp[0]);\n-                } else {\n-                    locale = Locale.forLanguageTag(value);\n-                }\n-                locales[i] = locale;\n-            }\n-        }\n-        this.locales = locales;\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        String characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = getServletContext().getRequestCharacterEncoding();\n-        }\n-       this.characterEncoding = characterEncoding;\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpHeaderConstants.POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            parameterMap = ServletUtil.decodeBody(\n-                    parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (value != null && value.length() > 0) {\n-            final Collection<Cookie> nettyCookieSet = ServletUtil.decodeCookie(value);\n-            if (nettyCookieSet.size() > 0) {\n-                cookies = nettyCookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) throws IllegalArgumentException {\n-        requireNonNull(name, \"name\");\n-        final String value = getHeader(name);\n-        if (value == null || \"\".equals(value)) {\n-            return -1;\n-        }\n-\n-        final DateFormat[] formats = FORMATS_TEMPLATE;\n-        Date date = null;\n-        for (int i = 0; (date == null) && (i < formats.length); i++) {\n-            try {\n-                date = formats[i].parse(value);\n-            } catch (ParseException e) {\n-                logger.info(\"Cannot parse \" + value + \" to date type\");\n-            }\n-        }\n-        if (date == null) {\n-            throw new IllegalArgumentException(value);\n-        }\n-        return date.getTime();\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        final Set nameSet = httpRequest.headers().names();\n-        return new Enumeration<String>() {\n-            private Iterator iterator = nameSet.iterator();\n-\n-            @Override\n-            public boolean hasMoreElements() {\n-                return iterator.hasNext();\n-            }\n-\n-            @Override\n-            public String nextElement() {\n-                return iterator.next().toString();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HttpHeaderConstants.HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HttpHeaderConstants.HTTP.equals(scheme) && (port != HttpHeaderConstants.HTTP_PORT)) ||\n-            (HttpHeaderConstants.HTTPS.equals(scheme) && (port != HttpHeaderConstants.HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (this.servletPath == null) {\n-            String servletPath = getServletContext().getServletPath(getRequestURI());\n-            final String contextPath = getServletContext().getContextPath();\n-            if (contextPath.length() > 0) {\n-                servletPath = servletPath.replaceFirst(contextPath,\"\");\n-            }\n-            this.servletPath = servletPath;\n-        }\n-        return this.servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        return null;\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        final Collection collection = httpRequest.headers().getAll(name);\n-        return new Enumeration<String>() {\n-            private Iterator iterator = collection.iterator();\n-\n-            @Override\n-            public boolean hasMoreElements() {\n-                return iterator.hasNext();\n-            }\n-\n-            @Override\n-            public String nextElement() {\n-                return iterator.next().toString();\n-            }\n-        };\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-                sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        getRequestedSessionId();\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        return null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(getAttributeMap().keySet());\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                .replace(\"[\", \"\").replace(\"]\", \"\"));\n-    }\n-\n-    @Override\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(getParameterMap().keySet());\n-    }\n-\n-    @Override\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        if (protocol == null) {\n-            protocol = serviceRequestContext.sessionProtocol().uriText();\n-        }\n-        return protocol;\n-    }\n-\n-    @Override\n-    public String getScheme() {\n-        if (scheme == null) {\n-            scheme = httpRequest.scheme();\n-        }\n-        return scheme;\n-    }\n-\n-    @Override\n-    public String getServerName() {\n-        final InetSocketAddress inetSocketAddress = serviceRequestContext.localAddress();\n-        if (inetSocketAddress != null) {\n-            return inetSocketAddress.getAddress().getHostAddress();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return Integer.parseInt(getHeader(\":authority\").split(\":\")[1]);\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(),charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n-        if (inetSocketAddress == null) {\n-            return null;\n-        }\n-        final InetAddress inetAddress = inetSocketAddress.getAddress();\n-        if (inetAddress == null) {\n-            return null;\n-        }\n-        return inetAddress.getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        final InetSocketAddress inetSocketAddress = serviceRequestContext.remoteAddress();\n-        if (inetSocketAddress == null) {\n-            return null;\n-        }\n-        return inetSocketAddress.getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        final Locale[] locales = this.locales;\n-        if (locales == null || locales.length == 0) {\n-            return null;\n-        }\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        if (this.locales == null) {\n-            decodeLocale();\n-        }\n-        return new Enumeration<Locale>() {\n-            private int index;\n-            @Override\n-            public boolean hasMoreElements() {\n-                return index < locales.length;\n-            }\n-\n-            @Override\n-            public Locale nextElement() {\n-                final Locale locale = locales[index];\n-                index++;\n-                return locale;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HttpHeaderConstants.HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return getServletContext().getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        requireNonNull(path, \"path\");\n-        return getServletContext().getRealPath(path);\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return getServletContext().getServerAddress().getHostName();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return getServletContext().getServerAddress().getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() throws IllegalStateException {\n-        return null;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse)\n-            throws IllegalStateException {\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        if (asyncSupportedFlag == null) {\n-            return true;\n-        }\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        return null;\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        final DefaultServletContext servletContext = getServletContext();\n-        final String contextPath = servletContext.getContextPath();\n-        if (contextPath == null || contextPath.isEmpty()) {\n-            return null;\n-        }\n-\n-        final String pathInfo = getPathInfo();\n-        if (pathInfo == null) {\n-            return null;\n-        }\n-\n-        return servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        final Principal principal = getUserPrincipal();\n-        if (principal != null) {\n-            return principal.getName();\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        return true;\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        for (Part part : getParts()) {\n-            if (name.equals(part.getName())) {\n-                return part;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass)\n-            throws IOException, ServletException {\n-        requireNonNull(httpUpgradeHandlerClass, \"httpUpgradeHandlerClass\");\n-        try {\n-            final T handler = httpUpgradeHandlerClass.newInstance();\n-            return handler;\n-        } catch (Exception e) {\n-            throw new ServletException(e.getMessage(),e);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjMxOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026319", "bodyText": "What is the default value for sessionTimeout?", "author": "minwoox", "createdAt": "2020-05-19T04:42:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NDI4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427684284", "bodyText": "I will set default value = 20 minutes. I think we don't support servlet session now. I will separate another PR to do this.", "author": "dominhhien", "createdAt": "2020-05-20T01:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjMxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjYxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026614", "bodyText": "Seems like we don't support this yet. Let's throw UnsupportedOperationException, right now.", "author": "minwoox", "createdAt": "2020-05-19T04:43:19Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjc4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427026784", "bodyText": "Shouldn't we target for 4?", "author": "minwoox", "createdAt": "2020-05-19T04:44:02Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4NDc3NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427684774", "bodyText": "No, we implement servlet 4. I will change it to 4.", "author": "dominhhien", "createdAt": "2020-05-20T01:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNjc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzU5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027595", "bodyText": "extension.isEmpty()", "author": "minwoox", "createdAt": "2020-05-19T04:47:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027641", "bodyText": "Should add @Nullable", "author": "minwoox", "createdAt": "2020-05-19T04:47:23Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyOTY4MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427029681", "bodyText": "Shouldn't we check if the file exists or not first?", "author": "minwoox", "createdAt": "2020-05-19T04:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4ODkyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427688924", "bodyText": "I think we shouldn't check file. Because method's target is get mime type (http content-type) from file extension instead of real file such as: .avi => video/x-msvideo . Web browser will open download popup, view pdf or play music base on mime type.", "author": "dominhhien", "createdAt": "2020-05-20T01:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427027877", "bodyText": "Let's add TODO", "author": "minwoox", "createdAt": "2020-05-19T04:48:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MTE5Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427691197", "bodyText": "I think we don't support resource (html, css, js) management now.", "author": "dominhhien", "createdAt": "2020-05-20T01:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMjQ1Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430832456", "bodyText": "Then, let's throw UnsupportedOperationException.\nAlso, could you check all other methods whether to throw UnsupportedOperationException, please?", "author": "minwoox", "createdAt": "2020-05-27T03:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNzg3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427028163", "bodyText": "Could fix this by referring one of the ServletContext implementations in other frameworks?", "author": "minwoox", "createdAt": "2020-05-19T04:49:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzM4MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427693380", "bodyText": "Yes, we can. I think we can do a simple resource management.\nWe need a resource directory on linux such as: /home/user/deploy/armeria_server/app/share .\nWhen web browser send URL end with .html | .css | .js | .jpg ....\nsuch as:\nhttp://host:port/app/index.html\ngetRealPath() will return file path:\n/home/user/deploy/armeria_server/app/share/index.html\nthen ServletHttpResponse will write FileOutputStream to web browser.", "author": "dominhhien", "createdAt": "2020-05-20T01:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODQzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427698433", "bodyText": "Also, we have some question:\n\nHow to read fast resource file, should cache resource file bytes on memory?\nHow to combine multi html file such as: template file + menu file + body file?\nShould we support Java server page standard (JSP)? My opinion is shouldn't, because it's very bulky\n\nI think we don't support resource management now. I will separate another PR to do this.", "author": "dominhhien", "createdAt": "2020-05-20T01:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMTU0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427701542", "bodyText": "How to read fast resource file, should cache resource file bytes on memory?\n\nYes, we can cache the resources. Or we might use HttpFile but not sure it's going to work or not. Anyway, I think it's also deserved to have its own PR.\n\nHow to combine multi html file such as: template file + menu file + body file?\n\nI think we don't have to consider that right now.\n\nShould we support Java server page standard (JSP)? My opinion is shouldn't, because it's very bulky\n\nI respect your opinion. \ud83d\ude04\n\nI think we don't support resource management now. I will separate another PR to do this.\n\nYes, that's a good idea. Implementing servlet is really huge work. So let's break one by one. \ud83d\ude06", "author": "minwoox", "createdAt": "2020-05-20T02:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyODE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427047200", "bodyText": "Let's remove filter related code right now.", "author": "minwoox", "createdAt": "2020-05-19T05:57:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);", "originalCommit": "5bf5f1c6af38d408bd311e02c8d8b65fb5f6617c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODcxMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427698711", "bodyText": "Agree, I got it !", "author": "dominhhien", "createdAt": "2020-05-20T01:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzMzUwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430833505", "bodyText": "So you don't want to make a separate PR for the filter?", "author": "minwoox", "createdAt": "2020-05-27T03:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NzIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427058611", "bodyText": "We should make the list as immutable not just for getServlets(), but also for getServletNames(), getInitParameterNames(), getAttributeNames() etc.\nreturn Collections.enumeration(servletRegistrationMap.values()\n                                                     .stream()\n                                                     .map(ServletRegistration::getServlet)\n                                                     .collect(toImmutableList()));\n\nAlso, one thing we have to think about is that if the field is unmodifiable after DefaultServletContext is initialized, we can pass it when we create DefaultServletContext.\nFor example, initParamMap can't be changed after DefaultServiceContext is initialized.\nSo we can do something like:\nclass ServletBuilder {\n\n    // Introduce a new class \n    private final DefaultServletContextBuilder servletContextBuilder;\n\n    ServletBuilder(ServerBuilder serverBuiler, String contextPath) {\n        servletContextBuilder = new DefaultServletContextBuilder(contextPath);\n    }\n\n    public ServletBuilder initParameter(String key, @Nullable String value) {\n        requireNonNull(key, \"key\");\n        servletContextBuilder.setInitParameter(key, value);\n        return this;\n    }\n\n    public ServerBuilder build() {\n        new DefaultServletService(servletContextBuilder.build());\n        ...\n    }\n    ...\n}\n\nclass ServletContext {\n\n    ServletContext(String contextPath, Map<String, String> initParamMap ...) {\n        this.initParamMap = ImmutableMap.copyOf(initParamMap);\n        ...\n    }\n}", "author": "minwoox", "createdAt": "2020-05-19T06:29:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,591 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout;\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private final Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private InetSocketAddress serverAddress;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean started;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        this.servletContextName = contextPath.replace(\"/\",\"\");\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isStarted() {\n+        return started;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setStarted(boolean started) {\n+        this.started = started;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get server address.\n+     */\n+    public InetSocketAddress getServerAddress() {\n+        return serverAddress;\n+    }\n+\n+    /**\n+     * Set server address.\n+     */\n+    public void setServerAddress(InetSocketAddress serverAddress) {\n+        requireNonNull(serverAddress, \"serverAddress\");\n+        this.serverAddress = serverAddress;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    /**\n+     * Get session timeout.\n+     */\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    /**\n+     * Set session timeout.\n+     */\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        requireNonNull(uripath, \"uripath\");\n+        return this;\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 3;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(String file) {\n+        requireNonNull(file, \"file\");\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.length() < 1) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            filterList.add(registration);\n+        }\n+        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n+        for (FilterRegistration registration : filterRegistrationMap.values()) {\n+            for (String servletName : registration.getServletNameMappings()) {\n+                if (servletName.equals(name)) {\n+                    filterList.add(registration);\n+                }\n+            }\n+        }\n+\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        final List<Servlet> list = new ArrayList<>();\n+        for (ServletRegistration registration : servletRegistrationMap.values()) {\n+            list.add(registration.getServlet());\n+        }\n+        return Collections.enumeration(list);", "originalCommit": "197d92c3d0161a57379a0ba6b4c3a25a08653781", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxODE0NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427718144", "bodyText": "We should make the list as immutable not just for getServlets(), but also for getServletNames(), getInitParameterNames(), getAttributeNames() etc.\n\nTotally agree!", "author": "dominhhien", "createdAt": "2020-05-20T03:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyODAxOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r427728019", "bodyText": "Also, one thing we have to think about is that if the field is unmodifiable after DefaultServletContext is initialized, we can pass it when we create DefaultServletContext.\nFor example, initParamMap can't be changed after DefaultServiceContext is initialized\n\nI will apply to ImmutableMap for initParamMap, other fields will keep. But I think we should use another method: \ufffdpack() instead of DefaultServletContext() constructor.\nThen we can call \ufffdpack() in ServletBuilder.build() to pack any field. Ofcourse, initParamMap is not final. How do you think?", "author": "dominhhien", "createdAt": "2020-05-20T04:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2MDM1OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429060358", "bodyText": "What's the \ufffdpack()? Could you elaborate more on this please?", "author": "minwoox", "createdAt": "2020-05-22T06:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExMjUyMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429112520", "bodyText": "pack() and unPack() method usually are used to encode, decode, complete header ... a object (example: ISO message) before send it. I think immutable and unImmutable may be like that.", "author": "dominhhien", "createdAt": "2020-05-22T08:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExNDMwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429114309", "bodyText": "I understood your implementation by constructor but if we have many immutable fields, I think using constructor is difficult to implement.", "author": "dominhhien", "createdAt": "2020-05-22T08:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTExODUwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429118502", "bodyText": "Ok, I got it. Then, could you pack other properties too so that they are not set after initialized?", "author": "minwoox", "createdAt": "2020-05-22T08:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMTAxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429121017", "bodyText": "Yes, I think so :) .", "author": "dominhhien", "createdAt": "2020-05-22T08:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEyMTkzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429121931", "bodyText": "We should raise an exception in these methods if the context is initialized:\naddServlet, addJspFile, addFilter, setSessionTrackingModes, addListener,\ndeclareRoles, setSessionTimeout, setRequestCharacterEncoding, setResponseCharacterEncoding", "author": "minwoox", "createdAt": "2020-05-22T08:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MTcyNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r429151727", "bodyText": "Agree, I will throw exception if the context is initialized", "author": "dominhhien", "createdAt": "2020-05-22T09:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODYxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex e030abb3c6..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,591 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.InetSocketAddress;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout;\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private final Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private InetSocketAddress serverAddress;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean started;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        this.servletContextName = contextPath.replace(\"/\",\"\");\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isStarted() {\n-        return started;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setStarted(boolean started) {\n-        this.started = started;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get server address.\n-     */\n-    public InetSocketAddress getServerAddress() {\n-        return serverAddress;\n-    }\n-\n-    /**\n-     * Set server address.\n-     */\n-    public void setServerAddress(InetSocketAddress serverAddress) {\n-        requireNonNull(serverAddress, \"serverAddress\");\n-        this.serverAddress = serverAddress;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    /**\n-     * Get session timeout.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Set session timeout.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        requireNonNull(uripath, \"uripath\");\n-        return this;\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 3;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(String file) {\n-        requireNonNull(file, \"file\");\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.length() < 1) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            filterList.add(registration);\n-        }\n-        filterUrlMapper.addMappingObjectsByUri(path,filterChain.getFilterRegistrationList());\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final List<FilterRegistration> filterList = filterChain.getFilterRegistrationList();\n-        for (FilterRegistration registration : filterRegistrationMap.values()) {\n-            for (String servletName : registration.getServletNameMappings()) {\n-                if (servletName.equals(name)) {\n-                    filterList.add(registration);\n-                }\n-            }\n-        }\n-\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        final List<Servlet> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getServlet());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        final List<String> list = new ArrayList<>();\n-        for (ServletRegistration registration : servletRegistrationMap.values()) {\n-            list.add(registration.getName());\n-        }\n-        return Collections.enumeration(list);\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, String value) {\n-        requireNonNull(name, \"name\");\n-        requireNonNull(value, \"value\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        if (isStarted()) {\n-            return null;\n-        }\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (\")\n-        .concat(serverAddress.getHostName())\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        return null;\n-    }\n-}\n"}}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "512a67108968aec63ea888349eba11bb2b47c691", "url": "https://github.com/line/armeria/commit/512a67108968aec63ea888349eba11bb2b47c691", "message": "Merge branch 'master' into master", "committedDate": "2020-05-21T08:02:27Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNTU5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430825592", "bodyText": "two spaces before =. Please use auto-formatting before you commit.", "author": "minwoox", "createdAt": "2020-05-27T02:39:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyNzk5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430827998", "bodyText": "This is checking the state not the argument.\nAlso, we can make a private method to use together.\n@Override\npublic void setSessionTimeout(int sessionTimeout) {\n    ensureUninitialized(\"sessionTimeout\");\n    checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n    this.sessionTimeout = sessionTimeout;\n}\n\nprivate void ensureUninitialized(String name) {\n    checkState(!initialized, \"Can't set %s after the servlet context is initialized.\", name);\n}\n\n// We can use ensureUninitialized() in all other setters too.", "author": "minwoox", "createdAt": "2020-05-27T02:49:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyOTIzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430829233", "bodyText": "Let's add @Nullable.\nCould you check all the methods and parameters if we forgot to add @Nullable, please?", "author": "minwoox", "createdAt": "2020-05-27T02:53:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDEwMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430834100", "bodyText": "If we pass the element and path when creating ServletRequestDispatcher, we can make the fields final and we don't need the setter.\nnew ServletRequestDispatcher(element, path);", "author": "minwoox", "createdAt": "2020-05-27T03:14:45Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430834668", "bodyText": "Could you add test cases that cover this logic?", "author": "minwoox", "createdAt": "2020-05-27T03:17:19Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzMjE1MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430932150", "bodyText": "Yes, I have already added test cases for this at class: ServletServiceTest line 269", "author": "dominhhien", "createdAt": "2020-05-27T08:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzNTY4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430935685", "bodyText": "What I meant was all cases like \"\", \"/home\" and \"/home/\". \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-27T08:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzNjAyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430936025", "bodyText": "Also I wonder what happened for \"\" and \"/\".", "author": "minwoox", "createdAt": "2020-05-27T08:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzODQ1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431038459", "bodyText": "I will add test case at class ServletContextPathTest and ServletEmptyContextPathTest . But I want to explain more about my code:\nAt addServlet() method: I removed / at last of servlet path before add to ServletRegistration.\nTherefore whether user choose \"/\" or \"\", servlet always maps to only path \"\"\nAt getNamedDispatcher() method: I removed / at last of servlet path too before get from ServletRegistration\nTherefore, whether user access URL path \"/\" or \"\", getNamedDispatcher() always return servlet maps to \"\".\n=> \"/\" and \"\" return the same servlet.", "author": "dominhhien", "createdAt": "2020-05-27T11:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA2ODE3OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431068178", "bodyText": "Ah I missed that. Thanks for the explanation. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-27T12:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNzk5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430837996", "bodyText": "A user might want to log use different level, so we should use the LogLevel and use it:\nprivate final LogLevel level;\n...\nlevel.log(logger, msg);", "author": "minwoox", "createdAt": "2020-05-27T03:31:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTQ2Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839463", "bodyText": "indentation. This should be:\nServletUtil.getServerInfo()\n           .concat(\"(JDK \")\n           ...\nAlso we can just use + instead of concat. And, please use cache for this.\n@Nullable\nprivate String serverInfo;\n\n...\n@Override\npublic String getServerInfo() {\n    if (serverInfo != null) {\n        return serverInfo;\n    }\n    ...\n}\n```java", "author": "minwoox", "createdAt": "2020-05-27T03:38:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTc2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839764", "bodyText": "ensureUninitialized(\"initParameter\");", "author": "minwoox", "createdAt": "2020-05-27T03:40:07Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NTAzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430845032", "bodyText": "Please address this #2686 (comment)", "author": "minwoox", "createdAt": "2020-05-27T04:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzOTkzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430839933", "bodyText": "need a space after ,. Please use auto-formatting.", "author": "minwoox", "createdAt": "2020-05-27T03:40:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDc1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430840755", "bodyText": "I think we can raise an error instead logging.\nthrow new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e)", "author": "minwoox", "createdAt": "2020-05-27T03:44:38Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTA2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430841060", "bodyText": "ensureUninitialized(\"initParameter\");", "author": "minwoox", "createdAt": "2020-05-27T03:45:50Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjQyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846429", "bodyText": "newInstance is deprecated.\nclazz.getDeclaredConstructor().newInstance()", "author": "minwoox", "createdAt": "2020-05-27T04:10:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjU2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846562", "bodyText": "throw new RuntimeException(\"Failed to create a serlvet: \" + class.getSimpleName() +, e)", "author": "minwoox", "createdAt": "2020-05-27T04:11:16Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0Njg2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430846861", "bodyText": "We should return an immutable map so that a user does not modify this.", "author": "minwoox", "createdAt": "2020-05-27T04:12:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848265", "bodyText": "We can just return sessionTrackingModeSet if we do\nprivate Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\nAlso we can do:\nprivate static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n        Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);", "author": "minwoox", "createdAt": "2020-05-27T04:19:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU0NDYwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431544601", "bodyText": "When defaultSessionTrackingModeSet is immutable and sessionTrackingModeSet = defaultSessionTrackingModeSet, I think sessionTrackingModeSet has never changed. We should keep defaultSessionTrackingModeSet is not immutable and convert sessionTrackingModeSet to immutable in pack() method.", "author": "dominhhien", "createdAt": "2020-05-28T02:16:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU0NjExMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r431546113", "bodyText": "When defaultSessionTrackingModeSet is immutable and sessionTrackingModeSet = defaultSessionTrackingModeSet, I think sessionTrackingModeSet has never changed.\n\nI mean we can set defaultSessionTrackingModeSet to sessionTrackingModeSet when the class is initialized:\npublic class DefaultServletContext {\n    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n        Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n\n    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n\n    ...\n\n    // A user can set sessionTrackingModeSet using the setter.\n    @Override\n    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n        ...\n    }\n}\nSorry about the misleading comment. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-28T02:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODI2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODMyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848329", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:20:07Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODM0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848348", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:20:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODYxMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848612", "bodyText": "We do not need this", "author": "minwoox", "createdAt": "2020-05-27T04:21:21Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0ODYzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430848635", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:21:28Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0OTE5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430849196", "bodyText": "We can just return requestCharacterEncoding if we do:\nprivate String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name()", "author": "minwoox", "createdAt": "2020-05-27T04:24:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")\n+        .concat(\":\")\n+        .concat(SystemPropertyUtil.get(\"user.name\"))\n+        .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        if (requestCharacterEncoding == null) {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0OTI0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r430849242", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-27T04:24:17Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.handler.codec.http.HttpConstants;\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String,Object> attributeMap = new HashMap<>();\n+    private Map<String,String> initParamMap = new HashMap<>();\n+    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet;\n+    private String requestCharacterEncoding;\n+    private String responseCharacterEncoding;\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        this.contextPath = contextPath;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings  = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        return null;\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        return path;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setMapperElement(element);\n+        dispatcher.setPath(path);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n+        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n+        dispatcher.setName(name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String msg) {\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String msg) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(msg, \"msg\");\n+        logger.debug(msg,exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        logger.debug(message,throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo()\n+                .concat(\"(JDK \")\n+                .concat(ServletUtil.getJvmVersion())\n+                .concat(\";\")\n+                .concat(ServletUtil.getOsName())\n+                .concat(\" \")\n+                .concat(ServletUtil.getArch())\n+                .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name,value) == null;\n+    }\n+\n+    /**\n+     * Convert variable before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name,object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName,servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create servlet failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        try {\n+            requireNonNull(filterName, \"filterName\");\n+            requireNonNull(className, \"className\");\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n+        filterRegistrationMap.put(filterName,registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            logger.error(\"Add filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create filter failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        if (sessionTrackingModeSet == null) {\n+            return getDefaultSessionTrackingModes();\n+        }\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.newInstance();\n+        } catch (InstantiationException | IllegalAccessException e) {\n+            logger.error(\"Create listener failed: \", e);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        return null;\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return this.getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+        .concat(\" (localhost\")\n+        .concat(\":\")\n+        .concat(SystemPropertyUtil.get(\"user.name\"))\n+        .concat(\")\");\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        if (requestCharacterEncoding == null) {\n+            return HttpConstants.DEFAULT_CHARSET.name();\n+        }\n+        return requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n+        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n+        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n+        this.requestCharacterEncoding = requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public String getResponseCharacterEncoding() {\n+        if (responseCharacterEncoding == null) {", "originalCommit": "5ec5418684d17c89e9b4c241b8a56af6389252fc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\ndeleted file mode 100755\nindex 7b598a34be..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ /dev/null\n\n@@ -1,573 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.InputStream;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.EventListener;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.Filter;\n-import javax.servlet.Servlet;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRegistration.Dynamic;\n-import javax.servlet.SessionCookieConfig;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.descriptor.JspConfigDescriptor;\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import com.linecorp.armeria.server.servlet.util.MimeMappings;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-import com.linecorp.armeria.server.servlet.util.UrlMapper;\n-\n-import io.netty.handler.codec.http.HttpConstants;\n-import io.netty.util.internal.SystemPropertyUtil;\n-\n-/**\n- * Servlet context (lifetime same as server).\n- */\n-public class DefaultServletContext implements ServletContext {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n-\n-    private int sessionTimeout = 20; // unit: minutes\n-    private final Map<String,Object> attributeMap = new HashMap<>();\n-    private Map<String,String> initParamMap = new HashMap<>();\n-    private final Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n-    private final Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n-    private final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n-            new HashSet<>(Arrays.asList(SessionTrackingMode.COOKIE,SessionTrackingMode.URL));\n-    private MimeMappings mimeMappings = new MimeMappings();\n-    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n-    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n-    private Set<SessionTrackingMode> sessionTrackingModeSet;\n-    private String requestCharacterEncoding;\n-    private String responseCharacterEncoding;\n-    private final String contextPath;\n-    private final String servletContextName;\n-    private boolean initialized;\n-\n-    /**\n-     * Constructor.\n-     */\n-    public DefaultServletContext(String contextPath) {\n-        requireNonNull(contextPath, \"contextPath\");\n-        this.contextPath = contextPath;\n-        if (contextPath.isEmpty()) {\n-            servletContextName = \"\";\n-        } else {\n-            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n-        }\n-    }\n-\n-    /**\n-     * Is server started.\n-     */\n-    public boolean isInitialized() {\n-        return initialized;\n-    }\n-\n-    /**\n-     * Set server started.\n-     */\n-    public void setInitialized(boolean initialized) {\n-        this.initialized = initialized;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public void addMimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        this.mimeMappings  = mimeMappings;\n-    }\n-\n-    /**\n-     * Get servlet path.\n-     */\n-    public String getServletPath(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return servletUrlMapper.getServletPath(absoluteUri);\n-    }\n-\n-    @Override\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    @Override\n-    public void setSessionTimeout(int sessionTimeout) {\n-        checkArgument(!isInitialized(), \"Can't set session timeout after server is initialized\");\n-        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    @Override\n-    public String getContextPath() {\n-        return contextPath;\n-    }\n-\n-    @Override\n-    public DefaultServletContext getContext(String uripath) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int getMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public int getEffectiveMajorVersion() {\n-        return 4;\n-    }\n-\n-    @Override\n-    public int getEffectiveMinorVersion() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public String getMimeType(@Nullable String file) {\n-        if (file == null) {\n-            return null;\n-        }\n-        final int period = file.lastIndexOf('.');\n-        if (period < 0) {\n-            return null;\n-        }\n-        final String extension = file.substring(period + 1);\n-        if (extension.isEmpty()) {\n-            return null;\n-        }\n-        return mimeMappings.get(extension);\n-    }\n-\n-    @Override\n-    public Set<String> getResourcePaths(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public URL getResource(String path) throws MalformedURLException {\n-        return null;\n-    }\n-\n-    @Override\n-    public InputStream getResourceAsStream(String path) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        return path;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        requireNonNull(path, \"path\");\n-        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n-        final ServletRegistration servletRegistration = element.getObject();\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setMapperElement(element);\n-        dispatcher.setPath(path);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getNamedDispatcher(String name) {\n-        requireNonNull(name, \"name\");\n-        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n-            name = name.substring(0, name.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration = getServletRegistration(name);\n-        if (servletRegistration == null) {\n-            return null;\n-        }\n-        final ServletFilterChain filterChain = new ServletFilterChain(this, servletRegistration);\n-        final ServletRequestDispatcher dispatcher = new ServletRequestDispatcher(filterChain);\n-        dispatcher.setName(name);\n-        return dispatcher;\n-    }\n-\n-    @Override\n-    public Servlet getServlet(String name) throws ServletException {\n-        requireNonNull(name, \"name\");\n-        final ServletRegistration registration = servletRegistrationMap.get(name);\n-        if (registration == null) {\n-            return null;\n-        }\n-        return registration.getServlet();\n-    }\n-\n-    @Override\n-    public Enumeration<Servlet> getServlets() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getServlet)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public Enumeration<String> getServletNames() {\n-        return Collections.enumeration(servletRegistrationMap.values()\n-                                                             .stream()\n-                                                             .map(ServletRegistration::getName)\n-                                                             .collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public void log(String msg) {\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg);\n-    }\n-\n-    @Override\n-    public void log(Exception exception, String msg) {\n-        requireNonNull(exception, \"exception\");\n-        requireNonNull(msg, \"msg\");\n-        logger.debug(msg,exception);\n-    }\n-\n-    @Override\n-    public void log(String message, Throwable throwable) {\n-        requireNonNull(message, \"message\");\n-        requireNonNull(throwable, \"throwable\");\n-        logger.debug(message,throwable);\n-    }\n-\n-    @Override\n-    public String getServerInfo() {\n-        return ServletUtil.getServerInfo()\n-                .concat(\"(JDK \")\n-                .concat(ServletUtil.getJvmVersion())\n-                .concat(\";\")\n-                .concat(ServletUtil.getOsName())\n-                .concat(\" \")\n-                .concat(ServletUtil.getArch())\n-                .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getInitParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getInitParameterNames() {\n-        return Collections.enumeration(initParamMap.keySet());\n-    }\n-\n-    @Override\n-    public boolean setInitParameter(String name, @Nullable String value) {\n-        requireNonNull(name, \"name\");\n-        return initParamMap.putIfAbsent(name,value) == null;\n-    }\n-\n-    /**\n-     * Convert variable before initialization.\n-     */\n-    public void pack() {\n-        initParamMap = ImmutableMap.copyOf(initParamMap);\n-    }\n-\n-    @Override\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        return attributeMap.get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(attributeMap.keySet());\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name);\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        attributeMap.put(name,object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        attributeMap.remove(name);\n-    }\n-\n-    @Override\n-    public String getServletContextName() {\n-        return servletContextName;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, String className) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(className, \"className\");\n-        try {\n-            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servlet, \"servlet\");\n-        checkArgument(!isInitialized(), \"Can't add servlet after server is initialized\");\n-        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n-            servletName = servletName.substring(0, servletName.length() - 1);\n-        }\n-        final ServletRegistration servletRegistration;\n-        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n-        servletRegistrationMap.put(servletName,servletRegistration);\n-        servletRegistration.addMapping(servletName);\n-        return servletRegistration;\n-    }\n-\n-    @Override\n-    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n-        requireNonNull(servletName, \"servletName\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        try {\n-            return addServlet(servletName, createServlet(servletClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n-        try {\n-            requireNonNull(clazz, \"clazz\");\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create servlet failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public ServletRegistration getServletRegistration(String servletName) {\n-        requireNonNull(servletName, \"servletName\");\n-        return servletRegistrationMap.get(servletName);\n-    }\n-\n-    @Override\n-    public Map<String, ServletRegistration> getServletRegistrations() {\n-        return servletRegistrationMap;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, String className) {\n-        try {\n-            requireNonNull(filterName, \"filterName\");\n-            requireNonNull(className, \"className\");\n-            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n-        } catch (ClassNotFoundException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Filter filter) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filter, \"filter\");\n-        checkArgument(!isInitialized(), \"Can't add filter after server is initialized\");\n-        final FilterRegistration registration =\n-                new FilterRegistration(filterName, filter, this, filterUrlMapper);\n-        filterRegistrationMap.put(filterName,registration);\n-        return registration;\n-    }\n-\n-    @Override\n-    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n-        requireNonNull(filterName, \"filterName\");\n-        requireNonNull(filterClass, \"filterClass\");\n-        try {\n-            return addFilter(filterName, createFilter(filterClass));\n-        } catch (ServletException e) {\n-            logger.error(\"Add filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create filter failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n-        requireNonNull(filterName, \"filterName\");\n-        return filterRegistrationMap.get(filterName);\n-    }\n-\n-    @Override\n-    public Map<String, FilterRegistration> getFilterRegistrations() {\n-        return filterRegistrationMap;\n-    }\n-\n-    @Override\n-    public SessionCookieConfig getSessionCookieConfig() {\n-        return null;\n-    }\n-\n-    @Override\n-    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n-        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n-        checkArgument(!isInitialized(), \"Can't set session tracking mode after server is initialized\");\n-        sessionTrackingModeSet = sessionTrackingModes;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n-        return defaultSessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n-        if (sessionTrackingModeSet == null) {\n-            return getDefaultSessionTrackingModes();\n-        }\n-        return sessionTrackingModeSet;\n-    }\n-\n-    @Override\n-    public void addListener(String className) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> void addListener(T listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void addListener(Class<? extends EventListener> listenerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n-        requireNonNull(clazz, \"clazz\");\n-        try {\n-            return clazz.newInstance();\n-        } catch (InstantiationException | IllegalAccessException e) {\n-            logger.error(\"Create listener failed: \", e);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public JspConfigDescriptor getJspConfigDescriptor() {\n-        return null;\n-    }\n-\n-    @Override\n-    public ClassLoader getClassLoader() {\n-        return this.getClass().getClassLoader();\n-    }\n-\n-    @Override\n-    public void declareRoles(String... roleNames) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getVirtualServerName() {\n-        return ServletUtil.getServerInfo()\n-        .concat(\" (localhost\")\n-        .concat(\":\")\n-        .concat(SystemPropertyUtil.get(\"user.name\"))\n-        .concat(\")\");\n-    }\n-\n-    @Override\n-    public String getRequestCharacterEncoding() {\n-        if (requestCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set request character encoding after server is initialized\");\n-        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n-        this.requestCharacterEncoding = requestCharacterEncoding;\n-    }\n-\n-    @Override\n-    public String getResponseCharacterEncoding() {\n-        if (responseCharacterEncoding == null) {\n-            return HttpConstants.DEFAULT_CHARSET.name();\n-        }\n-        return responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n-        checkArgument(!isInitialized(), \"Can't set response character encoding after server is initialized\");\n-        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n-        this.responseCharacterEncoding = responseCharacterEncoding;\n-    }\n-\n-    @Override\n-    public Dynamic addJspFile(String jspName, String jspFile) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"oid": "a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "url": "https://github.com/line/armeria/commit/a0a036edbcc3e54e2e3e6084b81059ce963b69b8", "message": "Add immutable, servletPath / at last, and refactor", "committedDate": "2020-05-20T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5OTk5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432299991", "bodyText": "public class -> final class", "author": "minwoox", "createdAt": "2020-05-29T07:20:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTA3NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432301075", "bodyText": "For tomcat, this value is 30 minutes by default. Could you tell me where you brought?", "author": "minwoox", "createdAt": "2020-05-29T07:22:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMzE2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432333161", "bodyText": "I think 15, 20, 30 minutes is ok. I will change to 30.", "author": "dominhhien", "createdAt": "2020-05-29T08:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMTQ0Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432301447", "bodyText": "Please move this up right down to logger so that private static final fields are located together.", "author": "minwoox", "createdAt": "2020-05-29T07:23:39Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDc3OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432304778", "bodyText": "Please use SystemInfo first to get the information.\nAlso, please leave a comment in the code if you copy any source from another repository.\n// Forked from https://github.com/a/b/c...", "author": "minwoox", "createdAt": "2020-05-29T07:30:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDkxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432304914", "bodyText": "Can remove public.", "author": "minwoox", "createdAt": "2020-05-29T07:31:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjI2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306269", "bodyText": "Constructor -> Creates a new instance.\nIf you find trouble writing Javadoc, please refer to other classes and copy the phrases.\nThat'll help the reviewers a lot. \ud83d\ude47\u200d\u2642\ufe0f", "author": "minwoox", "createdAt": "2020-05-29T07:33:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjM1Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306352", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-05-29T07:34:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjg5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432306898", "bodyText": "ditto can remove public.\nPlease remove the public modifier of the methods that didn't override in this class.", "author": "minwoox", "createdAt": "2020-05-29T07:35:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNzcxMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432307713", "bodyText": "Can just init(). (No need boolean initialized).", "author": "minwoox", "createdAt": "2020-05-29T07:37:10Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwODg5OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432308899", "bodyText": "This is not adding just setting because it replaces the previous MimeMappings set.\nWe can just rename this setMimeMappings.\n(We usually name the method without set such as mimeMappings. However, the interface is already using the setX, so let's follow it.)", "author": "minwoox", "createdAt": "2020-05-29T07:39:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwOTg3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432309872", "bodyText": "We don't need this because element.getObject() is not Nullable.", "author": "minwoox", "createdAt": "2020-05-29T07:41:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDM0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432310341", "bodyText": "We can just return without assigning the local variable.", "author": "minwoox", "createdAt": "2020-05-29T07:42:29Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDgxMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432310813", "bodyText": "Please annotated @Nullable if a method returns null.", "author": "minwoox", "createdAt": "2020-05-29T07:43:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMTY1MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432311650", "bodyText": "There's no need to unpack this. Let's remove this method.", "author": "minwoox", "createdAt": "2020-05-29T07:44:57Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMTkzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432311933", "bodyText": "We should remove this method and move the logic inside init() method.", "author": "minwoox", "createdAt": "2020-05-29T07:45:30Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMzYwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432313601", "bodyText": "Let's return the immutable view of the set so that a user cannot arbitrary modify the set.\nCollections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));", "author": "minwoox", "createdAt": "2020-05-29T07:48:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNDIzNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432314237", "bodyText": "please add\n//noinspection unchecked", "author": "minwoox", "createdAt": "2020-05-29T07:50:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTEyOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432315128", "bodyText": "We just can\nfinal ServletRegistration servletRegistration =\n    new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "author": "minwoox", "createdAt": "2020-05-29T07:51:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTcxOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432315719", "bodyText": "What happened if two different servlets are registered using one servletName?", "author": "minwoox", "createdAt": "2020-05-29T07:53:10Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNjkyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432326929", "bodyText": "I think latest added servlet is working, because servlet registration like a Map<path, servlet>.", "author": "dominhhien", "createdAt": "2020-05-29T08:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNTcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNjcxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432316716", "bodyText": "Ditto. please remove uncheck cast warning", "author": "minwoox", "createdAt": "2020-05-29T07:55:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432317306", "bodyText": "ditto What happened if two different filters are registered using the same name?", "author": "minwoox", "createdAt": "2020-05-29T07:56:17Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNjcyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432326725", "bodyText": "I think latest added filters is working, because filter registration like a Map<path, filter>.", "author": "dominhhien", "createdAt": "2020-05-29T08:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMTY5OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432331699", "bodyText": "Then, shouldn't we raise an exception in that case?\nThere should be no one who wants to just override the previously set filter.\nIf it happens, there's likely the chance the filter is misconfigured.", "author": "minwoox", "createdAt": "2020-05-29T08:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNzE3NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432337175", "bodyText": "But I think what happen if user want to override an existing filter? And why doesn't servlet API have removeServlet() method , removeFilter() method. Should we add these methods?", "author": "dominhhien", "createdAt": "2020-05-29T08:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2NjQ0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432366443", "bodyText": "Then let's keep as it is. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-29T09:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNzc0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432317745", "bodyText": "We should check the name is empty or not.\nWe can use isNullOrEmpty.", "author": "minwoox", "createdAt": "2020-05-29T07:57:10Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432318353", "bodyText": "If the name is empty, we should throw an exception.\n* @throws IllegalArgumentException if <code>servletName</code> is null\n* or an empty String", "author": "minwoox", "createdAt": "2020-05-29T07:58:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNDEzMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432324130", "bodyText": "I think servlet support empty name, it is root servlet.", "author": "dominhhien", "createdAt": "2020-05-29T08:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyNTU4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432325585", "bodyText": "https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/ServletContext.java#L769\nPlease refer to the Javadoc.", "author": "minwoox", "createdAt": "2020-05-29T08:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODM1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxODk4OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432318989", "bodyText": "sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModes);", "author": "minwoox", "createdAt": "2020-05-29T07:59:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxOTkwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432319907", "bodyText": "please just use + instead of concat as the IDE suggested.", "author": "minwoox", "createdAt": "2020-05-29T08:01:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a listener: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+                          .concat(\" (localhost\")", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMDE2Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r432320167", "bodyText": "We should not just append null when SystemPropertyUtil.get(\"user.name\") is null.", "author": "minwoox", "createdAt": "2020-05-29T08:02:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,581 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+import io.netty.util.internal.SystemPropertyUtil;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+public class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private final LogLevel level;\n+\n+    private int sessionTimeout = 20; // unit: minutes\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private final String contextPath;\n+    private final String servletContextName;\n+    private boolean initialized;\n+    private String serverInfo = ServletUtil.getServerInfo() + \"(JDK \" + ServletUtil.getJvmVersion() + \";\" +\n+                                ServletUtil.getOsName() + \" \" + ServletUtil.getArch() + \")\";\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    public DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\");\n+        }\n+    }\n+\n+    /**\n+     * Is server started.\n+     */\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void setInitialized(boolean initialized) {\n+        this.initialized = initialized;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void addMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        final ServletRegistration servletRegistration = element.getObject();\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), path, element);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        final ServletRequestDispatcher dispatcher =\n+                new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+        return dispatcher;\n+    }\n+\n+    @Override\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return serverInfo;\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    /**\n+     * Pack before initialization.\n+     */\n+    public void pack() {\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Unpack after initialization.\n+     */\n+    public void unpack() {\n+        initParamMap = Maps.newHashMap(initParamMap);\n+        servletRegistrationMap = Maps.newHashMap(servletRegistrationMap);\n+        filterRegistrationMap = Maps.newHashMap(filterRegistrationMap);\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(attributeMap.keySet());\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration;\n+        servletRegistration = new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, ServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, String className) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(className, \"className\");\n+        try {\n+            return addFilter(filterName, (Class<Filter>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Filter filter) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filter, \"filter\");\n+        final FilterRegistration registration =\n+                new FilterRegistration(filterName, filter, filterUrlMapper);\n+        filterRegistrationMap.put(filterName, registration);\n+        return registration;\n+    }\n+\n+    @Override\n+    public FilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        ensureUninitialized(\"addFilter\");\n+        requireNonNull(filterName, \"filterName\");\n+        requireNonNull(filterClass, \"filterClass\");\n+        try {\n+            return addFilter(filterName, createFilter(filterClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a filter. filterName: \" + filterName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a filter: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public javax.servlet.FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, FilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        ensureUninitialized(\"setSessionTrackingModes\");\n+        requireNonNull(sessionTrackingModes, \"sessionTrackingModes\");\n+        sessionTrackingModeSet = sessionTrackingModes;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        requireNonNull(clazz, \"clazz\");\n+        try {\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a listener: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ServletUtil.getServerInfo()\n+                          .concat(\" (localhost\")\n+                          .concat(\":\")\n+                          .concat(SystemPropertyUtil.get(\"user.name\"))", "originalCommit": "482e763f053528311fdf9c4d5c0192c326035c91", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 53%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex b2e31436e5..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -17,11 +17,13 @@ package com.linecorp.armeria.server.servlet;\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"oid": "aa96a87ae69c06c7263c85ffd6bd380dd5cac309", "url": "https://github.com/line/armeria/commit/aa96a87ae69c06c7263c85ffd6bd380dd5cac309", "message": "Update the project version to 0.99.4-SNAPSHOT", "committedDate": "2020-04-14T09:34:08Z", "type": "forcePushed"}, {"oid": "891afd85893d0037e20b6b463f10bd868ea64aa9", "url": "https://github.com/line/armeria/commit/891afd85893d0037e20b6b463f10bd868ea64aa9", "message": "Add servlet service and servlet context", "committedDate": "2020-05-30T15:33:31Z", "type": "commit"}, {"oid": "2d6daa7900aec1c0979c770627091cd2dc7cbf84", "url": "https://github.com/line/armeria/commit/2d6daa7900aec1c0979c770627091cd2dc7cbf84", "message": "Add servlet registration", "committedDate": "2020-05-30T15:35:15Z", "type": "commit"}, {"oid": "f3901c7b1d501836fdfef54d306e0538c2aabda5", "url": "https://github.com/line/armeria/commit/f3901c7b1d501836fdfef54d306e0538c2aabda5", "message": "Add filter registration", "committedDate": "2020-05-30T15:35:56Z", "type": "commit"}, {"oid": "86f784aaa9a6d816ba866ff077b0129488d38cf1", "url": "https://github.com/line/armeria/commit/86f784aaa9a6d816ba866ff077b0129488d38cf1", "message": "Add http header constants", "committedDate": "2020-05-30T15:36:30Z", "type": "commit"}, {"oid": "d6f44acb772037593f35a6c4904ed6217db98c85", "url": "https://github.com/line/armeria/commit/d6f44acb772037593f35a6c4904ed6217db98c85", "message": "Add multi value map for http header", "committedDate": "2020-05-30T15:38:04Z", "type": "commit"}, {"oid": "7a0aeba630fc8bd1cf6cf9373223cb5cf5ed1faa", "url": "https://github.com/line/armeria/commit/7a0aeba630fc8bd1cf6cf9373223cb5cf5ed1faa", "message": "Add mime mapping", "committedDate": "2020-05-30T15:38:29Z", "type": "commit"}, {"oid": "42fea96e1d37d19f69dbc2b5be7945398a85d227", "url": "https://github.com/line/armeria/commit/42fea96e1d37d19f69dbc2b5be7945398a85d227", "message": "Add package info", "committedDate": "2020-05-30T15:39:05Z", "type": "commit"}, {"oid": "a371fbcc69c998ca7d0fafc2f719a74c7a19107f", "url": "https://github.com/line/armeria/commit/a371fbcc69c998ca7d0fafc2f719a74c7a19107f", "message": "Add servlet util", "committedDate": "2020-05-30T15:39:36Z", "type": "commit"}, {"oid": "f36779f5469e7ee81b3bf518e417bac1c4d82184", "url": "https://github.com/line/armeria/commit/f36779f5469e7ee81b3bf518e417bac1c4d82184", "message": "Add string util", "committedDate": "2020-05-30T15:39:55Z", "type": "commit"}, {"oid": "efdb71dfc7616c73e624fbe0d6dcc4be56a77d01", "url": "https://github.com/line/armeria/commit/efdb71dfc7616c73e624fbe0d6dcc4be56a77d01", "message": "Add url mapper", "committedDate": "2020-05-30T15:40:14Z", "type": "commit"}, {"oid": "3599f5fa15fc3cc1670693f892f758c8c3b0dc49", "url": "https://github.com/line/armeria/commit/3599f5fa15fc3cc1670693f892f758c8c3b0dc49", "message": "Add default servlet input stream", "committedDate": "2020-05-30T15:40:38Z", "type": "commit"}, {"oid": "0cf936d20cff5de77151e68b5b7dac2c599d6f69", "url": "https://github.com/line/armeria/commit/0cf936d20cff5de77151e68b5b7dac2c599d6f69", "message": "Add default servlet output stream", "committedDate": "2020-05-30T15:41:01Z", "type": "commit"}, {"oid": "30971c4a0616ca2f84b89800a651a6fcc3200ab8", "url": "https://github.com/line/armeria/commit/30971c4a0616ca2f84b89800a651a6fcc3200ab8", "message": "Add servlet builder", "committedDate": "2020-05-30T15:42:11Z", "type": "commit"}, {"oid": "40e2b348ccd45a199902c0116ca90f7e26fd407f", "url": "https://github.com/line/armeria/commit/40e2b348ccd45a199902c0116ca90f7e26fd407f", "message": "Add servlet http request", "committedDate": "2020-05-30T15:42:29Z", "type": "commit"}, {"oid": "1be8fac1f6a25ae7c9929070e2eb7161dd387ca4", "url": "https://github.com/line/armeria/commit/1be8fac1f6a25ae7c9929070e2eb7161dd387ca4", "message": "Add servlet http response", "committedDate": "2020-05-30T15:42:53Z", "type": "commit"}, {"oid": "ab4051a3f126fd2261a72e97c15de823f566c0c6", "url": "https://github.com/line/armeria/commit/ab4051a3f126fd2261a72e97c15de823f566c0c6", "message": "Add servlet print writer", "committedDate": "2020-05-30T15:43:15Z", "type": "commit"}, {"oid": "e06eed7c534e79419592b013002fdd20436e8bfb", "url": "https://github.com/line/armeria/commit/e06eed7c534e79419592b013002fdd20436e8bfb", "message": "Add servlet request dispatcher", "committedDate": "2020-05-30T15:43:35Z", "type": "commit"}, {"oid": "7e580df0b5c205936a4300fe2810e0f42e9d6981", "url": "https://github.com/line/armeria/commit/7e580df0b5c205936a4300fe2810e0f42e9d6981", "message": "Add servlet service test cases", "committedDate": "2020-05-30T15:44:52Z", "type": "commit"}, {"oid": "61114dc7236136fa84094a3ff944a23d1f3e7686", "url": "https://github.com/line/armeria/commit/61114dc7236136fa84094a3ff944a23d1f3e7686", "message": "Add servlet context path test cases", "committedDate": "2020-05-30T15:45:29Z", "type": "commit"}, {"oid": "7265ab94ab9a4b3a75f7bf000a152368849f925f", "url": "https://github.com/line/armeria/commit/7265ab94ab9a4b3a75f7bf000a152368849f925f", "message": "Add empty context path test cases", "committedDate": "2020-05-30T15:45:58Z", "type": "commit"}, {"oid": "edbc50c7a39c65a2c694db6a0b406b026a6a0f97", "url": "https://github.com/line/armeria/commit/edbc50c7a39c65a2c694db6a0b406b026a6a0f97", "message": "Add example servlet project", "committedDate": "2020-05-30T15:46:49Z", "type": "commit"}, {"oid": "2c6bdd6a4af3f39307a12c0565d97e9da2f1b472", "url": "https://github.com/line/armeria/commit/2c6bdd6a4af3f39307a12c0565d97e9da2f1b472", "message": "Remove filter code, auto formating code", "committedDate": "2020-05-30T16:44:06Z", "type": "commit"}, {"oid": "479451c48b73830f25bf2e1cf758c18d2e811d5f", "url": "https://github.com/line/armeria/commit/479451c48b73830f25bf2e1cf758c18d2e811d5f", "message": "Remove http header constants", "committedDate": "2020-05-31T09:04:38Z", "type": "commit"}, {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "message": "Set private access", "committedDate": "2020-05-31T12:00:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NDAwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433594001", "bodyText": "Because this class is package-private now, we can remove public modifier from the methods which is not overriding.", "author": "minwoox", "createdAt": "2020-06-02T02:58:23Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 59%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex e150f01640..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -23,6 +23,7 @@ import static java.util.Objects.requireNonNull;\n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NTkzOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433595939", "bodyText": "Could be just \"servletName is empty\" in this case.", "author": "minwoox", "createdAt": "2020-06-02T03:07:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 59%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex e150f01640..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -23,6 +23,7 @@ import static java.util.Objects.requireNonNull;\n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NjQwNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433596405", "bodyText": "I think we can call this in the constructor of ServletRegistration.", "author": "minwoox", "createdAt": "2020-06-02T03:09:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        servletName = servletName.trim();\n+        final ServletRegistration servletRegistration =\n+                new ServletRegistration(servletName, servlet, this, servletUrlMapper);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        servletRegistration.addMapping(servletName);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 59%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex e150f01640..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -23,6 +23,7 @@ import static java.util.Objects.requireNonNull;\n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5NzQzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433597433", "bodyText": "Could remove public?\nCould be final?\nDefaultServletRegistration because ServletRegistration is the name of the interface?", "author": "minwoox", "createdAt": "2020-06-02T03:14:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODMxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598315", "bodyText": "Should we pass the initMap to ServletRegistration?", "author": "minwoox", "createdAt": "2020-06-02T03:18:27Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.util.MimeMappings;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<ServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<FilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, ServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, FilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    public void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    public String getServletPath(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return servletUrlMapper.getServletPath(absoluteUri);\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        ensureUninitialized(\"setSessionTimeout\");\n+        checkArgument(sessionTimeout > 0, \"sessionTimeout: %s (expected: > 0)\", sessionTimeout);\n+        this.sessionTimeout = sessionTimeout;\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<ServletRegistration> element = servletUrlMapper.getMappingObjectByUri(path);\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()), path, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        if (!name.isEmpty() && name.charAt(name.length() - 1) == '/') {\n+            name = name.substring(0, name.length() - 1);\n+        }\n+        final ServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final ServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(ServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ServletUtil.getServerInfo();\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public ServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (!servletName.isEmpty() && servletName.charAt(servletName.length() - 1) == '/') {\n+            servletName = servletName.substring(0, servletName.length() - 1);\n+        }\n+        servletName = servletName.trim();\n+        final ServletRegistration servletRegistration =\n+                new ServletRegistration(servletName, servlet, this, servletUrlMapper);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 59%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex e150f01640..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -23,6 +23,7 @@ import static java.util.Objects.requireNonNull;\n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODYyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598622", "bodyText": "Can remove ServletRegistration.this.", "author": "minwoox", "createdAt": "2020-06-02T03:20:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODY1Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598656", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-02T03:20:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5ODgwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433598809", "bodyText": "return initParameterMap.get(name);", "author": "minwoox", "createdAt": "2020-06-02T03:20:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTAwMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599001", "bodyText": "When this method is used? If this is not used now, can we add this when we need?", "author": "minwoox", "createdAt": "2020-06-02T03:21:49Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTAyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599024", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-02T03:21:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU5OTQ3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433599470", "bodyText": "Can we remove this method and make this registration is initialized when it created?", "author": "minwoox", "createdAt": "2020-06-02T03:23:50Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDE4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600183", "bodyText": "It seems like we need to return the mappingSet that urlPatterns are added before.", "author": "minwoox", "createdAt": "2020-06-02T03:27:04Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NjA1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433696051", "bodyText": "yes, each servlet have one ServletRegistration to addMapping multiple urlPatterns to one servletName such as: urlPattern (\"/home\", \"/home/user\", \"/home/*\") map to servletName (\"home\").\nI think, mappingSet is returned to check which urlPatterns were mapped.", "author": "dominhhien", "createdAt": "2020-06-02T08:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDQ3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600473", "bodyText": "Question: Don't we need to validate the value before assigning?", "author": "minwoox", "createdAt": "2020-06-02T03:28:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDcyOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433700728", "bodyText": "I see method's document: loadOnStartup may be positive, negative and zero. Therefore, I don't validate this value.", "author": "dominhhien", "createdAt": "2020-06-02T08:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDQ3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDcxNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600715", "bodyText": "ditto:\n* @return the (possibly empty) Set of URL patterns that were already\n* the exact target of a <code>security-constraint</code> that was\n* established via the portable deployment descriptor. This method\n* has no effect on the patterns included in the returned set", "author": "minwoox", "createdAt": "2020-06-02T03:29:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;\n+    }\n+\n+    @Override\n+    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n+        requireNonNull(constraint, \"constraint\");\n+        servletSecurityElement = constraint;\n+        return new HashSet<>(servletSecurityElement.getMethodNames());", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczODAxMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433738010", "bodyText": "I think returning HashSet<>(servletSecurityElement.getMethodNames()) for checking.", "author": "dominhhien", "createdAt": "2020-06-02T09:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMDg1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433600853", "bodyText": "We can just do this in one line: this.roleName = requireNonNull(roleName, \"roleName\");", "author": "minwoox", "createdAt": "2020-06-02T03:30:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.server.servlet.util.UrlMapper;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+public class ServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final DefaultServletContext servletContext;\n+    private final UrlMapper<ServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    private boolean asyncSupported = true;\n+    private int loadOnStartup = -1;\n+    private AtomicBoolean initServlet = new AtomicBoolean();\n+\n+    @Nullable\n+    private MultipartConfigElement multipartConfigElement;\n+    @Nullable\n+    private ServletSecurityElement servletSecurityElement;\n+    @Nullable\n+    private String roleName;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper) {\n+        this(servletName, servlet, servletContext, urlMapper, ImmutableMap.copyOf(new HashMap<>()));\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<ServletRegistration> urlMapper, Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.servletContext = servletContext;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return ServletRegistration.this.servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return ServletRegistration.this.servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return ServletRegistration.this.getInitParameter(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Get servlet security element.\n+     */\n+    @Nullable\n+    public ServletSecurityElement getServletSecurityElement() {\n+        return servletSecurityElement;\n+    }\n+\n+    /**\n+     * Get multipart config element.\n+     */\n+    @Nullable\n+    public MultipartConfigElement getMultipartConfigElement() {\n+        return multipartConfigElement;\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    public ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    public Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    /**\n+     * Is async supported.\n+     */\n+    public Boolean isAsyncSupported() {\n+        return asyncSupported;\n+    }\n+\n+    /**\n+     * Get load on startup.\n+     */\n+    public int getLoadOnStartup() {\n+        return loadOnStartup;\n+    }\n+\n+    /**\n+     * Is initialization servlet cas.\n+     */\n+    public boolean isInitServletCas(boolean expect, boolean update) {\n+        return initServlet.compareAndSet(expect, update);\n+    }\n+\n+    /**\n+     * Is initialization servlet.\n+     */\n+    public boolean isInitServlet() {\n+        return initServlet.get();\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    public Collection<String> getMappings() {\n+        return mappingSet;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getRunAsRole() {\n+        return roleName;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return servletName;\n+    }\n+\n+    @Override\n+    public String getClassName() {\n+        return servlet.getClass().getName();\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, String value) {\n+        throw new IllegalStateException(\"Can't set init parameter after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParameterMap.get(name);\n+    }\n+\n+    @Override\n+    public Set<String> setInitParameters(Map<String, String> initParameters) {\n+        throw new IllegalStateException(\"Can't set init parameters after ServletRegistration is initialized\");\n+    }\n+\n+    @Override\n+    public Map<String, String> getInitParameters() {\n+        return initParameterMap;\n+    }\n+\n+    @Override\n+    public void setLoadOnStartup(int loadOnStartup) {\n+        this.loadOnStartup = loadOnStartup;\n+    }\n+\n+    @Override\n+    public Set<String> setServletSecurity(ServletSecurityElement constraint) {\n+        requireNonNull(constraint, \"constraint\");\n+        servletSecurityElement = constraint;\n+        return new HashSet<>(servletSecurityElement.getMethodNames());\n+    }\n+\n+    @Override\n+    public void setMultipartConfig(MultipartConfigElement multipartConfig) {\n+        requireNonNull(multipartConfig, \"multipartConfig\");\n+        multipartConfigElement = multipartConfig;\n+    }\n+\n+    @Override\n+    public void setRunAsRole(String roleName) {\n+        requireNonNull(roleName, \"roleName\");\n+        this.roleName = roleName;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 54%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex b61fe9a8d8..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,17 +15,15 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicBoolean;\n \n import javax.annotation.Nullable;\n import javax.servlet.MultipartConfigElement;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMTUwMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433601503", "bodyText": "If the class is used only in the package we can make it as package-private.\nAlso, the methods are as well. We do not need the public modifier.\nCould you check all classes, please?", "author": "minwoox", "createdAt": "2020-06-02T03:33:30Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpRequest;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.server.HttpService;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+/**\n+ * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n+ * and write {@link HttpResponse} to client.\n+ */\n+public class DefaultServletService implements HttpService {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\ndeleted file mode 100755\nindex 3d95a83c27..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletService.java\n+++ /dev/null\n\n@@ -1,92 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.servlet.http.HttpServlet;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpRequest;\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.ResponseHeaders;\n-import com.linecorp.armeria.server.HttpService;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-/**\n- * An {@link HttpService} which handles {@link HttpRequest} and forward to Servlet APIs,\n- * and write {@link HttpResponse} to client.\n- */\n-public class DefaultServletService implements HttpService {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletService.class);\n-    private final DefaultServletContext servletContext;\n-\n-    /**\n-     * A class which helps a {@link DefaultServletService} have a {@link HttpServlet}.\n-     */\n-    public DefaultServletService(DefaultServletContext servletContext) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        this.servletContext = servletContext;\n-    }\n-\n-    /**\n-     * handles {@link HttpRequest} and forward to Servlet APIs.\n-     */\n-    @Override\n-    public HttpResponse serve(ServiceRequestContext ctx, HttpRequest req) throws Exception {\n-        requireNonNull(ctx, \"ctx\");\n-        requireNonNull(req, \"req\");\n-        final HttpResponseWriter res = HttpResponse.streaming();\n-        req.aggregate().handleAsync((aReq, cause) -> {\n-            if (cause != null) {\n-                logger.warn(\"{} Failed to aggregate a request:\", ctx, cause);\n-                if (res.tryWrite(ResponseHeaders.of(HttpStatus.INTERNAL_SERVER_ERROR))) {\n-                    res.close();\n-                }\n-                return null;\n-            }\n-            process(ctx, res, aReq);\n-            return null;\n-        }, ctx.blockingTaskExecutor());\n-        return res;\n-    }\n-\n-    private void process(ServiceRequestContext ctx, HttpResponseWriter res, AggregatedHttpRequest req) {\n-        requireNonNull(res, \"res\");\n-        final ServletHttpRequest request = new ServletHttpRequest(ctx, servletContext, req);\n-        final ServletHttpResponse response = new ServletHttpResponse(servletContext);\n-        try {\n-            final ServletRequestDispatcher dispatcher =\n-                    servletContext.getNamedDispatcher(request.getRequestURI());\n-            if (dispatcher == null) {\n-                res.tryWrite(ResponseHeaders.of(HttpStatus.NOT_FOUND));\n-                return;\n-            }\n-            request.setDispatcher(dispatcher);\n-            response.setResponseWriter(res);\n-            dispatcher.dispatch(request, response);\n-        } catch (Throwable throwable) {\n-            logger.error(\"Servlet process failed: \", throwable);\n-        } finally {\n-            res.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjExMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602113", "bodyText": "DefaultHttpServletRequest ?", "author": "minwoox", "createdAt": "2020-06-02T03:36:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjM3Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602377", "bodyText": "We can use HttpMethod.POST.toString() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:38:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjU1Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602556", "bodyText": "We can use SessionProtocol.HTTP.uriText() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:38:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjU3Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602576", "bodyText": "We can use SessionProtocol.HTTPS.uriText() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:39:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMjk4OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433602989", "bodyText": "We can use SessionProtocol.HTTP.defaultPort() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:41:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwMzAxMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433603010", "bodyText": "We can use SessionProtocol.HTTPS.defaultPort() instead.", "author": "minwoox", "createdAt": "2020-06-02T03:41:17Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNDkzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433604932", "bodyText": "Let's make this variable as final because we can extract this value when the ServletHttpRequest is initialized.\nfinal Charset charset = httpRequest.headers().contentType().charset();\nif (charset != null) {\n    ...\n} else {\n    ...\n}", "author": "minwoox", "createdAt": "2020-06-02T03:50:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,768 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n+import com.linecorp.armeria.server.servlet.util.ServletUtil;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+public class ServletHttpRequest implements HttpServletRequest {\n+    private static final int HTTPS_PORT = 443;\n+    private static final int HTTP_PORT = 80;\n+    private static final String HTTPS = \"https\";\n+    private static final String HTTP = \"http\";\n+    private static final String POST = \"POST\";\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+\n+    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private List<Part> fileUploadList = new ArrayList<>();\n+    private Boolean asyncSupportedFlag = true;\n+\n+    @Nullable\n+    private String servletPath;\n+    @Nullable\n+    private String queryString;\n+    @Nullable\n+    private String pathInfo;\n+    @Nullable\n+    private String requestURI;\n+    @Nullable\n+    private String characterEncoding;", "originalCommit": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNTA1Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r433605057", "bodyText": "Please consider all other fields if we can do the same approach. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-02T03:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwNDkzMg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\ndeleted file mode 100755\nindex fb398756dc..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,768 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-import com.linecorp.armeria.server.servlet.util.LinkedMultiValueMap;\n-import com.linecorp.armeria.server.servlet.util.ServletUtil;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-public class ServletHttpRequest implements HttpServletRequest {\n-    private static final int HTTPS_PORT = 443;\n-    private static final int HTTP_PORT = 80;\n-    private static final String HTTPS = \"https\";\n-    private static final String HTTP = \"http\";\n-    private static final String POST = \"POST\";\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream = new DefaultServletInputStream();\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-\n-    private LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private List<Part> fileUploadList = new ArrayList<>();\n-    private Boolean asyncSupportedFlag = true;\n-\n-    @Nullable\n-    private String servletPath;\n-    @Nullable\n-    private String queryString;\n-    @Nullable\n-    private String pathInfo;\n-    @Nullable\n-    private String requestURI;\n-    @Nullable\n-    private String characterEncoding;\n-    @Nullable\n-    private SessionTrackingMode sessionIdSource;\n-    private boolean usingInputStreamFlag;\n-    @Nullable\n-    private BufferedReader reader;\n-    @Nullable\n-    private Cookie[] cookies;\n-    @Nullable\n-    private Locale[] locales;\n-    @Nullable\n-    private ServletRequestDispatcher dispatcher;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(\n-                                               new String[x.getValue().size()]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[value.size()]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    protected ServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                                 DefaultServletContext servletContext,\n-                                 AggregatedHttpRequest request) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(request, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        httpRequest = request;\n-        inputStream.setContent(Unpooled.wrappedBuffer(request.content().array()));\n-        decodeUrlParameter();\n-        decodeBody();\n-        decodeCookie();\n-        decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        decodePaths();\n-    }\n-\n-    void setDispatcher(ServletRequestDispatcher dispatcher) {\n-        requireNonNull(dispatcher, \"dispatcher\");\n-        this.dispatcher = dispatcher;\n-    }\n-\n-    void setAsyncSupportedFlag(boolean asyncSupportedFlag) {\n-        this.asyncSupportedFlag = asyncSupportedFlag;\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    public AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private void decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue == null) {\n-            locales = DEFAULT_LOCALS;\n-        } else {\n-            locales = Arrays.stream(getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString()).split(\",\"))\n-                            .map(x -> x.split(\";\").length > 0 ?\n-                                      Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                              : Locale.forLanguageTag(x.trim())\n-                            ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * Parsing coding.\n-     */\n-    private void decodeCharacterEncoding() {\n-        characterEncoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        if (characterEncoding == null) {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (POST.equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    private void decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                cookies = cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private void decodePaths() {\n-        String requestURI = httpRequest.path();\n-        final String queryString;\n-        final int queryInx = requestURI.indexOf('?');\n-        if (queryInx > -1) {\n-            queryString = requestURI.substring(queryInx + 1);\n-            requestURI = requestURI.substring(0, queryInx);\n-        } else {\n-            queryString = null;\n-        }\n-        if (requestURI.length() > 1 && requestURI.charAt(0) == '/' && requestURI.charAt(1) == '/') {\n-            requestURI = requestURI.substring(1);\n-        }\n-\n-        this.requestURI = requestURI;\n-        this.queryString = queryString;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? null : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = HTTP_PORT;\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((HTTP.equals(scheme) && (port != HTTP_PORT)) ||\n-            (HTTPS.equals(scheme) && (port != HTTPS_PORT))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        if (servletPath == null) {\n-            servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                    servletContext.getContextPath(), \"\");\n-        }\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (headerStringValue == null) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return getServletContext().getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        if (characterEncoding == null) {\n-            decodeCharacterEncoding();\n-        }\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        requireNonNull(env, \"env\");\n-        characterEncoding = env;\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(httpRequest.headers().get(HttpHeaderNames.CONTENT_LENGTH)\n-                                           .replaceAll(\"\\\\[|\\\\]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        usingInputStreamFlag = true;\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (usingInputStreamFlag) {\n-            throw new IllegalStateException(\"getInputStream() has already been called for this request\");\n-        }\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    String charset = getCharacterEncoding();\n-                    if (charset == null) {\n-                        charset = getServletContext().getRequestCharacterEncoding();\n-                    }\n-                    reader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return HTTPS.equals(getScheme());\n-    }\n-\n-    @Override\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return asyncSupportedFlag;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getPathTranslated() {\n-        if (isNullOrEmpty(servletContext.getContextPath())) {\n-            return null;\n-        }\n-        return pathInfo == null ? null : servletContext.getRealPath(pathInfo);\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "message": "Set private access", "committedDate": "2020-05-31T12:00:31Z", "type": "forcePushed"}, {"oid": "b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "url": "https://github.com/line/armeria/commit/b3f132e7ce6154d2e0f86a0b6076ce01ff86435c", "message": "Set private access", "committedDate": "2020-05-31T12:00:31Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzEwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434323107", "bodyText": "The Javadoc says that this will return null if the header does not exist.\nLet's just return httpRequest.headers().get(name); and add @Nullable", "author": "minwoox", "createdAt": "2020-06-03T05:53:00Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final String queryString;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final String encoding = ServletUtil.decodeCharacterEncoding(getContentType());\n+        characterEncoding = encoding != null ? encoding : servletContext.getRequestCharacterEncoding();\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (headerValue.isEmpty()) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = httpRequest.headers().get(name);", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 0444a7ddfe..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,727 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String pathInfo;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-    private final String queryString;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final String encoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        characterEncoding = encoding != null ? encoding : servletContext.getRequestCharacterEncoding();\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue.isEmpty()) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? \"\" : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434326942", "bodyText": "yes, each servlet have one ServletRegistration to addMapping multiple urlPatterns to one servletName such as: urlPattern (\"/home\", \"/home/user\", \"/home/*\") map to servletName (\"home\").\nI think, mappingSet is returned to check which urlPatterns were mapped.\n\nSo this shouldn't be:\nrequireNonNull(urlPatterns, \"urlPatterns\");\nfinal Set<String> current = ImmutableSet.copyOf(mappingSet);\nmappingSet.addAll(Arrays.asList(urlPatterns));\nfor (String pattern : urlPatterns) {\n    urlMapper.addMapping(pattern, this, servletName);\n}\nreturn current;\n?", "author": "minwoox", "createdAt": "2020-06-03T06:05:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.MultipartConfigElement;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.ServletSecurityElement;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * The servlet supportPipeline.\n+ */\n+final class DefaultServletRegistration implements Dynamic {\n+    private final String servletName;\n+    private final Servlet servlet;\n+    private final ServletConfig servletConfig;\n+    private final UrlMapper<DefaultServletRegistration> urlMapper;\n+    private final Set<String> mappingSet = new HashSet<>();\n+    private final Map<String, String> initParameterMap;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletRegistration(String servletName, Servlet servlet, DefaultServletContext servletContext,\n+                               UrlMapper<DefaultServletRegistration> urlMapper,\n+                               Map<String, String> initParameterMap) {\n+        requireNonNull(servletName, \"servletName\");\n+        requireNonNull(servlet, \"servlet\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(urlMapper, \"urlMapper\");\n+\n+        this.servletName = servletName;\n+        this.servlet = servlet;\n+        this.urlMapper = urlMapper;\n+        this.initParameterMap = ImmutableMap.copyOf(initParameterMap);\n+        servletConfig = new ServletConfig() {\n+            @Override\n+            public String getServletName() {\n+                return servletName;\n+            }\n+\n+            @Override\n+            public ServletContext getServletContext() {\n+                return servletContext;\n+            }\n+\n+            @Override\n+            @Nullable\n+            public String getInitParameter(String name) {\n+                return initParameterMap.get(name);\n+            }\n+\n+            @Override\n+            public Enumeration<String> getInitParameterNames() {\n+                return Collections.enumeration(ImmutableSet.copyOf(getInitParameters().keySet()));\n+            }\n+        };\n+        addMapping(servletName);\n+    }\n+\n+    /**\n+     * Get servlet config.\n+     */\n+    ServletConfig getServletConfig() {\n+        return servletConfig;\n+    }\n+\n+    /**\n+     * Get servlet.\n+     */\n+    Servlet getServlet() {\n+        return servlet;\n+    }\n+\n+    @Override\n+    public Set<String> addMapping(String... urlPatterns) {\n+        requireNonNull(urlPatterns, \"urlPatterns\");\n+        mappingSet.addAll(Arrays.asList(urlPatterns));\n+        for (String pattern : urlPatterns) {\n+            urlMapper.addMapping(pattern, this, servletName);\n+        }\n+        return mappingSet;", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3NDAxMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434374010", "bodyText": "I think, source code's logic is right. Because mappingSet only store urlPatterns of this servletRegistration and urlMapper store urlPatterns of all servletRegistration. I think we only need to add checkState() to return if ServletContext is initialized at here. How do you think?\ncheckState(!((DefaultServletContext) servletConfig.getServletContext()).isInitialized(),\n                   \"Can't add servlet mapping after the servlet context is initialized.\");", "author": "dominhhien", "createdAt": "2020-06-03T07:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MjI2OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434382269", "bodyText": "Do you mean we should return current (mappingSet before add urlPatterns) instead of (mappingSet after add urlPattern)?", "author": "dominhhien", "createdAt": "2020-06-03T08:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4Mzg0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434383841", "bodyText": "Ah, I misunderstand the Javadoc. Then, I'm wondering if we follow what Tomcat does: https://github.com/quickhack/tomcat/blob/master/src/main/java/org/apache/catalina/core/ApplicationServletRegistration.java#L166\n\ud83e\udd14", "author": "minwoox", "createdAt": "2020-06-03T08:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNjk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nsimilarity index 76%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\nindex ca9518121c..f1c40cfd75 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletRegistration.java\n\n@@ -15,9 +15,9 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.Preconditions.checkState;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzU3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434327573", "bodyText": "Is there any chances that two thread access this map?", "author": "minwoox", "createdAt": "2020-06-03T06:07:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MzY2NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434353664", "bodyText": "I think two thread never access one this map instance because each httprequest run on one thread and create a parameterMap instance.", "author": "dominhhien", "createdAt": "2020-06-03T07:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzU3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 0444a7ddfe..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,727 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String pathInfo;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-    private final String queryString;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final String encoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        characterEncoding = encoding != null ? encoding : servletContext.getRequestCharacterEncoding();\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue.isEmpty()) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? \"\" : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzg1OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434327859", "bodyText": "please remove this and just return ImmutableMap.copyOf(parameterMap) where it used.", "author": "minwoox", "createdAt": "2020-06-03T06:07:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final String queryString;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {", "originalCommit": "4e975863fba562297d53e30d67bbaee12c836d1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MTYzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434351636", "bodyText": "I think unmodifiableParameterMap not only immutable of parameterMap but also convert parammeter value from String to String[]", "author": "dominhhien", "createdAt": "2020-06-03T07:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNzg1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 0444a7ddfe..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,727 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String pathInfo;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-    private final String queryString;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final String encoding = ServletUtil.decodeCharacterEncoding(getContentType());\n-        characterEncoding = encoding != null ? encoding : servletContext.getRequestCharacterEncoding();\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (headerValue.isEmpty()) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = httpRequest.headers().get(name);\n-        return value == null ? \"\" : String.valueOf(value);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1ODY2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434958661", "bodyText": "Let's assign this value in the constructor and return it so that we don't have to parse every time it needs", "author": "minwoox", "createdAt": "2020-06-04T02:34:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1ODgyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434958825", "bodyText": "We should return -1 if the length is greater than Integer.MAX_VALUE", "author": "minwoox", "createdAt": "2020-06-04T02:35:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTAxNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434959014", "bodyText": "Let's just do HttpMethod.POST == httpRequest.method()", "author": "minwoox", "createdAt": "2020-06-04T02:35:54Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTQyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434959429", "bodyText": "We should call this only when the content type is MediaType.FORM_DATA?", "author": "minwoox", "createdAt": "2020-06-04T02:37:39Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2MjQxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434962417", "bodyText": "serviceRequestContext.path() does not contain the query", "author": "minwoox", "createdAt": "2020-06-04T02:49:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NzE5Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434967197", "bodyText": "We have the logic for decoding cookies already. Let's use that:\nfinal String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\nif (cookieValue != null) {\n    final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n    this.cookies = cookies.stream().map(c -> {\n        final Cookie cookie = new Cookie(c.name(), c.value());\n        cookie.setDomain(c.domain());\n        cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n        cookie.setHttpOnly(c.isHttpOnly());\n        ... // more settings\n        return new Cookie(c.name(), c.value());\n    }).toArray(Cookie[]::new);\n} else {\n    this.cookies = COOKIES;\n}", "author": "minwoox", "createdAt": "2020-06-04T03:09:18Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTMxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969318", "bodyText": "Let's remove decodeUrlParameter and decodeBody.\nWe can use QueryParam for this purpose.\nFirst we need to move this logic to an internal public class to use together.\npackage com.linecorp.armeria.internal.server;\n\npublic final class QueryParamUtil {\n    ...\n}\nThen, we can use the method to parse assign to the field QueryParams queryParams.\nSo we can remove parameterMap and unmodifiableParameterMap.", "author": "minwoox", "createdAt": "2020-06-04T03:18:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTQyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969424", "bodyText": "Then we can simple do queryParams.get(name);", "author": "minwoox", "createdAt": "2020-06-04T03:18:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTQ3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969472", "bodyText": "return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));", "author": "minwoox", "createdAt": "2020-06-04T03:19:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTUzNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969537", "bodyText": "return queryParams.getAll(name).toArray(String[]::new);", "author": "minwoox", "createdAt": "2020-06-04T03:19:22Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2OTcwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r434969702", "bodyText": "We can build this using the queryParam. This will be expensive so we might create this one time in the constructor and reuse it.", "author": "minwoox", "createdAt": "2020-06-04T03:20:04Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,738 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.Charset;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n+        @Override\n+        public Set<Entry<String, String[]>> entrySet() {\n+            if (isEmpty()) {\n+                return Collections.emptySet();\n+            }\n+            return parameterMap.entrySet()\n+                               .stream()\n+                               .map(x -> new SimpleImmutableEntry<>(\n+                                       x.getKey(),\n+                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n+                               .collect(Collectors.toSet());\n+        }\n+\n+        @Override\n+        @Nullable\n+        public String[] get(@Nullable Object key) {\n+            final List<String> value = parameterMap.get(key);\n+            if (value == null) {\n+                return null;\n+            } else {\n+                return value.toArray(new String[0]);\n+            }\n+        }\n+\n+        @Override\n+        public boolean containsKey(Object key) {\n+            requireNonNull(key, \"key\");\n+            return parameterMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            requireNonNull(value, \"value\");\n+            return parameterMap.toSingleValueMap().containsValue(value);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parameterMap.size();\n+        }\n+    };\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = decodeRequestURI();\n+        decodeUrlParameter();\n+        decodeBody();\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+    }\n+\n+    /**\n+     * Get netty request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * parse parameter specification.\n+     */\n+    private void decodeBody() {\n+        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n+            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n+        }\n+    }\n+\n+    /**\n+     * Parsing URL parameters.\n+     */\n+    private void decodeUrlParameter() {\n+        final Charset charset = Charset.forName(getCharacterEncoding());\n+        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n+    }\n+\n+    /**\n+     * Parsing the cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n+        if (!isNullOrEmpty(value)) {\n+            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n+            if (!cookieSet.isEmpty()) {\n+                return cookieSet.toArray(new Cookie[0]);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeRequestURI() {\n+        final String path = httpRequest.path();\n+        int queryInx = path.indexOf('?');\n+        if (queryInx == -1) {\n+            queryInx = path.indexOf('#');\n+        }\n+        return queryInx > -1 ? path.substring(0, queryInx) : path;\n+    }\n+\n+    /**\n+     * Parsing path.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    /**\n+     * Get date header.\n+     */\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * The getHeader method returns the header for the given header name.\n+     * @param name name.\n+     * @return header value.\n+     */\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * Copy the implementation of tomcat.\n+     * @return Request URL.\n+     */\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    /**\n+     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n+     * If there's no extra path, it's either null,\n+     * Or a string that starts with '/'.\n+     * @return pathInfo.\n+     */\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    /**\n+     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n+     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n+     * matches, in which case it is an empty string.\n+     * @return servletPath.\n+     */\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    /**\n+     * servlet standard:\n+     * returns the value of the specified request header\n+     * as int. If the request has no title\n+     * the name specified by this method returns -1. if This method does not convert headers to integers\n+     * throws a NumberFormatException code. The first name is case insensitive.\n+     * @param name  specifies the name of the request header\n+     * @exception NumberFormatException If the header value cannot be converted to an int.\n+     * @return An integer request header representing a value or -1 if the request does not return -1.\n+     */\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    /**\n+     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n+     * If the context is web-based the server's URL namespace based on the \"default\" context,\n+     * then the path will be an empty string. Otherwise, if the context is not\n+     * server-based namespaces, so the path starts with /, but does not end with /.\n+     */\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return (int) getContentLengthLong();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n+                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        final String[] values = getParameterMap().get(name);\n+        if (values == null || values.length == 0) {\n+            return null;\n+        }\n+        return values[0];\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        return getParameterMap().get(name);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return unmodifiableParameterMap;", "originalCommit": "2afebf424f796fd96f5d5c188dbb668992eed379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\ndeleted file mode 100755\nindex 8961a1f32c..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ /dev/null\n\n@@ -1,738 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.InetSocketAddress;\n-import java.nio.charset.Charset;\n-import java.security.Principal;\n-import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.stream.Collectors;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.SessionTrackingMode;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpUpgradeHandler;\n-import javax.servlet.http.Part;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableSet;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.server.ServiceRequestContext;\n-\n-import io.netty.buffer.Unpooled;\n-\n-/**\n- * The servlet request.\n- */\n-final class DefaultServletHttpRequest implements HttpServletRequest {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n-    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n-    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n-            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n-            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n-    };\n-\n-    private final ServiceRequestContext serviceRequestContext;\n-    private final DefaultServletContext servletContext;\n-    private final AggregatedHttpRequest httpRequest;\n-    private final DefaultServletInputStream inputStream;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n-\n-    private final LinkedMultiValueMap<String, String> parameterMap = new LinkedMultiValueMap<>();\n-    private final List<Part> fileUploadList = new ArrayList<>();\n-    private final String servletPath;\n-    private final String requestURI;\n-    private final String characterEncoding;\n-    private final Locale[] locales;\n-\n-    @Nullable\n-    private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n-    @Nullable\n-    private final String queryString;\n-\n-    //Can't be final because user will decide reader or inputStream is initialize.\n-    @Nullable\n-    private BufferedReader reader;\n-\n-    private final Map<String, String[]> unmodifiableParameterMap = new AbstractMap<String, String[]>() {\n-        @Override\n-        public Set<Entry<String, String[]>> entrySet() {\n-            if (isEmpty()) {\n-                return Collections.emptySet();\n-            }\n-            return parameterMap.entrySet()\n-                               .stream()\n-                               .map(x -> new SimpleImmutableEntry<>(\n-                                       x.getKey(),\n-                                       x.getValue() != null ? x.getValue().toArray(new String[0]) : null))\n-                               .collect(Collectors.toSet());\n-        }\n-\n-        @Override\n-        @Nullable\n-        public String[] get(@Nullable Object key) {\n-            final List<String> value = parameterMap.get(key);\n-            if (value == null) {\n-                return null;\n-            } else {\n-                return value.toArray(new String[0]);\n-            }\n-        }\n-\n-        @Override\n-        public boolean containsKey(Object key) {\n-            requireNonNull(key, \"key\");\n-            return parameterMap.containsKey(key);\n-        }\n-\n-        @Override\n-        public boolean containsValue(Object value) {\n-            requireNonNull(value, \"value\");\n-            return parameterMap.toSingleValueMap().containsValue(value);\n-        }\n-\n-        @Override\n-        public int size() {\n-            return parameterMap.size();\n-        }\n-    };\n-\n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) {\n-        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(httpRequest, \"request\");\n-\n-        this.serviceRequestContext = serviceRequestContext;\n-        this.servletContext = servletContext;\n-        this.httpRequest = httpRequest;\n-        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n-\n-        final MediaType contentType = httpRequest.headers().contentType();\n-        if (contentType != null && contentType.charset() != null) {\n-            characterEncoding = contentType.charset().name();\n-        } else {\n-            characterEncoding = servletContext.getRequestCharacterEncoding();\n-        }\n-\n-        requestURI = decodeRequestURI();\n-        decodeUrlParameter();\n-        decodeBody();\n-        cookies = decodeCookie();\n-        locales = decodeLocale();\n-        getProtocol();\n-        getScheme();\n-        queryString = decodeQuery();\n-        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n-                servletContext.getContextPath(), \"\");\n-        pathInfo = decodePathInfo();\n-    }\n-\n-    /**\n-     * Get netty request.\n-     */\n-    AggregatedHttpRequest getHttpRequest() {\n-        return httpRequest;\n-    }\n-\n-    private Map<String, Object> getAttributeMap() {\n-        return attributeMap;\n-    }\n-\n-    /**\n-     * Parse area.\n-     */\n-    private Locale[] decodeLocale() {\n-        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n-        if (isNullOrEmpty(headerValue)) {\n-            return DEFAULT_LOCALS;\n-        } else {\n-            return Arrays.stream(headerValue.split(\",\"))\n-                         .map(x -> x.split(\";\").length > 0 ?\n-                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n-                                                           : Locale.forLanguageTag(x.trim())\n-                         ).toArray(Locale[]::new);\n-        }\n-    }\n-\n-    /**\n-     * parse parameter specification.\n-     */\n-    private void decodeBody() {\n-        if (HttpMethod.POST.toString().equalsIgnoreCase(getMethod()) && getContentLength() > 0) {\n-            ServletUtil.decodeBody(parameterMap, httpRequest.content().array(), getContentType());\n-        }\n-    }\n-\n-    /**\n-     * Parsing URL parameters.\n-     */\n-    private void decodeUrlParameter() {\n-        final Charset charset = Charset.forName(getCharacterEncoding());\n-        ServletUtil.decodeByUrl(parameterMap, httpRequest.path(), charset);\n-    }\n-\n-    /**\n-     * Parsing the cookie.\n-     */\n-    @Nullable\n-    private Cookie[] decodeCookie() {\n-        final String value = getHeader(HttpHeaderNames.COOKIE.toString());\n-        if (!isNullOrEmpty(value)) {\n-            final Collection<Cookie> cookieSet = ServletUtil.decodeCookie(value);\n-            if (!cookieSet.isEmpty()) {\n-                return cookieSet.toArray(new Cookie[0]);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodePathInfo() {\n-        return requestURI.replaceFirst(getContextPath(), \"\")\n-                         .replaceFirst(servletPath, \"\");\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeRequestURI() {\n-        final String path = httpRequest.path();\n-        int queryInx = path.indexOf('?');\n-        if (queryInx == -1) {\n-            queryInx = path.indexOf('#');\n-        }\n-        return queryInx > -1 ? path.substring(0, queryInx) : path;\n-    }\n-\n-    /**\n-     * Parsing path.\n-     */\n-    private String decodeQuery() {\n-        final int queryInx = httpRequest.path().indexOf('?');\n-        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Cookie[] getCookies() {\n-        return cookies;\n-    }\n-\n-    /**\n-     * Get date header.\n-     */\n-    @Override\n-    public long getDateHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        for (DateFormat x : FORMATS_TEMPLATE) {\n-            try {\n-                final Date date = x.parse(getHeader(name));\n-                if (date != null) {\n-                    return date.getTime();\n-                }\n-            } catch (Exception e) {\n-                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * The getHeader method returns the header for the given header name.\n-     * @param name name.\n-     * @return header value.\n-     */\n-    @Override\n-    @Nullable\n-    public String getHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        return httpRequest.headers().get(name);\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        return Collections.enumeration(\n-                httpRequest.headers().names().stream()\n-                           .map(x -> x.toString()).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * Copy the implementation of tomcat.\n-     * @return Request URL.\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        final StringBuffer url = new StringBuffer();\n-        final String scheme = getScheme();\n-        int port = getServerPort();\n-        if (port < 0) {\n-            port = SessionProtocol.HTTP.defaultPort();\n-        }\n-\n-        url.append(scheme);\n-        url.append(\"://\");\n-        url.append(getServerName());\n-        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n-            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n-            url.append(':');\n-            url.append(port);\n-        }\n-        url.append(getRequestURI());\n-        return url;\n-    }\n-\n-    /**\n-     * PathInfo\uff1aPart of the request Path that is not part of the Context Path or Servlet Path.\n-     * If there's no extra path, it's either null,\n-     * Or a string that starts with '/'.\n-     * @return pathInfo.\n-     */\n-    @Override\n-    @Nullable\n-    public String getPathInfo() {\n-        return pathInfo;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getQueryString() {\n-        return queryString;\n-    }\n-\n-    @Override\n-    public String getRequestURI() {\n-        return requestURI;\n-    }\n-\n-    /**\n-     * Servlet Path: the Path section corresponds directly to the mapping of the activation request.\n-     * The path starts with the \"/\" character, if the request is in the \"/ *\" or \"\" mode.\"\n-     * matches, in which case it is an empty string.\n-     * @return servletPath.\n-     */\n-    @Override\n-    public String getServletPath() {\n-        return servletPath;\n-    }\n-\n-    @Override\n-    public HttpSession getSession(boolean create) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public HttpSession getSession() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String changeSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Enumeration<String> getHeaders(String name) {\n-        requireNonNull(name, \"name\");\n-        return Collections.enumeration(\n-                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    /**\n-     * servlet standard:\n-     * returns the value of the specified request header\n-     * as int. If the request has no title\n-     * the name specified by this method returns -1. if This method does not convert headers to integers\n-     * throws a NumberFormatException code. The first name is case insensitive.\n-     * @param name  specifies the name of the request header\n-     * @exception NumberFormatException If the header value cannot be converted to an int.\n-     * @return An integer request header representing a value or -1 if the request does not return -1.\n-     */\n-    @Override\n-    public int getIntHeader(String name) {\n-        requireNonNull(name, \"name\");\n-        final String headerStringValue = getHeader(name);\n-        if (isNullOrEmpty(headerStringValue)) {\n-            return -1;\n-        }\n-        return Integer.parseInt(headerStringValue);\n-    }\n-\n-    @Override\n-    public String getMethod() {\n-        return httpRequest.method().toString();\n-    }\n-\n-    /**\n-     * Context Path: the Path prefix associated with the ServletContext is part of this servlet.\n-     * If the context is web-based the server's URL namespace based on the \"default\" context,\n-     * then the path will be an empty string. Otherwise, if the context is not\n-     * server-based namespaces, so the path starts with /, but does not end with /.\n-     */\n-    @Override\n-    public String getContextPath() {\n-        return servletContext.getContextPath();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE ||\n-               sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        return sessionIdSource == SessionTrackingMode.COOKIE;\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        return isRequestedSessionIdFromUrl();\n-    }\n-\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        return sessionIdSource == SessionTrackingMode.URL;\n-    }\n-\n-    @Override\n-    public String getRequestedSessionId() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Object getAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        final Object value = getAttributeMap().get(name);\n-        return value;\n-    }\n-\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n-    }\n-\n-    @Override\n-    public String getCharacterEncoding() {\n-        return characterEncoding;\n-    }\n-\n-    @Override\n-    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n-        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n-    }\n-\n-    @Override\n-    public int getContentLength() {\n-        return (int) getContentLengthLong();\n-    }\n-\n-    @Override\n-    public long getContentLengthLong() {\n-        return Integer.parseInt(getHeader(HttpHeaderNames.CONTENT_LENGTH.toString())\n-                                        .replaceAll(\"[\\\\[\\\\]]\", \"\"));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getContentType() {\n-        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n-    }\n-\n-    @Override\n-    public DefaultServletInputStream getInputStream() throws IOException {\n-        if (reader != null) {\n-            throw new IllegalStateException(\"getReader() has already been called for this request\");\n-        }\n-        return inputStream;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getParameter(String name) {\n-        requireNonNull(name, \"name\");\n-        final String[] values = getParameterMap().get(name);\n-        if (values == null || values.length == 0) {\n-            return null;\n-        }\n-        return values[0];\n-    }\n-\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        return Collections.enumeration(ImmutableSet.copyOf(getParameterMap().keySet()));\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String[] getParameterValues(String name) {\n-        requireNonNull(name, \"name\");\n-        return getParameterMap().get(name);\n-    }\n-\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        return unmodifiableParameterMap;\n-    }\n-\n-    @Override\n-    public String getProtocol() {\n-        return serviceRequestContext.sessionProtocol().uriText();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getScheme() {\n-        return httpRequest.scheme();\n-    }\n-\n-    @Override\n-    @Nullable\n-    public String getServerName() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public int getServerPort() {\n-        return serviceRequestContext.config().server().activeLocalPort();\n-    }\n-\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        if (reader == null) {\n-            synchronized (this) {\n-                if (reader == null) {\n-                    reader = new BufferedReader(\n-                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n-                }\n-            }\n-        }\n-        return reader;\n-    }\n-\n-    @Override\n-    public String getRemoteAddr() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n-    }\n-\n-    @Override\n-    public String getRemoteHost() {\n-        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n-    }\n-\n-    @Override\n-    public int getRemotePort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public void setAttribute(String name, @Nullable Object object) {\n-        requireNonNull(name, \"name\");\n-        if (object == null) {\n-            removeAttribute(name);\n-            return;\n-        }\n-        getAttributeMap().put(name, object);\n-    }\n-\n-    @Override\n-    public void removeAttribute(String name) {\n-        requireNonNull(name, \"name\");\n-        getAttributeMap().remove(name);\n-    }\n-\n-    @Override\n-    public Locale getLocale() {\n-        return locales[0];\n-    }\n-\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n-    }\n-\n-    @Override\n-    public boolean isSecure() {\n-        return SessionProtocol.HTTPS.uriText().equals(getScheme());\n-    }\n-\n-    @Override\n-    @Nullable\n-    public ServletRequestDispatcher getRequestDispatcher(String path) {\n-        return servletContext.getRequestDispatcher(path);\n-    }\n-\n-    @Override\n-    public String getRealPath(String path) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getLocalName() {\n-        return serviceRequestContext.config().server().defaultHostname();\n-    }\n-\n-    @Override\n-    public String getLocalAddr() {\n-        return serviceRequestContext.localAddress().toString();\n-    }\n-\n-    @Override\n-    public int getLocalPort() {\n-        return getServerPort();\n-    }\n-\n-    @Override\n-    public DefaultServletContext getServletContext() {\n-        return servletContext;\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isAsyncStarted() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isAsyncSupported() {\n-        return false;\n-    }\n-\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        return DispatcherType.REQUEST;\n-    }\n-\n-    @Override\n-    public String getPathTranslated() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    /**\n-     * \"BASIC\", or \"DIGEST\", or \"SSL\".\n-     * @return Authentication type.\n-     */\n-    @Override\n-    public String getAuthType() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isUserInRole(String role) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void login(String username, String password) throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void logout() throws ServletException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        return fileUploadList;\n-    }\n-\n-    @Override\n-    @Nullable\n-    public Part getPart(String name) throws IOException, ServletException {\n-        requireNonNull(name, \"name\");\n-        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);\n-    }\n-\n-    @Override\n-    public <T extends HttpUpgradeHandler> T upgrade(Class<T> httpUpgradeHandlerClass) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-}\n"}}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MjIyNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435842227", "bodyText": "public abstract-> public final\nAnd we need to add a private constructor\nprivate QueryParamUtil() {}", "author": "minwoox", "createdAt": "2020-06-05T10:47:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Parse query parameters.\n+ */\n+public abstract class QueryParamUtil {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java b/core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java\ndeleted file mode 100644\nindex 0521fb16f7..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal.server;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.StringReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.URLDecoder;\n-import java.nio.charset.StandardCharsets;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.QueryParams;\n-import com.linecorp.armeria.common.QueryParamsBuilder;\n-\n-/**\n- * Parse query parameters.\n- */\n-public abstract class QueryParamUtil {\n-\n-    /**\n-     * Parse aggregated http request to query parameters.\n-     */\n-    public static QueryParams parse(AggregatedHttpRequest request) throws IOException {\n-        requireNonNull(request, \"request\");\n-        // parse parameters from URL\n-        final QueryParamsBuilder queryParamsBuilder =\n-                QueryParams.fromQueryString(queryString(request.path())).toBuilder();\n-        final MediaType contentType = request.headers().contentType();\n-        if (!(HttpMethod.POST == request.method() && request.content().length() > 0 &&\n-              contentType != null && contentType.is(MediaType.FORM_DATA))) {\n-            return queryParamsBuilder.build();\n-        }\n-\n-        // parse parameters from body\n-        final BufferedReader reader = new BufferedReader(new StringReader(\n-                new String(request.content().array(), StandardCharsets.UTF_8)));\n-        parseQuery(reader.readLine(), queryParamsBuilder);\n-        return queryParamsBuilder.build();\n-    }\n-\n-    private static String queryString(String path) {\n-        final int queryInx = path.indexOf('?');\n-        return queryInx > -1 ? path.substring(queryInx + 1) : \"\";\n-    }\n-\n-    private static void parseQuery(\n-            String query, QueryParamsBuilder queryParamsBuilder) throws UnsupportedEncodingException {\n-        requireNonNull(query, \"query\");\n-        requireNonNull(queryParamsBuilder, \"queryParamsBuilder\");\n-        final String[] pairs = query.split(\"[&]\");\n-        for (String pair : pairs) {\n-            final String[] param = pair.split(\"[=]\");\n-            if (param.length < 2) {\n-                break;\n-            }\n-            queryParamsBuilder.add(URLDecoder.decode(param[0], StandardCharsets.UTF_8.name()),\n-                                   URLDecoder.decode(param[1], StandardCharsets.UTF_8.name()));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435843495", "bodyText": "The reason that I wanted you to put this class in this package was that I wanted to have the parsing logic here only so that we can remove the duplicate code.\nIs there any reason that you cannot move queryParamsOf() in AnnotatedValueResolver?", "author": "minwoox", "createdAt": "2020-06-05T10:50:55Z", "path": "core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+\n+/**\n+ * Parse query parameters.\n+ */\n+public abstract class QueryParamUtil {\n+\n+    /**\n+     * Parse aggregated http request to query parameters.\n+     */\n+    public static QueryParams parse(AggregatedHttpRequest request) throws IOException {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4MTAzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435981036", "bodyText": "I think, we cannot use AnnotatedValueResolver.queryParamOf() because I want to QueryParamUtil will support at future:\n\nparse parameters from url\nparse parameters from body\nparse upload files from multipart\n\nAnnotatedValueResolver.queryParamOf() doesn't support all these features.", "author": "dominhhien", "createdAt": "2020-06-05T15:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMjY0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r436012645", "bodyText": "Thanks for the explanation. \ud83d\ude04\nI think AnnotatedValueResolver.queryParamsOf() can\n\nparse parameters from URL.\nparse parameters from body.\n\nBut it cannot\n\nparse upload files from multipart\n\nIt's because we do not provide multipart support on Armeria at the moment. However, once we support it, annotated services and Servlet will use the same logic to parse that. Which means that we have to put the logic in the same place.\nSo what I recommended is, could you just copy the code into the DefaultServletHttpRequest and use it? I will send a follow up PR that removes the duplicate code. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-06-05T15:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MzQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java b/core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java\ndeleted file mode 100644\nindex 0521fb16f7..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/server/QueryParamUtil.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal.server;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.StringReader;\n-import java.io.UnsupportedEncodingException;\n-import java.net.URLDecoder;\n-import java.nio.charset.StandardCharsets;\n-\n-import com.linecorp.armeria.common.AggregatedHttpRequest;\n-import com.linecorp.armeria.common.HttpMethod;\n-import com.linecorp.armeria.common.MediaType;\n-import com.linecorp.armeria.common.QueryParams;\n-import com.linecorp.armeria.common.QueryParamsBuilder;\n-\n-/**\n- * Parse query parameters.\n- */\n-public abstract class QueryParamUtil {\n-\n-    /**\n-     * Parse aggregated http request to query parameters.\n-     */\n-    public static QueryParams parse(AggregatedHttpRequest request) throws IOException {\n-        requireNonNull(request, \"request\");\n-        // parse parameters from URL\n-        final QueryParamsBuilder queryParamsBuilder =\n-                QueryParams.fromQueryString(queryString(request.path())).toBuilder();\n-        final MediaType contentType = request.headers().contentType();\n-        if (!(HttpMethod.POST == request.method() && request.content().length() > 0 &&\n-              contentType != null && contentType.is(MediaType.FORM_DATA))) {\n-            return queryParamsBuilder.build();\n-        }\n-\n-        // parse parameters from body\n-        final BufferedReader reader = new BufferedReader(new StringReader(\n-                new String(request.content().array(), StandardCharsets.UTF_8)));\n-        parseQuery(reader.readLine(), queryParamsBuilder);\n-        return queryParamsBuilder.build();\n-    }\n-\n-    private static String queryString(String path) {\n-        final int queryInx = path.indexOf('?');\n-        return queryInx > -1 ? path.substring(queryInx + 1) : \"\";\n-    }\n-\n-    private static void parseQuery(\n-            String query, QueryParamsBuilder queryParamsBuilder) throws UnsupportedEncodingException {\n-        requireNonNull(query, \"query\");\n-        requireNonNull(queryParamsBuilder, \"queryParamsBuilder\");\n-        final String[] pairs = query.split(\"[&]\");\n-        for (String pair : pairs) {\n-            final String[] param = pair.split(\"[=]\");\n-            if (param.length < 2) {\n-                break;\n-            }\n-            queryParamsBuilder.add(URLDecoder.decode(param[0], StandardCharsets.UTF_8.name()),\n-                                   URLDecoder.decode(param[1], StandardCharsets.UTF_8.name()));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NzA5MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435847090", "bodyText": "x.split(\";\") happend twice.", "author": "minwoox", "createdAt": "2020-06-05T10:58:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0ODk4NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435848984", "bodyText": "It seems like the parsing locale logic is a little bit complex. We also have to consider quality as well.\nIf you want we can make a separate PR for this. If you want to include it in this PR, how about referring what other frameworks do? For example: https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/connector/Request.java#L3329", "author": "minwoox", "createdAt": "2020-06-05T11:03:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyNDAzMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r436224030", "bodyText": "I will create a separate PR for this later :)", "author": "dominhhien", "createdAt": "2020-06-06T01:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0ODk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MDcxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435850716", "bodyText": "Seems like we don't need these?\ngetProtocol();\ngetScheme();", "author": "minwoox", "createdAt": "2020-06-05T11:06:55Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4ODY4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435888683", "bodyText": "We can remove queryString and just use serviceRequestContext.query().", "author": "minwoox", "createdAt": "2020-06-05T12:29:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4OTg3MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435889871", "bodyText": "We do not have to use replace which is a bit heavy computation because we know that the requestURI starts with the context path. So we can do:\nrequestURI.substring(servletContext.getContextPath().length());", "author": "minwoox", "createdAt": "2020-06-05T12:32:08Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MzY5MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435893690", "bodyText": "This should be null when there's no path info.\nFrom the implementation this is always an empty string. Could you check this out by making unit tests please?", "author": "minwoox", "createdAt": "2020-06-05T12:39:42Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5Mzk4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435893987", "bodyText": "Do not have to call requestURI.replaceFirst(getContextPath(), \"\") here again. We already did.", "author": "minwoox", "createdAt": "2020-06-05T12:40:12Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896196", "bodyText": "I think we don't have to check this because queryParams does not have duplicate keys.\nAlso we can use immutable map builder from the first.\nfinal Builder<String, String[]> builder = ImmutableMap.builder();\nqueryParams.forEach(x -> builder.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0])));\nparameters = builder.build();", "author": "minwoox", "createdAt": "2020-06-05T12:44:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5NzQyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435997429", "bodyText": "queryParams have duplicate keys and failed at my test case\nURL = \"/home?test=1&array=abc&array=a%20bc#code=3\"\nTherefore I have to add check code.\n22:34:56.305 [armeria-common-blocking-tasks-1-1] ERROR c.l.a.s.s.DefaultServletService - Servlet process failed: \njava.lang.IllegalArgumentException: Multiple entries with same key: array=[Ljava.lang.String;@1afc24a0 and array=[Ljava.lang.String;@5ff5ccd4\n\tat com.google.common.collect.ImmutableMap.conflictException(ImmutableMap.java:216)", "author": "dominhhien", "createdAt": "2020-06-05T15:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNTA1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r436005051", "bodyText": "Ah, sorry about it. We should do:\nfinal Builder<String, String[]> builder = ImmutableMap.builder();\nfor (String name : queryParams.names()) {\n    builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n}\nparameters = builder.build();", "author": "minwoox", "createdAt": "2020-06-05T15:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjE5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjY4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896685", "bodyText": "Please add @VisibleForTesting when the method is not private to use in tests.", "author": "minwoox", "createdAt": "2020-06-05T12:45:19Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjkxMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435896912", "bodyText": "We can completely remove this method.", "author": "minwoox", "createdAt": "2020-06-05T12:45:45Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMTkzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435901932", "bodyText": "We can use httpRequest.authority() instead of getServerName() and port.", "author": "minwoox", "createdAt": "2020-06-05T12:55:07Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMjg0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435902843", "bodyText": "These two line can be merged into one.", "author": "minwoox", "createdAt": "2020-06-05T12:56:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMzc2Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435903767", "bodyText": "contentType can be null.\nWe should check it before call toString() on it.", "author": "minwoox", "createdAt": "2020-06-05T12:58:36Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNDU5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435904593", "bodyText": "We should check if getInputStream() is called or not as we did it in getInputStream().", "author": "minwoox", "createdAt": "2020-06-05T13:00:01Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null) {", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwNTQxNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435905416", "bodyText": "We can do serviceRequestContext.config().virtualHost().defaultHostname()\nand this is not nullable.", "author": "minwoox", "createdAt": "2020-06-05T13:01:24Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwOTc1MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r435909750", "bodyText": "Could just do serviceRequestContext.sessionProtocol().isTls()", "author": "minwoox", "createdAt": "2020-06-05T13:09:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,640 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.server.QueryParamUtil;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final Locale[] DEFAULT_LOCALS = { Locale.getDefault() };\n+    private static final String RFC1123_DATE = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(RFC1123_DATE, Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final Locale[] locales;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+    @Nullable\n+    private final String queryString;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = QueryParamUtil.parse(httpRequest);\n+        cookies = decodeCookie();\n+        locales = decodeLocale();\n+        getProtocol();\n+        getScheme();\n+        queryString = decodeQuery();\n+        servletPath = servletContext.getServletPath(requestURI).replaceFirst(\n+                servletContext.getContextPath(), \"\");\n+        pathInfo = decodePathInfo();\n+        final Map<String, String[]> params = new HashMap<>();\n+        queryParams.forEach(x -> {\n+            if (!params.containsKey(x.getKey())) {\n+                params.put(x.getKey(), queryParams.getAll(x.getKey()).toArray(new String[0]));\n+            }\n+        });\n+        parameters = ImmutableMap.copyOf(params);\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    private Map<String, Object> getAttributeMap() {\n+        return attributeMap;\n+    }\n+\n+    /**\n+     * Parse area.\n+     */\n+    private Locale[] decodeLocale() {\n+        final String headerValue = getHeader(HttpHeaderNames.ACCEPT_LANGUAGE.toString());\n+        if (isNullOrEmpty(headerValue)) {\n+            return DEFAULT_LOCALS;\n+        } else {\n+            return Arrays.stream(headerValue.split(\",\"))\n+                         .map(x -> x.split(\";\").length > 0 ?\n+                                   Locale.forLanguageTag(x.split(\";\")[0].trim())\n+                                                           : Locale.forLanguageTag(x.trim())\n+                         ).toArray(Locale[]::new);\n+        }\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        return requestURI.replaceFirst(getContextPath(), \"\")\n+                         .replaceFirst(servletPath, \"\");\n+    }\n+\n+    /**\n+     * Parse query string.\n+     */\n+    private String decodeQuery() {\n+        final int queryInx = httpRequest.path().indexOf('?');\n+        return queryInx > -1 ? httpRequest.path().substring(queryInx + 1) : \"\";\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        final StringBuffer url = new StringBuffer();\n+        final String scheme = getScheme();\n+        int port = getServerPort();\n+        if (port < 0) {\n+            port = SessionProtocol.HTTP.defaultPort();\n+        }\n+\n+        url.append(scheme);\n+        url.append(\"://\");\n+        url.append(getServerName());\n+        if ((SessionProtocol.HTTP.uriText().equals(scheme) && (port != SessionProtocol.HTTP.defaultPort())) ||\n+            (SessionProtocol.HTTPS.uriText().equals(scheme) && (port != SessionProtocol.HTTPS.defaultPort()))) {\n+            url.append(':');\n+            url.append(port);\n+        }\n+        url.append(getRequestURI());\n+        return url;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return queryString;\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        final Object value = getAttributeMap().get(name);\n+        return value;\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(getAttributeMap().keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return httpRequest.headers().contentType().toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getServerName() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    reader = new BufferedReader(\n+                            new InputStreamReader(getInputStream(), getCharacterEncoding()));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        getAttributeMap().put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        getAttributeMap().remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        return locales[0];\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        return Collections.enumeration(Arrays.stream(locales).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return SessionProtocol.HTTPS.uriText().equals(getScheme());", "originalCommit": "1a7fdb76fa860e49736f4bc6d6b123ff2c5a0377", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 63%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 169d1a7762..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -15,25 +15,21 @@\n  */\n package com.linecorp.armeria.server.servlet;\n \n+import static com.google.common.base.MoreObjects.firstNonNull;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNTU5NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437835595", "bodyText": "I think this is not nullable.", "author": "minwoox", "createdAt": "2020-06-10T03:11:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.server.servlet.UrlMapper.Element;\n+\n+/**\n+ * Servlet context (lifetime same as server).\n+ */\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final UrlMapper<DefaultServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n+    private final UrlMapper<DefaultFilterRegistration> filterUrlMapper = new UrlMapper<>(false);\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrationMap = new HashMap<>();\n+    private Map<String, DefaultFilterRegistration> filterRegistrationMap = new HashMap<>();\n+    private MimeMappings mimeMappings = new MimeMappings();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    /**\n+     * Check servlet context is initialized.\n+     */\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrationMap = ImmutableMap.copyOf(servletRegistrationMap);\n+        filterRegistrationMap = ImmutableMap.copyOf(filterRegistrationMap);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    void setMimeMapping(MimeMappings mimeMappings) {\n+        requireNonNull(mimeMappings, \"mimeMappings\");\n+        this.mimeMappings = mimeMappings;\n+    }\n+\n+    /**\n+     * Get servlet path.\n+     */\n+    @Nullable\n+    String getServletPath(String uri) {\n+        final Element element = servletUrlMapper.getMapping(StringUtil.normalizePath(uri));\n+        return element == null ? null : element.path.substring(contextPath.length());\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final UrlMapper.Element<DefaultServletRegistration> element =\n+                servletUrlMapper.getMapping(StringUtil.normalizePath(path));\n+        if (element == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(element.getObject()),\n+                                            element.pattern, element);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        name = StringUtil.normalizePath(name);\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration registration = servletRegistrationMap.get(name);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return registration.getServlet();\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(DefaultServletRegistration::getServlet)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        return Collections.enumeration(servletRegistrationMap.values()\n+                                                             .stream()\n+                                                             .map(DefaultServletRegistration::getName)\n+                                                             .collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + \";\" + SystemInfo.osType().name() + \")\";\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName), \"servletName is empty)\", servletName);\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        servletName = StringUtil.normalizePath(servletName);\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        servletRegistrationMap.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrationMap.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrationMap;\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DefaultFilterRegistration addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return filterRegistrationMap.get(filterName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultFilterRegistration> getFilterRegistrations() {\n+        return filterRegistrationMap;\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public JspConfigDescriptor getJspConfigDescriptor() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClassLoader getClassLoader() {\n+        return getClass().getClassLoader();\n+    }\n+\n+    @Override\n+    public void declareRoles(String... roleNames) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getVirtualServerName() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + \";\" + SystemInfo.osType().name() + \")\";\n+    }\n+\n+    @Override\n+    public String getRequestCharacterEncoding() {\n+        return requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setRequestCharacterEncoding(String requestCharacterEncoding) {\n+        ensureUninitialized(\"setRequestCharacterEncoding\");\n+        requireNonNull(requestCharacterEncoding, \"requestCharacterEncoding\");\n+        this.requestCharacterEncoding = requestCharacterEncoding;\n+    }\n+\n+    @Override\n+    public String getResponseCharacterEncoding() {\n+        return responseCharacterEncoding;\n+    }\n+\n+    @Override\n+    public void setResponseCharacterEncoding(String responseCharacterEncoding) {\n+        ensureUninitialized(\"setResponseCharacterEncoding\");\n+        requireNonNull(responseCharacterEncoding, \"responseCharacterEncoding\");\n+        this.responseCharacterEncoding = responseCharacterEncoding;\n+    }\n+\n+    @Override\n+    public Dynamic addJspFile(String jspName, String jspFile) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    private void ensureUninitialized(@Nullable String name) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 65%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex bce2315410..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -23,6 +23,7 @@ import static java.util.Objects.requireNonNull;\n import java.io.InputStream;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjA5Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437836093", "bodyText": "Let's add @Nullable", "author": "minwoox", "createdAt": "2020-06-10T03:13:14Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjkyMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437836920", "bodyText": "Let's just return getTime() right away because Date is Obsolete.", "author": "minwoox", "createdAt": "2020-06-10T03:16:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNzU0Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437837547", "bodyText": "This can log three times for just one header.\nHow about logging it after all parsing fails?", "author": "minwoox", "createdAt": "2020-06-10T03:19:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODA5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838091", "bodyText": "We might consider caching all this sort of heavy operation later. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-10T03:21:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODU1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838551", "bodyText": "queryParams.getAll(name).isEmpty()", "author": "minwoox", "createdAt": "2020-06-10T03:24:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzODc3MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437838770", "bodyText": "If useInputStream is true, I think we need to raise an exception.", "author": "minwoox", "createdAt": "2020-06-10T03:25:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null && !useInputStream) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzOTMxNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437839317", "bodyText": "We should return the remote port:\n((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort()", "author": "minwoox", "createdAt": "2020-06-10T03:27:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final DefaultServletInputStream inputStream;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    //Can't be final because user will decide reader or inputStream is initialize.\n+    @Nullable\n+    private BufferedReader reader;\n+\n+    private boolean useInputStream;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        inputStream = new DefaultServletInputStream(Unpooled.wrappedBuffer(httpRequest.content().array()));\n+\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                final Date date = x.parse(getHeader(name));\n+                if (date != null) {\n+                    return date.getTime();\n+                }\n+            } catch (Exception e) {\n+                logger.info(\"Try parse \" + getHeader(name) + \" to date\");\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public DefaultServletInputStream getInputStream() throws IOException {\n+        if (reader != null) {\n+            throw new IllegalStateException(\"getReader() has already been called for this request\");\n+        }\n+        useInputStream = true;\n+        return inputStream;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name) == null) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        if (reader == null && !useInputStream) {\n+            synchronized (this) {\n+                if (reader == null) {\n+                    reader = new BufferedReader(\n+                            new InputStreamReader(inputStream, getCharacterEncoding()));\n+                }\n+            }\n+        }\n+        return reader;\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return getServerPort();", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 77%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex ea804bdc70..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -21,19 +21,15 @@ import static java.util.Objects.requireNonNull;\n \n import java.io.BufferedReader;\n import java.io.IOException;\n-import java.io.InputStreamReader;\n import java.io.UnsupportedEncodingException;\n import java.net.InetSocketAddress;\n import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Date;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MTUyNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437841525", "bodyText": "We can just do headersBuilder.contentType(MediaType.HTML_UTF_8);", "author": "minwoox", "createdAt": "2020-06-10T03:37:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MTY3Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437841673", "bodyText": "Shouldn't this be getResponseCharacterEncoding()?", "author": "minwoox", "createdAt": "2020-06-10T03:38:12Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Mjk5OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437842998", "bodyText": "How about removing this method and add cookie every time addCookie() is called?", "author": "minwoox", "createdAt": "2020-06-10T03:44:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437844007", "bodyText": "This does nothing. Could you use PathAndQuery.encodeToPercents()?", "author": "minwoox", "createdAt": "2020-06-10T03:48:56Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxMDE3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437910179", "bodyText": "As Java doc said:\n     * Encodes the specified URL by including the session ID,\n     * or, if encoding is not needed, returns the URL unchanged.\n     * The implementation of this method includes the logic to\n     * determine whether the session ID needs to be encoded in the URL.\n\nTherefore I return the URL unchanged because we have not support servlet session yet.", "author": "dominhhien", "createdAt": "2020-06-10T07:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxNDU4MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437914581", "bodyText": "But we call this from encodeRedirectURL().\nShouldn't we encode it?", "author": "minwoox", "createdAt": "2020-06-10T07:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjI1Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437926253", "bodyText": "Yes I think so. Tomcat's encodeUrl() also just return Url append &jsessionId=.... : https://github.com/apache/tomcat/blob/master/java/org/apache/catalina/connector/Response.java . If we don't support servlet session now, I think we just return Url unchanged.", "author": "dominhhien", "createdAt": "2020-06-10T07:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0NzA0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437947045", "bodyText": "Thanks for checking. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-06-10T08:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NTgyMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437845821", "bodyText": "Looks like we should set \"text/html\" as the content type.\nHow about making a new headers and send it?\nfinal ResponseHeaders headers =\n        ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\nif (responseWriter.tryWrite(headers)) {\n    if (msg != null) {\n        if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n            return;\n        }\n    }\n    responseWriter.close();\n}", "author": "minwoox", "createdAt": "2020-06-10T03:56:53Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjA5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846096", "bodyText": "Seems like we need to use 302.", "author": "minwoox", "createdAt": "2020-06-10T03:58:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjEzOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846139", "bodyText": "Can remove toString()", "author": "minwoox", "createdAt": "2020-06-10T03:58:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjQyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846422", "bodyText": "Can do just set(name, value);", "author": "minwoox", "createdAt": "2020-06-10T03:59:31Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjU0Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846543", "bodyText": "Can do just add(name, value);", "author": "minwoox", "createdAt": "2020-06-10T04:00:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjY1NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846654", "bodyText": "setLong?", "author": "minwoox", "createdAt": "2020-06-10T04:00:29Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NjY4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846685", "bodyText": "addLong?", "author": "minwoox", "createdAt": "2020-06-10T04:00:37Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Njk3OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437846978", "bodyText": "Could just call directly headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\nSo we don't have to call toString", "author": "minwoox", "createdAt": "2020-06-10T04:01:48Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NzY3Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437847677", "bodyText": "We can add @Nullable and return null. Javadoc says so.", "author": "minwoox", "createdAt": "2020-06-10T04:04:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0Nzk1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437847955", "bodyText": "if (sm == null) {\n    headersBuilder.status(HttpStatus.valueOf(sc));\n} else {\n    headersBuilder.status(new HttpStatus(sc, sm));\n}", "author": "minwoox", "createdAt": "2020-06-10T04:06:16Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODk4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437848982", "bodyText": "final MediaType mediaType = headersBuilder.contentType();\nif (mediaType != null && mediaType.charset() != null) {\n    return mediaType.charset().toString();\n} \nreturn defaultCharacterEncoding;", "author": "minwoox", "createdAt": "2020-06-10T04:10:46Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            sm = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, sm));\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return getContentType().split(\";\")[1].trim();", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0OTQ1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437849451", "bodyText": "final MediaType mediaType = headersBuilder.contentType();\nif (mediaType != null) {\n    headersBuilder.contentType(mediaType.withCharset(Charset.forName(charset)));\n}", "author": "minwoox", "createdAt": "2020-06-10T04:12:41Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private final List<Cookie> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, MediaType.HTML_UTF_8.toString());\n+        setCharacterEncoding(servletContext.getRequestCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Parse cookies.\n+     */\n+    ResponseHeadersBuilder parseCookie() {\n+        return headersBuilder.setObject(\n+                HttpHeaderNames.SET_COOKIE,\n+                cookies.stream()\n+                       .map(x -> {\n+                           final String path = x.getPath() == null ? \"/\" : x.getPath();\n+                           final CookieBuilder builder =\n+                                   com.linecorp.armeria.common.Cookie.builder(x.getName(), x.getValue())\n+                                                                     .path(path)\n+                                                                     .httpOnly(\n+                                                                             x.isHttpOnly())\n+                                                                     .secure(x.getSecure());\n+                           if (x.getMaxAge() != -1) {\n+                               builder.maxAge(x.getMaxAge());\n+                           }\n+                           if (!isNullOrEmpty(x.getDomain())) {\n+                               builder.domain(x.getDomain());\n+                           }\n+                           return builder.build().toSetCookieHeader();\n+                       }).collect(Collectors.toList()));\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        cookies.add(cookie);\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        if (msg == null) {\n+            msg = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, msg));\n+        if (responseWriter.tryWrite(headersBuilder.build())) {\n+            if (responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                responseWriter.close();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.SEE_OTHER, HttpHeaderNames.LOCATION.toString(), location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setObject(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addObject(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.setObject(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.addObject(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        setHeader(HttpHeaderNames.CONTENT_TYPE.toString(), contentType);\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+        final String contentType = getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+        return contentType == null ? \"\" : contentType;\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            sm = \"\";\n+        }\n+        headersBuilder.status(new HttpStatus(sc, sm));\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return getContentType().split(\";\")[1].trim();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String charset) {\n+        requireNonNull(charset, \"charset\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE,", "originalCommit": "1d6554bf4298cac330209a372b85a258294035f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 58%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex e782595471..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -19,14 +19,16 @@ import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Strings.isNullOrEmpty;\n import static java.util.Objects.requireNonNull;\n \n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.stream.Collectors;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n"}}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "4e975863fba562297d53e30d67bbaee12c836d1e", "url": "https://github.com/line/armeria/commit/4e975863fba562297d53e30d67bbaee12c836d1e", "message": "Set final classes and final fields", "committedDate": "2020-06-03T04:10:42Z", "type": "forcePushed"}, {"oid": "5091a50bbda625835e16f194fab4004b1b11659a", "url": "https://github.com/line/armeria/commit/5091a50bbda625835e16f194fab4004b1b11659a", "message": "Add QueryParams, add PathInfo tests", "committedDate": "2020-06-10T08:08:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437921899", "bodyText": "It seems like we don't override this method because it's implemented in ServletInputStream?", "author": "minwoox", "createdAt": "2020-06-10T07:40:31Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NTkxMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437965913", "bodyText": "No, because all request data parsed to servlet parameters. I think readLine() is only useful to read a large size upload data. We don't support this case now.", "author": "dominhhien", "createdAt": "2020-06-10T08:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3MjgxMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437972812", "bodyText": "If we support read(), shouldn't we support readLine() as well?", "author": "minwoox", "createdAt": "2020-06-10T09:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3NTY0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437975642", "bodyText": "I think, we also shouldn't support read() now.", "author": "dominhhien", "createdAt": "2020-06-10T09:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3Nzg1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437977855", "bodyText": "Then, is it better to just not support in DefaultServletHttpRequest.getInputStream()?\nIs there any chance that content type of the request is not FORM_DATA so that the content is used directly by the user?", "author": "minwoox", "createdAt": "2020-06-10T09:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4MzExNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437983115", "bodyText": "Is there any chance that content type of the request is not FORM_DATA so that the content is used directly by the user?\n\nI have thought about your question before. But I have not found a solution for this problem. Does Armeria provide an API return InputStream to User without aggregate operation?\n\nThen, is it better to just not support in DefaultServletHttpRequest.getInputStream()?\n\nYes, I think so.", "author": "dominhhien", "createdAt": "2020-06-10T09:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NTE4Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437985187", "bodyText": "But I have not found a solution for this problem.\n\nI might lose a context. \ud83d\ude04 What was the problem you are mentioning?\n\nYes, I think so.\n\nIf so, let's do it. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-10T09:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5MTUwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437991509", "bodyText": "I might lose a context. \ud83d\ude04 What was the problem you are mentioning?\n\nI mean: Input stream support read directly bytes data, then we can read each part of data. But if we aggregated request, I think all data bytes already read to bytes array. Therefore using Input stream is unnecessary.", "author": "dominhhien", "createdAt": "2020-06-10T09:33:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTg5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\ndeleted file mode 100755\nindex 7642cd91d3..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.IOException;\n-\n-import javax.servlet.ReadListener;\n-import javax.servlet.ServletInputStream;\n-\n-import io.netty.buffer.ByteBuf;\n-\n-/**\n- * The servlet input stream.\n- */\n-final class DefaultServletInputStream extends ServletInputStream {\n-    private final ByteBuf source;\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    DefaultServletInputStream(ByteBuf source) {\n-        requireNonNull(source, \"source\");\n-        this.source = source;\n-    }\n-\n-    @Override\n-    public int readLine(byte[] b, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isFinished() {\n-        return source.readableBytes() == 0;\n-    }\n-\n-    @Override\n-    public boolean isReady() {\n-        return source.readableBytes() != 0;\n-    }\n-\n-    @Override\n-    public void setReadListener(ReadListener readListener) {\n-        requireNonNull(readListener, \"readListener\");\n-    }\n-\n-    @Override\n-    public long skip(long n) throws IOException {\n-        final long skipLen = Math.min(source.readableBytes(), n);\n-        source.skipBytes((int) skipLen);\n-        return skipLen;\n-    }\n-\n-    @Override\n-    public int available() throws IOException {\n-        return source.readableBytes();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public int read(byte[] bytes, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int read() throws IOException {\n-        if (isFinished()) {\n-            return -1;\n-        }\n-        return source.readByte();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMTYyNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437931627", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-10T07:56:06Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener) {\n+        requireNonNull(readListener, \"readListener\");\n+    }\n+\n+    @Override\n+    public long skip(long n) throws IOException {\n+        final long skipLen = Math.min(source.readableBytes(), n);\n+        source.skipBytes((int) skipLen);\n+        return skipLen;\n+    }\n+\n+    @Override\n+    public int available() throws IOException {\n+        return source.readableBytes();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    @Override\n+    public int read(byte[] bytes, int off, int len) throws IOException {", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\ndeleted file mode 100755\nindex 7642cd91d3..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.IOException;\n-\n-import javax.servlet.ReadListener;\n-import javax.servlet.ServletInputStream;\n-\n-import io.netty.buffer.ByteBuf;\n-\n-/**\n- * The servlet input stream.\n- */\n-final class DefaultServletInputStream extends ServletInputStream {\n-    private final ByteBuf source;\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    DefaultServletInputStream(ByteBuf source) {\n-        requireNonNull(source, \"source\");\n-        this.source = source;\n-    }\n-\n-    @Override\n-    public int readLine(byte[] b, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isFinished() {\n-        return source.readableBytes() == 0;\n-    }\n-\n-    @Override\n-    public boolean isReady() {\n-        return source.readableBytes() != 0;\n-    }\n-\n-    @Override\n-    public void setReadListener(ReadListener readListener) {\n-        requireNonNull(readListener, \"readListener\");\n-    }\n-\n-    @Override\n-    public long skip(long n) throws IOException {\n-        final long skipLen = Math.min(source.readableBytes(), n);\n-        source.skipBytes((int) skipLen);\n-        return skipLen;\n-    }\n-\n-    @Override\n-    public int available() throws IOException {\n-        return source.readableBytes();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public int read(byte[] bytes, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int read() throws IOException {\n-        if (isFinished()) {\n-            return -1;\n-        }\n-        return source.readByte();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzMjMzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437932331", "bodyText": "This doesn't do anthing?", "author": "minwoox", "createdAt": "2020-06-10T07:57:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;\n+    }\n+\n+    @Override\n+    public void setReadListener(ReadListener readListener) {\n+        requireNonNull(readListener, \"readListener\");", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\ndeleted file mode 100755\nindex 7642cd91d3..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.IOException;\n-\n-import javax.servlet.ReadListener;\n-import javax.servlet.ServletInputStream;\n-\n-import io.netty.buffer.ByteBuf;\n-\n-/**\n- * The servlet input stream.\n- */\n-final class DefaultServletInputStream extends ServletInputStream {\n-    private final ByteBuf source;\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    DefaultServletInputStream(ByteBuf source) {\n-        requireNonNull(source, \"source\");\n-        this.source = source;\n-    }\n-\n-    @Override\n-    public int readLine(byte[] b, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isFinished() {\n-        return source.readableBytes() == 0;\n-    }\n-\n-    @Override\n-    public boolean isReady() {\n-        return source.readableBytes() != 0;\n-    }\n-\n-    @Override\n-    public void setReadListener(ReadListener readListener) {\n-        requireNonNull(readListener, \"readListener\");\n-    }\n-\n-    @Override\n-    public long skip(long n) throws IOException {\n-        final long skipLen = Math.min(source.readableBytes(), n);\n-        source.skipBytes((int) skipLen);\n-        return skipLen;\n-    }\n-\n-    @Override\n-    public int available() throws IOException {\n-        return source.readableBytes();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public int read(byte[] bytes, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int read() throws IOException {\n-        if (isFinished()) {\n-            return -1;\n-        }\n-        return source.readByte();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNDY2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437934660", "bodyText": "Could be source.isReadable()?", "author": "minwoox", "createdAt": "2020-06-10T08:01:15Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return source.readableBytes() != 0;", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\ndeleted file mode 100755\nindex 7642cd91d3..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.IOException;\n-\n-import javax.servlet.ReadListener;\n-import javax.servlet.ServletInputStream;\n-\n-import io.netty.buffer.ByteBuf;\n-\n-/**\n- * The servlet input stream.\n- */\n-final class DefaultServletInputStream extends ServletInputStream {\n-    private final ByteBuf source;\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    DefaultServletInputStream(ByteBuf source) {\n-        requireNonNull(source, \"source\");\n-        this.source = source;\n-    }\n-\n-    @Override\n-    public int readLine(byte[] b, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isFinished() {\n-        return source.readableBytes() == 0;\n-    }\n-\n-    @Override\n-    public boolean isReady() {\n-        return source.readableBytes() != 0;\n-    }\n-\n-    @Override\n-    public void setReadListener(ReadListener readListener) {\n-        requireNonNull(readListener, \"readListener\");\n-    }\n-\n-    @Override\n-    public long skip(long n) throws IOException {\n-        final long skipLen = Math.min(source.readableBytes(), n);\n-        source.skipBytes((int) skipLen);\n-        return skipLen;\n-    }\n-\n-    @Override\n-    public int available() throws IOException {\n-        return source.readableBytes();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public int read(byte[] bytes, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int read() throws IOException {\n-        if (isFinished()) {\n-            return -1;\n-        }\n-        return source.readByte();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNDgxMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437934811", "bodyText": "Could be !source.isReadable()?", "author": "minwoox", "createdAt": "2020-06-10T08:01:29Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+\n+import javax.servlet.ReadListener;\n+import javax.servlet.ServletInputStream;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+/**\n+ * The servlet input stream.\n+ */\n+final class DefaultServletInputStream extends ServletInputStream {\n+    private final ByteBuf source;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    DefaultServletInputStream(ByteBuf source) {\n+        requireNonNull(source, \"source\");\n+        this.source = source;\n+    }\n+\n+    @Override\n+    public int readLine(byte[] b, int off, int len) throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isFinished() {\n+        return source.readableBytes() == 0;", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\ndeleted file mode 100755\nindex 7642cd91d3..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletInputStream.java\n+++ /dev/null\n\n@@ -1,89 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.IOException;\n-\n-import javax.servlet.ReadListener;\n-import javax.servlet.ServletInputStream;\n-\n-import io.netty.buffer.ByteBuf;\n-\n-/**\n- * The servlet input stream.\n- */\n-final class DefaultServletInputStream extends ServletInputStream {\n-    private final ByteBuf source;\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    DefaultServletInputStream(ByteBuf source) {\n-        requireNonNull(source, \"source\");\n-        this.source = source;\n-    }\n-\n-    @Override\n-    public int readLine(byte[] b, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean isFinished() {\n-        return source.readableBytes() == 0;\n-    }\n-\n-    @Override\n-    public boolean isReady() {\n-        return source.readableBytes() != 0;\n-    }\n-\n-    @Override\n-    public void setReadListener(ReadListener readListener) {\n-        requireNonNull(readListener, \"readListener\");\n-    }\n-\n-    @Override\n-    public long skip(long n) throws IOException {\n-        final long skipLen = Math.min(source.readableBytes(), n);\n-        source.skipBytes((int) skipLen);\n-        return skipLen;\n-    }\n-\n-    @Override\n-    public int available() throws IOException {\n-        return source.readableBytes();\n-    }\n-\n-    @Override\n-    public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public int read(byte[] bytes, int off, int len) throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public int read() throws IOException {\n-        if (isFinished()) {\n-            return -1;\n-        }\n-        return source.readByte();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTY4Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437935686", "bodyText": "Could be response.getResponseWriter().isOpen()?", "author": "minwoox", "createdAt": "2020-06-10T08:03:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nindex 28df51dad0..ab9818c9f7 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n\n@@ -24,36 +24,27 @@ import java.util.Arrays;\n import javax.servlet.ServletOutputStream;\n import javax.servlet.WriteListener;\n \n-import com.linecorp.armeria.common.HttpData;\n-\n-/**\n- * Servlets output streams (wrapper classes) that control access to the flow.\n- */\n final class DefaultServletOutputStream extends ServletOutputStream {\n+\n     private final DefaultServletHttpResponse response;\n \n     DefaultServletOutputStream(DefaultServletHttpResponse response) {\n-        requireNonNull(response, \"response\");\n         this.response = response;\n     }\n \n     @Override\n     public boolean isReady() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return response.isReady();\n     }\n \n     @Override\n     public void setWriteListener(WriteListener listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public void flush() throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        response.close();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTk1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437935955", "bodyText": "Could be response.getResponseWriter().close();?", "author": "minwoox", "createdAt": "2020-06-10T08:03:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nindex 28df51dad0..ab9818c9f7 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n\n@@ -24,36 +24,27 @@ import java.util.Arrays;\n import javax.servlet.ServletOutputStream;\n import javax.servlet.WriteListener;\n \n-import com.linecorp.armeria.common.HttpData;\n-\n-/**\n- * Servlets output streams (wrapper classes) that control access to the flow.\n- */\n final class DefaultServletOutputStream extends ServletOutputStream {\n+\n     private final DefaultServletHttpResponse response;\n \n     DefaultServletOutputStream(DefaultServletHttpResponse response) {\n-        requireNonNull(response, \"response\");\n         this.response = response;\n     }\n \n     @Override\n     public boolean isReady() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return response.isReady();\n     }\n \n     @Override\n     public void setWriteListener(WriteListener listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public void flush() throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        response.close();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437937722", "bodyText": "What happens to the second right? A user can do it?", "author": "minwoox", "createdAt": "2020-06-10T08:06:26Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        final byte[] bytes = new byte[1];\n+        bytes[0] = (byte) b;\n+        write(bytes);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+        requireNonNull(b, \"b\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        response.write(HttpData.copyOf(Arrays.copyOfRange(b, off, len)));", "originalCommit": "411299338b7890ed2174698df4430c1cfe74a3f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAwNTU5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438005592", "bodyText": "Do you mean off >= 0 is right? Sorry, I think I haven't caught your question.", "author": "dominhhien", "createdAt": "2020-06-10T09:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxOTQ0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438019441", "bodyText": "Let's say that if a user calls:\nDefaultServletOutputStream stream = ...\nstream.write(1);\nstream.write(2);\nThe first stream.write(1); call will close the response stream writer by calling response.getResponseWriter().close();\nSo 2 cannot be written. Isn't it?", "author": "minwoox", "createdAt": "2020-06-10T10:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAyODI0NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438028245", "bodyText": "Yes, 2 can't be written, therefore If I want to write a download file I have to convert whole file to bytes array and convert byte arrays to HttpData. I think it use so much memory, not good. Do you have another solution to write each part of download file? Can I call tryWrite(HttpData) multiple time? Can I split download file to multiple HttpData.", "author": "dominhhien", "createdAt": "2020-06-10T10:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAzNDM1NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438034355", "bodyText": "If we can't write multiple time, I think write(2) should be raise an exception. Ofcourse, we need a AtomicBoolean isWritten to check response have already written. What do you think?", "author": "dominhhien", "createdAt": "2020-06-10T10:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAzODE3OQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438038179", "bodyText": "I think we should allow users call write multiple time.\nHow about caching the written bytes and write it to the HttpResponseWriter when close() or flush() is called?", "author": "minwoox", "createdAt": "2020-06-10T11:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNzcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nindex 28df51dad0..ab9818c9f7 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n\n@@ -24,36 +24,27 @@ import java.util.Arrays;\n import javax.servlet.ServletOutputStream;\n import javax.servlet.WriteListener;\n \n-import com.linecorp.armeria.common.HttpData;\n-\n-/**\n- * Servlets output streams (wrapper classes) that control access to the flow.\n- */\n final class DefaultServletOutputStream extends ServletOutputStream {\n+\n     private final DefaultServletHttpResponse response;\n \n     DefaultServletOutputStream(DefaultServletHttpResponse response) {\n-        requireNonNull(response, \"response\");\n         this.response = response;\n     }\n \n     @Override\n     public boolean isReady() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        return response.isReady();\n     }\n \n     @Override\n     public void setWriteListener(WriteListener listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void close() throws IOException {\n-    }\n-\n-    @Override\n-    public void flush() throws IOException {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        response.close();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MTg5MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437941890", "bodyText": "Is this not supported?", "author": "minwoox", "createdAt": "2020-06-10T08:13:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");", "originalCommit": "5091a50bbda625835e16f194fab4004b1b11659a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java\ndeleted file mode 100755\nindex eb02cd6ac9..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java\n+++ /dev/null\n\n@@ -1,269 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.util.Formatter;\n-import java.util.Locale;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-\n-/**\n- *  Printing flow.\n- */\n-final class ServletPrintWriter extends PrintWriter {\n-    private final String lineSeparator = System.lineSeparator();\n-    private final DefaultServletHttpResponse response;\n-\n-    private boolean error;\n-\n-    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n-        super(out);\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-    }\n-\n-    @Override\n-    public void flush() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void close() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean checkError() {\n-        return error;\n-    }\n-\n-    @Override\n-    protected void setError() {\n-        error = true;\n-    }\n-\n-    @Override\n-    protected void clearError() {\n-        error = false;\n-    }\n-\n-    @Override\n-    public void write(int c) {\n-        write(String.valueOf(c));\n-    }\n-\n-    @Override\n-    public void write(char[] buf, int off, int len) {\n-        requireNonNull(buf, \"buf\");\n-        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n-        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n-        write(String.valueOf(buf, off, len));\n-    }\n-\n-    @Override\n-    public void write(char[] buf) {\n-        requireNonNull(buf, \"buf\");\n-        write(String.valueOf(buf));\n-    }\n-\n-    @Override\n-    public void write(String s, int off, int len) {\n-        requireNonNull(s, \"s\");\n-        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n-        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n-        final String writeStr;\n-        if (off == 0 && s.length() == len) {\n-            writeStr = s;\n-        } else {\n-            writeStr = s.substring(off, off + len);\n-        }\n-        response.write(HttpData.ofUtf8(writeStr));\n-    }\n-\n-    @Override\n-    public void write(String s) {\n-        requireNonNull(s, \"s\");\n-        write(s, 0, s.length());\n-    }\n-\n-    @Override\n-    public void print(boolean b) {\n-        write(b ? \"true\" : \"false\");\n-    }\n-\n-    @Override\n-    public void print(char c) {\n-        write(String.valueOf(c));\n-    }\n-\n-    @Override\n-    public void print(int i) {\n-        write(String.valueOf(i));\n-    }\n-\n-    @Override\n-    public void print(long l) {\n-        write(String.valueOf(l));\n-    }\n-\n-    @Override\n-    public void print(float f) {\n-        write(String.valueOf(f));\n-    }\n-\n-    @Override\n-    public void print(double d) {\n-        write(String.valueOf(d));\n-    }\n-\n-    @Override\n-    public void print(char[] s) {\n-        write(s);\n-    }\n-\n-    @Override\n-    public void print(String s) {\n-        requireNonNull(s, \"s\");\n-        write(s);\n-    }\n-\n-    @Override\n-    public void print(Object obj) {\n-        requireNonNull(obj, \"obj\");\n-        write(String.valueOf(obj));\n-    }\n-\n-    @Override\n-    public void println() {\n-        write(lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(boolean b) {\n-        write((b ? \"true\" : \"false\") + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(char x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(int x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(long x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(float x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(double x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(char[] x) {\n-        write(String.valueOf(x) + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(String x) {\n-        requireNonNull(x, \"x\");\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(Object x) {\n-        requireNonNull(x, \"x\");\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public PrintWriter printf(String format, Object... args) {\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(Locale.getDefault(), format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter printf(Locale l, String format, Object... args) {\n-        requireNonNull(l, \"l\");\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(l, format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter format(String format, Object... args) {\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(Locale.getDefault(), format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter format(Locale l, String format, Object... args) {\n-        requireNonNull(l, \"l\");\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        final StringBuilder sb = new StringBuilder();\n-        final Formatter formatter = new Formatter(sb, l);\n-        formatter.format(l, format, args);\n-        write(sb.toString());\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(@Nullable CharSequence csq) {\n-        if (csq == null) {\n-            write(\"null\");\n-        } else {\n-            write(csq.toString());\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(@Nullable CharSequence csq, int start, int end) {\n-        checkArgument(start >= 0, \"start: %s (expected: >= 0)\", start);\n-        checkArgument(end >= 0, \"end: %s (expected: >= 0)\", end);\n-        final CharSequence cs = csq == null ? \"null\" : csq;\n-        write(cs.subSequence(start, end).toString());\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(char c) {\n-        write(c);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MjUwMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r437942502", "bodyText": "ditto write can only happen once?", "author": "minwoox", "createdAt": "2020-06-10T08:14:21Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.HttpData;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+        return error;\n+    }\n+\n+    @Override\n+    protected void setError() {\n+        error = true;\n+    }\n+\n+    @Override\n+    protected void clearError() {\n+        error = false;\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        write(String.valueOf(c));\n+    }\n+\n+    @Override\n+    public void write(char[] buf, int off, int len) {\n+        requireNonNull(buf, \"buf\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        write(String.valueOf(buf, off, len));\n+    }\n+\n+    @Override\n+    public void write(char[] buf) {\n+        requireNonNull(buf, \"buf\");\n+        write(String.valueOf(buf));\n+    }\n+\n+    @Override\n+    public void write(String s, int off, int len) {\n+        requireNonNull(s, \"s\");\n+        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n+        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n+        final String writeStr;\n+        if (off == 0 && s.length() == len) {\n+            writeStr = s;\n+        } else {\n+            writeStr = s.substring(off, off + len);\n+        }\n+        response.write(HttpData.ofUtf8(writeStr));", "originalCommit": "5091a50bbda625835e16f194fab4004b1b11659a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAwMjM5MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r438002391", "bodyText": "Do you mean we should check state isWritten ?", "author": "dominhhien", "createdAt": "2020-06-10T09:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk0MjUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java\ndeleted file mode 100755\nindex eb02cd6ac9..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java\n+++ /dev/null\n\n@@ -1,269 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.util.Formatter;\n-import java.util.Locale;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-\n-/**\n- *  Printing flow.\n- */\n-final class ServletPrintWriter extends PrintWriter {\n-    private final String lineSeparator = System.lineSeparator();\n-    private final DefaultServletHttpResponse response;\n-\n-    private boolean error;\n-\n-    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n-        super(out);\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-    }\n-\n-    @Override\n-    public void flush() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public void close() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    @Override\n-    public boolean checkError() {\n-        return error;\n-    }\n-\n-    @Override\n-    protected void setError() {\n-        error = true;\n-    }\n-\n-    @Override\n-    protected void clearError() {\n-        error = false;\n-    }\n-\n-    @Override\n-    public void write(int c) {\n-        write(String.valueOf(c));\n-    }\n-\n-    @Override\n-    public void write(char[] buf, int off, int len) {\n-        requireNonNull(buf, \"buf\");\n-        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n-        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n-        write(String.valueOf(buf, off, len));\n-    }\n-\n-    @Override\n-    public void write(char[] buf) {\n-        requireNonNull(buf, \"buf\");\n-        write(String.valueOf(buf));\n-    }\n-\n-    @Override\n-    public void write(String s, int off, int len) {\n-        requireNonNull(s, \"s\");\n-        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n-        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n-        final String writeStr;\n-        if (off == 0 && s.length() == len) {\n-            writeStr = s;\n-        } else {\n-            writeStr = s.substring(off, off + len);\n-        }\n-        response.write(HttpData.ofUtf8(writeStr));\n-    }\n-\n-    @Override\n-    public void write(String s) {\n-        requireNonNull(s, \"s\");\n-        write(s, 0, s.length());\n-    }\n-\n-    @Override\n-    public void print(boolean b) {\n-        write(b ? \"true\" : \"false\");\n-    }\n-\n-    @Override\n-    public void print(char c) {\n-        write(String.valueOf(c));\n-    }\n-\n-    @Override\n-    public void print(int i) {\n-        write(String.valueOf(i));\n-    }\n-\n-    @Override\n-    public void print(long l) {\n-        write(String.valueOf(l));\n-    }\n-\n-    @Override\n-    public void print(float f) {\n-        write(String.valueOf(f));\n-    }\n-\n-    @Override\n-    public void print(double d) {\n-        write(String.valueOf(d));\n-    }\n-\n-    @Override\n-    public void print(char[] s) {\n-        write(s);\n-    }\n-\n-    @Override\n-    public void print(String s) {\n-        requireNonNull(s, \"s\");\n-        write(s);\n-    }\n-\n-    @Override\n-    public void print(Object obj) {\n-        requireNonNull(obj, \"obj\");\n-        write(String.valueOf(obj));\n-    }\n-\n-    @Override\n-    public void println() {\n-        write(lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(boolean b) {\n-        write((b ? \"true\" : \"false\") + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(char x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(int x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(long x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(float x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(double x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(char[] x) {\n-        write(String.valueOf(x) + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(String x) {\n-        requireNonNull(x, \"x\");\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(Object x) {\n-        requireNonNull(x, \"x\");\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public PrintWriter printf(String format, Object... args) {\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(Locale.getDefault(), format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter printf(Locale l, String format, Object... args) {\n-        requireNonNull(l, \"l\");\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(l, format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter format(String format, Object... args) {\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(Locale.getDefault(), format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter format(Locale l, String format, Object... args) {\n-        requireNonNull(l, \"l\");\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        final StringBuilder sb = new StringBuilder();\n-        final Formatter formatter = new Formatter(sb, l);\n-        formatter.format(l, format, args);\n-        write(sb.toString());\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(@Nullable CharSequence csq) {\n-        if (csq == null) {\n-            write(\"null\");\n-        } else {\n-            write(csq.toString());\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(@Nullable CharSequence csq, int start, int end) {\n-        checkArgument(start >= 0, \"start: %s (expected: >= 0)\", start);\n-        checkArgument(end >= 0, \"end: %s (expected: >= 0)\", end);\n-        final CharSequence cs = csq == null ? \"null\" : csq;\n-        write(cs.subSequence(start, end).toString());\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(char c) {\n-        write(c);\n-        return this;\n-    }\n-}\n"}}, {"oid": "2ec6c88b5b42c7dcd1fa50ef46f042fadc8d1c12", "url": "https://github.com/line/armeria/commit/2ec6c88b5b42c7dcd1fa50ef46f042fadc8d1c12", "message": "Check already sent", "committedDate": "2020-06-10T10:57:43Z", "type": "commit"}, {"oid": "9bc785005f71847396060d5b461d0f552a374b08", "url": "https://github.com/line/armeria/commit/9bc785005f71847396060d5b461d0f552a374b08", "message": "Cache written bytes, write multiple time", "committedDate": "2020-06-11T01:07:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyOTg4Mw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439229883", "bodyText": "We can do:\nfinal String dateHeader = getHeader(name);\nif (dateHeader == null) {\n    return -1;\n}\nfor (DateFormat x : FORMATS_TEMPLATE) {\n    try {\n        return x.parse(dateHeader).getTime();\n    } catch (Exception e) {\n        // ignored.\n    }\n}\nthrow new IllegalArgumentException(\"failed to parse a date header: \" + dateHeader);", "author": "minwoox", "createdAt": "2020-06-12T06:25:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMTg3Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439231872", "bodyText": "We should not call the deprecated method. The deprecated isRequestedSessionIdFromUrl() should call this method.", "author": "minwoox", "createdAt": "2020-06-12T06:31:11Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjIzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439232233", "bodyText": "Shouldn't we return false at the moment because this method checks whether the requested session ID was conveyed to the server as part of the request URL?", "author": "minwoox", "createdAt": "2020-06-12T06:32:09Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjg1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439232851", "bodyText": "Can't we just call return parameters.get(name);?", "author": "minwoox", "createdAt": "2020-06-12T06:33:59Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNDgxOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439234818", "bodyText": "I think we can do:\nfinal InetSocketAddress socketAddress = serviceRequestContext.localAddress();\nreturn socketAddress.getPort();", "author": "minwoox", "createdAt": "2020-06-12T06:39:24Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTEzMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235132", "bodyText": "This is not supported at the moment.", "author": "minwoox", "createdAt": "2020-06-12T06:40:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return serviceRequestContext.sessionProtocol().isTls();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return servletContext.getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return serviceRequestContext.config().server().defaultHostname();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return serviceRequestContext.localAddress().toString();\n+    }\n+\n+    @Override\n+    public int getLocalPort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isAsyncStarted() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAsyncSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public AsyncContext getAsyncContext() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DispatcherType getDispatcherType() {\n+        return DispatcherType.REQUEST;\n+    }\n+\n+    @Override\n+    public String getPathTranslated() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getAuthType() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteUser() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isUserInRole(String role) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Principal getUserPrincipal() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void login(String username, String password) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void logout() throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Collection<Part> getParts() throws IOException, ServletException {\n+        return fileUploadList;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTE2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235160", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-12T06:40:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * The servlet request.\n+ */\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final List<Part> fileUploadList = new ArrayList<>();\n+    private final String servletPath;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    private final Map<String, String[]> parameters;\n+\n+    @Nullable\n+    private final Cookie[] cookies;\n+    @Nullable\n+    private final String pathInfo;\n+\n+    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n+                              DefaultServletContext servletContext,\n+                              AggregatedHttpRequest httpRequest) throws IOException {\n+        requireNonNull(serviceRequestContext, \"serviceRequestContext\");\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(httpRequest, \"request\");\n+\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+\n+        requestURI = serviceRequestContext.path();\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+        servletPath = servletContext.getServletPath(requestURI);\n+        pathInfo = decodePathInfo();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    /**\n+     * Parse {@link QueryParams} from {@link AggregatedHttpRequest}.\n+     */\n+    private static QueryParams queryParamsOf(@Nullable String query,\n+                                             @Nullable MediaType contentType,\n+                                             @Nullable AggregatedHttpRequest message) {\n+        try {\n+            final QueryParams params1 = query != null ? QueryParams.fromQueryString(query) : null;\n+            QueryParams params2 = null;\n+            if (message != null && contentType != null && contentType.belongsTo(MediaType.FORM_DATA)) {\n+                // Respect 'charset' attribute of the 'content-type' header if it exists.\n+                final String body = message.content(contentType.charset(StandardCharsets.US_ASCII));\n+                if (!body.isEmpty()) {\n+                    params2 = QueryParams.fromQueryString(body);\n+                }\n+            }\n+\n+            if (params1 == null || params1.isEmpty()) {\n+                return firstNonNull(params2, QueryParams.of());\n+            } else if (params2 == null || params2.isEmpty()) {\n+                return params1;\n+            } else {\n+                return QueryParams.builder()\n+                                  .sizeHint(params1.size() + params2.size())\n+                                  .add(params1)\n+                                  .add(params2)\n+                                  .build();\n+            }\n+        } catch (Exception e) {\n+            // If we failed to decode the query string, we ignore the exception raised here.\n+            // A missing parameter might be checked when invoking the annotated method.\n+            logger.debug(\"Failed to decode query string: {}\", query, e);\n+            return QueryParams.of();\n+        }\n+    }\n+\n+    /**\n+     * Get aggregated http request.\n+     */\n+    @VisibleForTesting\n+    AggregatedHttpRequest getHttpRequest() {\n+        return httpRequest;\n+    }\n+\n+    /**\n+     * Parse cookie.\n+     */\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parse path info.\n+     */\n+    @Nullable\n+    private String decodePathInfo() {\n+        final int index = getContextPath().length() + servletPath.length();\n+        return index < requestURI.length() ? requestURI.substring(index) : null;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        boolean error = false;\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(getHeader(name)).getTime();\n+            } catch (Exception e) {\n+                error = true;\n+            }\n+        }\n+        if (error) {\n+            logger.info(\"Can't parse \" + getHeader(name) + \" to date\");\n+        }\n+        return -1;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return Collections.enumeration(\n+                httpRequest.headers().getAll(name).stream().collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public int getIntHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String headerStringValue = getHeader(name);\n+        if (isNullOrEmpty(headerStringValue)) {\n+            return -1;\n+        }\n+        return Integer.parseInt(headerStringValue);\n+    }\n+\n+    @Override\n+    public String getMethod() {\n+        return httpRequest.method().toString();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return servletContext.getContextPath();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdValid() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE ||\n+               sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromCookie() {\n+        return sessionIdSource == SessionTrackingMode.COOKIE;\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromURL() {\n+        return isRequestedSessionIdFromUrl();\n+    }\n+\n+    @Override\n+    public boolean isRequestedSessionIdFromUrl() {\n+        return sessionIdSource == SessionTrackingMode.URL;\n+    }\n+\n+    @Override\n+    public String getRequestedSessionId() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        return characterEncoding;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String env) throws UnsupportedEncodingException {\n+        throw new IllegalStateException(\"Can't set character encoding after request is initialized\");\n+    }\n+\n+    @Override\n+    public int getContentLength() {\n+        return httpRequest.content().length();\n+    }\n+\n+    @Override\n+    public long getContentLengthLong() {\n+        return getContentLength();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        return contentType == null ? null : contentType.toString();\n+    }\n+\n+    @Override\n+    public ServletInputStream getInputStream() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return queryParams.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getParameterNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(queryParams.names()));\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String[] getParameterValues(String name) {\n+        requireNonNull(name, \"name\");\n+        if (queryParams.getAll(name).isEmpty()) {\n+            return null;\n+        }\n+        return queryParams.getAll(name).toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public Map<String, String[]> getParameterMap() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public String getProtocol() {\n+        return serviceRequestContext.sessionProtocol().uriText();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getScheme() {\n+        return httpRequest.scheme();\n+    }\n+\n+    @Override\n+    public String getServerName() {\n+        return serviceRequestContext.config().virtualHost().defaultHostname();\n+    }\n+\n+    @Override\n+    public int getServerPort() {\n+        return serviceRequestContext.config().server().activeLocalPort();\n+    }\n+\n+    @Override\n+    public BufferedReader getReader() throws IOException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteAddr() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getAddress().getHostAddress();\n+    }\n+\n+    @Override\n+    public String getRemoteHost() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getHostName();\n+    }\n+\n+    @Override\n+    public int getRemotePort() {\n+        return ((InetSocketAddress) serviceRequestContext.remoteAddress()).getPort();\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name, \"name\");\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public Locale getLocale() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Enumeration<Locale> getLocales() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isSecure() {\n+        return serviceRequestContext.sessionProtocol().isTls();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        return servletContext.getRequestDispatcher(path);\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getLocalName() {\n+        return serviceRequestContext.config().server().defaultHostname();\n+    }\n+\n+    @Override\n+    public String getLocalAddr() {\n+        return serviceRequestContext.localAddress().toString();\n+    }\n+\n+    @Override\n+    public int getLocalPort() {\n+        return getServerPort();\n+    }\n+\n+    @Override\n+    public DefaultServletContext getServletContext() {\n+        return servletContext;\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public AsyncContext startAsync(ServletRequest servletRequest, ServletResponse servletResponse) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isAsyncStarted() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAsyncSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public AsyncContext getAsyncContext() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public DispatcherType getDispatcherType() {\n+        return DispatcherType.REQUEST;\n+    }\n+\n+    @Override\n+    public String getPathTranslated() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getAuthType() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRemoteUser() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean isUserInRole(String role) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public boolean authenticate(HttpServletResponse response) throws IOException, ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Principal getUserPrincipal() {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void login(String username, String password) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void logout() throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public Collection<Part> getParts() throws IOException, ServletException {\n+        return fileUploadList;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Part getPart(String name) throws IOException, ServletException {\n+        requireNonNull(name, \"name\");\n+        return getParts().stream().filter(x -> name.equals(x.getName())).findAny().orElse(null);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 81%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 42ffbb32b0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -27,11 +27,9 @@ import java.nio.charset.StandardCharsets;\n import java.security.Principal;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n-import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNTU3Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439235576", "bodyText": "Could you add an empty line here so that private static final stands alone?", "author": "minwoox", "createdAt": "2020-06-12T06:41:34Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzc5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439237796", "bodyText": "I think the value can be negative. So we do not need this check.", "author": "minwoox", "createdAt": "2020-06-12T06:47:35Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzgzMQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439237831", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-06-12T06:47:40Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MDI2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439240262", "bodyText": "Shouldn't we check if getWriter() is called?", "author": "minwoox", "createdAt": "2020-06-12T06:54:32Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MDQzMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439240430", "bodyText": "Shouldn't we check if getOutputStream() is called?", "author": "minwoox", "createdAt": "2020-06-12T06:54:57Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NTg4NQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439245885", "bodyText": "Should return return servletContext.getResponseCharacterEncoding();", "author": "minwoox", "createdAt": "2020-06-12T07:09:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NzM2MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439247360", "bodyText": "throw new IllegalStateException(\"must set content type before setting a charset\")", "author": "minwoox", "createdAt": "2020-06-12T07:12:44Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.common.CookieBuilder;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.ResponseHeadersBuilder;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+import io.netty.util.AsciiString;\n+\n+/**\n+ * Servlet response.\n+ */\n+final class DefaultServletHttpResponse implements HttpServletResponse {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private final List<String> cookies = new ArrayList<>();\n+    private final DefaultServletOutputStream outputStream;\n+    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n+    private final PrintWriter writer;\n+    private final HttpResponseWriter responseWriter;\n+    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n+    private AtomicBoolean isWritten = new AtomicBoolean(false);\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n+        requireNonNull(servletContext, \"servletContext\");\n+        requireNonNull(responseWriter, \"responseWriter\");\n+        this.responseWriter = responseWriter;\n+        outputStream = new DefaultServletOutputStream(this);\n+        writer = new ServletPrintWriter(this, outputStream);\n+        headersBuilder.contentType(MediaType.HTML_UTF_8);\n+        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n+    }\n+\n+    /**\n+     * Get response writer.\n+     */\n+    HttpResponseWriter getResponseWriter() {\n+        return responseWriter;\n+    }\n+\n+    /**\n+     * Write data to response writer.\n+     */\n+    void flush() {\n+        if (isWritten.compareAndSet(false, true)) {\n+            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n+                                                      .status(HttpStatus.OK).build())) {\n+                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n+                    responseWriter.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write {@link HttpData} to client.\n+     */\n+    void write(byte[] data) {\n+        requireNonNull(data, \"data\");\n+        try {\n+            content.write(data);\n+        } catch (IOException e) {\n+            logger.error(\"Write data failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void addCookie(Cookie cookie) {\n+        requireNonNull(cookie, \"cookie\");\n+        final String path = cookie.getPath() == null ? \"/\" : cookie.getPath();\n+        final CookieBuilder builder =\n+                com.linecorp.armeria.common.Cookie.builder(cookie.getName(), cookie.getValue())\n+                                                  .path(path)\n+                                                  .httpOnly(\n+                                                          cookie.isHttpOnly())\n+                                                  .secure(cookie.getSecure());\n+        if (cookie.getMaxAge() != -1) {\n+            builder.maxAge(cookie.getMaxAge());\n+        }\n+        if (!isNullOrEmpty(cookie.getDomain())) {\n+            builder.domain(cookie.getDomain());\n+        }\n+        cookies.add(builder.build().toSetCookieHeader());\n+    }\n+\n+    @Override\n+    public boolean containsHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.contains(name);\n+    }\n+\n+    @Override\n+    public String encodeURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return url;\n+    }\n+\n+    @Override\n+    public String encodeRedirectURL(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeURL(url);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public String encodeRedirectUrl(String url) {\n+        requireNonNull(url, \"url\");\n+        return encodeRedirectURL(url);\n+    }\n+\n+    @Override\n+    public void sendError(int sc, @Nullable String msg) throws IOException {\n+        final ResponseHeaders headers = ResponseHeaders.builder(sc).contentType(MediaType.HTML_UTF_8).build();\n+        if (responseWriter.tryWrite(headers)) {\n+            if (msg != null) {\n+                if (!responseWriter.tryWrite(HttpData.ofUtf8(msg))) {\n+                    return;\n+                }\n+            }\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void sendError(int sc) throws IOException {\n+        sendError(sc, null);\n+    }\n+\n+    @Override\n+    public void sendRedirect(String location) throws IOException {\n+        requireNonNull(location, \"location\");\n+        if (responseWriter.tryWrite(\n+                ResponseHeaders.of(HttpStatus.FOUND, HttpHeaderNames.LOCATION, location))) {\n+            responseWriter.close();\n+        }\n+    }\n+\n+    @Override\n+    public void setDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.setLong(name, date);\n+    }\n+\n+    @Override\n+    public void addDateHeader(String name, long date) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(date > 0, \"date: %s (expected: > 0)\", date);\n+        headersBuilder.addLong(name, date);\n+    }\n+\n+    @Override\n+    public void setHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.set(name, value);\n+    }\n+\n+    @Override\n+    public void addHeader(String name, String value) {\n+        requireNonNull(name, \"name\");\n+        requireNonNull(value, \"value\");\n+        headersBuilder.add(name, value);\n+    }\n+\n+    @Override\n+    public void setIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.setInt(name, value);\n+    }\n+\n+    @Override\n+    public void addIntHeader(String name, int value) {\n+        requireNonNull(name, \"name\");\n+        checkArgument(value >= 0, \"value: %s (expected: >= 0)\", value);\n+        headersBuilder.addInt(name, value);\n+    }\n+\n+    @Override\n+    public void setContentType(String contentType) {\n+        requireNonNull(contentType, \"contentType\");\n+        headersBuilder.set(HttpHeaderNames.CONTENT_TYPE, contentType);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getContentType() {\n+        return getHeader(HttpHeaderNames.CONTENT_TYPE.toString());\n+    }\n+\n+    @Override\n+    public void setStatus(int sc) {\n+        headersBuilder.status(sc);\n+    }\n+\n+    @Override\n+    @Deprecated\n+    public void setStatus(int sc, @Nullable String sm) {\n+        if (sm == null) {\n+            headersBuilder.status(HttpStatus.valueOf(sc));\n+        } else {\n+            headersBuilder.status(new HttpStatus(sc, sm));\n+        }\n+    }\n+\n+    @Override\n+    public int getStatus() {\n+        return headersBuilder.status().code();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.get(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaders(String name) {\n+        requireNonNull(name, \"name\");\n+        return headersBuilder.getAll(name);\n+    }\n+\n+    @Override\n+    public Collection<String> getHeaderNames() {\n+        return headersBuilder.names().stream()\n+                             .map(AsciiString::toString).collect(ImmutableList.toImmutableList());\n+    }\n+\n+    @Override\n+    public String getCharacterEncoding() {\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null && mediaType.charset() != null) {\n+            return mediaType.charset().toString();\n+        }\n+        return ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    }\n+\n+    @Override\n+    public DefaultServletOutputStream getOutputStream() throws IOException {\n+        return outputStream;\n+    }\n+\n+    @Override\n+    public PrintWriter getWriter() throws IOException {\n+        return writer;\n+    }\n+\n+    @Override\n+    public void setCharacterEncoding(String charset) {\n+        requireNonNull(charset, \"charset\");\n+        final MediaType mediaType = headersBuilder.contentType();\n+        if (mediaType != null) {\n+            headersBuilder.contentType(mediaType.withCharset(Charset.forName(charset)));\n+        }", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nsimilarity index 72%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\nindex 7daeb86dc1..fc095b4d25 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpResponse.java\n\n@@ -28,85 +28,76 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.Locale;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.CompletableFuture;\n \n import javax.annotation.Nullable;\n import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletResponse;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n import com.google.common.collect.ImmutableList;\n \n import com.linecorp.armeria.common.CookieBuilder;\n import com.linecorp.armeria.common.HttpData;\n import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpResponseWriter;\n+import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.MediaType;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.ResponseHeadersBuilder;\n-import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n \n import io.netty.util.AsciiString;\n \n-/**\n- * Servlet response.\n- */\n final class DefaultServletHttpResponse implements HttpServletResponse {\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n-    private final List<String> cookies = new ArrayList<>();\n+\n+    private final DefaultServletContext servletContext;\n+    private final CompletableFuture<HttpResponse> resFuture;\n     private final DefaultServletOutputStream outputStream;\n-    private final ResponseHeadersBuilder headersBuilder = ResponseHeaders.builder();\n     private final PrintWriter writer;\n-    private final HttpResponseWriter responseWriter;\n-    private ByteArrayOutputStream content = new ByteArrayOutputStream();\n-    private AtomicBoolean isWritten = new AtomicBoolean(false);\n-\n-    DefaultServletHttpResponse(DefaultServletContext servletContext, HttpResponseWriter responseWriter) {\n-        requireNonNull(servletContext, \"servletContext\");\n-        requireNonNull(responseWriter, \"responseWriter\");\n-        this.responseWriter = responseWriter;\n+    private final ResponseHeadersBuilder headersBuilder;\n+\n+    private final List<String> setCookies = new ArrayList<>();\n+\n+    private final ByteArrayOutputStream content = new ByteArrayOutputStream();\n+\n+    private boolean usingOutputStream;\n+\n+    private boolean usingWriter;\n+\n+    DefaultServletHttpResponse(DefaultServletContext servletContext,\n+                               CompletableFuture<HttpResponse> resFuture) {\n+        this.servletContext = servletContext;\n+        this.resFuture = resFuture;\n         outputStream = new DefaultServletOutputStream(this);\n-        writer = new ServletPrintWriter(this, outputStream);\n-        headersBuilder.contentType(MediaType.HTML_UTF_8);\n-        setCharacterEncoding(servletContext.getResponseCharacterEncoding());\n-    }\n-\n-    /**\n-     * Get response writer.\n-     */\n-    HttpResponseWriter getResponseWriter() {\n-        return responseWriter;\n-    }\n-\n-    /**\n-     * Write data to response writer.\n-     */\n-    void flush() {\n-        if (isWritten.compareAndSet(false, true)) {\n-            if (responseWriter.tryWrite(headersBuilder.setObject(HttpHeaderNames.SET_COOKIE, cookies)\n-                                                      .status(HttpStatus.OK).build())) {\n-                if (responseWriter.tryWrite(HttpData.copyOf(content.toByteArray()))) {\n-                    responseWriter.close();\n-                }\n-            }\n-        }\n+        writer = new PrintWriter(outputStream);\n+        final MediaType contentType = MediaType.HTML_UTF_8.withCharset(\n+                Charset.forName(servletContext.getResponseCharacterEncoding()));\n+        headersBuilder = ResponseHeaders.builder(HttpStatus.OK).contentType(contentType);\n     }\n \n-    /**\n-     * Write {@link HttpData} to client.\n-     */\n-    void write(byte[] data) {\n-        requireNonNull(data, \"data\");\n-        try {\n-            content.write(data);\n-        } catch (IOException e) {\n-            logger.error(\"Write data failed\", e);\n+    boolean isReady() {\n+        return !resFuture.isDone();\n+    }\n+\n+    void close() {\n+        if (resFuture.isDone()) {\n+            return;\n+        }\n+\n+        if (!setCookies.isEmpty()) {\n+            headersBuilder.set(HttpHeaderNames.SET_COOKIE, setCookies);\n+        }\n+        if (content.size() == 0) {\n+            resFuture.complete(HttpResponse.of(\n+                    headersBuilder.removeAndThen(HttpHeaderNames.CONTENT_TYPE).build()));\n+        } else {\n+            resFuture.complete(HttpResponse.of(headersBuilder.build(), HttpData.wrap(content.toByteArray())));\n         }\n     }\n \n+    void write(byte[] data) throws IOException {\n+        content.write(data);\n+    }\n+\n     @Override\n     public void addCookie(Cookie cookie) {\n         requireNonNull(cookie, \"cookie\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439256120", "bodyText": "How about using ByteBufs and storing them in an array?\nSo that we can write when close() is called?\nprivate final List<ByteBuf> byteBufs = new ArrayList<>();\n\n...\n\n@Override\npublic void close() throws IOException {\n    if (!byteBufs.isEmpty()) {\n        response.getResponseWriter().write(\n                HttpData.wrap(Unpooled.wrappedBuffer(byteBufs.toArray(new ByteBuf[0]))));\n        byteBufs.clear();\n    }\n}\n\n@Override\npublic void write(int b) throws IOException {\n    byteBufs.add(Unpooled.copyInt(b));\n}\n\n@Override\npublic void write(byte[] b, int off, int len) throws IOException {\n    byteBufs.add(Unpooled.copiedBuffer(b, off, len));\n}\n\n@Override\npublic void write(byte[] b) throws IOException {\n    byteBufs.add(Unpooled.copiedBuffer(b));\n}\nAlso, I think we can just ignore flush() call because we do not support streaming response in servlet.", "author": "minwoox", "createdAt": "2020-06-12T07:33:47Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.WriteListener;\n+\n+/**\n+ * Servlets output streams (wrapper classes) that control access to the flow.\n+ */\n+final class DefaultServletOutputStream extends ServletOutputStream {\n+    private final DefaultServletHttpResponse response;\n+\n+    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public boolean isReady() {\n+        return response.getResponseWriter().isOpen();\n+    }\n+\n+    @Override\n+    public void setWriteListener(WriteListener listener) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        response.flush();\n+        response.getResponseWriter().close();\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        response.flush();\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+        final byte[] bytes = new byte[1];\n+        bytes[0] = (byte) b;\n+        write(bytes);", "originalCommit": "9bc785005f71847396060d5b461d0f552a374b08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzMTM2OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439331368", "bodyText": "I tried your solution but response always is failed with exception:\ncom.linecorp.armeria.common.stream.ClosedStreamException\n\tat com.linecorp.armeria.common.stream.ClosedStreamException.get(ClosedStreamException.java:37)\n\tat com.linecorp.armeria.common.stream.StreamWriter.write(StreamWriter.java:72)\n\tat com.linecorp.armeria.server.servlet.DefaultServletOutputStream.close(DefaultServletOutputStream.java:58)\n\tat com.linecorp.armeria.server.servlet.ServletServiceTest$HomeServlet.doDelete(ServletServiceTest.java:478)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:671)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:750)\n\tat com.linecorp.armeria.server.servlet.ServletFilterChain.doFilter(ServletFilterChain.java:61)\n\tat com.linecorp.armeria.server.servlet.ServletRequestDispatcher.dispatch(ServletRequestDispatcher.java:89)\n\tat com.linecorp.armeria.server.servlet.DefaultServletService.process(DefaultServletService.java:83)\n\tat com.linecorp.armeria.server.servlet.DefaultServletService.lambda$serve$0(DefaultServletService.java:67)\n\tat java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:930)\n\tat java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:907)\n\tat java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:478)\n\tat com.linecorp.armeria.common.RequestContext.lambda$makeContextAware$3(RequestContext.java:379)\n\tat com.linecorp.armeria.internal.common.metric.TimedRunnable.run(TimedRunnable.java:63)\n\tat java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)\n\tat java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)\n\tat java.base/java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:304)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.base/java.lang.Thread.run(Thread.java:835)\n\nPlease help me check this.", "author": "dominhhien", "createdAt": "2020-06-12T10:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0NTQ0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439345448", "bodyText": "I think use ByteArrayOutputStream is good as ByteBuf. Because both append bytes in memory very fast.", "author": "dominhhien", "createdAt": "2020-06-12T10:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg5MTgzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439891836", "bodyText": "I tried it in my local and it seems working well. \ud83e\udd14\nCould you paste your code or let me know what was the problem?", "author": "minwoox", "createdAt": "2020-06-15T01:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNTA4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439905082", "bodyText": "My code DefaultServletOutputStream.java :\nfinal class DefaultServletOutputStream extends ServletOutputStream {\n    private final DefaultServletHttpResponse response;\n    private final List<ByteBuf> byteBufs = new ArrayList<>();\n\n    DefaultServletOutputStream(DefaultServletHttpResponse response) {\n        requireNonNull(response, \"response\");\n        this.response = response;\n    }\n\n    @Override\n    public boolean isReady() {\n        return response.getResponseWriter().isOpen();\n    }\n\n    @Override\n    public void setWriteListener(WriteListener listener) {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!byteBufs.isEmpty()) {\n            response.getResponseWriter().write(\n                    HttpData.wrap(Unpooled.wrappedBuffer(byteBufs.toArray(new ByteBuf[0]))));\n            byteBufs.clear();\n        }\n    }\n\n    @Override\n    public void flush() throws IOException {\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        byteBufs.add(Unpooled.copyInt(b));\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        requireNonNull(b, \"b\");\n        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n        byteBufs.add(Unpooled.copiedBuffer(b, off, len));\n    }\n\n    @Override\n    public void write(byte[] b) throws IOException {\n        requireNonNull(b, \"b\");\n        byteBufs.add(Unpooled.copiedBuffer(b));\n    }\n}\nServletServiceTest was failed at doDelete().", "author": "dominhhien", "createdAt": "2020-06-15T02:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNjEzNQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439906135", "bodyText": "I think doDelete() does not use DefaultServletOutputStream because it just calls response.sendError(HttpStatus.NOT_FOUND.code(), \"Not Found\"); right away. Did I miss something?", "author": "minwoox", "createdAt": "2020-06-15T02:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzE0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439907142", "bodyText": "No, do you check doDelete() at inner class: ServletServiceTest.HomeServlet (ServletServiceTest.java line 477)", "author": "dominhhien", "createdAt": "2020-06-15T02:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkxMzgyMg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439913822", "bodyText": "Ah there's another HomeServlet in the class. Sorry about that I missed. (Perhaps we should rename it to something else to avoid confusion.)\nThe reason that it didn't work is that it tries to write the data first without writing headers. So I think we should fix that.\nIf we use ByteArrayOutputStream, we have to copy the byte array twice.\nBut if we use ByteBuf we can just copy the data only once. If we change to use the ByteBufAllocator from ServiceRequestContext later, we can even reduce to allocate additional byte arrays.\nSo I think it's better to use ByteBufs to hold the data. What do you think?", "author": "minwoox", "createdAt": "2020-06-15T03:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMDkyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439920924", "bodyText": "The implementation will be a little tricky so just leave it as it is and fix it later. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-06-15T04:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NjEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nsimilarity index 76%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\nindex 4adcc7417c..ab9818c9f7 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletOutputStream.java\n\n@@ -24,36 +24,27 @@ import java.util.Arrays;\n import javax.servlet.ServletOutputStream;\n import javax.servlet.WriteListener;\n \n-/**\n- * Servlets output streams (wrapper classes) that control access to the flow.\n- */\n final class DefaultServletOutputStream extends ServletOutputStream {\n+\n     private final DefaultServletHttpResponse response;\n \n     DefaultServletOutputStream(DefaultServletHttpResponse response) {\n-        requireNonNull(response, \"response\");\n         this.response = response;\n     }\n \n     @Override\n     public boolean isReady() {\n-        return response.getResponseWriter().isOpen();\n+        return response.isReady();\n     }\n \n     @Override\n     public void setWriteListener(WriteListener listener) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public void close() throws IOException {\n-        response.flush();\n-        response.getResponseWriter().close();\n-    }\n-\n-    @Override\n-    public void flush() throws IOException {\n-        response.flush();\n+        response.close();\n     }\n \n     @Override\n"}}, {"oid": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "url": "https://github.com/line/armeria/commit/06c030125256d45391f5c6cbaf4020a12ea0b9ac", "message": "Check use output stream or writer", "committedDate": "2020-06-12T10:50:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMTQ1Nw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439921457", "bodyText": "Is there any reason that you overridden methods in this class?\nIt seems like we can just use the methods in PrintWriter?", "author": "minwoox", "createdAt": "2020-06-15T04:11:42Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.util.Formatter;\n+import java.util.Locale;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ *  Printing flow.\n+ */\n+final class ServletPrintWriter extends PrintWriter {\n+    private final String lineSeparator = System.lineSeparator();\n+    private final DefaultServletHttpResponse response;\n+\n+    private boolean error;\n+\n+    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n+        super(out);\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+    }\n+\n+    @Override\n+    public void flush() {\n+    }\n+\n+    @Override\n+    public void close() {\n+        response.close();\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+        return error;\n+    }\n+\n+    @Override\n+    protected void setError() {\n+        error = true;\n+    }\n+\n+    @Override\n+    protected void clearError() {\n+        error = false;\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        write(String.valueOf(c));\n+    }\n+\n+    @Override\n+    public void write(char[] buf, int off, int len) {", "originalCommit": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyNjk2MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439926961", "bodyText": "Method PrintWriter.write() may be call to OutputStream.write(). I will check all write methods If there is any method that doesn't need to override, i will remove code.", "author": "dominhhien", "createdAt": "2020-06-15T04:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyMTQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java\ndeleted file mode 100755\nindex 20f74bbf4e..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletPrintWriter.java\n+++ /dev/null\n\n@@ -1,266 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.util.Formatter;\n-import java.util.Locale;\n-\n-import javax.annotation.Nullable;\n-\n-/**\n- *  Printing flow.\n- */\n-final class ServletPrintWriter extends PrintWriter {\n-    private final String lineSeparator = System.lineSeparator();\n-    private final DefaultServletHttpResponse response;\n-\n-    private boolean error;\n-\n-    ServletPrintWriter(DefaultServletHttpResponse response, OutputStream out) {\n-        super(out);\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-    }\n-\n-    @Override\n-    public void flush() {\n-    }\n-\n-    @Override\n-    public void close() {\n-        response.close();\n-    }\n-\n-    @Override\n-    public boolean checkError() {\n-        return error;\n-    }\n-\n-    @Override\n-    protected void setError() {\n-        error = true;\n-    }\n-\n-    @Override\n-    protected void clearError() {\n-        error = false;\n-    }\n-\n-    @Override\n-    public void write(int c) {\n-        write(String.valueOf(c));\n-    }\n-\n-    @Override\n-    public void write(char[] buf, int off, int len) {\n-        requireNonNull(buf, \"buf\");\n-        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n-        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n-        write(String.valueOf(buf, off, len));\n-    }\n-\n-    @Override\n-    public void write(char[] buf) {\n-        requireNonNull(buf, \"buf\");\n-        write(String.valueOf(buf));\n-    }\n-\n-    @Override\n-    public void write(String s, int off, int len) {\n-        requireNonNull(s, \"s\");\n-        checkArgument(off >= 0, \"off: %s (expected: >= 0)\", off);\n-        checkArgument(len >= 0, \"len: %s (expected: >= 0)\", len);\n-        final String writeStr;\n-        if (off == 0 && s.length() == len) {\n-            writeStr = s;\n-        } else {\n-            writeStr = s.substring(off, off + len);\n-        }\n-        response.write(writeStr.getBytes());\n-    }\n-\n-    @Override\n-    public void write(String s) {\n-        requireNonNull(s, \"s\");\n-        write(s, 0, s.length());\n-    }\n-\n-    @Override\n-    public void print(boolean b) {\n-        write(b ? \"true\" : \"false\");\n-    }\n-\n-    @Override\n-    public void print(char c) {\n-        write(String.valueOf(c));\n-    }\n-\n-    @Override\n-    public void print(int i) {\n-        write(String.valueOf(i));\n-    }\n-\n-    @Override\n-    public void print(long l) {\n-        write(String.valueOf(l));\n-    }\n-\n-    @Override\n-    public void print(float f) {\n-        write(String.valueOf(f));\n-    }\n-\n-    @Override\n-    public void print(double d) {\n-        write(String.valueOf(d));\n-    }\n-\n-    @Override\n-    public void print(char[] s) {\n-        write(s);\n-    }\n-\n-    @Override\n-    public void print(String s) {\n-        requireNonNull(s, \"s\");\n-        write(s);\n-    }\n-\n-    @Override\n-    public void print(Object obj) {\n-        requireNonNull(obj, \"obj\");\n-        write(String.valueOf(obj));\n-    }\n-\n-    @Override\n-    public void println() {\n-        write(lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(boolean b) {\n-        write((b ? \"true\" : \"false\") + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(char x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(int x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(long x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(float x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(double x) {\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(char[] x) {\n-        write(String.valueOf(x) + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(String x) {\n-        requireNonNull(x, \"x\");\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public void println(Object x) {\n-        requireNonNull(x, \"x\");\n-        write(x + lineSeparator);\n-    }\n-\n-    @Override\n-    public PrintWriter printf(String format, Object... args) {\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(Locale.getDefault(), format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter printf(Locale l, String format, Object... args) {\n-        requireNonNull(l, \"l\");\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(l, format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter format(String format, Object... args) {\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        format(Locale.getDefault(), format, args);\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter format(Locale l, String format, Object... args) {\n-        requireNonNull(l, \"l\");\n-        requireNonNull(format, \"format\");\n-        requireNonNull(args, \"args\");\n-        final StringBuilder sb = new StringBuilder();\n-        final Formatter formatter = new Formatter(sb, l);\n-        formatter.format(l, format, args);\n-        write(sb.toString());\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(@Nullable CharSequence csq) {\n-        if (csq == null) {\n-            write(\"null\");\n-        } else {\n-            write(csq.toString());\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(@Nullable CharSequence csq, int start, int end) {\n-        checkArgument(start >= 0, \"start: %s (expected: >= 0)\", start);\n-        checkArgument(end >= 0, \"end: %s (expected: >= 0)\", end);\n-        final CharSequence cs = csq == null ? \"null\" : csq;\n-        write(cs.subSequence(start, end).toString());\n-        return this;\n-    }\n-\n-    @Override\n-    public PrintWriter append(char c) {\n-        write(c);\n-        return this;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439973707", "bodyText": "The allToken is always * so we do not want to specify it.\nThe class StringUtil is a bit complex because it's for ANT mapping. How about just using Pattern for simplicity?\nWe can just consider three cases:\n\nThe path that ends with *. (e.g /foo/bar/*)\nImplicit mapping. (e.g *.bop)\nExact path matching.\n\nWe might revisit this to optimize later though.", "author": "minwoox", "createdAt": "2020-06-15T07:16:52Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Url mapping\n+ * Mapping specification\n+ * In the web application deployment descriptor.\n+ */\n+final class UrlMapper<T> {\n+    private final boolean singlePattern;\n+    private final List<Element<T>> elementList = new ArrayList<>();\n+    private final StringUtil stringUtil = new StringUtil();\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    UrlMapper(boolean singlePattern) {\n+        this.singlePattern = singlePattern;\n+    }\n+\n+    /**\n+     * Add mapping.\n+     */\n+    void addMapping(String urlPattern, T object, String objectName) {\n+        requireNonNull(urlPattern, \"urlPattern\");\n+        requireNonNull(object, \"object\");\n+        requireNonNull(objectName, \"objectName\");\n+        if (elementList.stream()\n+                       .filter(x -> singlePattern && x.name.equals(objectName))\n+                       .findAny().orElse(null) != null) {\n+            throw new IllegalArgumentException(\"The [\" + objectName + \"] mapping exist!\");\n+        }\n+\n+        final Element element = elementList.stream()\n+                                           .filter(x -> x.pattern.equals(urlPattern))\n+                                           .findFirst().orElse(null);\n+        if (element != null) {\n+            element.name = objectName;\n+            element.object = object;\n+        } else {\n+            elementList.add(new Element<>(urlPattern, object, objectName));\n+        }\n+    }\n+\n+    /**\n+     * Gets a mapping object.\n+     */\n+    @Nullable\n+    Element<T> getMapping(String absoluteUri) {\n+        requireNonNull(absoluteUri, \"absoluteUri\");\n+        return elementList.stream()\n+                          .filter(x -> stringUtil.match(x.pattern, absoluteUri, \"*\"))", "originalCommit": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3OTA1NA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439979054", "bodyText": "Yes, I think so. We will revisit this to optimize later.", "author": "dominhhien", "createdAt": "2020-06-15T07:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk4Mzc0Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439983742", "bodyText": "What I meant is that I think we need to remove the StringUtil class and just use Pattern in this PR. And then We revisit this to optimize it. \ud83d\ude06", "author": "minwoox", "createdAt": "2020-06-15T07:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NzQwNw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439997407", "bodyText": "Oh, I understand now :D. I will remove StringUtil.", "author": "dominhhien", "createdAt": "2020-06-15T08:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3MzcwNw=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java\ndeleted file mode 100644\nindex ca5d501650..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java\n+++ /dev/null\n\n@@ -1,131 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Strings.isNullOrEmpty;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.StringJoiner;\n-\n-import javax.annotation.Nullable;\n-\n-/**\n- * Url mapping\n- * Mapping specification\n- * In the web application deployment descriptor.\n- */\n-final class UrlMapper<T> {\n-    private final boolean singlePattern;\n-    private final List<Element<T>> elementList = new ArrayList<>();\n-    private final StringUtil stringUtil = new StringUtil();\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    UrlMapper(boolean singlePattern) {\n-        this.singlePattern = singlePattern;\n-    }\n-\n-    /**\n-     * Add mapping.\n-     */\n-    void addMapping(String urlPattern, T object, String objectName) {\n-        requireNonNull(urlPattern, \"urlPattern\");\n-        requireNonNull(object, \"object\");\n-        requireNonNull(objectName, \"objectName\");\n-        if (elementList.stream()\n-                       .filter(x -> singlePattern && x.name.equals(objectName))\n-                       .findAny().orElse(null) != null) {\n-            throw new IllegalArgumentException(\"The [\" + objectName + \"] mapping exist!\");\n-        }\n-\n-        final Element element = elementList.stream()\n-                                           .filter(x -> x.pattern.equals(urlPattern))\n-                                           .findFirst().orElse(null);\n-        if (element != null) {\n-            element.name = objectName;\n-            element.object = object;\n-        } else {\n-            elementList.add(new Element<>(urlPattern, object, objectName));\n-        }\n-    }\n-\n-    /**\n-     * Gets a mapping object.\n-     */\n-    @Nullable\n-    Element<T> getMapping(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return elementList.stream()\n-                          .filter(x -> stringUtil.match(x.pattern, absoluteUri, \"*\"))\n-                          .findAny()\n-                          .orElse(\n-                                  elementList.stream()\n-                                             .filter(s -> !\"default\".equals(s.name) &&\n-                                                          !isNullOrEmpty(s.name) &&\n-                                                          ('*' == s.pattern.charAt(0) ||\n-                                                           \"/*\".equals(s.pattern) ||\n-                                                           \"/**\".equals(s.pattern)))\n-                                             .findAny()\n-                                             .orElse(\n-                                                     elementList.stream()\n-                                                                .filter(a -> \"default\".equals(a.name))\n-                                                                .findAny()\n-                                                                .orElse(null)\n-                                             )\n-                          );\n-    }\n-\n-    /**\n-     * Class element.\n-     */\n-    static class Element<T> {\n-        String pattern;\n-        T object;\n-        String name;\n-        String path;\n-\n-        Element(String pattern, T object, String name) {\n-            requireNonNull(name, \"objectName\");\n-            requireNonNull(object, \"object\");\n-            this.pattern = pattern;\n-            this.object = object;\n-            this.name = name;\n-            final StringJoiner joiner = new StringJoiner(\"/\");\n-            final String[] pattens = pattern.split(\"/\");\n-            for (int i = 0; i < pattens.length; i++) {\n-                final String path = pattens[i];\n-                if (path.contains(\"*\")) {\n-                    if (i == pattens.length - 1) {\n-                        continue;\n-                    }\n-                }\n-                joiner.add(path);\n-            }\n-            path = joiner.toString();\n-        }\n-\n-        /**\n-         * Get object.\n-         */\n-        T getObject() {\n-            return object;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r439976282", "bodyText": "We should not expose this setter because MimeMappings is a package-private class.\nHow about adding a method for adding mime mapping in this class:\npublic void addMimeMapping(String extension, String mimeType) {\n    ...\n}", "author": "minwoox", "createdAt": "2020-06-15T07:22:20Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.http.HttpServlet;\n+\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.server.ServerBuilder;\n+\n+/**\n+ * A builder class which creates a new {@link DefaultServletContext} instance.\n+ */\n+public class ServletBuilder {\n+    private final DefaultServletContext servletContext;\n+    private final ServerBuilder serverBuilder;\n+    private final String contextPath;\n+\n+    private boolean rootServletAdded;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder) {\n+        this(serverBuilder, \"\");\n+    }\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n+        requireNonNull(serverBuilder, \"serverBuilder\");\n+        requireNonNull(contextPath, \"contextPath\");\n+        if (!contextPath.isEmpty()) {\n+            checkArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n+                          \"contextPath must start with / and must not end with /. contextPath: %s\",\n+                          contextPath);\n+        }\n+        servletContext = new DefaultServletContext(contextPath);\n+        this.contextPath = contextPath;\n+        this.serverBuilder = serverBuilder;\n+    }\n+\n+    /**\n+     * Creates a new {@link ServerBuilder}.\n+     */\n+    public ServerBuilder build() {\n+        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n+        final DefaultServletService servletService = new DefaultServletService(servletContext);\n+        serverBuilder.serviceUnder(path, servletService);\n+        if (rootServletAdded) {\n+            serverBuilder.service(path, servletService);\n+        } else {\n+            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n+        }\n+        servletContext.init();\n+        return serverBuilder;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(httpServlet, \"httpServlet\");\n+        validatePath(path);\n+        servletContext.addServlet(contextPath + path, httpServlet);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a servlet.\n+     */\n+    public ServletBuilder servlet(String path, String servletClass) {\n+        requireNonNull(path, \"path\");\n+        requireNonNull(servletClass, \"servletClass\");\n+        validatePath(path);\n+        servletContext.addServlet(contextPath + path, servletClass);\n+        return this;\n+    }\n+\n+    /**\n+     * Validate servlet path.\n+     */\n+    public void validatePath(String path) {\n+        if (path.isEmpty() || \"/\".equals(path)) {\n+            rootServletAdded = true;\n+        } else {\n+            checkArgument(path.charAt(0) == '/',\n+                          \"servletPath must start with /. servletPath: %s\",\n+                          path);\n+        }\n+    }\n+\n+    /**\n+     * Set attribute value.\n+     */\n+    public ServletBuilder attribute(String key, @Nullable Object value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setAttribute(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Set init parameter.\n+     */\n+    public ServletBuilder initParameter(String key, @Nullable String value) {\n+        requireNonNull(key, \"key\");\n+        servletContext.setInitParameter(key, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Add a new mime mapping.\n+     */\n+    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {", "originalCommit": "06c030125256d45391f5c6cbaf4020a12ea0b9ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4OTgzNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r440089836", "bodyText": "But I think MimeMapping usually add a large extensions list (thousand of extensions). Therefore I want to separate another methods to add extension mapping instead of use ServletBuilder. What do you think?", "author": "dominhhien", "createdAt": "2020-06-15T10:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyMTE4Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r440521182", "bodyText": "Then we can add\naddMimeMappings(Map<String, String> mappings) {...}\nWhat do you think:", "author": "minwoox", "createdAt": "2020-06-16T00:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk3NjI4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\ndeleted file mode 100755\nindex 380f8c6f9f..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/ServletBuilder.java\n+++ /dev/null\n\n@@ -1,156 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.server.servlet;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-import javax.servlet.http.HttpServlet;\n-\n-import com.linecorp.armeria.common.HttpResponse;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.server.ServerBuilder;\n-\n-/**\n- * A builder class which creates a new {@link DefaultServletContext} instance.\n- */\n-public class ServletBuilder {\n-    private final DefaultServletContext servletContext;\n-    private final ServerBuilder serverBuilder;\n-    private final String contextPath;\n-\n-    private boolean rootServletAdded;\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder) {\n-        this(serverBuilder, \"\");\n-    }\n-\n-    /**\n-     * Creates a new instance.\n-     */\n-    public ServletBuilder(ServerBuilder serverBuilder, String contextPath) {\n-        requireNonNull(serverBuilder, \"serverBuilder\");\n-        requireNonNull(contextPath, \"contextPath\");\n-        if (!contextPath.isEmpty()) {\n-            checkArgument(contextPath.charAt(0) == '/' && contextPath.charAt(contextPath.length() - 1) != '/',\n-                          \"contextPath must start with / and must not end with /. contextPath: %s\",\n-                          contextPath);\n-        }\n-        servletContext = new DefaultServletContext(contextPath);\n-        this.contextPath = contextPath;\n-        this.serverBuilder = serverBuilder;\n-    }\n-\n-    /**\n-     * Creates a new {@link ServerBuilder}.\n-     */\n-    public ServerBuilder build() {\n-        final String path = contextPath.isEmpty() ? \"/\" : contextPath;\n-        final DefaultServletService servletService = new DefaultServletService(servletContext);\n-        serverBuilder.serviceUnder(path, servletService);\n-        if (rootServletAdded) {\n-            serverBuilder.service(path, servletService);\n-        } else {\n-            serverBuilder.service(path, (ctx, req) -> HttpResponse.of(HttpStatus.NOT_FOUND));\n-        }\n-        servletContext.init();\n-        return serverBuilder;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, HttpServlet httpServlet) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(httpServlet, \"httpServlet\");\n-        validatePath(path);\n-        servletContext.addServlet(contextPath + path, httpServlet);\n-        return this;\n-    }\n-\n-    /**\n-     * Add a servlet.\n-     */\n-    public ServletBuilder servlet(String path, String servletClass) {\n-        requireNonNull(path, \"path\");\n-        requireNonNull(servletClass, \"servletClass\");\n-        validatePath(path);\n-        servletContext.addServlet(contextPath + path, servletClass);\n-        return this;\n-    }\n-\n-    /**\n-     * Validate servlet path.\n-     */\n-    public void validatePath(String path) {\n-        if (path.isEmpty() || \"/\".equals(path)) {\n-            rootServletAdded = true;\n-        } else {\n-            checkArgument(path.charAt(0) == '/',\n-                          \"servletPath must start with /. servletPath: %s\",\n-                          path);\n-        }\n-    }\n-\n-    /**\n-     * Set attribute value.\n-     */\n-    public ServletBuilder attribute(String key, @Nullable Object value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setAttribute(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Set init parameter.\n-     */\n-    public ServletBuilder initParameter(String key, @Nullable String value) {\n-        requireNonNull(key, \"key\");\n-        servletContext.setInitParameter(key, value);\n-        return this;\n-    }\n-\n-    /**\n-     * Add a new mime mapping.\n-     */\n-    public ServletBuilder mimeMapping(MimeMappings mimeMappings) {\n-        requireNonNull(mimeMappings, \"mimeMappings\");\n-        servletContext.setMimeMapping(mimeMappings);\n-        return this;\n-    }\n-\n-    /**\n-     * Set request character encoding.\n-     */\n-    public ServletBuilder requestEncoding(String requestEncoding) {\n-        requireNonNull(requestEncoding, \"requestEncoding\");\n-        servletContext.setRequestCharacterEncoding(requestEncoding);\n-        return this;\n-    }\n-\n-    /**\n-     * Set response character encoding.\n-     */\n-    public ServletBuilder responseEncoding(String responseEncoding) {\n-        requireNonNull(responseEncoding, \"responseEncoding\");\n-        servletContext.setResponseCharacterEncoding(responseEncoding);\n-        return this;\n-    }\n-}\n"}}, {"oid": "bbfb666e1e951343b807c5aeb8bb8ac4ea86cc90", "url": "https://github.com/line/armeria/commit/bbfb666e1e951343b807c5aeb8bb8ac4ea86cc90", "message": "Remove StringUtil and ServletPrintWriter", "committedDate": "2020-06-15T11:09:27Z", "type": "commit"}, {"oid": "323f468dd12536b300d87e38f9beb5fae4f1c63f", "url": "https://github.com/line/armeria/commit/323f468dd12536b300d87e38f9beb5fae4f1c63f", "message": "Change setMimeMapping parameter type", "committedDate": "2020-06-16T05:06:12Z", "type": "commit"}, {"oid": "a098372f4657d629ac03734e205fb507b6736adb", "url": "https://github.com/line/armeria/commit/a098372f4657d629ac03734e205fb507b6736adb", "message": "Merge branch 'master' into pr-2686.20200619103717", "committedDate": "2020-06-19T01:37:26Z", "type": "commit"}, {"oid": "5823076cb36a800794484e4077e02b26c0da36e5", "url": "https://github.com/line/armeria/commit/5823076cb36a800794484e4077e02b26c0da36e5", "message": "Remove mimeMapping class", "committedDate": "2020-06-19T01:56:51Z", "type": "commit"}, {"oid": "82799785f19432ecafe9b04670987afc618ff70c", "url": "https://github.com/line/armeria/commit/82799785f19432ecafe9b04670987afc618ff70c", "message": "Remove DefaultFilterRegistration", "committedDate": "2020-06-19T02:26:07Z", "type": "commit"}, {"oid": "31c425d2478dd365ec98ebde765110aa7f25bdb3", "url": "https://github.com/line/armeria/commit/31c425d2478dd365ec98ebde765110aa7f25bdb3", "message": "Remove useless javadoc", "committedDate": "2020-06-19T02:30:35Z", "type": "commit"}, {"oid": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "url": "https://github.com/line/armeria/commit/4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "message": "Fix to use CompletableFuture", "committedDate": "2020-06-19T03:30:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r442617409", "bodyText": "@dominhhien What is singlePattern? Could you explain please?", "author": "minwoox", "createdAt": "2020-06-19T03:54:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server.servlet;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nullable;\n+\n+final class UrlMapper<T> {\n+    private final boolean singlePattern;\n+    private final List<Element<T>> elementList = new ArrayList<>();\n+\n+    UrlMapper(boolean singlePattern) {\n+        this.singlePattern = singlePattern;\n+    }\n+\n+    void addMapping(String urlPattern, T object, String objectName) {\n+        requireNonNull(urlPattern, \"urlPattern\");\n+        requireNonNull(object, \"object\");\n+        requireNonNull(objectName, \"objectName\");\n+        if (elementList.stream()\n+                       .filter(x -> singlePattern && x.name.equals(objectName))", "originalCommit": "4bf310f36ab1ff451a9cb0b3c6e19362a1c4a476", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxOTcyOQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r442619729", "bodyText": "If singlePattern = true, we couldn't override mapping (ServletRegistration).\nIf singlePattern = false, we could override mapping (FilterRegistration).\nRefer DefaultServletContext.java\n    private final UrlMapper<DefaultServletRegistration> servletUrlMapper = new UrlMapper<>(true);\n    private final UrlMapper<DefaultFilterRegistration> filterUrlMapper = new UrlMapper<>(false);", "author": "dominhhien", "createdAt": "2020-06-19T04:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1NDU2Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r442654562", "bodyText": "Let me just remove it for now because it's always true. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-06-19T06:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java b/servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java\ndeleted file mode 100644\nindex 17d3c5be6b..0000000000\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/UrlMapper.java\n+++ /dev/null\n\n@@ -1,115 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.server.servlet;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.StringJoiner;\n-import java.util.regex.Pattern;\n-\n-import javax.annotation.Nullable;\n-\n-final class UrlMapper<T> {\n-    private final boolean singlePattern;\n-    private final List<Element<T>> elementList = new ArrayList<>();\n-\n-    UrlMapper(boolean singlePattern) {\n-        this.singlePattern = singlePattern;\n-    }\n-\n-    void addMapping(String urlPattern, T object, String objectName) {\n-        requireNonNull(urlPattern, \"urlPattern\");\n-        requireNonNull(object, \"object\");\n-        requireNonNull(objectName, \"objectName\");\n-        if (elementList.stream()\n-                       .filter(x -> singlePattern && x.name.equals(objectName))\n-                       .findAny().orElse(null) != null) {\n-            throw new IllegalArgumentException(\"The [\" + objectName + \"] mapping exist!\");\n-        }\n-\n-        final Element element = elementList.stream()\n-                                           .filter(x -> x.pattern.equals(urlPattern))\n-                                           .findFirst().orElse(null);\n-        if (element != null) {\n-            element.name = objectName;\n-            element.object = object;\n-        } else {\n-            elementList.add(new Element<>(urlPattern, object, objectName));\n-        }\n-    }\n-\n-    @Nullable\n-    Element<T> getMapping(String absoluteUri) {\n-        requireNonNull(absoluteUri, \"absoluteUri\");\n-        return elementList\n-                .stream()\n-                .filter(x -> absoluteUri.equals(x.pattern)) // Match exact path: /home\n-                .findAny()\n-                .orElse(\n-                        // Match contain *: /home/*.html\n-                        elementList\n-                                .stream()\n-                                .filter(s -> s.pattern.contains(\"*\") &&\n-                                             Pattern.compile(s.pattern.replace(\".\", \"\\\\.\")\n-                                                                      .replace(\"*\", \".*\"))\n-                                                    .matcher(absoluteUri)\n-                                                    .find())\n-                                .findAny()\n-                                .orElse(null));\n-    }\n-\n-    static class Element<T> {\n-        String pattern;\n-        T object;\n-        String name;\n-        String path;\n-\n-        Element(String pattern, T object, String name) {\n-            requireNonNull(name, \"objectName\");\n-            requireNonNull(object, \"object\");\n-            this.pattern = pattern;\n-            this.object = object;\n-            this.name = name;\n-            final StringJoiner joiner = new StringJoiner(\"/\");\n-            final String[] pattens = pattern.split(\"/\");\n-            for (int i = 0; i < pattens.length; i++) {\n-                final String path = pattens[i];\n-                if (path.contains(\"*\")) {\n-                    if (i == pattens.length - 1) {\n-                        continue;\n-                    }\n-                }\n-                joiner.add(path);\n-            }\n-            path = joiner.toString();\n-        }\n-\n-        T getObject() {\n-            return object;\n-        }\n-    }\n-\n-    static String normalizePath(String path) {\n-        requireNonNull(path, \"path\");\n-        if (!path.isEmpty() && path.charAt(path.length() - 1) == '/') {\n-            path = path.substring(0, path.length() - 1);\n-        }\n-        return path.trim();\n-    }\n-}\n"}}, {"oid": "bf555513f7660a9439bda08539b4c286b67be545", "url": "https://github.com/line/armeria/commit/bf555513f7660a9439bda08539b4c286b67be545", "message": "Various fixes", "committedDate": "2020-06-22T09:20:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjEyNA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r443486124", "bodyText": "I think we should throw UnsupportedOperationException here. Let me fix this.", "author": "dominhhien", "createdAt": "2020-06-22T11:14:03Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final DefaultServletRegistration registration = servletUrlMapper.getMapping(path);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(registration), registration.getName());\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return null;", "originalCommit": "bf555513f7660a9439bda08539b4c286b67be545", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 83%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 1572c0c906..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -65,7 +65,7 @@ final class DefaultServletContext implements ServletContext {\n     private final String contextPath;\n     private final String servletContextName;\n \n-    private int sessionTimeout = 30; // unit: minutes\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n     private boolean initialized;\n     private Map<String, String> initParamMap = new HashMap<>();\n     private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjQ0OA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r443486448", "bodyText": "I think we should throw UnsupportedOperationException here. Let me fix this.", "author": "dominhhien", "createdAt": "2020-06-22T11:14:43Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,534 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeout = 30; // unit: minutes\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeout;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final DefaultServletRegistration registration = servletUrlMapper.getMapping(path);\n+        if (registration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(registration), registration.getName());\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        requireNonNull(name, \"name\");\n+        final DefaultServletRegistration servletRegistration = getServletRegistration(name);\n+        if (servletRegistration == null) {\n+            return null;\n+        }\n+        return new ServletRequestDispatcher(new ServletFilterChain(servletRegistration), name);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        requireNonNull(filterName, \"filterName\");\n+        return null;\n+    }\n+\n+    @Override\n+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {\n+        return ImmutableMap.of();\n+    }", "originalCommit": "bf555513f7660a9439bda08539b4c286b67be545", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 83%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 1572c0c906..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -65,7 +65,7 @@ final class DefaultServletContext implements ServletContext {\n     private final String contextPath;\n     private final String servletContextName;\n \n-    private int sessionTimeout = 30; // unit: minutes\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n     private boolean initialized;\n     private Map<String, String> initParamMap = new HashMap<>();\n     private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5MDc1MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r443490751", "bodyText": "I think\nrequestURI.substring(servletContext.getContextPath().length() + 1) = servletPath + pathInfo\n=> servletPath != requestURI.substring(servletContext.getContextPath().length() + 1)\nLet me fix this.", "author": "dominhhien", "createdAt": "2020-06-22T11:23:58Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -111,7 +107,7 @@\n         requestURI = serviceRequestContext.path();\n         queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n         cookies = decodeCookie();\n-        servletPath = servletContext.getServletPath(requestURI);\n+        servletPath = requestURI.substring(servletContext.getContextPath().length() + 1);", "originalCommit": "bf555513f7660a9439bda08539b4c286b67be545", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nsimilarity index 87%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\nindex 0c681c20c0..cbe323228d 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java\n\n@@ -75,40 +75,41 @@ final class DefaultServletHttpRequest implements HttpServletRequest {\n             new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n     };\n \n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n     private final ServiceRequestContext serviceRequestContext;\n     private final DefaultServletContext servletContext;\n     private final AggregatedHttpRequest httpRequest;\n-    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n-    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n     private final String servletPath;\n+    @Nullable\n+    private final String pathInfo;\n     private final String requestURI;\n     private final String characterEncoding;\n     private final QueryParams queryParams;\n-    private final Map<String, String[]> parameters;\n-\n     @Nullable\n     private final Cookie[] cookies;\n-    @Nullable\n-    private final String pathInfo;\n+    private final Map<String, String[]> parameters;\n \n-    DefaultServletHttpRequest(ServiceRequestContext serviceRequestContext,\n-                              DefaultServletContext servletContext,\n-                              AggregatedHttpRequest httpRequest) throws IOException {\n+    DefaultServletHttpRequest(DefaultServletContext servletContext,\n+                              ServiceRequestContext serviceRequestContext,\n+                              AggregatedHttpRequest httpRequest,\n+                              String servletPath,\n+                              @Nullable String pathInfo) {\n         this.serviceRequestContext = serviceRequestContext;\n         this.servletContext = servletContext;\n         this.httpRequest = httpRequest;\n+        this.servletPath = servletPath;\n+        this.pathInfo = pathInfo;\n+        requestURI = serviceRequestContext.path();\n         final MediaType contentType = httpRequest.headers().contentType();\n         if (contentType != null && contentType.charset() != null) {\n             characterEncoding = contentType.charset().name();\n         } else {\n             characterEncoding = servletContext.getRequestCharacterEncoding();\n         }\n-\n-        requestURI = serviceRequestContext.path();\n         queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n         cookies = decodeCookie();\n-        servletPath = requestURI.substring(servletContext.getContextPath().length() + 1);\n-        pathInfo = decodePathInfo();\n \n         final Builder<String, String[]> builder = ImmutableMap.builder();\n         for (String name : queryParams.names()) {\n"}}, {"oid": "bf555513f7660a9439bda08539b4c286b67be545", "url": "https://github.com/line/armeria/commit/bf555513f7660a9439bda08539b4c286b67be545", "message": "Various fixes", "committedDate": "2020-06-22T09:20:40Z", "type": "forcePushed"}, {"oid": "13391fc73f02de293ac84a27377c76184192ed49", "url": "https://github.com/line/armeria/commit/13391fc73f02de293ac84a27377c76184192ed49", "message": "Fix decode servlet path and test case", "committedDate": "2020-06-24T15:42:16Z", "type": "commit"}, {"oid": "b445960fd75b05820cce7adb6bcb90e4ec93a367", "url": "https://github.com/line/armeria/commit/b445960fd75b05820cce7adb6bcb90e4ec93a367", "message": "Merge branch 'master' into pr-2686", "committedDate": "2020-07-07T11:48:52Z", "type": "commit"}, {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo", "committedDate": "2020-07-10T08:20:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTg0MQ==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453611841", "bodyText": "Validation on extension and mimeType?", "author": "trustin", "createdAt": "2020-07-13T12:26:05Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 94%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 96551e7af9..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -43,7 +43,6 @@ import javax.servlet.SessionTrackingMode;\n import javax.servlet.descriptor.JspConfigDescriptor;\n import javax.servlet.http.HttpServlet;\n \n-import org.apache.commons.lang3.tuple.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMTk5Mg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453611992", "bodyText": "The keys and values of mappings need validation.", "author": "trustin", "createdAt": "2020-07-13T12:26:23Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 94%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 96551e7af9..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -43,7 +43,6 @@ import javax.servlet.SessionTrackingMode;\n import javax.servlet.descriptor.JspConfigDescriptor;\n import javax.servlet.http.HttpServlet;\n \n-import org.apache.commons.lang3.tuple.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxMzYwNg==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453613606", "bodyText": "IIRC, many many servlet implementations rely on these operations to load some resources such as templates and properties files, no?", "author": "trustin", "createdAt": "2020-07-13T12:29:25Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 94%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 96551e7af9..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -43,7 +43,6 @@ import javax.servlet.SessionTrackingMode;\n import javax.servlet.descriptor.JspConfigDescriptor;\n import javax.servlet.http.HttpServlet;\n \n-import org.apache.commons.lang3.tuple.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNDM5Ng==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453614396", "bodyText": "Is is some sort of specification to return the Java version and OS name in this string?", "author": "trustin", "createdAt": "2020-07-13T12:30:49Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final Pair<String, DefaultServletRegistration> pair = servletUrlMapper.getMapping(path);\n+        if (pair == null) {\n+            return null;\n+        }\n+\n+        // TODO Integrate this logic into servletUrlMapper.\n+        final String pathPattern = pair.getKey();\n+        final String servletPath;\n+        final String pathInfo;\n+        if (pathPattern.endsWith(\"/*\")) {\n+            // pathPattern: \"/lawn/*\"\n+            // path: \"/lawn/index.html\" then,\n+            // servletPath: \"/lawn\"\n+            // pathInfo: \"/index.html\"\n+            servletPath = pathPattern.substring(0, pathPattern.length() - 2);\n+            pathInfo = path.substring(servletPath.length());\n+        } else {\n+            // pathPattern starts with \"*.\" or exact path.\n+            servletPath = path;\n+            pathInfo = null;\n+        }\n+\n+        return new ServletRequestDispatcher(new ServletFilterChain(pair.getValue()), pair.getValue().getName(),\n+                                            servletPath, pathInfo);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0OTMyOA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r454049328", "bodyText": "Yes, I refer from https://github.com/apache/tomcat/blob/master/java/jakarta/servlet/ServletContext.java java doc.\n    /**\n     * Returns the name and version of the servlet container on which the\n     * servlet is running.\n     * <p>\n     * The form of the returned string is\n     * <i>servername</i>/<i>versionnumber</i>. For example, the JavaServer Web\n     * Development Kit may return the string\n     * <code>JavaServer Web Dev Kit/1.0</code>.\n     * <p>\n     * The servlet container may return other optional information after the\n     * primary string in parentheses, for example,\n     * <code>JavaServer Web Dev Kit/1.0 (JDK 1.1.6; Windows NT 4.0 x86)</code>.\n     *\n     * @return a <code>String</code> containing at least the servlet container\n     *         name and version number\n     */", "author": "dominhhien", "createdAt": "2020-07-14T01:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNDM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 94%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 96551e7af9..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -43,7 +43,6 @@ import javax.servlet.SessionTrackingMode;\n import javax.servlet.descriptor.JspConfigDescriptor;\n import javax.servlet.http.HttpServlet;\n \n-import org.apache.commons.lang3.tuple.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNTY4MA==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453615680", "bodyText": "Servlet context listeners are also an important part of Servlet specification many frameworks rely on. Are we sure we do not want to implement this? That would mean it will not work for most code.", "author": "trustin", "createdAt": "2020-07-13T12:33:13Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.EventListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterRegistration;\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration.Dynamic;\n+import javax.servlet.SessionCookieConfig;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+\n+import com.linecorp.armeria.common.logging.LogLevel;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+\n+final class DefaultServletContext implements ServletContext {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletContext.class);\n+    private static final Set<SessionTrackingMode> defaultSessionTrackingModeSet =\n+            Sets.immutableEnumSet(SessionTrackingMode.COOKIE, SessionTrackingMode.URL);\n+\n+    private final LogLevel level;\n+    private final ServletUrlMapper servletUrlMapper = new ServletUrlMapper();\n+    private final Map<String, Object> attributeMap = new HashMap<>();\n+    private final String contextPath;\n+    private final String servletContextName;\n+\n+    private int sessionTimeoutMinutes = 30; // TODO add setters.\n+    private boolean initialized;\n+    private Map<String, String> initParamMap = new HashMap<>();\n+    private Map<String, DefaultServletRegistration> servletRegistrations = new HashMap<>();\n+    private Map<String, String> mimeMappings = new HashMap<>();\n+    private Set<SessionTrackingMode> sessionTrackingModeSet = defaultSessionTrackingModeSet;\n+    private String requestCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+    private String responseCharacterEncoding = ArmeriaHttpUtil.HTTP_DEFAULT_CONTENT_CHARSET.name();\n+\n+    DefaultServletContext(String contextPath) {\n+        this(contextPath, LogLevel.DEBUG);\n+    }\n+\n+    DefaultServletContext(String contextPath, LogLevel level) {\n+        requireNonNull(contextPath, \"contextPath\");\n+        requireNonNull(level, \"level\");\n+        this.contextPath = contextPath;\n+        this.level = level;\n+        if (contextPath.isEmpty()) {\n+            servletContextName = \"\";\n+        } else {\n+            servletContextName = contextPath.substring(1).replace(\"/\", \"_\").trim();\n+        }\n+    }\n+\n+    boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Set server started.\n+     */\n+    void init() {\n+        initialized = true;\n+        initParamMap = ImmutableMap.copyOf(initParamMap);\n+        servletRegistrations = ImmutableMap.copyOf(servletRegistrations);\n+        sessionTrackingModeSet = ImmutableSet.copyOf(sessionTrackingModeSet);\n+        mimeMappings = ImmutableMap.copyOf(mimeMappings);\n+    }\n+\n+    void mimeMapping(String extension, String mimeType) {\n+        requireNonNull(extension, \"extension\");\n+        requireNonNull(mimeType, \"mimeType\");\n+        mimeMappings.put(extension, mimeType);\n+    }\n+\n+    void mimeMappings(Map<String, String> mappings) {\n+        mimeMappings.putAll(requireNonNull(mappings, \"mappings\"));\n+    }\n+\n+    @Override\n+    public int getSessionTimeout() {\n+        return sessionTimeoutMinutes;\n+    }\n+\n+    @Override\n+    public void setSessionTimeout(int sessionTimeout) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getContextPath() {\n+        return contextPath;\n+    }\n+\n+    @Override\n+    public DefaultServletContext getContext(String uripath) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getEffectiveMajorVersion() {\n+        return 4;\n+    }\n+\n+    @Override\n+    public int getEffectiveMinorVersion() {\n+        return 0;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getMimeType(@Nullable String file) {\n+        if (file == null) {\n+            return null;\n+        }\n+        final int period = file.lastIndexOf('.');\n+        if (period < 0) {\n+            return null;\n+        }\n+        final String extension = file.substring(period + 1);\n+        if (extension.isEmpty()) {\n+            return null;\n+        }\n+        return mimeMappings.get(extension);\n+    }\n+\n+    @Override\n+    public Set<String> getResourcePaths(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public URL getResource(String path) throws MalformedURLException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public InputStream getResourceAsStream(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getRealPath(String path) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getRequestDispatcher(String path) {\n+        requireNonNull(path, \"path\");\n+        final Pair<String, DefaultServletRegistration> pair = servletUrlMapper.getMapping(path);\n+        if (pair == null) {\n+            return null;\n+        }\n+\n+        // TODO Integrate this logic into servletUrlMapper.\n+        final String pathPattern = pair.getKey();\n+        final String servletPath;\n+        final String pathInfo;\n+        if (pathPattern.endsWith(\"/*\")) {\n+            // pathPattern: \"/lawn/*\"\n+            // path: \"/lawn/index.html\" then,\n+            // servletPath: \"/lawn\"\n+            // pathInfo: \"/index.html\"\n+            servletPath = pathPattern.substring(0, pathPattern.length() - 2);\n+            pathInfo = path.substring(servletPath.length());\n+        } else {\n+            // pathPattern starts with \"*.\" or exact path.\n+            servletPath = path;\n+            pathInfo = null;\n+        }\n+\n+        return new ServletRequestDispatcher(new ServletFilterChain(pair.getValue()), pair.getValue().getName(),\n+                                            servletPath, pathInfo);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public ServletRequestDispatcher getNamedDispatcher(String name) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Servlet getServlet(String name) throws ServletException {\n+        // This method is deprecated and should return null.\n+        return null;\n+    }\n+\n+    @Override\n+    public Enumeration<Servlet> getServlets() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public Enumeration<String> getServletNames() {\n+        // This method is deprecated and should return an empty set.\n+        return Collections.enumeration(ImmutableSet.of());\n+    }\n+\n+    @Override\n+    public void log(String message) {\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message);\n+    }\n+\n+    @Override\n+    public void log(Exception exception, String message) {\n+        requireNonNull(exception, \"exception\");\n+        requireNonNull(message, \"message\");\n+        level.log(logger, message, exception);\n+    }\n+\n+    @Override\n+    public void log(String message, Throwable throwable) {\n+        requireNonNull(message, \"message\");\n+        requireNonNull(throwable, \"throwable\");\n+        level.log(logger, message, throwable);\n+    }\n+\n+    @Override\n+    public String getServerInfo() {\n+        return ArmeriaHttpUtil.SERVER_HEADER +\n+               \" (JDK \" + SystemInfo.javaVersion() + ';' + SystemInfo.osType().name() + ')';\n+    }\n+\n+    @Override\n+    public String getInitParameter(String name) {\n+        requireNonNull(name, \"name\");\n+        return initParamMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getInitParameterNames() {\n+        return Collections.enumeration(initParamMap.keySet());\n+    }\n+\n+    @Override\n+    public boolean setInitParameter(String name, @Nullable String value) {\n+        ensureUninitialized(\"setInitParameter\");\n+        requireNonNull(name, \"name\");\n+        return initParamMap.putIfAbsent(name, value) == null;\n+    }\n+\n+    @Override\n+    public Object getAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        return attributeMap.get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getAttributeNames() {\n+        return Collections.enumeration(ImmutableSet.copyOf(attributeMap.keySet()));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, @Nullable Object object) {\n+        requireNonNull(name);\n+        if (object == null) {\n+            removeAttribute(name);\n+            return;\n+        }\n+        attributeMap.put(name, object);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        requireNonNull(name, \"name\");\n+        attributeMap.remove(name);\n+    }\n+\n+    @Override\n+    public String getServletContextName() {\n+        return servletContextName;\n+    }\n+\n+    private void addUrlPatterns(String servletName, @Nullable DefaultServletRegistration registration,\n+                                String... urlPatterns) {\n+        if (registration == null) {\n+            return;\n+        }\n+        final Set<String> conflicts = registration.addMapping(urlPatterns);\n+        if (!conflicts.isEmpty()) {\n+            servletRegistrations.remove(servletName);\n+            throw new IllegalArgumentException(conflicts + \" are mapped already in urlPatterns: \" +\n+                                               Arrays.toString(urlPatterns));\n+        }\n+    }\n+\n+    void addServlet(String servletName, String className, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, className);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, HttpServlet httpServlet, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, httpServlet);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    void addServlet(String servletName, Class<? extends Servlet> servletClass, String... urlPatterns) {\n+        final DefaultServletRegistration registration = addServlet(servletName, servletClass);\n+        addUrlPatterns(servletName, registration, urlPatterns);\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, String className) {\n+        requireNonNull(className, \"className\");\n+        try {\n+            //noinspection unchecked\n+            return addServlet(servletName, (Class<HttpServlet>) Class.forName(className));\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", className: \" + className, e);\n+        }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Servlet servlet) {\n+        ensureUninitialized(\"addServlet\");\n+        checkArgument(!isNullOrEmpty(servletName),\n+                      \"servletName: %s (expected: not null and empty)\", servletName);\n+        requireNonNull(servlet, \"servlet\");\n+        if (servletRegistrations.containsKey(servletName)) {\n+            logger.warn(\"{} is registered already.\", servletName);\n+            return null;\n+        }\n+        final DefaultServletRegistration servletRegistration =\n+                new DefaultServletRegistration(servletName, servlet, this, servletUrlMapper, initParamMap);\n+        if (servletRegistrations.containsValue(servletRegistration)) {\n+            logger.warn(\"{} is registered already.\", servlet);\n+            return null;\n+        }\n+        servletRegistrations.put(servletName, servletRegistration);\n+        return servletRegistration;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public DefaultServletRegistration addServlet(String servletName, Class<? extends Servlet> servletClass) {\n+        requireNonNull(servletClass, \"servletClass\");\n+        try {\n+            return addServlet(servletName, createServlet(servletClass));\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\"Failed to add a servlet. servletName: \" + servletName +\n+                                       \", servletClass: \" + servletClass, e);\n+        }\n+    }\n+\n+    @Override\n+    public <T extends Servlet> T createServlet(Class<T> clazz) throws ServletException {\n+        try {\n+            requireNonNull(clazz, \"clazz\");\n+            return clazz.getDeclaredConstructor().newInstance();\n+        } catch (Exception e) {\n+            throw new ServletException(\"Failed to create a servlet: \" + clazz.getSimpleName(), e);\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public DefaultServletRegistration getServletRegistration(String servletName) {\n+        requireNonNull(servletName, \"servletName\");\n+        return servletRegistrations.get(servletName);\n+    }\n+\n+    @Override\n+    public Map<String, DefaultServletRegistration> getServletRegistrations() {\n+        return servletRegistrations;\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, String className) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Filter filter) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public FilterRegistration.Dynamic addFilter(String filterName, Class<? extends Filter> filterClass) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends Filter> T createFilter(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public FilterRegistration getFilterRegistration(String filterName) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Map<String, ? extends FilterRegistration> getFilterRegistrations() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public SessionCookieConfig getSessionCookieConfig() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getDefaultSessionTrackingModes() {\n+        return defaultSessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public Set<SessionTrackingMode> getEffectiveSessionTrackingModes() {\n+        return sessionTrackingModeSet;\n+    }\n+\n+    @Override\n+    public void addListener(String className) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends EventListener> void addListener(T listener) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void addListener(Class<? extends EventListener> listenerClass) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public <T extends EventListener> T createListener(Class<T> clazz) throws ServletException {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2a9d3d0095bc106151ad97fa1427680e13a362aa", "chunk": "diff --git a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nsimilarity index 94%\nrename from servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nrename to servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\nindex 96551e7af9..999ca5b084 100755\n--- a/servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n+++ b/servlet4/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletContext.java\n\n@@ -43,7 +43,6 @@ import javax.servlet.SessionTrackingMode;\n import javax.servlet.descriptor.JspConfigDescriptor;\n import javax.servlet.http.HttpServlet;\n \n-import org.apache.commons.lang3.tuple.Pair;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYxNjYzMw==", "url": "https://github.com/line/armeria/pull/2686#discussion_r453616633", "bodyText": "At least some sort of minimal session support should exist. It's not easy to find a Servlet application that does not rely on this feature.", "author": "trustin", "createdAt": "2020-07-13T12:35:04Z", "path": "servlet/src/main/java/com/linecorp/armeria/server/servlet/DefaultServletHttpRequest.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.servlet;\n+\n+import static com.google.common.base.MoreObjects.firstNonNull;\n+import static com.google.common.base.Strings.isNullOrEmpty;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.security.Principal;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.annotation.Nullable;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.DispatcherType;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.SessionTrackingMode;\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpUpgradeHandler;\n+import javax.servlet.http.Part;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMap.Builder;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.primitives.Ints;\n+\n+import com.linecorp.armeria.common.AggregatedHttpRequest;\n+import com.linecorp.armeria.common.Cookies;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+import io.netty.util.AsciiString;\n+\n+final class DefaultServletHttpRequest implements HttpServletRequest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultServletHttpRequest.class);\n+    private static final SimpleDateFormat[] FORMATS_TEMPLATE = {\n+            new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEEEEE, dd-MMM-yy HH:mm:ss zzz\", Locale.ENGLISH),\n+            new SimpleDateFormat(\"EEE MMMM d HH:mm:ss yyyy\", Locale.ENGLISH)\n+    };\n+\n+    private final Map<String, Object> attributeMap = new ConcurrentHashMap<>(16);\n+    private final SessionTrackingMode sessionIdSource = SessionTrackingMode.COOKIE;\n+\n+    private final ServiceRequestContext serviceRequestContext;\n+    private final DefaultServletContext servletContext;\n+    private final AggregatedHttpRequest httpRequest;\n+    private final String servletPath;\n+    @Nullable\n+    private final String pathInfo;\n+    private final String requestURI;\n+    private final String characterEncoding;\n+    private final QueryParams queryParams;\n+    @Nullable\n+    private final Cookie[] cookies;\n+    private final Map<String, String[]> parameters;\n+\n+    DefaultServletHttpRequest(DefaultServletContext servletContext,\n+                              ServiceRequestContext serviceRequestContext,\n+                              AggregatedHttpRequest httpRequest,\n+                              String servletPath,\n+                              @Nullable String pathInfo) {\n+        this.serviceRequestContext = serviceRequestContext;\n+        this.servletContext = servletContext;\n+        this.httpRequest = httpRequest;\n+        this.servletPath = servletPath;\n+        this.pathInfo = pathInfo;\n+        requestURI = serviceRequestContext.path();\n+        final MediaType contentType = httpRequest.headers().contentType();\n+        if (contentType != null && contentType.charset() != null) {\n+            characterEncoding = contentType.charset().name();\n+        } else {\n+            characterEncoding = servletContext.getRequestCharacterEncoding();\n+        }\n+        queryParams = queryParamsOf(serviceRequestContext.query(), contentType, httpRequest);\n+        cookies = decodeCookie();\n+\n+        final Builder<String, String[]> builder = ImmutableMap.builder();\n+        for (String name : queryParams.names()) {\n+            builder.put(name, queryParams.getAll(name).toArray(new String[0]));\n+        }\n+        parameters = builder.build();\n+    }\n+\n+    @Nullable\n+    private Cookie[] decodeCookie() {\n+        final String cookieValue = httpRequest.headers().get(HttpHeaderNames.COOKIE);\n+        if (cookieValue != null) {\n+            final Cookies cookies = com.linecorp.armeria.common.Cookie.fromCookieHeader(cookieValue);\n+            return cookies.stream().map(c -> {\n+                final Cookie cookie = new Cookie(c.name(), c.value());\n+                if (c.domain() != null) {\n+                    cookie.setDomain(c.domain());\n+                }\n+                if (c.path() != null) {\n+                    cookie.setPath(c.path());\n+                }\n+                cookie.setSecure(c.isSecure());\n+                cookie.setMaxAge(Ints.saturatedCast(c.maxAge()));\n+                cookie.setHttpOnly(c.isHttpOnly());\n+                return new Cookie(c.name(), c.value());\n+            }).toArray(Cookie[]::new);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    @Nullable\n+    public Cookie[] getCookies() {\n+        return cookies;\n+    }\n+\n+    @Override\n+    public long getDateHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        final String dateHeader = getHeader(name);\n+        if (dateHeader == null) {\n+            return -1;\n+        }\n+        for (DateFormat x : FORMATS_TEMPLATE) {\n+            try {\n+                return x.parse(dateHeader).getTime();\n+            } catch (Exception e) {\n+                // ignored.\n+            }\n+        }\n+        throw new IllegalArgumentException(\"failed to parse a date header: \" + dateHeader);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getHeader(String name) {\n+        requireNonNull(name, \"name\");\n+        return httpRequest.headers().get(name);\n+    }\n+\n+    @Override\n+    public Enumeration<String> getHeaderNames() {\n+        return Collections.enumeration(\n+                httpRequest.headers().names().stream()\n+                           .map(AsciiString::toString).collect(ImmutableList.toImmutableList()));\n+    }\n+\n+    @Override\n+    public StringBuffer getRequestURL() {\n+        return new StringBuffer(httpRequest.scheme() + \"://\" + httpRequest.authority() + requestURI);\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getPathInfo() {\n+        return pathInfo;\n+    }\n+\n+    @Override\n+    @Nullable\n+    public String getQueryString() {\n+        return serviceRequestContext.query();\n+    }\n+\n+    @Override\n+    public String getRequestURI() {\n+        return requestURI;\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return servletPath;\n+    }\n+\n+    @Override\n+    public HttpSession getSession(boolean create) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public HttpSession getSession() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String changeSessionId() {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "3ca62c43618d7e894500dcd37a4d60e5b68617ee", "url": "https://github.com/line/armeria/commit/3ca62c43618d7e894500dcd37a4d60e5b68617ee", "message": "Add MimeType validation, use Map.Entry instead of Pair", "committedDate": "2020-07-14T08:49:26Z", "type": "forcePushed"}, {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo", "committedDate": "2020-07-10T08:20:28Z", "type": "forcePushed"}, {"oid": "598e25baa3d9caaab5aca80a66ba284bb6a643d5", "url": "https://github.com/line/armeria/commit/598e25baa3d9caaab5aca80a66ba284bb6a643d5", "message": "Fix ServletRequestDispatcher to have servletPath and pathInfo", "committedDate": "2020-07-10T08:20:28Z", "type": "forcePushed"}, {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "message": "Merge pull request #1 from line/master\n\nUpdate new source code", "committedDate": "2020-07-15T10:00:53Z", "type": "commit"}, {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "message": "Merge pull request #1 from line/master\n\nUpdate new source code", "committedDate": "2020-07-15T10:00:53Z", "type": "forcePushed"}, {"oid": "4e35fd9e69503351e45dcb30a621f2bc992b12a6", "url": "https://github.com/line/armeria/commit/4e35fd9e69503351e45dcb30a621f2bc992b12a6", "message": "Merge pull request #1 from line/master\n\nUpdate new source code", "committedDate": "2020-07-15T10:00:53Z", "type": "forcePushed"}, {"oid": "ab174a4244a1a02201cda04c6a29bd1877681d69", "url": "https://github.com/line/armeria/commit/ab174a4244a1a02201cda04c6a29bd1877681d69", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter", "committedDate": "2020-07-15T10:41:20Z", "type": "commit"}, {"oid": "ab174a4244a1a02201cda04c6a29bd1877681d69", "url": "https://github.com/line/armeria/commit/ab174a4244a1a02201cda04c6a29bd1877681d69", "message": "MimeType validation, Pair -> Map.Entry, servlet-container -> servlet-adapter", "committedDate": "2020-07-15T10:41:20Z", "type": "forcePushed"}]}