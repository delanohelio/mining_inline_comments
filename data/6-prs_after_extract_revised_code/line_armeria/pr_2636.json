{"pr_number": 2636, "pr_title": "Add HTTP/1 PING(`OPTIONS *`)", "pr_createdAt": "2020-03-28T06:32:26Z", "pr_url": "https://github.com/line/armeria/pull/2636", "timeline": [{"oid": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "url": "https://github.com/line/armeria/commit/3d98d18da9d33e2c643271ac33e837d0f8ff8746", "message": "Clean up", "committedDate": "2020-03-28T06:55:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEwOTA0OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400109049", "bodyText": "a PING frame", "author": "trustin", "createdAt": "2020-03-30T11:10:03Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -219,18 +219,14 @@ public long idleTimeoutMillis() {\n     }\n \n     /**\n-     * Returns the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout in milliseconds.\n+     * Returns the PING interval in milliseconds.\n+     * When neither read nor write was performed for the specified period of time,\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\nindex 2ff735cde4..b67b8db13f 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\n\n@@ -223,7 +223,7 @@ public final class ClientFactoryOptions\n      * When neither read nor write was performed for the specified period of time,\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n      * is sent for HTTP/1,\n-     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * or a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n      */\n     public long pingIntervalMillis() {\n         return get(ClientFactoryOption.PING_INTERVAL_MILLIS);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEwOTU2Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400109566", "bodyText": "Keep the getter and setter together.", "author": "trustin", "createdAt": "2020-03-30T11:11:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java", "diffHunk": "@@ -101,4 +108,21 @@ protected void convertTrailers(HttpHeaders inputHeaders,\n                                    io.netty.handler.codec.http.HttpHeaders outputHeaders) {\n         ArmeriaHttpUtil.toNettyHttp1ClientTrailer(inputHeaders, outputHeaders);\n     }\n+\n+    @Nullable\n+    @Override\n+    public KeepAliveHandler keepAliveHandler() {\n+        return keepAliveHandler;\n+    }\n+\n+    @Override\n+    public void keepAliveWrite(int id) {\n+        if (keepAliveHandler != null && !keepAliveHandler.isPing(id)) {\n+            super.keepAliveWrite(id);\n+        }\n+    }\n+\n+    public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java\nindex 6cf3f8a3b9..469a4f21d3 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java\n\n@@ -115,14 +115,12 @@ final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder implements Clien\n         return keepAliveHandler;\n     }\n \n-    @Override\n-    public void keepAliveWrite(int id) {\n-        if (keepAliveHandler != null && !keepAliveHandler.isPing(id)) {\n-            super.keepAliveWrite(id);\n-        }\n-    }\n-\n     public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {\n         this.keepAliveHandler = keepAliveHandler;\n     }\n+\n+    @Override\n+    protected boolean isPing(int id) {\n+        return keepAliveHandler != null && !keepAliveHandler.isPing(id);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMDU4NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400110584", "bodyText": "Global comment - maybe<Verb><Object>", "author": "trustin", "createdAt": "2020-03-30T11:13:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -84,6 +88,11 @@ HttpResponseWrapper addResponse(\n         return resWrapper;\n     }\n \n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeKeepAliveInitialize(ctx);", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex 3c2e4e8895..c1f8786a14 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -90,7 +90,7 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n \n     void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n         this.keepAliveHandler = keepAliveHandler;\n-        maybeKeepAliveInitialize(ctx);\n+        maybeInitializeKeepAliveHandler(ctx);\n     }\n \n     private void onWrapperCompleted(HttpResponseWrapper resWrapper, @Nullable Throwable cause) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMDcyMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400110722", "bodyText": "Global comment - <Verb><Object>", "author": "trustin", "createdAt": "2020-03-30T11:13:20Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -96,13 +105,18 @@ private void onWrapperCompleted(HttpResponseWrapper resWrapper, @Nullable Throwa\n     }\n \n     @Override\n-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {}\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        maybeKeepAliveInitialize(ctx);\n+    }\n \n     @Override\n-    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {}\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+        keepAliveDestroy();", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex 3c2e4e8895..c1f8786a14 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -106,17 +106,17 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n \n     @Override\n     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n-        maybeKeepAliveInitialize(ctx);\n+        maybeInitializeKeepAliveHandler(ctx);\n     }\n \n     @Override\n     public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n-        keepAliveDestroy();\n+        destroyKeepAliveHandler();\n     }\n \n     @Override\n     public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n-        maybeKeepAliveInitialize(ctx);\n+        maybeInitializeKeepAliveHandler(ctx);\n         ctx.fireChannelRegistered();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMTA3NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400111075", "bodyText": "Maybe no need to check if registered?", "author": "trustin", "createdAt": "2020-03-30T11:13:57Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +284,41 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTc3Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400681776", "bodyText": "Removed :-)", "author": "ikhoon", "createdAt": "2020-03-31T06:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMTA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex 3c2e4e8895..c1f8786a14 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -285,13 +285,13 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n         ctx.fireExceptionCaught(cause);\n     }\n \n-    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n-        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void keepAliveDestroy() {\n+    private void destroyKeepAliveHandler() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMTQ4NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400111485", "bodyText": "keepAlive -> keepAliveHandler", "author": "trustin", "createdAt": "2020-03-30T11:14:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +284,41 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void keepAliveDestroy() {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex 3c2e4e8895..c1f8786a14 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -285,13 +285,13 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n         ctx.fireExceptionCaught(cause);\n     }\n \n-    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n-        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void keepAliveDestroy() {\n+    private void destroyKeepAliveHandler() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400112464", "bodyText": "What would be the sensible default for this flag?", "author": "trustin", "createdAt": "2020-03-30T11:16:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -197,10 +197,10 @@\n                     DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS,\n                     value -> value >= 0);\n \n-    private static final long DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS = 0; // Disabled\n-    private static final long DEFAULT_HTTP2_PING_TIMEOUT_MILLIS =\n-            getLong(\"defaultHttp2PingTimeoutMillis\",\n-                    DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS,\n+    private static final long DEFAULT_DEFAULT_PING_INTERVAL_MILLIS = 0; // Disabled", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY0ODIwOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400648208", "bodyText": "Hmm... I thought PING is an optional feature. If we turn it on by default, what about 5000 milliseconds?\nBecause the default PING interval should be less than the default idle timeouts.\n\nthe default idle timeout of service-side is 15000 milliseconds\nthe default idle timeout of client-side is 10000 milliseconds", "author": "ikhoon", "createdAt": "2020-03-31T05:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxNTc4Mw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402215783", "bodyText": "Sounds good to me. I guess it'll be nice if we do not send ping frames too often so that some HTTP/2 servers reject us, e.g. gRPC-Java has such check. Could you double check? Related issue: #2639", "author": "trustin", "createdAt": "2020-04-02T10:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMyODE0OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402328148", "bodyText": "https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md\nThe default keepalive configuration of upstream gRPC server seems to be conservative.\n\nThe default value of permitKeepAliveTime is 5 minutes.\npermitKeepAliveWithoutCalls() is disable by default.\n\nThese means\n\nOur gRPC client should not send a PING frame with no outstand streams\nThe PING interval should be longer than 5 minutes with active streams.\n\nWe might need a different default keepalive configuration for gRPC? Any thoughts? @anuraaga", "author": "ikhoon", "createdAt": "2020-04-02T13:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg1OTE2OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403859169", "bodyText": "I guess we need to be as conservative as gRPC-Java by default to prevent any surprises. KeepAliveEnforcer contains the core logic of the defense mechanism: https://github.com/grpc/grpc-java/blob/master/netty/src/main/java/io/grpc/netty/KeepAliveEnforcer.java which seems to be:\n\ninterested only in the interval between PING frames. It doesn't take other traffic into account.\n\nPerhaps we need another parameter, like 'minimum interval between pings'?\n\n\naccepting up to 2 violations (dunno why)", "author": "trustin", "createdAt": "2020-04-06T06:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg4MTY0NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403881645", "bodyText": "I'm not sure this is useful for us, but gRPC client limits the min ping interval.\nhttps://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/internal/KeepAliveManager.java#L235-L240", "author": "ikhoon", "createdAt": "2020-04-06T07:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExMjQ2NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzExMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400117112", "bodyText": "Perhaps we can keep accessing it via writer.keepAliveHandler(), instead of adding a new member field?", "author": "trustin", "createdAt": "2020-03-30T11:25:36Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java", "diffHunk": "@@ -84,6 +84,8 @@\n     private final AsciiString scheme;\n     private final InboundTrafficController inboundTrafficController;\n     private final ServerHttp1ObjectEncoder writer;\n+    @Nullable\n+    private final KeepAliveHandler keepAliveHandler;", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MTg4OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400681888", "bodyText": "Fixed", "author": "ikhoon", "createdAt": "2020-03-31T06:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzExMg=="}], "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java b/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\nindex 52cc4b9ced..dee164d6f0 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\n\n@@ -84,8 +84,6 @@ final class Http1RequestDecoder extends ChannelDuplexHandler {\n     private final AsciiString scheme;\n     private final InboundTrafficController inboundTrafficController;\n     private final ServerHttp1ObjectEncoder writer;\n-    @Nullable\n-    private final KeepAliveHandler keepAliveHandler;\n \n     /** The request being decoded currently. */\n     @Nullable\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExNzIxOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400117218", "bodyText": "Can be removed because channelActive() will be invoked.", "author": "trustin", "createdAt": "2020-03-30T11:25:51Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java", "diffHunk": "@@ -97,6 +99,31 @@\n         this.scheme = scheme;\n         inboundTrafficController = InboundTrafficController.ofHttp1(channel);\n         this.writer = writer;\n+        keepAliveHandler = writer.keepAliveHandler();\n+    }\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        maybeKeepAliveInitialize(ctx);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+        keepAliveDestroy();\n+        super.handlerRemoved(ctx);\n+    }\n+\n+    @Override\n+    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+        maybeKeepAliveInitialize(ctx);\n+        super.channelRegistered(ctx);\n+    }", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java b/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\nindex 52cc4b9ced..dee164d6f0 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\n\n@@ -99,30 +97,23 @@ final class Http1RequestDecoder extends ChannelDuplexHandler {\n         this.scheme = scheme;\n         inboundTrafficController = InboundTrafficController.ofHttp1(channel);\n         this.writer = writer;\n-        keepAliveHandler = writer.keepAliveHandler();\n     }\n \n     @Override\n     public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n-        maybeKeepAliveInitialize(ctx);\n+        maybeInitializeKeepAliveHandler(ctx);\n         super.handlerAdded(ctx);\n     }\n \n     @Override\n     public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n-        keepAliveDestroy();\n+        destroyKeepAliveHandler();\n         super.handlerRemoved(ctx);\n     }\n \n-    @Override\n-    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n-        maybeKeepAliveInitialize(ctx);\n-        super.channelRegistered(ctx);\n-    }\n-\n     @Override\n     public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        maybeKeepAliveInitialize(ctx);\n+        maybeInitializeKeepAliveHandler(ctx);\n         super.channelActive(ctx);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExODI3Mg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400118272", "bodyText": "I think this name is highly confusing. Please fine something better.\nThis method doesn't have to be public if I understood correctly.", "author": "trustin", "createdAt": "2020-03-30T11:27:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java", "diffHunk": "@@ -40,6 +42,16 @@ default EventLoop eventLoop() {\n         return channel().eventLoop();\n     }\n \n+    @Nullable\n+    KeepAliveHandler keepAliveHandler();\n+\n+    default void keepAliveWrite(int id) {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY4MjQ5NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400682495", "bodyText": "Agreed, I removed this method and updated sub classes.", "author": "ikhoon", "createdAt": "2020-03-31T06:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExODI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "95610a5376e147631156f86173cbdd69edc3ce60", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\nindex 3722b6be1a..59941135db 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\n\n@@ -45,13 +45,6 @@ public interface HttpObjectEncoder {\n     @Nullable\n     KeepAliveHandler keepAliveHandler();\n \n-    default void keepAliveWrite(int id) {\n-        final KeepAliveHandler keepAliveHandler = keepAliveHandler();\n-        if (keepAliveHandler != null) {\n-            keepAliveHandler.onReadOrWrite();\n-        }\n-    }\n-\n     /**\n      * Writes an HTTP trailers.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExODk3Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400118976", "bodyText": "instance that schedules", "author": "trustin", "createdAt": "2020-03-30T11:29:14Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;\n+    private final long pingIdleTimeNanos;\n+    private final ScheduledExecutorService executor;\n+\n+    @Nullable\n+    private ScheduledFuture<?> allIdleTimeout;\n+    private long lastAllIdleTime;\n+    private boolean firstAllIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private long lastPingAckTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    /**\n+     * Creates a new instance schedules {@link IdleStateEvent}s.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\nindex 659d67adea..b72fba0655 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n\n@@ -33,7 +33,7 @@ import io.netty.channel.ChannelHandlerContext;\n import io.netty.util.internal.ObjectUtil;\n \n /**\n- * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * A Scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n  * has not invoked for a while.\n  *\n  * <h3>Supported idle states</h3>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDExOTgyMw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400119823", "bodyText": "Could be inlined?", "author": "trustin", "createdAt": "2020-03-30T11:31:02Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\nindex 659d67adea..b72fba0655 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n\n@@ -33,7 +33,7 @@ import io.netty.channel.ChannelHandlerContext;\n import io.netty.util.internal.ObjectUtil;\n \n /**\n- * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * A Scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n  * has not invoked for a while.\n  *\n  * <h3>Supported idle states</h3>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyMTAyMQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400121021", "bodyText": "allIdle -> just idle or connectionIdle ?", "author": "trustin", "createdAt": "2020-03-30T11:33:21Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\nindex 659d67adea..b72fba0655 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n\n@@ -33,7 +33,7 @@ import io.netty.channel.ChannelHandlerContext;\n import io.netty.util.internal.ObjectUtil;\n \n /**\n- * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * A Scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n  * has not invoked for a while.\n  *\n  * <h3>Supported idle states</h3>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyMTQyNg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400121426", "bodyText": "These need to be updated to something similar to what you explained in Flags.", "author": "trustin", "createdAt": "2020-03-30T11:34:03Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;\n+    private final long pingIdleTimeNanos;\n+    private final ScheduledExecutorService executor;\n+\n+    @Nullable\n+    private ScheduledFuture<?> allIdleTimeout;\n+    private long lastAllIdleTime;\n+    private boolean firstAllIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private long lastPingAckTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    /**\n+     * Creates a new instance schedules {@link IdleStateEvent}s.\n+     *\n+     * @param allIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+     *                    will be triggered when neither read nor write was performed for\n+     *                    the specified period of time. Specify {@code 0} to disable.\n+     * @param pingIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+     *                     will be triggered when neither read nor write was performed for\n+     *                     the specified period of time. Specify {@code 0} to disable.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\nindex 659d67adea..b72fba0655 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n\n@@ -33,7 +33,7 @@ import io.netty.channel.ChannelHandlerContext;\n import io.netty.util.internal.ObjectUtil;\n \n /**\n- * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * A Scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n  * has not invoked for a while.\n  *\n  * <h3>Supported idle states</h3>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyMzE4MQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400123181", "bodyText": "Could you update the comments in this class to reflect its actual behavior?", "author": "trustin", "createdAt": "2020-03-30T11:37:22Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * has not invoked for a while.\n+ *\n+ * <h3>Supported idle states</h3>\n+ * <table border=\"1\">\n+ * <tr><th>Property</th><th>Meaning</th></tr>\n+ * <tr>\n+ *   <td>{@code allIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * <tr>\n+ *   <td>{@code pingIdleTime}</td>\n+ *   <td>an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+ *       will be triggered when neither read nor write was performed for the\n+ *       specified period of time. Specify {@code 0} to disable.</td>\n+ * </tr>\n+ * </table>\n+ */\n+abstract class IdleTimeoutScheduler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L99\n+\n+    private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutScheduler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static long ticksInNanos() {\n+        return System.nanoTime();\n+    }\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case ALL_IDLE:\n+                return first ? FIRST_ALL_IDLE_STATE_EVENT : ALL_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    private final long allIdleTimeNanos;\n+    private final long pingIdleTimeNanos;\n+    private final ScheduledExecutorService executor;\n+\n+    @Nullable\n+    private ScheduledFuture<?> allIdleTimeout;\n+    private long lastAllIdleTime;\n+    private boolean firstAllIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private long lastPingAckTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    /**\n+     * Creates a new instance schedules {@link IdleStateEvent}s.\n+     *\n+     * @param allIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#ALL_IDLE}\n+     *                    will be triggered when neither read nor write was performed for\n+     *                    the specified period of time. Specify {@code 0} to disable.\n+     * @param pingIdleTime an {@link IdleStateEvent} whose state is {@link IdleState#PING_IDLE}\n+     *                     will be triggered when neither read nor write was performed for\n+     *                     the specified period of time. Specify {@code 0} to disable.\n+     * @param unit the {@link TimeUnit}\n+     * @param executor the executor to schedule a timeout to trigger an {@link IdleStateEvent}.\n+     */\n+    IdleTimeoutScheduler(long allIdleTime, long pingIdleTime, TimeUnit unit,\n+                         ScheduledExecutorService executor) {\n+        ObjectUtil.checkNotNull(unit, \"unit\");\n+        this.executor = executor;\n+\n+        if (allIdleTime <= 0) {\n+            allIdleTimeNanos = 0;\n+        } else {\n+            allIdleTimeNanos = Math.max(unit.toNanos(allIdleTime), MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIdleTime <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(unit.toNanos(pingIdleTime), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public void onReadOrWrite() {\n+        if (allIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastAllIdleTime = lastPingAckTime = ticksInNanos();\n+            firstAllIdleEvent = firstPingIdleEvent = true;\n+        }\n+    }\n+\n+    public void onPing() {\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingAckTime = ticksInNanos();\n+        }\n+    }\n+\n+    public void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (allIdleTimeNanos > 0) {\n+            allIdleTimeout = executor.schedule(new AllIdleTimeoutTask(ctx),\n+                                               allIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor.schedule(new PingIdleTimeoutTask(ctx),\n+                                                pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public void destroy() {\n+        state = 2;\n+        if (allIdleTimeout != null) {\n+            allIdleTimeout.cancel(false);\n+            allIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+    }\n+\n+    protected abstract void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt);\n+\n+    private abstract static class AbstractIdleTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        AbstractIdleTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (!ctx.channel().isOpen()) {\n+                return;\n+            }\n+\n+            run(ctx);\n+        }\n+\n+        protected abstract void run(ChannelHandlerContext ctx);\n+    }\n+\n+    private final class AllIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        AllIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastAllIdleTime = IdleTimeoutScheduler.this.lastAllIdleTime;\n+            final long nextDelay = allIdleTimeNanos - (ticksInNanos() - lastAllIdleTime);\n+            if (nextDelay <= 0) {\n+                // Both reader and writer are idle - set a new timeout and\n+                // notify the callback.\n+                allIdleTimeout = executor.schedule(this, allIdleTimeNanos, TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstAllIdleEvent;\n+                firstAllIdleEvent = false;\n+                final IdleStateEvent event = newIdleStateEvent(IdleState.ALL_IDLE, first);\n+                try {\n+                    onIdleEvent(ctx, event);\n+                } catch (Exception e) {\n+                    if (!warn) {\n+                        logger.warn(\"An error occurred while notifying an all idle event\", e);\n+                        warn = true;\n+                    }\n+                }\n+            } else {\n+                // Either read or write occurred before the timeout - set a new\n+                // timeout with shorter delay.\n+                allIdleTimeout = executor.schedule(this, nextDelay, TimeUnit.NANOSECONDS);\n+            }\n+        }\n+    }\n+\n+    private final class PingIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        PingIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastPingAckTime = IdleTimeoutScheduler.this.lastPingAckTime;\n+            final long nextDelay = pingIdleTimeNanos - (ticksInNanos() - lastPingAckTime);\n+            if (nextDelay <= 0) {\n+                // Ping is idle - set a new timeout and notify the callback.\n+                pingIdleTimeout = executor.schedule(this, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstPingIdleEvent;\n+                firstPingIdleEvent = false;\n+\n+                final IdleStateEvent event = newIdleStateEvent(IdleState.PING_IDLE, first);\n+                try {\n+                    onIdleEvent(ctx, event);\n+                } catch (Exception e) {\n+                    if (!warn) {\n+                        logger.warn(\"An error occurred while notifying a ping idle event\", e);\n+                        warn = true;\n+                    }\n+                }\n+            } else {\n+                // Ping occurred before the timeout - set a new timeout with shorter delay.", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\nindex 659d67adea..b72fba0655 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutScheduler.java\n\n@@ -33,7 +33,7 @@ import io.netty.channel.ChannelHandlerContext;\n import io.netty.util.internal.ObjectUtil;\n \n /**\n- * A scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n+ * A Scheduler that triggers an {@link IdleStateEvent} when {@link #onReadOrWrite()} or {@linkplain #onPing()}\n  * has not invoked for a while.\n  *\n  * <h3>Supported idle states</h3>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyNDI5Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400124297", "bodyText": "How about merging the two classes into one given that IdleTimeoutScheduler is always used together with KeepAliveHandler?", "author": "trustin", "createdAt": "2020-03-30T11:39:28Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link IdleTimeoutScheduler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler extends IdleTimeoutScheduler {", "originalCommit": "3d98d18da9d33e2c643271ac33e837d0f8ff8746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyNjExOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400626119", "bodyText": "That sounds good. \ud83d\udc4d It can simplify the hierarchy.", "author": "ikhoon", "createdAt": "2020-03-31T03:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDEyNDI5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 5a47f6c082..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -20,6 +20,7 @@ import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgxNDE3OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r400814179", "bodyText": "Can remove public?", "author": "minwoox", "createdAt": "2020-03-31T10:42:47Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java", "diffHunk": "@@ -101,4 +108,19 @@ protected void convertTrailers(HttpHeaders inputHeaders,\n                                    io.netty.handler.codec.http.HttpHeaders outputHeaders) {\n         ArmeriaHttpUtil.toNettyHttp1ClientTrailer(inputHeaders, outputHeaders);\n     }\n+\n+    @Nullable\n+    @Override\n+    public KeepAliveHandler keepAliveHandler() {\n+        return keepAliveHandler;\n+    }\n+\n+    public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java\nindex 469a4f21d3..6cf3f8a3b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientHttp1ObjectEncoder.java\n\n@@ -115,12 +115,14 @@ final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder implements Clien\n         return keepAliveHandler;\n     }\n \n-    public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {\n-        this.keepAliveHandler = keepAliveHandler;\n+    @Override\n+    public void keepAliveWrite(int id) {\n+        if (keepAliveHandler != null && !keepAliveHandler.isPing(id)) {\n+            super.keepAliveWrite(id);\n+        }\n     }\n \n-    @Override\n-    protected boolean isPing(int id) {\n-        return keepAliveHandler != null && !keepAliveHandler.isPing(id);\n+    public void setKeepAliveHandler(Http1ClientKeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNzIwMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401307202", "bodyText": "How about making a field for HttpSession and use it instead of channel?", "author": "minwoox", "createdAt": "2020-04-01T01:33:34Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.KeepAliveHandler;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+\n+final class Http1ClientKeepAliveHandler extends KeepAliveHandler {\n+\n+    private static final RequestHeaders HTTP1_PING_REQUEST = RequestHeaders.of(HttpMethod.OPTIONS, \"*\");\n+\n+    private final Channel channel;\n+    private final ClientHttp1ObjectEncoder encoder;\n+    private final Http1ResponseDecoder decoder;\n+\n+    Http1ClientKeepAliveHandler(Channel channel, ClientHttp1ObjectEncoder encoder, Http1ResponseDecoder decoder,\n+                                long idleTimeoutMillis, long pingIntervalMillis) {\n+        super(channel, \"client\", idleTimeoutMillis, pingIntervalMillis);\n+        this.channel = requireNonNull(channel, \"channel\");", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java\nindex 3a69bcd04c..13346b874c 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java\n\n@@ -30,33 +30,31 @@ final class Http1ClientKeepAliveHandler extends KeepAliveHandler {\n \n     private static final RequestHeaders HTTP1_PING_REQUEST = RequestHeaders.of(HttpMethod.OPTIONS, \"*\");\n \n-    private final Channel channel;\n+    private final HttpSession httpSession;\n     private final ClientHttp1ObjectEncoder encoder;\n     private final Http1ResponseDecoder decoder;\n \n     Http1ClientKeepAliveHandler(Channel channel, ClientHttp1ObjectEncoder encoder, Http1ResponseDecoder decoder,\n                                 long idleTimeoutMillis, long pingIntervalMillis) {\n         super(channel, \"client\", idleTimeoutMillis, pingIntervalMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n+        httpSession = HttpSession.get(requireNonNull(channel, \"channel\"));\n         this.encoder = requireNonNull(encoder, \"encoder\");\n         this.decoder = requireNonNull(decoder, \"decoder\");\n     }\n \n     @Override\n     protected ChannelFuture writePing(ChannelHandlerContext ctx) {\n-        final HttpSession httpSession = HttpSession.get(channel);\n         final int id = httpSession.incrementAndGetNumRequestsSent();\n-        final int streamId = (id << 1) + 1;\n \n         decoder.setPingReqId(id);\n-        final ChannelFuture future = encoder.writeHeaders(id, streamId, HTTP1_PING_REQUEST, true);\n+        final ChannelFuture future = encoder.writeHeaders(id, 0, HTTP1_PING_REQUEST, true);\n         ctx.flush();\n         return future;\n     }\n \n     @Override\n     protected boolean hasRequestsInProgress(ChannelHandlerContext ctx) {\n-        return HttpSession.get(ctx.channel()).hasUnfinishedResponses();\n+        return httpSession.hasUnfinishedResponses();\n     }\n \n     boolean isPing(int id) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwODY1MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401308650", "bodyText": "nit: we could just set 0 for streamId because it's not used.", "author": "minwoox", "createdAt": "2020-04-01T01:39:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.KeepAliveHandler;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+\n+final class Http1ClientKeepAliveHandler extends KeepAliveHandler {\n+\n+    private static final RequestHeaders HTTP1_PING_REQUEST = RequestHeaders.of(HttpMethod.OPTIONS, \"*\");\n+\n+    private final Channel channel;\n+    private final ClientHttp1ObjectEncoder encoder;\n+    private final Http1ResponseDecoder decoder;\n+\n+    Http1ClientKeepAliveHandler(Channel channel, ClientHttp1ObjectEncoder encoder, Http1ResponseDecoder decoder,\n+                                long idleTimeoutMillis, long pingIntervalMillis) {\n+        super(channel, \"client\", idleTimeoutMillis, pingIntervalMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.encoder = requireNonNull(encoder, \"encoder\");\n+        this.decoder = requireNonNull(decoder, \"decoder\");\n+    }\n+\n+    @Override\n+    protected ChannelFuture writePing(ChannelHandlerContext ctx) {\n+        final HttpSession httpSession = HttpSession.get(channel);\n+        final int id = httpSession.incrementAndGetNumRequestsSent();\n+        final int streamId = (id << 1) + 1;", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java\nindex 3a69bcd04c..13346b874c 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ClientKeepAliveHandler.java\n\n@@ -30,33 +30,31 @@ final class Http1ClientKeepAliveHandler extends KeepAliveHandler {\n \n     private static final RequestHeaders HTTP1_PING_REQUEST = RequestHeaders.of(HttpMethod.OPTIONS, \"*\");\n \n-    private final Channel channel;\n+    private final HttpSession httpSession;\n     private final ClientHttp1ObjectEncoder encoder;\n     private final Http1ResponseDecoder decoder;\n \n     Http1ClientKeepAliveHandler(Channel channel, ClientHttp1ObjectEncoder encoder, Http1ResponseDecoder decoder,\n                                 long idleTimeoutMillis, long pingIntervalMillis) {\n         super(channel, \"client\", idleTimeoutMillis, pingIntervalMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n+        httpSession = HttpSession.get(requireNonNull(channel, \"channel\"));\n         this.encoder = requireNonNull(encoder, \"encoder\");\n         this.decoder = requireNonNull(decoder, \"decoder\");\n     }\n \n     @Override\n     protected ChannelFuture writePing(ChannelHandlerContext ctx) {\n-        final HttpSession httpSession = HttpSession.get(channel);\n         final int id = httpSession.incrementAndGetNumRequestsSent();\n-        final int streamId = (id << 1) + 1;\n \n         decoder.setPingReqId(id);\n-        final ChannelFuture future = encoder.writeHeaders(id, streamId, HTTP1_PING_REQUEST, true);\n+        final ChannelFuture future = encoder.writeHeaders(id, 0, HTTP1_PING_REQUEST, true);\n         ctx.flush();\n         return future;\n     }\n \n     @Override\n     protected boolean hasRequestsInProgress(ChannelHandlerContext ctx) {\n-        return HttpSession.get(ctx.channel()).hasUnfinishedResponses();\n+        return httpSession.hasUnfinishedResponses();\n     }\n \n     boolean isPing(int id) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMTU4OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401321588", "bodyText": "It seems like we can replace this to a boolean field like isInitialized?", "author": "minwoox", "createdAt": "2020-04-01T02:31:13Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 6916cf887c..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyNzIwNw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401327207", "bodyText": "Can't we just assign TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis)?", "author": "minwoox", "createdAt": "2020-04-01T02:53:32Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4MzkyMw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401483923", "bodyText": "Thanks for pointing out, no longer needed. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-04-01T09:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyNzIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 6916cf887c..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyNzIzMQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401327231", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-01T02:53:39Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 6916cf887c..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyODE2NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401328164", "bodyText": "indentation?", "author": "minwoox", "createdAt": "2020-04-01T02:57:26Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -33,134 +32,56 @@\n import com.google.common.base.Stopwatch;\n \n import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n import io.netty.handler.codec.http2.Http2FrameWriter;\n import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n \n /**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@link Flags#defaultHttp2PingTimeoutMillis()} is greater that zero.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@link Flags#defaultUseHttp2PingWhenNoActiveStreams()}.\n+ * A {@link KeepAliveHandler} that sends HTTP2 PING frame\n+ * when neither read nor write was performed within the specified {@code pingIntervalMillis},\n+ * and closes the connection when neither read nor write was performed within\n+ * the given {@code idleTimeoutMillis}.\n  *\n  * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n+ * is read on connection will invalidate the condition that triggers connection closure.\n  *\n  * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n  * as {@link EventLoop}.\n  *\n- * @see Flags#defaultUseHttp2PingWhenNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n+ * @see Flags#defaultClientIdleTimeoutMillis()\n+ * @see Flags#defaultServerIdleTimeoutMillis()\n+ * @see Flags#defaultPingIntervalMillis()\n  */\n @NotThreadSafe\n-public class Http2KeepAliveHandler {\n+public abstract class Http2KeepAliveHandler extends KeepAliveHandler {\n \n     private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n \n     @Nullable\n     private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n     private final Http2FrameWriter frameWriter;\n     private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n     private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n \n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n     private long lastPingPayload;\n-    private State state = State.IDLE;\n \n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+    protected Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 String name, long idleTimeoutMillis, long pingIntervalMillis) {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "830b1427949561bec9ce446b63b10784387a2be8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\nindex 993d9415e8..250d1ca93c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n\n@@ -70,7 +70,7 @@ public abstract class Http2KeepAliveHandler extends KeepAliveHandler {\n     private long lastPingPayload;\n \n     protected Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+                                    String name, long idleTimeoutMillis, long pingIntervalMillis) {\n         super(channel, name, idleTimeoutMillis, pingIntervalMillis);\n         this.channel = requireNonNull(channel, \"channel\");\n         this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyOTIzOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401329239", "bodyText": "Seems like Http2ResponseDecoder checks if keepAliveHandler is null or not in onPingRead.\nI think we should do the same approach: assert or null check.", "author": "minwoox", "createdAt": "2020-04-01T03:01:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +284,41 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof LastHttpContent) {\n+            onPingComplete();\n+        } else {\n+            keepAliveHandler.onPing();", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4NzEyMA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401487120", "bodyText": "This method is called when isPing() is true so I didn't add a null check.\nHowever, it looks good to add assert.", "author": "ikhoon", "createdAt": "2020-04-01T09:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyOTIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex c1f8786a14..3c2e4e8895 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -285,13 +285,13 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n         ctx.fireExceptionCaught(cause);\n     }\n \n-    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n-        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void destroyKeepAliveHandler() {\n+    private void keepAliveDestroy() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzNjg1NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401336855", "bodyText": "a PING?", "author": "minwoox", "createdAt": "2020-04-01T03:33:32Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -702,36 +700,20 @@ public static boolean defaultUseHttp1Pipelining() {\n     }\n \n     /**\n-     * Returns whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n+     * Returns the default value for the PING interval.\n+     * An <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1 client, or\n+     * <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 server and client.", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ4OTc5OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401489798", "bodyText": "Oops, I've fixed it yesterday, but didn't push it. \ud83d\ude31", "author": "ikhoon", "createdAt": "2020-04-01T09:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzNjg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "830b1427949561bec9ce446b63b10784387a2be8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 7913a0a378..c9946b810c 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -702,8 +702,8 @@ public final class Flags {\n     /**\n      * Returns the default value for the PING interval.\n      * An <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1 client, or\n-     * <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 server and client.\n+     * is sent for HTTP/1 client, or a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame\n+     * is sent for HTTP/2 server and client.\n      *\n      * <p>Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n      * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzODg0Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401338847", "bodyText": "not relevant to this change but is it This condition can be false ...?", "author": "minwoox", "createdAt": "2020-04-01T03:42:34Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -169,21 +90,21 @@ public void onPingAck(long data) {\n             return;\n         }\n \n+        onPing();\n+        final Future<?> shutdownFuture = shutdownFuture();\n         if (shutdownFuture != null) {\n             final boolean isCancelled = shutdownFuture.cancel(false);\n             if (!isCancelled) {\n                 logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n             }\n         }\n         logger.debug(\"{} PING(ACK=1, DATA={}) received in {} ns\", channel, lastPingPayload, elapsed);\n-        state = State.IDLE;\n-        resetFutures();\n     }\n \n     private boolean isGoodPingAck(long data) {\n         // This condition can be true when channel read some data other than PING ACK frame", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\nindex 993d9415e8..f78ebc7c03 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n\n@@ -102,7 +102,7 @@ public abstract class Http2KeepAliveHandler extends KeepAliveHandler {\n     }\n \n     private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n+        // 'isPendingPingAck()' can return false when channel read some data other than PING ACK frame\n         // or a PING ACK is received without sending PING in first place.\n         if (!isPendingPingAck()) {\n             logger.debug(\"{} PING(ACK=1, DATA={}) ignored\", channel, data);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzOTgzNw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401339837", "bodyText": "@Nullable?", "author": "minwoox", "createdAt": "2020-04-01T03:46:48Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        state = 2;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = lastPingIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = firstPingIdleEvent = true;\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    protected final Future<?> shutdownFuture() {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 6916cf887c..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM2Nzc0Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401367746", "bodyText": "Could just do this after newIdleStateEvent is called and remove first.", "author": "minwoox", "createdAt": "2020-04-01T05:42:56Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        state = 2;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = lastPingIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = firstPingIdleEvent = true;\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {\n+        if (evt.state() == IdleState.CONNECTION_IDLE && evt.isFirst()) {\n+            if (!hasRequestsInProgress(ctx)) {\n+                pingState = PingState.SHUTDOWN;\n+                logger.debug(\"{} Closing an idle {} connection\", ctx.channel(), name);\n+                ctx.channel().close();\n+            }\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0 && evt.state() == IdleState.PING_IDLE && evt.isFirst()) {\n+            pingState = PingState.PING_SCHEDULED;\n+            writePing(ctx).addListener(pingWriteListener);\n+        }\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an idle channel\", channel);\n+            } else {\n+                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n+            }\n+            pingState = PingState.SHUTDOWN;\n+        });\n+    }\n+\n+    private ScheduledExecutorService executor() {\n+        return channel.eventLoop();\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    @VisibleForTesting\n+    enum PingState {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} PING write successful\", channel);\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+                pingState = PingState.PENDING_PING_ACK;\n+                resetStopwatch();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on destroy.\n+                if (!future.isCancelled() && Exceptions.isExpected(future.cause())) {\n+                    logger.debug(\"{} PING write failed\", channel, future.cause());\n+                }\n+                if (pingState != PingState.SHUTDOWN) {\n+                    pingState = PingState.IDLE;\n+                }\n+            }\n+        }\n+\n+        private void resetStopwatch() {\n+            if (stopwatch != null) {\n+                stopwatch.reset().start();\n+            }\n+        }\n+    }\n+\n+    private abstract static class AbstractIdleTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        AbstractIdleTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (!ctx.channel().isOpen()) {\n+                return;\n+            }\n+\n+            run(ctx);\n+        }\n+\n+        protected abstract void run(ChannelHandlerContext ctx);\n+    }\n+\n+    private final class ConnectionIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        ConnectionIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastConnectionIdleTime = KeepAliveHandler.this.lastConnectionIdleTime;\n+            final long nextDelay = connectionIdleTimeNanos - (System.nanoTime() - lastConnectionIdleTime);\n+            if (nextDelay <= 0) {\n+                // Both reader and writer are idle - set a new timeout and\n+                // notify the callback.\n+                connectionIdleTimeout = executor().schedule(this, connectionIdleTimeNanos,\n+                                                            TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstConnectionIdleEvent;\n+                firstConnectionIdleEvent = false;", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 6916cf887c..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM2ODAyOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401368028", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-01T05:43:57Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: state=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private byte state; // 0 - none, 1 - initialized, 2 - destroyed\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private PingState pingState = PingState.IDLE;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis),\n+                                               MIN_TIMEOUT_NANOS);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = Math.max(TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis), MIN_TIMEOUT_NANOS);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        switch (state) {\n+            case 1:\n+            case 2:\n+                return;\n+        }\n+\n+        state = 1;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        state = 2;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0 || pingIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = lastPingIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = firstPingIdleEvent = true;\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {\n+        if (evt.state() == IdleState.CONNECTION_IDLE && evt.isFirst()) {\n+            if (!hasRequestsInProgress(ctx)) {\n+                pingState = PingState.SHUTDOWN;\n+                logger.debug(\"{} Closing an idle {} connection\", ctx.channel(), name);\n+                ctx.channel().close();\n+            }\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0 && evt.state() == IdleState.PING_IDLE && evt.isFirst()) {\n+            pingState = PingState.PING_SCHEDULED;\n+            writePing(ctx).addListener(pingWriteListener);\n+        }\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an idle channel\", channel);\n+            } else {\n+                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n+            }\n+            pingState = PingState.SHUTDOWN;\n+        });\n+    }\n+\n+    private ScheduledExecutorService executor() {\n+        return channel.eventLoop();\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    @VisibleForTesting\n+    enum PingState {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} PING write successful\", channel);\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+                pingState = PingState.PENDING_PING_ACK;\n+                resetStopwatch();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on destroy.\n+                if (!future.isCancelled() && Exceptions.isExpected(future.cause())) {\n+                    logger.debug(\"{} PING write failed\", channel, future.cause());\n+                }\n+                if (pingState != PingState.SHUTDOWN) {\n+                    pingState = PingState.IDLE;\n+                }\n+            }\n+        }\n+\n+        private void resetStopwatch() {\n+            if (stopwatch != null) {\n+                stopwatch.reset().start();\n+            }\n+        }\n+    }\n+\n+    private abstract static class AbstractIdleTask implements Runnable {\n+\n+        private final ChannelHandlerContext ctx;\n+\n+        AbstractIdleTask(ChannelHandlerContext ctx) {\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (!ctx.channel().isOpen()) {\n+                return;\n+            }\n+\n+            run(ctx);\n+        }\n+\n+        protected abstract void run(ChannelHandlerContext ctx);\n+    }\n+\n+    private final class ConnectionIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        ConnectionIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastConnectionIdleTime = KeepAliveHandler.this.lastConnectionIdleTime;\n+            final long nextDelay = connectionIdleTimeNanos - (System.nanoTime() - lastConnectionIdleTime);\n+            if (nextDelay <= 0) {\n+                // Both reader and writer are idle - set a new timeout and\n+                // notify the callback.\n+                connectionIdleTimeout = executor().schedule(this, connectionIdleTimeNanos,\n+                                                            TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstConnectionIdleEvent;\n+                firstConnectionIdleEvent = false;\n+                final IdleStateEvent event = newIdleStateEvent(IdleState.CONNECTION_IDLE, first);\n+                try {\n+                    onIdleEvent(ctx, event);\n+                } catch (Exception e) {\n+                    if (!warn) {\n+                        logger.warn(\"An error occurred while notifying an all idle event\", e);\n+                        warn = true;\n+                    }\n+                }\n+            } else {\n+                // Either read or write occurred before the connection idle timeout - set a new\n+                // timeout with shorter delay.\n+                connectionIdleTimeout = executor().schedule(this, nextDelay, TimeUnit.NANOSECONDS);\n+            }\n+        }\n+    }\n+\n+    private final class PingIdleTimeoutTask extends AbstractIdleTask {\n+\n+        private boolean warn;\n+\n+        PingIdleTimeoutTask(ChannelHandlerContext ctx) {\n+            super(ctx);\n+        }\n+\n+        @Override\n+        protected void run(ChannelHandlerContext ctx) {\n+\n+            final long lastPingIdleTime = KeepAliveHandler.this.lastPingIdleTime;\n+            final long nextDelay = pingIdleTimeNanos - (System.nanoTime() - lastPingIdleTime);\n+            if (nextDelay <= 0) {\n+                // PING is idle - set a new timeout and notify the callback.\n+                pingIdleTimeout = executor().schedule(this, pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+\n+                final boolean first = firstPingIdleEvent;\n+                firstPingIdleEvent = false;", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 6916cf887c..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzYwOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401437608", "bodyText": "Question: do we need to check ctx.channel().isRegistered()?", "author": "minwoox", "createdAt": "2020-04-01T08:21:51Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java", "diffHunk": "@@ -312,4 +342,18 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc\n \n         ctx.fireUserEventTriggered(evt);\n     }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        final KeepAliveHandler keepAliveHandler = writer.keepAliveHandler();\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5NzMzOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401497339", "bodyText": "The original IdleStateHandler checks ctx.channel().isRegistered(). https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateHandler.java#L241\nIf this method is called by handlerAdded(), I think the condition is meaningful.", "author": "ikhoon", "createdAt": "2020-04-01T09:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java b/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\nindex dee164d6f0..52cc4b9ced 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Http1RequestDecoder.java\n\n@@ -343,15 +351,13 @@ final class Http1RequestDecoder extends ChannelDuplexHandler {\n         ctx.fireUserEventTriggered(evt);\n     }\n \n-    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n-        final KeepAliveHandler keepAliveHandler = writer.keepAliveHandler();\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n         if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void destroyKeepAliveHandler() {\n-        final KeepAliveHandler keepAliveHandler = writer.keepAliveHandler();\n+    private void keepAliveDestroy() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTEzNA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401441134", "bodyText": "Question: do we need this handler for Http2PrefaceOrHttpHandler?", "author": "minwoox", "createdAt": "2020-04-01T08:27:59Z", "path": "core/src/main/java/com/linecorp/armeria/server/HttpServerPipelineConfigurator.java", "diffHunk": "@@ -448,20 +447,38 @@ public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws E\n \n         private final ServerHttp1ObjectEncoder responseEncoder;\n         @Nullable\n+        private final KeepAliveHandler keepAliveHandler;\n+        @Nullable\n         private String name;\n \n         Http2PrefaceOrHttpHandler(ServerHttp1ObjectEncoder responseEncoder) {\n             this.responseEncoder = responseEncoder;\n+            keepAliveHandler = responseEncoder.keepAliveHandler();", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwNTA3OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401505078", "bodyText": "Yes. When a client connects a connection and does not send any packets, we have to close the connection after an idle timeout.", "author": "ikhoon", "createdAt": "2020-04-01T10:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyNDEzNw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401524137", "bodyText": "The following test failed without this. \ud83d\ude00\n\n  \n    \n      armeria/core/src/test/java/com/linecorp/armeria/server/ServerTest.java\n    \n    \n         Line 286\n      in\n      46eff82\n    \n    \n    \n    \n\n        \n          \n           void testIdleTimeoutByNoContentSent() throws Exception {", "author": "ikhoon", "createdAt": "2020-04-01T10:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTEzNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTMxMA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401441310", "bodyText": "an HTTP/2", "author": "minwoox", "createdAt": "2020-04-01T08:28:17Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +460,21 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n-     *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\nindex 6e9237f7d8..961a45376f 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n\n@@ -461,7 +461,7 @@ public final class ServerBuilder {\n \n     /**\n      * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n-     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n+     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n      */\n     public ServerBuilder pingIntervalMillis(long pingIntervalMillis) {\n         this.pingIntervalMillis = validateNonNegative(pingIntervalMillis, \"pingIntervalMillis\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0MTM5MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401441390", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-01T08:28:25Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +460,21 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n-     *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n      */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n+    public ServerBuilder pingIntervalMillis(long pingIntervalMillis) {\n+        this.pingIntervalMillis = validateNonNegative(pingIntervalMillis, \"pingIntervalMillis\");\n         return this;\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n-     *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\nindex 6e9237f7d8..961a45376f 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n\n@@ -461,7 +461,7 @@ public final class ServerBuilder {\n \n     /**\n      * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n-     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n+     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n      */\n     public ServerBuilder pingIntervalMillis(long pingIntervalMillis) {\n         this.pingIntervalMillis = validateNonNegative(pingIntervalMillis, \"pingIntervalMillis\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401446500", "bodyText": "I think this test will make flaky test. How about using just await() after clientIdleTimeout elapsed?", "author": "minwoox", "createdAt": "2020-04-01T08:36:51Z", "path": "core/src/test/java/com/linecorp/armeria/server/HttpServerKeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.ConnectionPoolListener;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.server.logging.LoggingService;\n+import com.linecorp.armeria.testing.junit.server.ServerExtension;\n+\n+import io.netty.util.AttributeMap;\n+\n+class HttpServerKeepAliveHandlerTest {\n+\n+    private static final int serverIdleTimeout = 5000;\n+    private static final int serverPingInterval = 1000;\n+\n+    @RegisterExtension\n+    static ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.idleTimeoutMillis(serverIdleTimeout);\n+            sb.pingIntervalMillis(serverPingInterval);\n+            sb.decorator(LoggingService.newDecorator())\n+              .service(\"/\", (ctx, req) -> HttpResponse.of(\"OK\"));\n+        }\n+    };\n+\n+    private AtomicInteger counter;\n+    private ConnectionPoolListener listener;\n+\n+    @BeforeEach\n+    void setUp() {\n+        counter = new AtomicInteger();\n+        listener = new ConnectionPoolListener() {\n+            @Override\n+            public void connectionOpen(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                       InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                counter.incrementAndGet();\n+            }\n+\n+            @Override\n+            public void connectionClosed(SessionProtocol protocol, InetSocketAddress remoteAddr,\n+                                         InetSocketAddress localAddr, AttributeMap attrs) throws Exception {\n+                counter.decrementAndGet();\n+            }\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({ \"H1C\", \"H2C\" })\n+    void closeByClientIdleTimeout(SessionProtocol protocol) throws InterruptedException {\n+        final int clientIdleTimeout = 2000;\n+        final ClientFactory factory = ClientFactory.builder()\n+                                                   .idleTimeoutMillis(clientIdleTimeout)\n+                                                   .connectionPoolListener(listener)\n+                                                   .build();\n+        final WebClient client = WebClient.builder(server.uri(protocol))\n+                                          .factory(factory)\n+                                          .build();\n+\n+        client.get(\"/\").aggregate().join();\n+\n+        // HTTP/2 PING frame sent by the server cannot prevent to close an idle connection.\n+        Thread.sleep(clientIdleTimeout + 1000);", "originalCommit": "7ba9f0eeb2440d48bf0f6acf842b6bcaae510ce4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwMjYyOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401502629", "bodyText": "Unfortunately, we should not use await() because clientIdleTimeout is 2000 and serverIdleTimeout is 5000.\nI wanted to check whether the connection is closed by the client-side.\nIf it waits more than 5000 milliseconds here, we don't know which closes the connection.\nProbably we could multiply the timeouts by 2 and use await().timeout(serverIdleTimeout - buffer).", "author": "ikhoon", "createdAt": "2020-04-01T10:08:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5NTM3MQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401995371", "bodyText": "Then How about just checking if serverIdleTimeout is passed or not after the counter becomes 0?\nAlso, don't we need to check if the counter was 1 before it gets to 0?", "author": "minwoox", "createdAt": "2020-04-02T01:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk5NTY5OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r401995699", "bodyText": "Oh, that sounds good.", "author": "ikhoon", "createdAt": "2020-04-02T01:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ0NjUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "5b4794e5d12a22917930848057f70acd2f38a40a", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/server/HttpServerKeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/server/HttpServerKeepAliveHandlerTest.java\nindex 40d169f61f..9b76661c33 100644\n--- a/core/src/test/java/com/linecorp/armeria/server/HttpServerKeepAliveHandlerTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/server/HttpServerKeepAliveHandlerTest.java\n\n@@ -17,16 +17,21 @@\n package com.linecorp.armeria.server;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.awaitility.Awaitility.await;\n \n import java.net.InetSocketAddress;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import org.hamcrest.Matchers;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.RegisterExtension;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n \n+import com.google.common.base.Stopwatch;\n+\n import com.linecorp.armeria.client.ClientFactory;\n import com.linecorp.armeria.client.ConnectionPoolListener;\n import com.linecorp.armeria.client.WebClient;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwOTQ5NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402209495", "bodyText": "A user might find this inconvenient because he or she has to update the both settings when he or she wants to disable the ping and reduce the idle timeout. How about automatically disabling ping interval when it's greater than idle timeout?", "author": "trustin", "createdAt": "2020-04-02T10:26:01Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,7 +555,16 @@ private ClientFactoryOptions buildOptions() {\n             return ClientFactoryOption.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n \n-        return ClientFactoryOptions.of(options.values());\n+        final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n+        final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n+        final long pingIntervalMillis = newOptions.pingIntervalMillis();\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n+                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n+                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n+                          idleTimeoutMillis, pingIntervalMillis);\n+        }\n+        return newOptions;", "originalCommit": "484e319f4f1f660c1c139def88c4e4a1d4d46bb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxMzEyNA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402713124", "bodyText": "SGTM, disabled ping interval automatically and updated Javadoc.", "author": "ikhoon", "createdAt": "2020-04-03T03:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIwOTQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "69655ac442a81900523d1de83e41aa8ca376d3fe", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex 6af9e51e93..df14edfb0a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -558,11 +564,8 @@ public final class ClientFactoryBuilder {\n         final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n         final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n         final long pingIntervalMillis = newOptions.pingIntervalMillis();\n-        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n-            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n-                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n-                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n-                          idleTimeoutMillis, pingIntervalMillis);\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n+            return ClientFactoryOptions.of(newOptions, ClientFactoryOption.PING_INTERVAL_MILLIS.newValue(0L));\n         }\n         return newOptions;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxNDIxMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402214212", "bodyText": "I think it's not very common but:\n\nAn OPTIONS response can have chunked content.\nHTTP/1 decoder may emit a FullHttpResponse which is both an HttpResponse and an LastHttpContent.\n\nIn such cases, keepAliveHandler.onPing() can be invoked more or less than desired.", "author": "trustin", "createdAt": "2020-04-02T10:34:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +279,47 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeInitializeKeepAliveHandler(ctx);\n+    }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof LastHttpContent) {\n+            onPingComplete();\n+        } else {\n+            assert keepAliveHandler != null;\n+            keepAliveHandler.onPing();\n+        }", "originalCommit": "484e319f4f1f660c1c139def88c4e4a1d4d46bb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcxNDUzMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402714532", "bodyText": "Good point, I didn't think of that.", "author": "ikhoon", "createdAt": "2020-04-03T03:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIxNDIxMg=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex acbe66ff63..3c2e4e8895 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -280,18 +285,13 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n         ctx.fireExceptionCaught(cause);\n     }\n \n-    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n-        this.keepAliveHandler = keepAliveHandler;\n-        maybeInitializeKeepAliveHandler(ctx);\n-    }\n-\n-    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n-        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void destroyKeepAliveHandler() {\n+    private void keepAliveDestroy() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMDMzOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r402220338", "bodyText": "What happens if a server doesn't respond to a ping? Do we send another OPTIONS *? I guess we should not send another OPTIONS * but close the connection, unlike HTTP/2.", "author": "trustin", "createdAt": "2020-04-02T10:45:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +279,47 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeInitializeKeepAliveHandler(ctx);\n+    }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof LastHttpContent) {\n+            onPingComplete();\n+        } else {\n+            assert keepAliveHandler != null;\n+            keepAliveHandler.onPing();\n+        }\n+    }\n+\n+    void setPingReqId(int id) {\n+        lastPingReqId = id;\n+    }\n+\n+    boolean isPingReqId(int id) {\n+        return lastPingReqId == id;\n+    }", "originalCommit": "484e319f4f1f660c1c139def88c4e4a1d4d46bb4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex acbe66ff63..3c2e4e8895 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -280,18 +285,13 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n         ctx.fireExceptionCaught(cause);\n     }\n \n-    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n-        this.keepAliveHandler = keepAliveHandler;\n-        maybeInitializeKeepAliveHandler(ctx);\n-    }\n-\n-    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n-        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void destroyKeepAliveHandler() {\n+    private void keepAliveDestroy() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0Njg0MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403846840", "bodyText": "Could use a singleton.", "author": "trustin", "createdAt": "2020-04-06T06:03:17Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,11 +564,8 @@ private ClientFactoryOptions buildOptions() {\n         final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n         final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n         final long pingIntervalMillis = newOptions.pingIntervalMillis();\n-        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n-            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n-                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n-                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n-                          idleTimeoutMillis, pingIntervalMillis);\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n+            return ClientFactoryOptions.of(newOptions, ClientFactoryOption.PING_INTERVAL_MILLIS.newValue(0L));", "originalCommit": "b5d13a4136d6a6826b4a42dd085863538662ffad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex df14edfb0a..ab64416832 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -564,8 +558,11 @@ public final class ClientFactoryBuilder {\n         final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n         final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n         final long pingIntervalMillis = newOptions.pingIntervalMillis();\n-        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n-            return ClientFactoryOptions.of(newOptions, ClientFactoryOption.PING_INTERVAL_MILLIS.newValue(0L));\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n+                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n+                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n+                          idleTimeoutMillis, pingIntervalMillis);\n         }\n         return newOptions;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0ODYzNA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r403848634", "bodyText": "nit: how about mentioning HTTP/2's case first?", "author": "trustin", "createdAt": "2020-04-06T06:08:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +419,39 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1,\n+     * or a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.", "originalCommit": "b5d13a4136d6a6826b4a42dd085863538662ffad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex df14edfb0a..ab64416832 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -423,10 +423,7 @@ public final class ClientFactoryBuilder {\n      * When neither read nor write was performed for the given {@code pingIntervalMillis},\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n      * is sent for HTTP/1,\n-     * or a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n      * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405200926", "bodyText": "Do we need this?", "author": "minwoox", "createdAt": "2020-04-08T01:07:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,7 +572,19 @@ private ClientFactoryOptions buildOptions() {\n             return ClientFactoryOption.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n \n-        return ClientFactoryOptions.of(options.values());\n+        final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n+        final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n+        final long pingIntervalMillis = newOptions.pingIntervalMillis();\n+        final long minPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n+        if (idleTimeoutMillis > 0) {\n+            if (minPingIntervalMillis >= idleTimeoutMillis) {\n+                return ClientFactoryOptions.of(newOptions, ZERO_PING_INTERVAL);\n+            }\n+            if (minPingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUzNjcwMg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405536702", "bodyText": "Because the default PING interval could be set by Flags.defaultPingIntervalMillis().\nIf the default PING interval is smaller than 10 seconds, bumps that to 10 seconds.", "author": "ikhoon", "createdAt": "2020-04-08T13:45:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwMzYxMQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405903611", "bodyText": "When I left the comment there was no\nif (pingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {\n    return newOptions;\n}\nthis condition, so I left the comment. I guess it's fixed now.", "author": "minwoox", "createdAt": "2020-04-09T01:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxNzAzOA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405917038", "bodyText": "Ah... thanks!", "author": "ikhoon", "createdAt": "2020-04-09T02:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMDkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex c0bf74cff6..ab64416832 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -575,14 +558,11 @@ public final class ClientFactoryBuilder {\n         final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n         final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n         final long pingIntervalMillis = newOptions.pingIntervalMillis();\n-        final long minPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n-        if (idleTimeoutMillis > 0) {\n-            if (minPingIntervalMillis >= idleTimeoutMillis) {\n-                return ClientFactoryOptions.of(newOptions, ZERO_PING_INTERVAL);\n-            }\n-            if (minPingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {\n-                return ClientFactoryOptions.of(newOptions, MIN_PING_INTERVAL);\n-            }\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n+                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n+                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n+                          idleTimeoutMillis, pingIntervalMillis);\n         }\n         return newOptions;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMjQ4Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405202487", "bodyText": "Shouldn't we subscribe to this to prevent memory leak?", "author": "minwoox", "createdAt": "2020-04-08T01:13:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java", "diffHunk": "@@ -263,4 +279,48 @@ public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exceptio\n     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n         ctx.fireExceptionCaught(cause);\n     }\n+\n+    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n+        this.keepAliveHandler = keepAliveHandler;\n+        maybeInitializeKeepAliveHandler(ctx);\n+    }\n+\n+    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+            keepAliveHandler.initialize(ctx);\n+        }\n+    }\n+\n+    private void destroyKeepAliveHandler() {\n+        if (keepAliveHandler != null) {\n+            keepAliveHandler.destroy();\n+        }\n+    }\n+\n+    private void onPingRead(Object msg) {\n+        if (msg instanceof HttpResponse) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0Nzc1OA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405547758", "bodyText": "It's Netty HttpResponse. I forgot to release it. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-04-08T14:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMjQ4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\nindex 49fb524fd3..3c2e4e8895 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http1ResponseDecoder.java\n\n@@ -280,33 +285,30 @@ final class Http1ResponseDecoder extends HttpResponseDecoder implements ChannelI\n         ctx.fireExceptionCaught(cause);\n     }\n \n-    void setKeepAliveHandler(ChannelHandlerContext ctx, KeepAliveHandler keepAliveHandler) {\n-        this.keepAliveHandler = keepAliveHandler;\n-        maybeInitializeKeepAliveHandler(ctx);\n-    }\n-\n-    private void maybeInitializeKeepAliveHandler(ChannelHandlerContext ctx) {\n-        if (keepAliveHandler != null && ctx.channel().isActive()) {\n+    private void maybeKeepAliveInitialize(ChannelHandlerContext ctx) {\n+        if (keepAliveHandler != null && ctx.channel().isActive() && ctx.channel().isRegistered()) {\n             keepAliveHandler.initialize(ctx);\n         }\n     }\n \n-    private void destroyKeepAliveHandler() {\n+    private void keepAliveDestroy() {\n         if (keepAliveHandler != null) {\n             keepAliveHandler.destroy();\n         }\n     }\n \n     private void onPingRead(Object msg) {\n-        if (msg instanceof HttpResponse) {\n-            assert keepAliveHandler != null;\n-            keepAliveHandler.onPing();\n-        }\n         if (msg instanceof LastHttpContent) {\n             onPingComplete();\n+        } else {\n+            keepAliveHandler.onPing();\n         }\n     }\n \n+    private boolean isPing() {\n+        return lastPingReqId == resId;\n+    }\n+\n     void setPingReqId(int id) {\n         lastPingReqId = id;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwOTU0MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405209540", "bodyText": "If the event is not first, then the channel is not closed even there's no requests in progress?", "author": "minwoox", "createdAt": "2020-04-08T01:39:43Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: initialized=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private boolean isInitialized;\n+    private PingState pingState = PingState.IDLE;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        if (isInitialized) {\n+            return;\n+        }\n+        isInitialized = true;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        isInitialized = true;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = true;\n+        }\n+\n+        if (pingResetsPreviousPing()) {\n+            if (pingIdleTimeNanos > 0) {\n+                lastPingIdleTime = System.nanoTime();\n+                firstPingIdleEvent = true;\n+            }\n+            pingState = PingState.IDLE;\n+            cancelFutures();\n+        }\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean pingResetsPreviousPing();\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    @Nullable\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {\n+        if (evt.state() == IdleState.CONNECTION_IDLE && evt.isFirst()) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU5ODI5OQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405598299", "bodyText": "The original code in IdleTimeoutHandler is:\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\n    \n    \n        Lines 57 to 64\n      in\n      b1bb733\n    \n    \n    \n    \n\n        \n          \n           if (!evt.isFirst()) { \n        \n\n        \n          \n               return; \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           if (!hasRequestsInProgress(ctx)) { \n        \n\n        \n          \n               logger.debug(\"{} Closing an idle {} connection\", ctx.channel(), name); \n        \n\n        \n          \n               ctx.channel().close(); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI will investigate more to know how the connection is handled on idle with active requests.", "author": "ikhoon", "createdAt": "2020-04-08T15:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwOTU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYzMjk5Nw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405632997", "bodyText": "A connection is not closed when an active request is closed by the request timeout after the first CONNECTION_IDLE event. This behavior seems weird because there are no active requests in the connection.\nLet me remove evt.isFirst() condition.", "author": "ikhoon", "createdAt": "2020-04-08T15:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwOTU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex df06a47980..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxMDg1NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405210854", "bodyText": "Can remove idleTimeoutMillis > 0.", "author": "minwoox", "createdAt": "2020-04-08T01:45:00Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -1406,6 +1401,11 @@ public ServerBuilder annotatedServiceExtensions(\n      * Returns a newly-created {@link Server} based on the configuration properties set so far.\n      */\n     public Server build() {\n+        long pingIntervalMillis = Math.max(this.pingIntervalMillis, 10_000L);\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {", "originalCommit": "32e036591c7d89eae4a73ac17bc1f95bbd37b565", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\nindex 971b4f89fb..6e9237f7d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n\n@@ -1401,9 +1393,11 @@ public final class ServerBuilder {\n      * Returns a newly-created {@link Server} based on the configuration properties set so far.\n      */\n     public Server build() {\n-        long pingIntervalMillis = Math.max(this.pingIntervalMillis, 10_000L);\n-        if (idleTimeoutMillis > 0 && pingIntervalMillis >= idleTimeoutMillis) {\n-            pingIntervalMillis = 0;\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            checkArgument(idleTimeoutMillis > pingIntervalMillis,\n+                          \"idleTimeoutMillis: %s, pingIntervalMillis: %s \" +\n+                          \"(expected: idleTimeoutMillis > pingIntervalMillis)\",\n+                          idleTimeoutMillis, pingIntervalMillis);\n         }\n \n         final AnnotatedServiceExtensions extensions =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNTU5Mw==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405905593", "bodyText": "This could be\n<p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.", "author": "minwoox", "createdAt": "2020-04-09T01:27:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,44 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n+     *                                  is smaller than 10000 milliseconds.\n+     */\n+    public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n+        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n+                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n+                      MIN_PING_INTERVAL_MILLIS);\n+        option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets whether to send HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * when there are no active streams open.\n+     * Sets the PING interval.\n+     * When neither read nor write was performed for the given {@code pingInterval},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n+     *\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n+     *\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex c82e3793f0..ab64416832 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -430,42 +421,31 @@ public final class ClientFactoryBuilder {\n     /**\n      * Sets the PING interval in milliseconds.\n      * When neither read nor write was performed for the given {@code pingIntervalMillis},\n-     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n-        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n-                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n-                      MIN_PING_INTERVAL_MILLIS);\n+        checkArgument(pingIntervalMillis >= 0,\n+                      \"pingIntervalMillis: %s (expected: >= 0)\", pingIntervalMillis);\n         option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets the PING interval.\n+     * Sets the PING interval in milliseconds.\n      * When neither read nor write was performed for the given {@code pingInterval},\n-     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingInterval} is smaller than 10 seconds.\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingInterval(Duration pingInterval) {\n-        pingIntervalMillis(requireNonNull(pingInterval, \"pingInterval\").toMillis());\n+        requireNonNull(pingInterval, \"pingInterval\");\n+        checkArgument(pingInterval.toMillis() >= 0,\n+                      \"pingInterval: %s (expected: >= 0)\", pingInterval.toMillis());\n+        pingIntervalMillis(pingInterval.toMillis());\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNTY0NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405905645", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-09T01:28:07Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,44 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex c82e3793f0..ab64416832 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -430,42 +421,31 @@ public final class ClientFactoryBuilder {\n     /**\n      * Sets the PING interval in milliseconds.\n      * When neither read nor write was performed for the given {@code pingIntervalMillis},\n-     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n-        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n-                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n-                      MIN_PING_INTERVAL_MILLIS);\n+        checkArgument(pingIntervalMillis >= 0,\n+                      \"pingIntervalMillis: %s (expected: >= 0)\", pingIntervalMillis);\n         option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets the PING interval.\n+     * Sets the PING interval in milliseconds.\n      * When neither read nor write was performed for the given {@code pingInterval},\n-     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingInterval} is smaller than 10 seconds.\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingInterval(Duration pingInterval) {\n-        pingIntervalMillis(requireNonNull(pingInterval, \"pingInterval\").toMillis());\n+        requireNonNull(pingInterval, \"pingInterval\");\n+        checkArgument(pingInterval.toMillis() >= 0,\n+                      \"pingInterval: %s (expected: >= 0)\", pingInterval.toMillis());\n+        pingIntervalMillis(pingInterval.toMillis());\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNjA4Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405906086", "bodyText": "ditto. Could use {@value }", "author": "minwoox", "createdAt": "2020-04-09T01:29:56Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,44 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n+     *                                  is smaller than 10000 milliseconds.\n+     */\n+    public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n+        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n+                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n+                      MIN_PING_INTERVAL_MILLIS);\n+        option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets whether to send HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * when there are no active streams open.\n+     * Sets the PING interval.\n+     * When neither read nor write was performed for the given {@code pingInterval},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n+     *\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n+     *\n+     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingInterval} is smaller than 10 seconds.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex c82e3793f0..ab64416832 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -430,42 +421,31 @@ public final class ClientFactoryBuilder {\n     /**\n      * Sets the PING interval in milliseconds.\n      * When neither read nor write was performed for the given {@code pingIntervalMillis},\n-     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingIntervalMillis(long pingIntervalMillis) {\n-        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n-                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n-                      MIN_PING_INTERVAL_MILLIS);\n+        checkArgument(pingIntervalMillis >= 0,\n+                      \"pingIntervalMillis: %s (expected: >= 0)\", pingIntervalMillis);\n         option(ClientFactoryOption.PING_INTERVAL_MILLIS, pingIntervalMillis);\n         return this;\n     }\n \n     /**\n-     * Sets the PING interval.\n+     * Sets the PING interval in milliseconds.\n      * When neither read nor write was performed for the given {@code pingInterval},\n-     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n      * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n-     * is sent for HTTP/1.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds. {@code 0} means the client will not send a PING.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingInterval} is smaller than 10 seconds.\n+     * is sent for HTTP/1,\n+     * or <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2.\n+     * {@code 0} means the client will not send a PING.\n      */\n     public ClientFactoryBuilder pingInterval(Duration pingInterval) {\n-        pingIntervalMillis(requireNonNull(pingInterval, \"pingInterval\").toMillis());\n+        requireNonNull(pingInterval, \"pingInterval\");\n+        checkArgument(pingInterval.toMillis() >= 0,\n+                      \"pingInterval: %s (expected: >= 0)\", pingInterval.toMillis());\n+        pingIntervalMillis(pingInterval.toMillis());\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNzU1MA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405907550", "bodyText": "nit: it's", "author": "minwoox", "createdAt": "2020-04-09T01:35:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleStateEvent.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+/**\n+ * An idle state event triggered by {@link KeepAliveHandler}.\n+ */\n+class IdleStateEvent {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    public static final IdleStateEvent FIRST_CONNECTION_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.CONNECTION_IDLE, true);\n+    public static final IdleStateEvent CONNECTION_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.CONNECTION_IDLE, false);\n+    public static final IdleStateEvent FIRST_PING_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.PING_IDLE, true);\n+    public static final IdleStateEvent PING_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.PING_IDLE, false);\n+\n+    private final IdleState state;\n+    private final boolean first;\n+\n+    /**\n+     * Constructor for sub-classes.\n+     *\n+     * @param state the {@link IdleStateEvent} which triggered the event.\n+     * @param first {@code true} if its the first idle event for the {@link IdleStateEvent}.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleStateEvent.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleStateEvent.java\nindex d372619130..4024842c30 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleStateEvent.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleStateEvent.java\n\n@@ -30,22 +30,21 @@\n  */\n package com.linecorp.armeria.internal.common;\n \n-import static java.util.Objects.requireNonNull;\n-\n+import io.netty.util.internal.ObjectUtil;\n import io.netty.util.internal.StringUtil;\n \n /**\n- * An idle state event triggered by {@link KeepAliveHandler}.\n+ * An idle state event triggered by {@link IdleTimeoutScheduler}.\n  */\n class IdleStateEvent {\n \n     // Forked from Netty 4.1.48\n     // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n \n-    public static final IdleStateEvent FIRST_CONNECTION_IDLE_STATE_EVENT =\n-            new DefaultIdleStateEvent(IdleState.CONNECTION_IDLE, true);\n-    public static final IdleStateEvent CONNECTION_IDLE_STATE_EVENT =\n-            new DefaultIdleStateEvent(IdleState.CONNECTION_IDLE, false);\n+    public static final IdleStateEvent FIRST_ALL_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.ALL_IDLE, true);\n+    public static final IdleStateEvent ALL_IDLE_STATE_EVENT =\n+            new DefaultIdleStateEvent(IdleState.ALL_IDLE, false);\n     public static final IdleStateEvent FIRST_PING_IDLE_STATE_EVENT =\n             new DefaultIdleStateEvent(IdleState.PING_IDLE, true);\n     public static final IdleStateEvent PING_IDLE_STATE_EVENT =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwOTg0Mg==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405909842", "bodyText": "How about inlining this? I think connection and ping idle event doesn't have to be in the same place.", "author": "minwoox", "createdAt": "2020-04-09T01:44:59Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+/*\n+ * Copyright 2012 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n+import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+\n+/**\n+ * A {@link KeepAliveHandler} that writes a PING when neither read nor write was performed for\n+ * the specified {@code pingIntervalMillis}, and closes the connection\n+ * when neither read nor write was performed within the given {@code idleTimeoutMillis}.\n+ */\n+public abstract class KeepAliveHandler {\n+\n+    // Forked from Netty 4.1.48\n+    // https://github.com/netty/netty/blob/81513c3728df8add3c94fd0bdaaf9ba424925b29/handler/src/main/java/io/netty/handler/timeout/IdleStateEvent.java\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KeepAliveHandler.class);\n+\n+    private static IdleStateEvent newIdleStateEvent(IdleState state, boolean first) {\n+        switch (state) {\n+            case CONNECTION_IDLE:\n+                return first ? FIRST_CONNECTION_IDLE_STATE_EVENT : CONNECTION_IDLE_STATE_EVENT;\n+            case PING_IDLE:\n+                return first ? FIRST_PING_IDLE_STATE_EVENT : PING_IDLE_STATE_EVENT;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled: initialized=\" + state + \", first=\" + first);\n+        }\n+    }\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private final Channel channel;\n+    private final String name;\n+\n+    @Nullable\n+    private ScheduledFuture<?> connectionIdleTimeout;\n+    private final long connectionIdleTimeNanos;\n+    private long lastConnectionIdleTime;\n+    private boolean firstConnectionIdleEvent = true;\n+\n+    @Nullable\n+    private ScheduledFuture<?> pingIdleTimeout;\n+    private final long pingIdleTimeNanos;\n+    private long lastPingIdleTime;\n+    private boolean firstPingIdleEvent = true;\n+\n+    private boolean isInitialized;\n+    private PingState pingState = PingState.IDLE;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    protected KeepAliveHandler(Channel channel, String name, long idleTimeoutMillis, long pingIntervalMillis) {\n+        this.channel = channel;\n+        this.name = name;\n+\n+        if (idleTimeoutMillis <= 0) {\n+            connectionIdleTimeNanos = 0;\n+        } else {\n+            connectionIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(idleTimeoutMillis);\n+        }\n+        if (pingIntervalMillis <= 0) {\n+            pingIdleTimeNanos = 0;\n+        } else {\n+            pingIdleTimeNanos = TimeUnit.MILLISECONDS.toNanos(pingIntervalMillis);\n+        }\n+    }\n+\n+    public final void initialize(ChannelHandlerContext ctx) {\n+        // Avoid the case where destroy() is called before scheduling timeouts.\n+        // See: https://github.com/netty/netty/issues/143\n+        if (isInitialized) {\n+            return;\n+        }\n+        isInitialized = true;\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            connectionIdleTimeout = executor().schedule(new ConnectionIdleTimeoutTask(ctx),\n+                                                        connectionIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+        if (pingIdleTimeNanos > 0) {\n+            pingIdleTimeout = executor().schedule(new PingIdleTimeoutTask(ctx),\n+                                                  pingIdleTimeNanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+\n+    public final void destroy() {\n+        isInitialized = true;\n+        if (connectionIdleTimeout != null) {\n+            connectionIdleTimeout.cancel(false);\n+            connectionIdleTimeout = null;\n+        }\n+        if (pingIdleTimeout != null) {\n+            pingIdleTimeout.cancel(false);\n+            pingIdleTimeout = null;\n+        }\n+        pingState = PingState.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public final void onReadOrWrite() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (connectionIdleTimeNanos > 0) {\n+            lastConnectionIdleTime = System.nanoTime();\n+            firstConnectionIdleEvent = true;\n+        }\n+\n+        if (pingResetsPreviousPing()) {\n+            if (pingIdleTimeNanos > 0) {\n+                lastPingIdleTime = System.nanoTime();\n+                firstPingIdleEvent = true;\n+            }\n+            pingState = PingState.IDLE;\n+            cancelFutures();\n+        }\n+    }\n+\n+    public final void onPing() {\n+        if (pingState == PingState.SHUTDOWN) {\n+            return;\n+        }\n+\n+        if (pingIdleTimeNanos > 0) {\n+            firstPingIdleEvent = true;\n+            lastPingIdleTime = System.nanoTime();\n+        }\n+        pingState = PingState.IDLE;\n+        cancelFutures();\n+    }\n+\n+    protected abstract ChannelFuture writePing(ChannelHandlerContext ctx);\n+\n+    protected abstract boolean pingResetsPreviousPing();\n+\n+    protected abstract boolean hasRequestsInProgress(ChannelHandlerContext ctx);\n+\n+    @Nullable\n+    protected final Future<?> shutdownFuture() {\n+        return shutdownFuture;\n+    }\n+\n+    protected final boolean isPendingPingAck() {\n+        return pingState == PingState.PENDING_PING_ACK;\n+    }\n+\n+    @VisibleForTesting\n+    final PingState state() {\n+        return pingState;\n+    }\n+\n+    @VisibleForTesting\n+    void onIdleEvent(ChannelHandlerContext ctx, IdleStateEvent evt) {", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzODgwOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405938809", "bodyText": "That sounds good. I will remove this generalization.", "author": "ikhoon", "createdAt": "2020-04-09T03:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwOTg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\nindex 638f7020d6..eb77f71b74 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/KeepAliveHandler.java\n\n@@ -13,35 +13,14 @@\n  * License for the specific language governing permissions and limitations\n  * under the License.\n  */\n-/*\n- * Copyright 2012 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.internal.common.IdleStateEvent.CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_CONNECTION_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.FIRST_PING_IDLE_STATE_EVENT;\n-import static com.linecorp.armeria.internal.common.IdleStateEvent.PING_IDLE_STATE_EVENT;\n-\n import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n \n import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMDQ4MQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405910481", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-09T01:47:32Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +463,39 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(Duration http2PingTimeoutMillis) {\n-        requireNonNull(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        this.http2PingTimeoutMillis =\n-                validateNonNegative(http2PingTimeoutMillis.toMillis(), \"http2PingTimeoutMillis\");\n+     * <p>The minimum PING interval is 10 seconds.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\nindex f595462d1e..6e9237f7d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n\n@@ -464,38 +461,20 @@ public final class ServerBuilder {\n \n     /**\n      * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds.\n-     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n      */\n     public ServerBuilder pingIntervalMillis(long pingIntervalMillis) {\n-        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n-                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n-                      MIN_PING_INTERVAL_MILLIS);\n-        this.pingIntervalMillis = pingIntervalMillis;\n+        this.pingIntervalMillis = validateNonNegative(pingIntervalMillis, \"pingIntervalMillis\");\n         return this;\n     }\n \n     /**\n      * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds.\n-     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n      */\n     public ServerBuilder pingInterval(Duration pingInterval) {\n-        pingIntervalMillis(requireNonNull(pingInterval, \"pingInterval\").toMillis());\n+        requireNonNull(pingInterval, \"pingInterval\");\n+        pingIntervalMillis = validateNonNegative(pingInterval.toMillis(), \"pingInterval\");\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkxMDUyOQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r405910529", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-04-09T01:47:43Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +463,39 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(Duration http2PingTimeoutMillis) {\n-        requireNonNull(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        this.http2PingTimeoutMillis =\n-                validateNonNegative(http2PingTimeoutMillis.toMillis(), \"http2PingTimeoutMillis\");\n+     * <p>The minimum PING interval is 10 seconds.\n+     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n+     *                                  is smaller than 10000 milliseconds.", "originalCommit": "4850e0202f5307be535f26d4aad8d86ede1b05e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\nindex f595462d1e..6e9237f7d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n\n@@ -464,38 +461,20 @@ public final class ServerBuilder {\n \n     /**\n      * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds.\n-     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n      */\n     public ServerBuilder pingIntervalMillis(long pingIntervalMillis) {\n-        checkArgument(pingIntervalMillis == 0 || pingIntervalMillis >= MIN_PING_INTERVAL_MILLIS,\n-                      \"pingIntervalMillis: %s (expected: >= %s or == 0)\", pingIntervalMillis,\n-                      MIN_PING_INTERVAL_MILLIS);\n-        this.pingIntervalMillis = pingIntervalMillis;\n+        this.pingIntervalMillis = validateNonNegative(pingIntervalMillis, \"pingIntervalMillis\");\n         return this;\n     }\n \n     /**\n      * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n-     *\n-     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n-     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n-     *\n-     * <p>The minimum PING interval is 10 seconds.\n-     * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n-     *\n-     * @throws IllegalArgumentException if the specified {@code pingIntervalMillis}\n-     *                                  is smaller than 10000 milliseconds.\n+     * {@code 0} means the server will not send PING frames on a HTTP/2 connection.\n      */\n     public ServerBuilder pingInterval(Duration pingInterval) {\n-        pingIntervalMillis(requireNonNull(pingInterval, \"pingInterval\").toMillis());\n+        requireNonNull(pingInterval, \"pingInterval\");\n+        pingIntervalMillis = validateNonNegative(pingInterval.toMillis(), \"pingInterval\");\n         return this;\n     }\n \n"}}, {"oid": "15fe952b48ecafeaf7ab3da9dac1800770c5218c", "url": "https://github.com/line/armeria/commit/15fe952b48ecafeaf7ab3da9dac1800770c5218c", "message": "Add HTTP/1 PING(`OPTIONS *`)\n\nMotivation:\n\nSometimes, a client that sends a request via a load balancer could get `ClosedSessionException`\nbecause the load balancer closes the connection while sending the request.\nPlease see #2576 for detail information.\n\nModifications:\n\n- Make HTTP/1 client send `PING` with `OPTIONS *` when a connection is idle.\n- Introduce `IdleTimeoutScheduler` that schedules a PING interval and an idle timeout.\n- Split PING traffic from normal read and write.\n  - Regardless of PING requests and responses, the connection would be closed on idle.\n- Breaking\n  - Remove `Flags.defaultHttp2PingTimeoutMillis` in favor of `defaultPingIntervalMillis`.\n  - Remove `Flags.defaultUseHttp2PingWhenNoActiveStreams` without replacement.\n    - HTTP/2 can send PING frame with or without active streams.\n    - HTTP/1 can only send PING on no active streams.\n  - Remove `ClientFactory*.http2PingTimeoutMillis()` and `ServerBuilder.http2PingTimeoutMillis()`\n    in favor of `*.pingIntervalMillis()`\n- Miscellaneous\n  - Move ClientHttp*ObjectEncoder to `client` package from `internal` and make them package private\n  - Move ServerHttp*ObjectEncoder to `server` package from `internal` and make them package private\n\nResult:\n\n- HTTP/1 client can send `OPTION *` when a connection is idle.\n- You can now prevent an unexpected disconnection from an idle timeout of a load balancer.", "committedDate": "2020-04-09T03:46:07Z", "type": "commit"}, {"oid": "50331d35ef0cca97aa8d433cfc7e38e5d4f3d403", "url": "https://github.com/line/armeria/commit/50331d35ef0cca97aa8d433cfc7e38e5d4f3d403", "message": "Indent", "committedDate": "2020-04-09T03:46:07Z", "type": "commit"}, {"oid": "4946e8b65179a07991dcddbba38cb1449880f55b", "url": "https://github.com/line/armeria/commit/4946e8b65179a07991dcddbba38cb1449880f55b", "message": "Clean up", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "95610a5376e147631156f86173cbdd69edc3ce60", "url": "https://github.com/line/armeria/commit/95610a5376e147631156f86173cbdd69edc3ce60", "message": "Address comments by @trustin", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "830b1427949561bec9ce446b63b10784387a2be8", "url": "https://github.com/line/armeria/commit/830b1427949561bec9ce446b63b10784387a2be8", "message": "Update Javadoc and clean up", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "url": "https://github.com/line/armeria/commit/16efa9fd17dd8b1996c19adcba8f5191cbb6b105", "message": "Address comments by @minwoox", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "7f3b4ae3e411a7aea755a52fcdfc79b94c8737d3", "url": "https://github.com/line/armeria/commit/7f3b4ae3e411a7aea755a52fcdfc79b94c8737d3", "message": "Destroy KeepAliveHandler when HttpObjectEncoder is closed", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "5b4794e5d12a22917930848057f70acd2f38a40a", "url": "https://github.com/line/armeria/commit/5b4794e5d12a22917930848057f70acd2f38a40a", "message": "Address comments by @minwoox / Remove a potential flaky test", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "69655ac442a81900523d1de83e41aa8ca376d3fe", "url": "https://github.com/line/armeria/commit/69655ac442a81900523d1de83e41aa8ca376d3fe", "message": "Address comments by @trustin\n\n- Don't send other PINGs before receiving PING ack for HTTP/1\n- Ignore the specified PING interval when it is greater than the idle timeout.\n- Update `Http1ResponseDecoder.onPingRead()`", "committedDate": "2020-04-09T03:46:08Z", "type": "commit"}, {"oid": "140cb8b7bdb75b1f0d97e955f74d21950ad826c2", "url": "https://github.com/line/armeria/commit/140cb8b7bdb75b1f0d97e955f74d21950ad826c2", "message": "Address comments by @trusin", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "f62d7557d401abb82295238aeaf8944315e8f85b", "url": "https://github.com/line/armeria/commit/f62d7557d401abb82295238aeaf8944315e8f85b", "message": "Fix flaky test", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "d0cf22e9fbe0c3233194e365984f59abf8b59fb8", "url": "https://github.com/line/armeria/commit/d0cf22e9fbe0c3233194e365984f59abf8b59fb8", "message": "Limit minimum PING interval to 10 seconds", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "bca216965f84dc480451d419b158b46f323eddcd", "url": "https://github.com/line/armeria/commit/bca216965f84dc480451d419b158b46f323eddcd", "message": "throw IllegalArgumentException if pingInterval < MIN_PING_INTERVAL in builders", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "85a95b5bca39a9fa7e2d817bbe0c837cb180c99f", "url": "https://github.com/line/armeria/commit/85a95b5bca39a9fa7e2d817bbe0c837cb180c99f", "message": "Fix checkstyle", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "d54696d921ddc1734259b1dfc0afafd8d519e06c", "url": "https://github.com/line/armeria/commit/d54696d921ddc1734259b1dfc0afafd8d519e06c", "message": "Release message", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "e92e8c202dd3413655d05d7926414312412e7dcd", "url": "https://github.com/line/armeria/commit/e92e8c202dd3413655d05d7926414312412e7dcd", "message": "Address comments by @minwoox / Allow closing an connection with non first idle event", "committedDate": "2020-04-09T03:46:09Z", "type": "commit"}, {"oid": "d641ad23961fcb912ff097bf782a1af98d76dc46", "url": "https://github.com/line/armeria/commit/d641ad23961fcb912ff097bf782a1af98d76dc46", "message": "Address comments by @minwoox\n\n- Inline `onIdleEvent` method\n- Remove IdleState and IdleStateEvent\n- Update Javadoc", "committedDate": "2020-04-09T03:46:10Z", "type": "commit"}, {"oid": "d641ad23961fcb912ff097bf782a1af98d76dc46", "url": "https://github.com/line/armeria/commit/d641ad23961fcb912ff097bf782a1af98d76dc46", "message": "Address comments by @minwoox\n\n- Inline `onIdleEvent` method\n- Remove IdleState and IdleStateEvent\n- Update Javadoc", "committedDate": "2020-04-09T03:46:10Z", "type": "forcePushed"}, {"oid": "ce067274766fc052591730da4b14df0683994344", "url": "https://github.com/line/armeria/commit/ce067274766fc052591730da4b14df0683994344", "message": "Fix broken test", "committedDate": "2020-04-09T04:40:22Z", "type": "commit"}, {"oid": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "url": "https://github.com/line/armeria/commit/6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "message": "Remove 'isLastConnectionIdleTimeSet' and 'isLastPingIdleTimeSet'", "committedDate": "2020-04-11T15:03:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzOTY3NQ==", "url": "https://github.com/line/armeria/pull/2636#discussion_r407339675", "bodyText": "minimum -> minimum allowed", "author": "trustin", "createdAt": "2020-04-13T06:30:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -419,36 +428,47 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the PING interval in milliseconds.\n+     * When neither read nor write was performed for the given {@code pingIntervalMillis},\n+     * a <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> frame is sent for HTTP/2 or\n+     * an <a herf=\"https://tools.ietf.org/html/rfc7231#section-4.3.7\">OPTIONS</a> request with an asterisk (\"*\")\n+     * is sent for HTTP/1.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        checkArgument(http2PingTimeoutMillis >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n-        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n-     */\n-    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n-        checkArgument(http2PingTimeout.toMillis() >= 0,\n-                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n-        http2PingTimeoutMillis(http2PingTimeout.toMillis());\n+     * <p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.", "originalCommit": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1389c13084780397f0a9b6510f56d47f12c7e6aa", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex 35150dbcd4..9c0cbd2c1e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -437,7 +437,7 @@ public final class ClientFactoryBuilder {\n      * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n      * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * <p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.\n+     * <p>The minimum allowed PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.\n      * {@code 0} means the client will not send a PING.\n      *\n      * @throws IllegalArgumentException if the specified {@code pingIntervalMillis} is smaller than\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MDM0Ng==", "url": "https://github.com/line/armeria/pull/2636#discussion_r407340346", "bodyText": "min -> clamped?", "author": "trustin", "createdAt": "2020-04-13T06:33:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -558,7 +578,22 @@ private ClientFactoryOptions buildOptions() {\n             return ClientFactoryOption.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n \n-        return ClientFactoryOptions.of(options.values());\n+        final ClientFactoryOptions newOptions = ClientFactoryOptions.of(options.values());\n+        final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n+        final long pingIntervalMillis = newOptions.pingIntervalMillis();\n+        if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n+            final long minPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);", "originalCommit": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1389c13084780397f0a9b6510f56d47f12c7e6aa", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex 35150dbcd4..9c0cbd2c1e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -582,14 +582,14 @@ public final class ClientFactoryBuilder {\n         final long idleTimeoutMillis = newOptions.idleTimeoutMillis();\n         final long pingIntervalMillis = newOptions.pingIntervalMillis();\n         if (idleTimeoutMillis > 0 && pingIntervalMillis > 0) {\n-            final long minPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n-            if (minPingIntervalMillis >= idleTimeoutMillis) {\n+            final long clampedPingIntervalMillis = Math.max(pingIntervalMillis, MIN_PING_INTERVAL_MILLIS);\n+            if (clampedPingIntervalMillis >= idleTimeoutMillis) {\n                 return ClientFactoryOptions.of(newOptions, ZERO_PING_INTERVAL);\n             }\n             if (pingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {\n                 return newOptions;\n             }\n-            if (minPingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {\n+            if (clampedPingIntervalMillis == MIN_PING_INTERVAL_MILLIS) {\n                 return ClientFactoryOptions.of(newOptions, MIN_PING_INTERVAL);\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0ODY3NA==", "url": "https://github.com/line/armeria/pull/2636#discussion_r407348674", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-04-13T07:02:06Z", "path": "core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java", "diffHunk": "@@ -461,33 +463,39 @@ public ServerBuilder idleTimeout(Duration idleTimeout) {\n     }\n \n     /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n-        this.http2PingTimeoutMillis = validateNonNegative(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        return this;\n-    }\n-\n-    /**\n-     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n+     * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * @param http2PingTimeoutMillis the timeout. {@code 0} disables the timeout.\n-     */\n-    public ServerBuilder http2PingTimeoutMillis(Duration http2PingTimeoutMillis) {\n-        requireNonNull(http2PingTimeoutMillis, \"http2PingTimeoutMillis\");\n-        this.http2PingTimeoutMillis =\n-                validateNonNegative(http2PingTimeoutMillis.toMillis(), \"http2PingTimeoutMillis\");\n+     * <p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.", "originalCommit": "6bc4459e9a3b7b87988508fcd2f4e19136f1ac17", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1389c13084780397f0a9b6510f56d47f12c7e6aa", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\nindex 4f7b659ede..525c2b8ffb 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/ServerBuilder.java\n\n@@ -468,7 +468,7 @@ public final class ServerBuilder {\n      * <p>Note that this settings is only in effect when {@link #idleTimeoutMillis(long)}} or\n      * {@link #idleTimeout(Duration)} is greater than the specified PING interval.\n      *\n-     * <p>The minimum PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.\n+     * <p>The minimum allowed PING interval is {@value #MIN_PING_INTERVAL_MILLIS} milliseconds.\n      * {@code 0} means the server will not send PING frames on an HTTP/2 connection.\n      *\n      * @throws IllegalArgumentException if the specified {@code pingIntervalMillis} is smaller than\n"}}, {"oid": "1389c13084780397f0a9b6510f56d47f12c7e6aa", "url": "https://github.com/line/armeria/commit/1389c13084780397f0a9b6510f56d47f12c7e6aa", "message": "Adress comments by @trustin", "committedDate": "2020-04-13T07:16:06Z", "type": "commit"}]}