{"pr_number": 2679, "pr_title": "Use IP address to register service information in ZooKeeper discovery\u2026", "pr_createdAt": "2020-04-24T00:44:17Z", "pr_url": "https://github.com/line/armeria/pull/2679", "timeline": [{"oid": "08f98d706b30de13dba41683b22df1c14d75ed2a", "url": "https://github.com/line/armeria/commit/08f98d706b30de13dba41683b22df1c14d75ed2a", "message": "Use IP address to register service information in ZooKeeper discovery by default\nMotivation:\nIt would be nice if we use IP address instead of `defaultHostName` in ZooKeeper service discovery\nwhen a user didn't specify the `Endpoint`.\n- There's high chance that the client cannot connect to the server becuase the `defaultHostName` might not registered to DNS server.\n- Client does not have to do DNS resolution, but just connect to the server directly.\n\nModifications:\n- Change to use IP address in ZooKeeper discovery when `Endpoint` is not specified.\n\nResult:\n- Close #2674\n- Robustness", "committedDate": "2020-04-24T00:42:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MDU2MQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414260561", "bodyText": "How about removing Cidr from the flag name and accepting both exact IP address and CIDR?\nNot exactly related with this PR, but we could improve InetAddressPredicated.ofCidr() to accept an exact IP address if / is not found in the string.", "author": "trustin", "createdAt": "2020-04-24T03:13:25Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -318,6 +324,20 @@\n             exceptionLoggingMode(\"annotatedServiceExceptionVerbosity\",\n                                  DEFAULT_ANNOTATED_SERVICE_EXCEPTION_VERBOSITY);\n \n+    private static final List<Predicate<InetAddress>> PREFERRED_IP_V4_CIDR =\n+            CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4Cidr\", \"\", unused -> true))", "originalCommit": "08f98d706b30de13dba41683b22df1c14d75ed2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNjIyMA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414506220", "bodyText": "That's a good idea. Fixed. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-24T11:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MDU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e4827fe61678d633c8d29caf725686d0d303076", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 4e746f290d..0b95368c1c 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -324,20 +352,6 @@ public final class Flags {\n             exceptionLoggingMode(\"annotatedServiceExceptionVerbosity\",\n                                  DEFAULT_ANNOTATED_SERVICE_EXCEPTION_VERBOSITY);\n \n-    private static final List<Predicate<InetAddress>> PREFERRED_IP_V4_CIDR =\n-            CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4Cidr\", \"\", unused -> true))\n-                        .stream()\n-                        .map(cidr -> {\n-                            try {\n-                                return InetAddressPredicates.ofCidr(cidr);\n-                            } catch (Exception e) {\n-                                logger.warn(\"Failed to parse a preferred ip CIDR: {}\", cidr);\n-                            }\n-                            return null;\n-                        })\n-                        .filter(Objects::nonNull)\n-                        .collect(toImmutableList());\n-\n     private static final boolean USE_JDK_DNS_RESOLVER = getBoolean(\"useJdkDnsResolver\", false);\n \n     private static final boolean REPORT_BLOCKED_EVENT_LOOP =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTQ3Nw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414261477", "bodyText": "non-loopback ?", "author": "trustin", "createdAt": "2020-04-24T03:16:26Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.util;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+/**\n+ * A utility class which provides useful methods for {@link InetAddress}.\n+ */\n+public final class InetUtil {\n+\n+    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+    // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n+\n+    @Nullable\n+    private static InetAddress firstNonLoopbackIpV4Address;\n+\n+    /**\n+     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.", "originalCommit": "08f98d706b30de13dba41683b22df1c14d75ed2a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e4827fe61678d633c8d29caf725686d0d303076", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java b/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\ndeleted file mode 100644\nindex ac81d78776..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\n+++ /dev/null\n\n@@ -1,114 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common.util;\n-\n-import java.io.IOException;\n-import java.net.Inet4Address;\n-import java.net.InetAddress;\n-import java.net.NetworkInterface;\n-import java.net.UnknownHostException;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.function.Predicate;\n-\n-import javax.annotation.Nullable;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-/**\n- * A utility class which provides useful methods for {@link InetAddress}.\n- */\n-public final class InetUtil {\n-\n-    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n-    // - Use CIDR in isPreferredAddress instead of regular expression.\n-\n-    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n-\n-    @Nullable\n-    private static InetAddress firstNonLoopbackIpV4Address;\n-\n-    /**\n-     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.\n-     */\n-    @Nullable\n-    public static InetAddress findFirstNonLoopbackIpV4Address() {\n-        if (firstNonLoopbackIpV4Address != null) {\n-            return firstNonLoopbackIpV4Address;\n-        }\n-        InetAddress result = null;\n-        try {\n-            int lowest = Integer.MAX_VALUE;\n-            for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n-                 nics.hasMoreElements();) {\n-                final NetworkInterface ifc = nics.nextElement();\n-                if (ifc.isUp()) {\n-                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                    if (ifc.getIndex() < lowest || result == null) {\n-                        lowest = ifc.getIndex();\n-                    } else if (result != null) {\n-                        continue;\n-                    }\n-\n-                    for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                         addrs.hasMoreElements();) {\n-                        final InetAddress address = addrs.nextElement();\n-                        if (address instanceof Inet4Address &&\n-                            !address.isLoopbackAddress() &&\n-                            isPreferredAddress(address)) {\n-                            result = address;\n-                        }\n-                    }\n-                }\n-            }\n-        } catch (IOException ex) {\n-            logger.error(\"Cannot get first non-loopback address\", ex);\n-        }\n-\n-        if (result != null) {\n-            return firstNonLoopbackIpV4Address = result;\n-        }\n-\n-        try {\n-            return firstNonLoopbackIpV4Address = InetAddress.getLocalHost();\n-        } catch (UnknownHostException e) {\n-            logger.warn(\"Unable to retrieve localhost\");\n-        }\n-\n-        return null;\n-    }\n-\n-    private static boolean isPreferredAddress(InetAddress address) {\n-        final List<Predicate<InetAddress>> predicates = Flags.preferredIpV4Cidr();\n-        if (predicates.isEmpty()) {\n-            return true;\n-        }\n-        for (Predicate<InetAddress> predicate : predicates) {\n-            if (predicate.test(address)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private InetUtil() {}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTc2NQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414261765", "bodyText": "How about returning a single Predicate<InetAddress>>?", "author": "trustin", "createdAt": "2020-04-24T03:17:21Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.util;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+/**\n+ * A utility class which provides useful methods for {@link InetAddress}.\n+ */\n+public final class InetUtil {\n+\n+    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+    // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n+\n+    @Nullable\n+    private static InetAddress firstNonLoopbackIpV4Address;\n+\n+    /**\n+     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.\n+     */\n+    @Nullable\n+    public static InetAddress findFirstNonLoopbackIpV4Address() {\n+        if (firstNonLoopbackIpV4Address != null) {\n+            return firstNonLoopbackIpV4Address;\n+        }\n+        InetAddress result = null;\n+        try {\n+            int lowest = Integer.MAX_VALUE;\n+            for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                 nics.hasMoreElements();) {\n+                final NetworkInterface ifc = nics.nextElement();\n+                if (ifc.isUp()) {\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (ifc.getIndex() < lowest || result == null) {\n+                        lowest = ifc.getIndex();\n+                    } else if (result != null) {\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (address instanceof Inet4Address &&\n+                            !address.isLoopbackAddress() &&\n+                            isPreferredAddress(address)) {\n+                            result = address;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            logger.error(\"Cannot get first non-loopback address\", ex);\n+        }\n+\n+        if (result != null) {\n+            return firstNonLoopbackIpV4Address = result;\n+        }\n+\n+        try {\n+            return firstNonLoopbackIpV4Address = InetAddress.getLocalHost();\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Unable to retrieve localhost\");\n+        }\n+\n+        return null;\n+    }\n+\n+    private static boolean isPreferredAddress(InetAddress address) {\n+        final List<Predicate<InetAddress>> predicates = Flags.preferredIpV4Cidr();", "originalCommit": "08f98d706b30de13dba41683b22df1c14d75ed2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNjM4Nw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414506387", "bodyText": "Thanks, fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-04-24T11:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MTc2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e4827fe61678d633c8d29caf725686d0d303076", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java b/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\ndeleted file mode 100644\nindex ac81d78776..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\n+++ /dev/null\n\n@@ -1,114 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common.util;\n-\n-import java.io.IOException;\n-import java.net.Inet4Address;\n-import java.net.InetAddress;\n-import java.net.NetworkInterface;\n-import java.net.UnknownHostException;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.function.Predicate;\n-\n-import javax.annotation.Nullable;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-/**\n- * A utility class which provides useful methods for {@link InetAddress}.\n- */\n-public final class InetUtil {\n-\n-    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n-    // - Use CIDR in isPreferredAddress instead of regular expression.\n-\n-    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n-\n-    @Nullable\n-    private static InetAddress firstNonLoopbackIpV4Address;\n-\n-    /**\n-     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.\n-     */\n-    @Nullable\n-    public static InetAddress findFirstNonLoopbackIpV4Address() {\n-        if (firstNonLoopbackIpV4Address != null) {\n-            return firstNonLoopbackIpV4Address;\n-        }\n-        InetAddress result = null;\n-        try {\n-            int lowest = Integer.MAX_VALUE;\n-            for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n-                 nics.hasMoreElements();) {\n-                final NetworkInterface ifc = nics.nextElement();\n-                if (ifc.isUp()) {\n-                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                    if (ifc.getIndex() < lowest || result == null) {\n-                        lowest = ifc.getIndex();\n-                    } else if (result != null) {\n-                        continue;\n-                    }\n-\n-                    for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                         addrs.hasMoreElements();) {\n-                        final InetAddress address = addrs.nextElement();\n-                        if (address instanceof Inet4Address &&\n-                            !address.isLoopbackAddress() &&\n-                            isPreferredAddress(address)) {\n-                            result = address;\n-                        }\n-                    }\n-                }\n-            }\n-        } catch (IOException ex) {\n-            logger.error(\"Cannot get first non-loopback address\", ex);\n-        }\n-\n-        if (result != null) {\n-            return firstNonLoopbackIpV4Address = result;\n-        }\n-\n-        try {\n-            return firstNonLoopbackIpV4Address = InetAddress.getLocalHost();\n-        } catch (UnknownHostException e) {\n-            logger.warn(\"Unable to retrieve localhost\");\n-        }\n-\n-        return null;\n-    }\n-\n-    private static boolean isPreferredAddress(InetAddress address) {\n-        final List<Predicate<InetAddress>> predicates = Flags.preferredIpV4Cidr();\n-        if (predicates.isEmpty()) {\n-            return true;\n-        }\n-        for (Predicate<InetAddress> predicate : predicates) {\n-            if (predicate.test(address)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private InetUtil() {}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MjAxOQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414262019", "bodyText": "How about:\n\nmerging into SystemInfo\nusing the same hack with SystemInfo.Hostname\nlogging the IP address\n\n..?", "author": "trustin", "createdAt": "2020-04-24T03:18:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.util;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+/**\n+ * A utility class which provides useful methods for {@link InetAddress}.\n+ */\n+public final class InetUtil {", "originalCommit": "08f98d706b30de13dba41683b22df1c14d75ed2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNjYyNg==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414506626", "bodyText": "Thanks! fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-04-24T11:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2MjAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e4827fe61678d633c8d29caf725686d0d303076", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java b/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\ndeleted file mode 100644\nindex ac81d78776..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\n+++ /dev/null\n\n@@ -1,114 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common.util;\n-\n-import java.io.IOException;\n-import java.net.Inet4Address;\n-import java.net.InetAddress;\n-import java.net.NetworkInterface;\n-import java.net.UnknownHostException;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.function.Predicate;\n-\n-import javax.annotation.Nullable;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-/**\n- * A utility class which provides useful methods for {@link InetAddress}.\n- */\n-public final class InetUtil {\n-\n-    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n-    // - Use CIDR in isPreferredAddress instead of regular expression.\n-\n-    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n-\n-    @Nullable\n-    private static InetAddress firstNonLoopbackIpV4Address;\n-\n-    /**\n-     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.\n-     */\n-    @Nullable\n-    public static InetAddress findFirstNonLoopbackIpV4Address() {\n-        if (firstNonLoopbackIpV4Address != null) {\n-            return firstNonLoopbackIpV4Address;\n-        }\n-        InetAddress result = null;\n-        try {\n-            int lowest = Integer.MAX_VALUE;\n-            for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n-                 nics.hasMoreElements();) {\n-                final NetworkInterface ifc = nics.nextElement();\n-                if (ifc.isUp()) {\n-                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                    if (ifc.getIndex() < lowest || result == null) {\n-                        lowest = ifc.getIndex();\n-                    } else if (result != null) {\n-                        continue;\n-                    }\n-\n-                    for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                         addrs.hasMoreElements();) {\n-                        final InetAddress address = addrs.nextElement();\n-                        if (address instanceof Inet4Address &&\n-                            !address.isLoopbackAddress() &&\n-                            isPreferredAddress(address)) {\n-                            result = address;\n-                        }\n-                    }\n-                }\n-            }\n-        } catch (IOException ex) {\n-            logger.error(\"Cannot get first non-loopback address\", ex);\n-        }\n-\n-        if (result != null) {\n-            return firstNonLoopbackIpV4Address = result;\n-        }\n-\n-        try {\n-            return firstNonLoopbackIpV4Address = InetAddress.getLocalHost();\n-        } catch (UnknownHostException e) {\n-            logger.warn(\"Unable to retrieve localhost\");\n-        }\n-\n-        return null;\n-    }\n-\n-    private static boolean isPreferredAddress(InetAddress address) {\n-        final List<Predicate<InetAddress>> predicates = Flags.preferredIpV4Cidr();\n-        if (predicates.isEmpty()) {\n-            return true;\n-        }\n-        for (Predicate<InetAddress> predicate : predicates) {\n-            if (predicate.test(address)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private InetUtil() {}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI5Mzc5NQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414293795", "bodyText": "Don't we need to have a negative cache when failed to lookup an IP address?\nOn second thought that would be a rare case, we can ignore this. \ud83d\ude00", "author": "ikhoon", "createdAt": "2020-04-24T05:00:40Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common.util;\n+\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.UnknownHostException;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+/**\n+ * A utility class which provides useful methods for {@link InetAddress}.\n+ */\n+public final class InetUtil {\n+\n+    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+    // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n+\n+    @Nullable\n+    private static InetAddress firstNonLoopbackIpV4Address;\n+\n+    /**\n+     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.\n+     */\n+    @Nullable\n+    public static InetAddress findFirstNonLoopbackIpV4Address() {\n+        if (firstNonLoopbackIpV4Address != null) {\n+            return firstNonLoopbackIpV4Address;\n+        }\n+        InetAddress result = null;\n+        try {\n+            int lowest = Integer.MAX_VALUE;\n+            for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                 nics.hasMoreElements();) {\n+                final NetworkInterface ifc = nics.nextElement();\n+                if (ifc.isUp()) {\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (ifc.getIndex() < lowest || result == null) {\n+                        lowest = ifc.getIndex();\n+                    } else if (result != null) {\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (address instanceof Inet4Address &&\n+                            !address.isLoopbackAddress() &&\n+                            isPreferredAddress(address)) {\n+                            result = address;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            logger.error(\"Cannot get first non-loopback address\", ex);\n+        }\n+\n+        if (result != null) {\n+            return firstNonLoopbackIpV4Address = result;\n+        }\n+\n+        try {\n+            return firstNonLoopbackIpV4Address = InetAddress.getLocalHost();\n+        } catch (UnknownHostException e) {\n+            logger.warn(\"Unable to retrieve localhost\");\n+        }\n+\n+        return null;", "originalCommit": "08f98d706b30de13dba41683b22df1c14d75ed2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNzA2MA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414507060", "bodyText": "Because I moved this to SystemInfo as @trustin suggested, I do not have to do that. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-24T11:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI5Mzc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e4827fe61678d633c8d29caf725686d0d303076", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java b/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\ndeleted file mode 100644\nindex ac81d78776..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/util/InetUtil.java\n+++ /dev/null\n\n@@ -1,114 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common.util;\n-\n-import java.io.IOException;\n-import java.net.Inet4Address;\n-import java.net.InetAddress;\n-import java.net.NetworkInterface;\n-import java.net.UnknownHostException;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.function.Predicate;\n-\n-import javax.annotation.Nullable;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-/**\n- * A utility class which provides useful methods for {@link InetAddress}.\n- */\n-public final class InetUtil {\n-\n-    // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n-    // - Use CIDR in isPreferredAddress instead of regular expression.\n-\n-    private static final Logger logger = LoggerFactory.getLogger(InetUtil.class);\n-\n-    @Nullable\n-    private static InetAddress firstNonLoopbackIpV4Address;\n-\n-    /**\n-     * Returns the non loopback IPv4 address whose {@link NetworkInterface#getIndex()} is the lowest.\n-     */\n-    @Nullable\n-    public static InetAddress findFirstNonLoopbackIpV4Address() {\n-        if (firstNonLoopbackIpV4Address != null) {\n-            return firstNonLoopbackIpV4Address;\n-        }\n-        InetAddress result = null;\n-        try {\n-            int lowest = Integer.MAX_VALUE;\n-            for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n-                 nics.hasMoreElements();) {\n-                final NetworkInterface ifc = nics.nextElement();\n-                if (ifc.isUp()) {\n-                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                    if (ifc.getIndex() < lowest || result == null) {\n-                        lowest = ifc.getIndex();\n-                    } else if (result != null) {\n-                        continue;\n-                    }\n-\n-                    for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                         addrs.hasMoreElements();) {\n-                        final InetAddress address = addrs.nextElement();\n-                        if (address instanceof Inet4Address &&\n-                            !address.isLoopbackAddress() &&\n-                            isPreferredAddress(address)) {\n-                            result = address;\n-                        }\n-                    }\n-                }\n-            }\n-        } catch (IOException ex) {\n-            logger.error(\"Cannot get first non-loopback address\", ex);\n-        }\n-\n-        if (result != null) {\n-            return firstNonLoopbackIpV4Address = result;\n-        }\n-\n-        try {\n-            return firstNonLoopbackIpV4Address = InetAddress.getLocalHost();\n-        } catch (UnknownHostException e) {\n-            logger.warn(\"Unable to retrieve localhost\");\n-        }\n-\n-        return null;\n-    }\n-\n-    private static boolean isPreferredAddress(InetAddress address) {\n-        final List<Predicate<InetAddress>> predicates = Flags.preferredIpV4Cidr();\n-        if (predicates.isEmpty()) {\n-            return true;\n-        }\n-        for (Predicate<InetAddress> predicate : predicates) {\n-            if (predicate.test(address)) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private InetUtil() {}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMzgwNw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414403807", "bodyText": "nit: ipAddressOrHostname? \ud83d\ude06", "author": "ikhoon", "createdAt": "2020-04-24T08:45:18Z", "path": "zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListener.java", "diffHunk": "@@ -98,8 +101,10 @@ public void serverStarted(Server server) throws Exception {\n         if (endpoint == null) {\n             final ServerPort activePort = server.activePort();\n             assert activePort != null;\n-            endpoint = Endpoint.of(server.defaultHostname(),\n-                                   activePort.localAddress().getPort());\n+            final InetAddress inetAddress = InetUtil.findFirstNonLoopbackIpV4Address();\n+            final String hostnameOrIpAddress = inetAddress != null ? inetAddress.getHostAddress()", "originalCommit": "08f98d706b30de13dba41683b22df1c14d75ed2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDUwNzIwMA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r414507200", "bodyText": "Fixed \ud83d\ude09", "author": "minwoox", "createdAt": "2020-04-24T11:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMzgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "3e4827fe61678d633c8d29caf725686d0d303076", "chunk": "diff --git a/zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListener.java b/zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListener.java\nindex f7d23afb29..e654ab4f3d 100644\n--- a/zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListener.java\n+++ b/zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListener.java\n\n@@ -101,10 +101,10 @@ public final class ZooKeeperUpdatingListener extends ServerListenerAdapter {\n         if (endpoint == null) {\n             final ServerPort activePort = server.activePort();\n             assert activePort != null;\n-            final InetAddress inetAddress = InetUtil.findFirstNonLoopbackIpV4Address();\n-            final String hostnameOrIpAddress = inetAddress != null ? inetAddress.getHostAddress()\n+            final InetAddress inetAddress = SystemInfo.defaultNonLoopbackIpV4Address();\n+            final String ipAddressOrHostname = inetAddress != null ? inetAddress.getHostAddress()\n                                                                    : server.defaultHostname();\n-            endpoint = Endpoint.of(hostnameOrIpAddress, activePort.localAddress().getPort());\n+            endpoint = Endpoint.of(ipAddressOrHostname, activePort.localAddress().getPort());\n         }\n         client.start();\n         final String key = endpoint.host() + '_' + endpoint.port();\n"}}, {"oid": "3e4827fe61678d633c8d29caf725686d0d303076", "url": "https://github.com/line/armeria/commit/3e4827fe61678d633c8d29caf725686d0d303076", "message": "Address comments by @trustin and @ikhoon", "committedDate": "2020-04-24T11:32:30Z", "type": "commit"}, {"oid": "0e3a942393606f5047256deb1be3d1ba2304cf9a", "url": "https://github.com/line/armeria/commit/0e3a942393606f5047256deb1be3d1ba2304cf9a", "message": "Use IP address in encoder", "committedDate": "2020-04-27T04:04:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3OTgyMw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415579823", "bodyText": "Could you optimize for the case of one predicate as well?\nswitch (preferredIpV4s.size()) {\n    case 0: ... case 1: ... default: ...\n}", "author": "trustin", "createdAt": "2020-04-27T07:36:06Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -120,6 +122,32 @@\n                 VERBOSE_EXCEPTION_SAMPLER_SPEC = spec;\n                 VERBOSE_EXCEPTION_SAMPLER = new ExceptionSampler(VERBOSE_EXCEPTION_SAMPLER_SPEC);\n         }\n+\n+        final List<Predicate<InetAddress>> preferredIpV4s =\n+        CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4\", \"\", unused -> true))\n+                    .stream()\n+                    .map(cidr -> {\n+                        try {\n+                            return InetAddressPredicates.ofCidr(cidr);\n+                        } catch (Exception e) {\n+                            logger.warn(\"Failed to parse a preferred IPv4: {}\", cidr);\n+                        }\n+                        return null;\n+                    })\n+                    .filter(Objects::nonNull)\n+                    .collect(toImmutableList());\n+        if (preferredIpV4s.isEmpty()) {\n+            PREFERRED_IP_V4 = null;\n+        } else {\n+            PREFERRED_IP_V4 = inetAddress -> {", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMjgxNA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415632814", "bodyText": "Fixed, thanks!", "author": "minwoox", "createdAt": "2020-04-27T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3OTgyMw=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 0b95368c1c..4af61181f4 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -123,8 +123,8 @@ public final class Flags {\n                 VERBOSE_EXCEPTION_SAMPLER = new ExceptionSampler(VERBOSE_EXCEPTION_SAMPLER_SPEC);\n         }\n \n-        final List<Predicate<InetAddress>> preferredIpV4s =\n-        CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4\", \"\", unused -> true))\n+        final List<Predicate<InetAddress>> preferredIpV4Addrs =\n+        CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4Addrs\", \"\", unused -> true))\n                     .stream()\n                     .map(cidr -> {\n                         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MDE0OQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415580149", "bodyText": "and -> or ?", "author": "trustin", "createdAt": "2020-04-27T07:36:33Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -951,18 +965,19 @@ public static ExceptionVerbosity annotatedServiceExceptionVerbosity() {\n     }\n \n     /**\n-     * Returns the list of {@link Predicate}s that is used to choose the non loopback IP v4 address in\n-     * {@link InetUtil#findFirstNonLoopbackIpV4Address()}.\n+     * Returns the {@link Predicate} that is used to choose the non-loopback IP v4 address in\n+     * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n      *\n-     * <p>The default value of this flag is an emtpy {@link List}, which means all valid IPv4 addresses are\n+     * <p>The default value of this flag is an empty {@link List}, which means all valid IPv4 addresses are\n      * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=<csv>} JVM option\n      * to override the default value. The {@code csv} should be\n-     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing (CIDR)</a>s separated\n-     * with commas.\n-     * For example, {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=10.0.0.0/8,192.168.1.0/24}.\n+     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s and", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 0b95368c1c..4af61181f4 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -968,16 +973,16 @@ public final class Flags {\n      * Returns the {@link Predicate} that is used to choose the non-loopback IP v4 address in\n      * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n      *\n-     * <p>The default value of this flag is an empty {@link List}, which means all valid IPv4 addresses are\n-     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=<csv>} JVM option\n+     * <p>The default value of this flag is {@code null}, which means all valid IPv4 addresses are\n+     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addrs=<csv>} JVM option\n      * to override the default value. The {@code csv} should be\n-     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s and\n+     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s or\n      * exact IP addresses separated by commas.\n-     * For example, {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n+     * For example, {@code -Dcom.linecorp.armeria.=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n      */\n     @Nullable\n-    public static Predicate<InetAddress> preferredIpV4() {\n-        return PREFERRED_IP_V4;\n+    public static Predicate<InetAddress> preferredIpV4Addrs() {\n+        return PREFERRED_IP_V4_ADDRS;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MDYxNQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415580615", "bodyText": "Thanks, @minwoox", "author": "trustin", "createdAt": "2020-04-27T07:37:19Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -49,7 +56,7 @@\n \n     private static final int JAVA_VERSION;\n \n-    private static boolean JETTY_ALPN_OPTIONAL_OR_AVAILABLE;\n+    private static final boolean JETTY_ALPN_OPTIONAL_OR_AVAILABLE;", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzAyNg==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415633026", "bodyText": "\ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-27T08:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MDYxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MDgyNw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415580827", "bodyText": "Could you add @see Flags#....?", "author": "trustin", "createdAt": "2020-04-27T07:37:42Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -157,6 +166,14 @@ public static int pid() {\n         return Pid.PID;\n     }\n \n+    /**\n+     * Returns the non-loopback {@link Inet4Address} whose {@link NetworkInterface#getIndex()} is the lowest.\n+     */", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzIyNQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415633225", "bodyText": "Fixed.", "author": "minwoox", "createdAt": "2020-04-27T08:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MDgyNw=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -168,6 +168,8 @@ public final class SystemInfo {\n \n     /**\n      * Returns the non-loopback {@link Inet4Address} whose {@link NetworkInterface#getIndex()} is the lowest.\n+     *\n+     * @see Flags#preferredIpV4Addrs()\n      */\n     @Nullable\n     public static Inet4Address defaultNonLoopbackIpV4Address() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MTM0OA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415581348", "bodyText": "Could do this for less indentation:\nif (!ifc.isUp()) {\n    continue;\n}\n...", "author": "trustin", "createdAt": "2020-04-27T07:38:36Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +394,74 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface ifc = nics.nextElement();\n+                    if (ifc.isUp()) {", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -405,59 +407,79 @@ public final class SystemInfo {\n \n         static {\n             Inet4Address result = null;\n+            String nicDisplayName = null;\n             try {\n                 int lowest = Integer.MAX_VALUE;\n                 for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n                      nics.hasMoreElements();) {\n-                    final NetworkInterface ifc = nics.nextElement();\n-                    if (ifc.isUp()) {\n-                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                        if (ifc.getIndex() < lowest || result == null) {\n-                            lowest = ifc.getIndex();\n-                        } else if (result != null) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n                             continue;\n                         }\n-\n-                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                             addrs.hasMoreElements();) {\n-                            final InetAddress address = addrs.nextElement();\n-                            if (address instanceof Inet4Address &&\n-                                !address.isLoopbackAddress() &&\n-                                isPreferredAddress(address)) {\n-                                result = (Inet4Address) address;\n-                            }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n                         }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n                     }\n                 }\n             } catch (IOException ex) {\n-                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n             }\n \n-            Inet4Address temp = null;\n             if (result != null) {\n-                temp = result;\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n+                Inet4Address temp = null;\n                 try {\n                     final InetAddress localHost = InetAddress.getLocalHost();\n                     if (localHost instanceof Inet4Address) {\n                         temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",\n+                                    temp);\n                     } else {\n-                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                        logger.warn(\"Could not get a non-loopback IPv4 address. \" +\n+                                    \"defaultNonLoopbackIpV4Address is set to null\");\n                     }\n                 } catch (UnknownHostException e) {\n-                    logger.warn(\"Unable to retrieve localhost\");\n+                    logger.warn(\"Unable to retrieve the localhost address. \" +\n+                                \"defaultNonLoopbackIpV4Address is set to null\", e);\n                 }\n-            }\n-\n-            defaultNonLoopbackIpV4Address = temp;\n-            if (defaultNonLoopbackIpV4Address != null) {\n-                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+                defaultNonLoopbackIpV4Address = temp;\n             }\n         }\n \n         private static boolean isPreferredAddress(InetAddress address) {\n-            final Predicate<InetAddress> predicates = Flags.preferredIpV4();\n+            final Predicate<InetAddress> predicates = Flags.preferredIpV4Addrs();\n             if (predicates == null) {\n                 return true;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MTc5NQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415581795", "bodyText": "Cannot -> Could not ?\nnon-loopback -> a non-lookback\n. -> :\nLog level 'error' means the situation that an application cannot work anymore due to an unrecoverable error. It seems not?", "author": "trustin", "createdAt": "2020-04-27T07:39:20Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +394,74 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface ifc = nics.nextElement();\n+                    if (ifc.isUp()) {\n+                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                        if (ifc.getIndex() < lowest || result == null) {\n+                            lowest = ifc.getIndex();\n+                        } else if (result != null) {\n+                            continue;\n+                        }\n+\n+                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                             addrs.hasMoreElements();) {\n+                            final InetAddress address = addrs.nextElement();\n+                            if (address instanceof Inet4Address &&\n+                                !address.isLoopbackAddress() &&\n+                                isPreferredAddress(address)) {\n+                                result = (Inet4Address) address;\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzYyNQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415633625", "bodyText": "Copied without much thinking. Thanks!", "author": "minwoox", "createdAt": "2020-04-27T08:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MTc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -405,59 +407,79 @@ public final class SystemInfo {\n \n         static {\n             Inet4Address result = null;\n+            String nicDisplayName = null;\n             try {\n                 int lowest = Integer.MAX_VALUE;\n                 for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n                      nics.hasMoreElements();) {\n-                    final NetworkInterface ifc = nics.nextElement();\n-                    if (ifc.isUp()) {\n-                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                        if (ifc.getIndex() < lowest || result == null) {\n-                            lowest = ifc.getIndex();\n-                        } else if (result != null) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n                             continue;\n                         }\n-\n-                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                             addrs.hasMoreElements();) {\n-                            final InetAddress address = addrs.nextElement();\n-                            if (address instanceof Inet4Address &&\n-                                !address.isLoopbackAddress() &&\n-                                isPreferredAddress(address)) {\n-                                result = (Inet4Address) address;\n-                            }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n                         }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n                     }\n                 }\n             } catch (IOException ex) {\n-                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n             }\n \n-            Inet4Address temp = null;\n             if (result != null) {\n-                temp = result;\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n+                Inet4Address temp = null;\n                 try {\n                     final InetAddress localHost = InetAddress.getLocalHost();\n                     if (localHost instanceof Inet4Address) {\n                         temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",\n+                                    temp);\n                     } else {\n-                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                        logger.warn(\"Could not get a non-loopback IPv4 address. \" +\n+                                    \"defaultNonLoopbackIpV4Address is set to null\");\n                     }\n                 } catch (UnknownHostException e) {\n-                    logger.warn(\"Unable to retrieve localhost\");\n+                    logger.warn(\"Unable to retrieve the localhost address. \" +\n+                                \"defaultNonLoopbackIpV4Address is set to null\", e);\n                 }\n-            }\n-\n-            defaultNonLoopbackIpV4Address = temp;\n-            if (defaultNonLoopbackIpV4Address != null) {\n-                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+                defaultNonLoopbackIpV4Address = temp;\n             }\n         }\n \n         private static boolean isPreferredAddress(InetAddress address) {\n-            final Predicate<InetAddress> predicates = Flags.preferredIpV4();\n+            final Predicate<InetAddress> predicates = Flags.preferredIpV4Addrs();\n             if (predicates == null) {\n                 return true;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MTkwNA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415581904", "bodyText": "Ditto", "author": "trustin", "createdAt": "2020-04-27T07:39:30Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +394,74 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface ifc = nics.nextElement();\n+                    if (ifc.isUp()) {\n+                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                        if (ifc.getIndex() < lowest || result == null) {\n+                            lowest = ifc.getIndex();\n+                        } else if (result != null) {\n+                            continue;\n+                        }\n+\n+                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                             addrs.hasMoreElements();) {\n+                            final InetAddress address = addrs.nextElement();\n+                            if (address instanceof Inet4Address &&\n+                                !address.isLoopbackAddress() &&\n+                                isPreferredAddress(address)) {\n+                                result = (Inet4Address) address;\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+            }\n+\n+            Inet4Address temp = null;\n+            if (result != null) {\n+                temp = result;\n+            } else {\n+                try {\n+                    final InetAddress localHost = InetAddress.getLocalHost();\n+                    if (localHost instanceof Inet4Address) {\n+                        temp = (Inet4Address) localHost;\n+                    } else {\n+                        logger.warn(\"Cannot get non-loopback IPv4 address.\");", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -405,59 +407,79 @@ public final class SystemInfo {\n \n         static {\n             Inet4Address result = null;\n+            String nicDisplayName = null;\n             try {\n                 int lowest = Integer.MAX_VALUE;\n                 for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n                      nics.hasMoreElements();) {\n-                    final NetworkInterface ifc = nics.nextElement();\n-                    if (ifc.isUp()) {\n-                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                        if (ifc.getIndex() < lowest || result == null) {\n-                            lowest = ifc.getIndex();\n-                        } else if (result != null) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n                             continue;\n                         }\n-\n-                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                             addrs.hasMoreElements();) {\n-                            final InetAddress address = addrs.nextElement();\n-                            if (address instanceof Inet4Address &&\n-                                !address.isLoopbackAddress() &&\n-                                isPreferredAddress(address)) {\n-                                result = (Inet4Address) address;\n-                            }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n                         }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n                     }\n                 }\n             } catch (IOException ex) {\n-                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n             }\n \n-            Inet4Address temp = null;\n             if (result != null) {\n-                temp = result;\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n+                Inet4Address temp = null;\n                 try {\n                     final InetAddress localHost = InetAddress.getLocalHost();\n                     if (localHost instanceof Inet4Address) {\n                         temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",\n+                                    temp);\n                     } else {\n-                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                        logger.warn(\"Could not get a non-loopback IPv4 address. \" +\n+                                    \"defaultNonLoopbackIpV4Address is set to null\");\n                     }\n                 } catch (UnknownHostException e) {\n-                    logger.warn(\"Unable to retrieve localhost\");\n+                    logger.warn(\"Unable to retrieve the localhost address. \" +\n+                                \"defaultNonLoopbackIpV4Address is set to null\", e);\n                 }\n-            }\n-\n-            defaultNonLoopbackIpV4Address = temp;\n-            if (defaultNonLoopbackIpV4Address != null) {\n-                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+                defaultNonLoopbackIpV4Address = temp;\n             }\n         }\n \n         private static boolean isPreferredAddress(InetAddress address) {\n-            final Predicate<InetAddress> predicates = Flags.preferredIpV4();\n+            final Predicate<InetAddress> predicates = Flags.preferredIpV4Addrs();\n             if (predicates == null) {\n                 return true;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MjI2Nw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415582267", "bodyText": "\"Unable to retrieve the localhost address:\", e", "author": "trustin", "createdAt": "2020-04-27T07:40:07Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +394,74 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface ifc = nics.nextElement();\n+                    if (ifc.isUp()) {\n+                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                        if (ifc.getIndex() < lowest || result == null) {\n+                            lowest = ifc.getIndex();\n+                        } else if (result != null) {\n+                            continue;\n+                        }\n+\n+                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                             addrs.hasMoreElements();) {\n+                            final InetAddress address = addrs.nextElement();\n+                            if (address instanceof Inet4Address &&\n+                                !address.isLoopbackAddress() &&\n+                                isPreferredAddress(address)) {\n+                                result = (Inet4Address) address;\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+            }\n+\n+            Inet4Address temp = null;\n+            if (result != null) {\n+                temp = result;\n+            } else {\n+                try {\n+                    final InetAddress localHost = InetAddress.getLocalHost();\n+                    if (localHost instanceof Inet4Address) {\n+                        temp = (Inet4Address) localHost;\n+                    } else {\n+                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                    }\n+                } catch (UnknownHostException e) {\n+                    logger.warn(\"Unable to retrieve localhost\");", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzc1MA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415633750", "bodyText": "Fixed.", "author": "minwoox", "createdAt": "2020-04-27T08:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MjI2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -405,59 +407,79 @@ public final class SystemInfo {\n \n         static {\n             Inet4Address result = null;\n+            String nicDisplayName = null;\n             try {\n                 int lowest = Integer.MAX_VALUE;\n                 for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n                      nics.hasMoreElements();) {\n-                    final NetworkInterface ifc = nics.nextElement();\n-                    if (ifc.isUp()) {\n-                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                        if (ifc.getIndex() < lowest || result == null) {\n-                            lowest = ifc.getIndex();\n-                        } else if (result != null) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n                             continue;\n                         }\n-\n-                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                             addrs.hasMoreElements();) {\n-                            final InetAddress address = addrs.nextElement();\n-                            if (address instanceof Inet4Address &&\n-                                !address.isLoopbackAddress() &&\n-                                isPreferredAddress(address)) {\n-                                result = (Inet4Address) address;\n-                            }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n                         }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n                     }\n                 }\n             } catch (IOException ex) {\n-                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n             }\n \n-            Inet4Address temp = null;\n             if (result != null) {\n-                temp = result;\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n+                Inet4Address temp = null;\n                 try {\n                     final InetAddress localHost = InetAddress.getLocalHost();\n                     if (localHost instanceof Inet4Address) {\n                         temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",\n+                                    temp);\n                     } else {\n-                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                        logger.warn(\"Could not get a non-loopback IPv4 address. \" +\n+                                    \"defaultNonLoopbackIpV4Address is set to null\");\n                     }\n                 } catch (UnknownHostException e) {\n-                    logger.warn(\"Unable to retrieve localhost\");\n+                    logger.warn(\"Unable to retrieve the localhost address. \" +\n+                                \"defaultNonLoopbackIpV4Address is set to null\", e);\n                 }\n-            }\n-\n-            defaultNonLoopbackIpV4Address = temp;\n-            if (defaultNonLoopbackIpV4Address != null) {\n-                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+                defaultNonLoopbackIpV4Address = temp;\n             }\n         }\n \n         private static boolean isPreferredAddress(InetAddress address) {\n-            final Predicate<InetAddress> predicates = Flags.preferredIpV4();\n+            final Predicate<InetAddress> predicates = Flags.preferredIpV4Addrs();\n             if (predicates == null) {\n                 return true;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MjUzMw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415582533", "bodyText": "D -> d ?", "author": "trustin", "createdAt": "2020-04-27T07:40:33Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +394,74 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface ifc = nics.nextElement();\n+                    if (ifc.isUp()) {\n+                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                        if (ifc.getIndex() < lowest || result == null) {\n+                            lowest = ifc.getIndex();\n+                        } else if (result != null) {\n+                            continue;\n+                        }\n+\n+                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                             addrs.hasMoreElements();) {\n+                            final InetAddress address = addrs.nextElement();\n+                            if (address instanceof Inet4Address &&\n+                                !address.isLoopbackAddress() &&\n+                                isPreferredAddress(address)) {\n+                                result = (Inet4Address) address;\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+            }\n+\n+            Inet4Address temp = null;\n+            if (result != null) {\n+                temp = result;\n+            } else {\n+                try {\n+                    final InetAddress localHost = InetAddress.getLocalHost();\n+                    if (localHost instanceof Inet4Address) {\n+                        temp = (Inet4Address) localHost;\n+                    } else {\n+                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                    }\n+                } catch (UnknownHostException e) {\n+                    logger.warn(\"Unable to retrieve localhost\");\n+                }\n+            }\n+\n+            defaultNonLoopbackIpV4Address = temp;\n+            if (defaultNonLoopbackIpV4Address != null) {\n+                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzNDQwMQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415634401", "bodyText": "Followed the above line logger.info(\"Hostname .... Let me change both. Thanks!", "author": "minwoox", "createdAt": "2020-04-27T08:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4MjUzMw=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -405,59 +407,79 @@ public final class SystemInfo {\n \n         static {\n             Inet4Address result = null;\n+            String nicDisplayName = null;\n             try {\n                 int lowest = Integer.MAX_VALUE;\n                 for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n                      nics.hasMoreElements();) {\n-                    final NetworkInterface ifc = nics.nextElement();\n-                    if (ifc.isUp()) {\n-                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                        if (ifc.getIndex() < lowest || result == null) {\n-                            lowest = ifc.getIndex();\n-                        } else if (result != null) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n                             continue;\n                         }\n-\n-                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                             addrs.hasMoreElements();) {\n-                            final InetAddress address = addrs.nextElement();\n-                            if (address instanceof Inet4Address &&\n-                                !address.isLoopbackAddress() &&\n-                                isPreferredAddress(address)) {\n-                                result = (Inet4Address) address;\n-                            }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n                         }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n                     }\n                 }\n             } catch (IOException ex) {\n-                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n             }\n \n-            Inet4Address temp = null;\n             if (result != null) {\n-                temp = result;\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n+                Inet4Address temp = null;\n                 try {\n                     final InetAddress localHost = InetAddress.getLocalHost();\n                     if (localHost instanceof Inet4Address) {\n                         temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",\n+                                    temp);\n                     } else {\n-                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                        logger.warn(\"Could not get a non-loopback IPv4 address. \" +\n+                                    \"defaultNonLoopbackIpV4Address is set to null\");\n                     }\n                 } catch (UnknownHostException e) {\n-                    logger.warn(\"Unable to retrieve localhost\");\n+                    logger.warn(\"Unable to retrieve the localhost address. \" +\n+                                \"defaultNonLoopbackIpV4Address is set to null\", e);\n                 }\n-            }\n-\n-            defaultNonLoopbackIpV4Address = temp;\n-            if (defaultNonLoopbackIpV4Address != null) {\n-                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+                defaultNonLoopbackIpV4Address = temp;\n             }\n         }\n \n         private static boolean isPreferredAddress(InetAddress address) {\n-            final Predicate<InetAddress> predicates = Flags.preferredIpV4();\n+            final Predicate<InetAddress> predicates = Flags.preferredIpV4Addrs();\n             if (predicates == null) {\n                 return true;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4Mzg4NQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415583885", "bodyText": "How about logging when defaultNonLoopbackIpV4Address is null as well?", "author": "trustin", "createdAt": "2020-04-27T07:42:37Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +394,74 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface ifc = nics.nextElement();\n+                    if (ifc.isUp()) {\n+                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                        if (ifc.getIndex() < lowest || result == null) {\n+                            lowest = ifc.getIndex();\n+                        } else if (result != null) {\n+                            continue;\n+                        }\n+\n+                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n+                             addrs.hasMoreElements();) {\n+                            final InetAddress address = addrs.nextElement();\n+                            if (address instanceof Inet4Address &&\n+                                !address.isLoopbackAddress() &&\n+                                isPreferredAddress(address)) {\n+                                result = (Inet4Address) address;\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+            }\n+\n+            Inet4Address temp = null;\n+            if (result != null) {\n+                temp = result;\n+            } else {\n+                try {\n+                    final InetAddress localHost = InetAddress.getLocalHost();\n+                    if (localHost instanceof Inet4Address) {\n+                        temp = (Inet4Address) localHost;\n+                    } else {\n+                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                    }\n+                } catch (UnknownHostException e) {\n+                    logger.warn(\"Unable to retrieve localhost\");\n+                }\n+            }\n+\n+            defaultNonLoopbackIpV4Address = temp;\n+            if (defaultNonLoopbackIpV4Address != null) {\n+                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+            }", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex 1685d79cdb..7d6ea07c28 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -405,59 +407,79 @@ public final class SystemInfo {\n \n         static {\n             Inet4Address result = null;\n+            String nicDisplayName = null;\n             try {\n                 int lowest = Integer.MAX_VALUE;\n                 for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n                      nics.hasMoreElements();) {\n-                    final NetworkInterface ifc = nics.nextElement();\n-                    if (ifc.isUp()) {\n-                        // The NIC whose index is the lowest will be likely the valid IPv4 address.\n-                        // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n-                        if (ifc.getIndex() < lowest || result == null) {\n-                            lowest = ifc.getIndex();\n-                        } else if (result != null) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n                             continue;\n                         }\n-\n-                        for (final Enumeration<InetAddress> addrs = ifc.getInetAddresses();\n-                             addrs.hasMoreElements();) {\n-                            final InetAddress address = addrs.nextElement();\n-                            if (address instanceof Inet4Address &&\n-                                !address.isLoopbackAddress() &&\n-                                isPreferredAddress(address)) {\n-                                result = (Inet4Address) address;\n-                            }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n                         }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n                     }\n                 }\n             } catch (IOException ex) {\n-                logger.error(\"Cannot get non-loopback IPv4 address.\", ex);\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n             }\n \n-            Inet4Address temp = null;\n             if (result != null) {\n-                temp = result;\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n+                Inet4Address temp = null;\n                 try {\n                     final InetAddress localHost = InetAddress.getLocalHost();\n                     if (localHost instanceof Inet4Address) {\n                         temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",\n+                                    temp);\n                     } else {\n-                        logger.warn(\"Cannot get non-loopback IPv4 address.\");\n+                        logger.warn(\"Could not get a non-loopback IPv4 address. \" +\n+                                    \"defaultNonLoopbackIpV4Address is set to null\");\n                     }\n                 } catch (UnknownHostException e) {\n-                    logger.warn(\"Unable to retrieve localhost\");\n+                    logger.warn(\"Unable to retrieve the localhost address. \" +\n+                                \"defaultNonLoopbackIpV4Address is set to null\", e);\n                 }\n-            }\n-\n-            defaultNonLoopbackIpV4Address = temp;\n-            if (defaultNonLoopbackIpV4Address != null) {\n-                logger.info(\"DefaultNonLoopbackIpV4Address: {}\", defaultNonLoopbackIpV4Address);\n+                defaultNonLoopbackIpV4Address = temp;\n             }\n         }\n \n         private static boolean isPreferredAddress(InetAddress address) {\n-            final Predicate<InetAddress> predicates = Flags.preferredIpV4();\n+            final Predicate<InetAddress> predicates = Flags.preferredIpV4Addrs();\n             if (predicates == null) {\n                 return true;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDUxMw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415584513", "bodyText": "preferredIpV4Addrs ?", "author": "trustin", "createdAt": "2020-04-27T07:43:35Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -951,18 +965,19 @@ public static ExceptionVerbosity annotatedServiceExceptionVerbosity() {\n     }\n \n     /**\n-     * Returns the list of {@link Predicate}s that is used to choose the non loopback IP v4 address in\n-     * {@link InetUtil#findFirstNonLoopbackIpV4Address()}.\n+     * Returns the {@link Predicate} that is used to choose the non-loopback IP v4 address in\n+     * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n      *\n-     * <p>The default value of this flag is an emtpy {@link List}, which means all valid IPv4 addresses are\n+     * <p>The default value of this flag is an empty {@link List}, which means all valid IPv4 addresses are\n      * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=<csv>} JVM option\n      * to override the default value. The {@code csv} should be\n-     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing (CIDR)</a>s separated\n-     * with commas.\n-     * For example, {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=10.0.0.0/8,192.168.1.0/24}.\n+     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s and\n+     * exact IP addresses separated by commas.\n+     * For example, {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n      */\n-    public static List<Predicate<InetAddress>> preferredIpV4Cidr() {\n-        return PREFERRED_IP_V4_CIDR;\n+    @Nullable\n+    public static Predicate<InetAddress> preferredIpV4() {", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 0b95368c1c..4af61181f4 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -968,16 +973,16 @@ public final class Flags {\n      * Returns the {@link Predicate} that is used to choose the non-loopback IP v4 address in\n      * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n      *\n-     * <p>The default value of this flag is an empty {@link List}, which means all valid IPv4 addresses are\n-     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=<csv>} JVM option\n+     * <p>The default value of this flag is {@code null}, which means all valid IPv4 addresses are\n+     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addrs=<csv>} JVM option\n      * to override the default value. The {@code csv} should be\n-     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s and\n+     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s or\n      * exact IP addresses separated by commas.\n-     * For example, {@code -Dcom.linecorp.armeria.preferredIpV4Cidr=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n+     * For example, {@code -Dcom.linecorp.armeria.=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n      */\n     @Nullable\n-    public static Predicate<InetAddress> preferredIpV4() {\n-        return PREFERRED_IP_V4;\n+    public static Predicate<InetAddress> preferredIpV4Addrs() {\n+        return PREFERRED_IP_V4_ADDRS;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDc0NA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415584744", "bodyText": "IP_V4 -> IP_V4_ADDRS ?", "author": "trustin", "createdAt": "2020-04-27T07:43:59Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -90,6 +89,9 @@\n     private static final String VERBOSE_EXCEPTION_SAMPLER_SPEC;\n     private static final Sampler<Class<? extends Throwable>> VERBOSE_EXCEPTION_SAMPLER;\n \n+    @Nullable\n+    private static final Predicate<InetAddress> PREFERRED_IP_V4;", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMjU4Mw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415632583", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-04-27T08:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 0b95368c1c..4af61181f4 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -90,7 +90,7 @@ public final class Flags {\n     private static final Sampler<Class<? extends Throwable>> VERBOSE_EXCEPTION_SAMPLER;\n \n     @Nullable\n-    private static final Predicate<InetAddress> PREFERRED_IP_V4;\n+    private static final Predicate<InetAddress> PREFERRED_IP_V4_ADDRS;\n \n     static {\n         final String spec = getNormalized(\"verboseExceptions\", DEFAULT_VERBOSE_EXCEPTION_SAMPLER_SPEC, val -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDg3OQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415584879", "bodyText": "preferredIpV4Addrs ?", "author": "trustin", "createdAt": "2020-04-27T07:44:13Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -120,6 +122,32 @@\n                 VERBOSE_EXCEPTION_SAMPLER_SPEC = spec;\n                 VERBOSE_EXCEPTION_SAMPLER = new ExceptionSampler(VERBOSE_EXCEPTION_SAMPLER_SPEC);\n         }\n+\n+        final List<Predicate<InetAddress>> preferredIpV4s =\n+        CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4\", \"\", unused -> true))", "originalCommit": "3e4827fe61678d633c8d29caf725686d0d303076", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 0b95368c1c..4af61181f4 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -123,8 +123,8 @@ public final class Flags {\n                 VERBOSE_EXCEPTION_SAMPLER = new ExceptionSampler(VERBOSE_EXCEPTION_SAMPLER_SPEC);\n         }\n \n-        final List<Predicate<InetAddress>> preferredIpV4s =\n-        CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4\", \"\", unused -> true))\n+        final List<Predicate<InetAddress>> preferredIpV4Addrs =\n+        CSV_SPLITTER.splitToList(getNormalized(\"preferredIpV4Addrs\", \"\", unused -> true))\n                     .stream()\n                     .map(cidr -> {\n                         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5MDE3NA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415590174", "bodyText": "This can break things, especially when a client has to send the host name.\n\nHost or :authority headers\nTLS SNI", "author": "trustin", "createdAt": "2020-04-27T07:52:19Z", "path": "zookeeper/src/main/java/com/linecorp/armeria/common/zookeeper/DefaultNodeValueCodec.java", "diffHunk": "@@ -98,7 +98,13 @@ public Endpoint decode(String segment) {\n \n     @Override\n     public byte[] encode(Endpoint endpoint) {\n-        return (endpoint.host() + fieldDelimiter + endpoint.port() + fieldDelimiter + endpoint.weight())\n+        final String ipAddressOrHostname;\n+        if (endpoint.hasIpAddr()) {\n+            ipAddressOrHostname = endpoint.ipAddr();\n+        } else {\n+            ipAddressOrHostname = endpoint.host();\n+        }\n+        return (ipAddressOrHostname + fieldDelimiter + endpoint.port() + fieldDelimiter + endpoint.weight())", "originalCommit": "0e3a942393606f5047256deb1be3d1ba2304cf9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzNTA0Mg==", "url": "https://github.com/line/armeria/pull/2679#discussion_r415635042", "bodyText": "Oops, couldn't think of it. Thanks!", "author": "minwoox", "createdAt": "2020-04-27T08:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5MDE3NA=="}], "type": "inlineReview", "revised_code": {"commit": "308381e50c078c466b3fb2744990ec00873f9283", "chunk": "diff --git a/zookeeper/src/main/java/com/linecorp/armeria/common/zookeeper/DefaultNodeValueCodec.java b/zookeeper/src/main/java/com/linecorp/armeria/common/zookeeper/DefaultNodeValueCodec.java\nindex e27dc56bad..7896087bfd 100644\n--- a/zookeeper/src/main/java/com/linecorp/armeria/common/zookeeper/DefaultNodeValueCodec.java\n+++ b/zookeeper/src/main/java/com/linecorp/armeria/common/zookeeper/DefaultNodeValueCodec.java\n\n@@ -98,13 +98,7 @@ final class DefaultNodeValueCodec implements NodeValueCodec {\n \n     @Override\n     public byte[] encode(Endpoint endpoint) {\n-        final String ipAddressOrHostname;\n-        if (endpoint.hasIpAddr()) {\n-            ipAddressOrHostname = endpoint.ipAddr();\n-        } else {\n-            ipAddressOrHostname = endpoint.host();\n-        }\n-        return (ipAddressOrHostname + fieldDelimiter + endpoint.port() + fieldDelimiter + endpoint.weight())\n+        return (endpoint.host() + fieldDelimiter + endpoint.port() + fieldDelimiter + endpoint.weight())\n                 .getBytes(StandardCharsets.UTF_8);\n     }\n }\n"}}, {"oid": "308381e50c078c466b3fb2744990ec00873f9283", "url": "https://github.com/line/armeria/commit/308381e50c078c466b3fb2744990ec00873f9283", "message": "Address comments by @trustin", "committedDate": "2020-04-27T08:58:49Z", "type": "commit"}, {"oid": "caddaac37c9b0b06e37366307592c1fe86ae9f2f", "url": "https://github.com/line/armeria/commit/caddaac37c9b0b06e37366307592c1fe86ae9f2f", "message": "Fix", "committedDate": "2020-04-27T09:03:06Z", "type": "commit"}, {"oid": "dee11ca1802b39e657b703afe966c87d855132f7", "url": "https://github.com/line/armeria/commit/dee11ca1802b39e657b703afe966c87d855132f7", "message": "Fix more", "committedDate": "2020-04-27T09:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwMTIxMA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r416301210", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * to override the default value. The {@code csv} should be\n          \n          \n            \n                 * to override the default value. The {@code CSV} should be", "author": "ikhoon", "createdAt": "2020-04-28T03:33:38Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -930,6 +969,22 @@ public static ExceptionVerbosity annotatedServiceExceptionVerbosity() {\n         return ANNOTATED_SERVICE_EXCEPTION_VERBOSITY;\n     }\n \n+    /**\n+     * Returns the {@link Predicate} that is used to choose the non-loopback IP v4 address in\n+     * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n+     *\n+     * <p>The default value of this flag is {@code null}, which means all valid IPv4 addresses are\n+     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addrs=<csv>} JVM option\n+     * to override the default value. The {@code csv} should be", "originalCommit": "dee11ca1802b39e657b703afe966c87d855132f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMzNTIyMg==", "url": "https://github.com/line/armeria/pull/2679#discussion_r416335222", "bodyText": "Let me just use csv because the above line used lowercased.", "author": "minwoox", "createdAt": "2020-04-28T05:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwMTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMzNjQ2OA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r416336468", "bodyText": "SGTM", "author": "ikhoon", "createdAt": "2020-04-28T05:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwMTIxMA=="}], "type": "inlineReview", "revised_code": {"commit": "882bc4f605f4ab7761584edc926c0788d4da1dd8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 4af61181f4..f70c454285 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -974,15 +974,15 @@ public final class Flags {\n      * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n      *\n      * <p>The default value of this flag is {@code null}, which means all valid IPv4 addresses are\n-     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addrs=<csv>} JVM option\n+     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addresses=<csv>} JVM option\n      * to override the default value. The {@code csv} should be\n      * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s or\n-     * exact IP addresses separated by commas.\n-     * For example, {@code -Dcom.linecorp.armeria.=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n+     * exact IP addresses separated by commas. For example,\n+     * {@code -Dcom.linecorp.armeria.preferredIpV4Addresses=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n      */\n     @Nullable\n-    public static Predicate<InetAddress> preferredIpV4Addrs() {\n-        return PREFERRED_IP_V4_ADDRS;\n+    public static Predicate<InetAddress> preferredIpV4Addresses() {\n+        return PREFERRED_IP_V4_ADDRESSES;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMDA4MA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r416310080", "bodyText": "Sometimes users might want to run Armeria servers on Docker or Kubernetes.\nThen they has to expose a container port like docker run -p 8080:80.\nI'm not strong, but don't we need to provide a way to customize a service registry port and IP(or hostname) without automatic?", "author": "ikhoon", "createdAt": "2020-04-28T04:02:52Z", "path": "zookeeper/src/main/java/com/linecorp/armeria/server/zookeeper/ZooKeeperUpdatingListener.java", "diffHunk": "@@ -98,8 +101,10 @@ public void serverStarted(Server server) throws Exception {\n         if (endpoint == null) {\n             final ServerPort activePort = server.activePort();\n             assert activePort != null;\n-            endpoint = Endpoint.of(server.defaultHostname(),\n-                                   activePort.localAddress().getPort());\n+            final InetAddress inetAddress = SystemInfo.defaultNonLoopbackIpV4Address();\n+            final String ipAddressOrHostname = inetAddress != null ? inetAddress.getHostAddress()\n+                                                                   : server.defaultHostname();\n+            endpoint = Endpoint.of(ipAddressOrHostname, activePort.localAddress().getPort());", "originalCommit": "dee11ca1802b39e657b703afe966c87d855132f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNDQwMA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r416314400", "bodyText": "We have ZooKeeperUpdatingListenerBuilder.endpoint() for that. This is set only when the endpoint is not set. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-28T04:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMDA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTQ3NQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r416315475", "bodyText": "Ah. I missed endpoint == null check. \ud83d\ude05", "author": "ikhoon", "createdAt": "2020-04-28T04:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMDA4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5Nzk4Mw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r417197983", "bodyText": "...armeria.preferredIpV4Addrs=...?\nBy the way, should we use Addresses? \ud83e\udd14", "author": "trustin", "createdAt": "2020-04-29T09:55:55Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -930,6 +969,22 @@ public static ExceptionVerbosity annotatedServiceExceptionVerbosity() {\n         return ANNOTATED_SERVICE_EXCEPTION_VERBOSITY;\n     }\n \n+    /**\n+     * Returns the {@link Predicate} that is used to choose the non-loopback IP v4 address in\n+     * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n+     *\n+     * <p>The default value of this flag is {@code null}, which means all valid IPv4 addresses are\n+     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addrs=<csv>} JVM option\n+     * to override the default value. The {@code csv} should be\n+     * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s or\n+     * exact IP addresses separated by commas.\n+     * For example, {@code -Dcom.linecorp.armeria.=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.", "originalCommit": "dee11ca1802b39e657b703afe966c87d855132f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyOTcyMQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r417229721", "bodyText": "Yeah, let me use that. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-04-29T10:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5Nzk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "882bc4f605f4ab7761584edc926c0788d4da1dd8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 4af61181f4..f70c454285 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -974,15 +974,15 @@ public final class Flags {\n      * {@link SystemInfo#defaultNonLoopbackIpV4Address()}.\n      *\n      * <p>The default value of this flag is {@code null}, which means all valid IPv4 addresses are\n-     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addrs=<csv>} JVM option\n+     * preferred. Specify the {@code -Dcom.linecorp.armeria.preferredIpV4Addresses=<csv>} JVM option\n      * to override the default value. The {@code csv} should be\n      * <a href=\"https://tools.ietf.org/html/rfc4632\">Classless Inter-domain Routing(CIDR)</a>s or\n-     * exact IP addresses separated by commas.\n-     * For example, {@code -Dcom.linecorp.armeria.=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n+     * exact IP addresses separated by commas. For example,\n+     * {@code -Dcom.linecorp.armeria.preferredIpV4Addresses=211.111.111.111,10.0.0.0/8,192.168.1.0/24}.\n      */\n     @Nullable\n-    public static Predicate<InetAddress> preferredIpV4Addrs() {\n-        return PREFERRED_IP_V4_ADDRS;\n+    public static Predicate<InetAddress> preferredIpV4Addresses() {\n+        return PREFERRED_IP_V4_ADDRESSES;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5ODkwNw==", "url": "https://github.com/line/armeria/pull/2679#discussion_r417198907", "bodyText": "nit: How about (from ...)?", "author": "trustin", "createdAt": "2020-04-29T09:57:36Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +396,94 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            String nicDisplayName = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not an Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n+            }\n+\n+            if (result != null) {\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",", "originalCommit": "dee11ca1802b39e657b703afe966c87d855132f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMwNjA4OQ==", "url": "https://github.com/line/armeria/pull/2679#discussion_r419306089", "bodyText": "Fixed. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-04T09:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5ODkwNw=="}], "type": "inlineReview", "revised_code": {"commit": "882bc4f605f4ab7761584edc926c0788d4da1dd8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex de2b22adf3..f4ad6cc630 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -456,7 +456,7 @@ public final class SystemInfo {\n \n             if (result != null) {\n                 defaultNonLoopbackIpV4Address = result;\n-                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} (from: {})\",\n                             defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n                 Inet4Address temp = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE5OTA0NA==", "url": "https://github.com/line/armeria/pull/2679#discussion_r417199044", "bodyText": "nit: How about (from ...)?", "author": "trustin", "createdAt": "2020-04-29T09:57:51Z", "path": "core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java", "diffHunk": "@@ -377,4 +396,94 @@ private static void logFailure(String method, boolean warn, Throwable cause) {\n             }\n         }\n     }\n+\n+    private static final class DefaultNonLoopbackIPv4Address {\n+\n+        // Forked from InetUtils in spring-cloud-common 3.0.0.M1 at e7bb7ed3ae19a91c6fa7b3b698dd9788f70df7d4\n+        // - Use CIDR in isPreferredAddress instead of regular expression.\n+\n+        @Nullable\n+        static final Inet4Address defaultNonLoopbackIpV4Address;\n+\n+        static {\n+            Inet4Address result = null;\n+            String nicDisplayName = null;\n+            try {\n+                int lowest = Integer.MAX_VALUE;\n+                for (final Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\n+                     nics.hasMoreElements();) {\n+                    final NetworkInterface nic = nics.nextElement();\n+                    if (!nic.isUp()) {\n+                        logger.debug(\"{} is down. Trying next.\", nic.getDisplayName());\n+                        continue;\n+                    }\n+\n+                    // The NIC whose index is the lowest will be likely the valid IPv4 address.\n+                    // See https://github.com/spring-cloud/spring-cloud-commons/issues/82.\n+                    if (nic.getIndex() < lowest || result == null) {\n+                        lowest = nic.getIndex();\n+                    } else {\n+                        logger.debug(\"{} has higher index({}) than {}. Skip.\",\n+                                     nic.getDisplayName(), nic.getIndex(), result);\n+                        continue;\n+                    }\n+\n+                    for (final Enumeration<InetAddress> addrs = nic.getInetAddresses();\n+                         addrs.hasMoreElements();) {\n+                        final InetAddress address = addrs.nextElement();\n+                        if (!(address instanceof Inet4Address)) {\n+                            logger.debug(\"{} of {} is not an Inet4Address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (address.isLoopbackAddress()) {\n+                            logger.debug(\"{} of {} is a loopback address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        if (!isPreferredAddress(address)) {\n+                            logger.debug(\"{} of {} is not a preferred IP address. Trying next.\",\n+                                         address, nic.getDisplayName());\n+                            continue;\n+                        }\n+                        result = (Inet4Address) address;\n+                        nicDisplayName = nic.getDisplayName();\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                logger.warn(\"Could not get a non-loopback IPv4 address:\", ex);\n+            }\n+\n+            if (result != null) {\n+                defaultNonLoopbackIpV4Address = result;\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                            defaultNonLoopbackIpV4Address, nicDisplayName);\n+            } else {\n+                Inet4Address temp = null;\n+                try {\n+                    final InetAddress localHost = InetAddress.getLocalHost();\n+                    if (localHost instanceof Inet4Address) {\n+                        temp = (Inet4Address) localHost;\n+                        logger.info(\"defaultNonLoopbackIpV4Address: {} from: InetAddress.getLocalHost()\",", "originalCommit": "dee11ca1802b39e657b703afe966c87d855132f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "882bc4f605f4ab7761584edc926c0788d4da1dd8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\nindex de2b22adf3..f4ad6cc630 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/util/SystemInfo.java\n\n@@ -456,7 +456,7 @@ public final class SystemInfo {\n \n             if (result != null) {\n                 defaultNonLoopbackIpV4Address = result;\n-                logger.info(\"defaultNonLoopbackIpV4Address: {} from: {}\",\n+                logger.info(\"defaultNonLoopbackIpV4Address: {} (from: {})\",\n                             defaultNonLoopbackIpV4Address, nicDisplayName);\n             } else {\n                 Inet4Address temp = null;\n"}}, {"oid": "882bc4f605f4ab7761584edc926c0788d4da1dd8", "url": "https://github.com/line/armeria/commit/882bc4f605f4ab7761584edc926c0788d4da1dd8", "message": "Address comments by @trustin", "committedDate": "2020-05-04T09:14:36Z", "type": "commit"}]}