{"pr_number": 2383, "pr_title": "Fix to have context in the thread-local when calling AsyncMetho\u2026", "pr_createdAt": "2020-01-08T03:28:58Z", "pr_url": "https://github.com/line/armeria/pull/2383", "timeline": [{"oid": "22b315e999c0ca4e78c7a69b469908cf3da2898a", "url": "https://github.com/line/armeria/commit/22b315e999c0ca4e78c7a69b469908cf3da2898a", "message": "Fix to have context in the thread-local when calling AsyncMethodCallback\nMotivations:\nIf the `reply` returned from Thrift client call is comeplete before calling `future.handle()`, the context is not pushed into thread-local when calling `AsyncMethodCallback`.\n\nModifications:\n- Fix to push context right before calling `future.handle()`\n- `ClientRequestContextCaptor` now captures nested contexts.\n  - This is not a breaking change because we didn't publish a new version yet.\n  - Add `ClientRequestContextCaptor.getOrNull()`\n\nResult:\n- Fix test failure", "committedDate": "2020-01-08T03:20:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1MzgxMw==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364053813", "bodyText": "How about not adding after close()?", "author": "trustin", "createdAt": "2020-01-08T03:48:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java", "diffHunk": "@@ -129,6 +129,13 @@ private static void reportThreadSafetyViolation() {\n             this.oldCaptor = oldCaptor;\n         }\n \n+        void add(ClientRequestContext ctx) {\n+            captured.add(ctx);\n+            if (oldCaptor != null) {\n+                oldCaptor.add(ctx);\n+            }\n+        }", "originalCommit": "22b315e999c0ca4e78c7a69b469908cf3da2898a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2NzkzOA==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364067938", "bodyText": "Oops. \ud83d\ude05 I thought it's null after it's closed.", "author": "minwoox", "createdAt": "2020-01-08T05:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1MzgxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDA3NQ==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070075", "bodyText": "Changed. But I couldn't make a test case because oldCaptor.add() is never called...", "author": "minwoox", "createdAt": "2020-01-08T05:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1MzgxMw=="}], "type": "inlineReview", "revised_code": {"commit": "8ed3ac232e7a5c8dd51b8b7776558d10d07ced65", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java b/core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java\nindex 4fd8d9ddd..fb5ed7c15 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientThreadLocalState.java\n\n@@ -123,7 +123,7 @@ final class ClientThreadLocalState {\n         final List<ClientRequestContext> captured = new ArrayList<>();\n \n         @Nullable\n-        private final DefaultClientRequestContextCaptor oldCaptor;\n+        private DefaultClientRequestContextCaptor oldCaptor;\n \n         DefaultClientRequestContextCaptor(@Nullable DefaultClientRequestContextCaptor oldCaptor) {\n             this.oldCaptor = oldCaptor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364056241", "bodyText": "I think we can directly mount the context here and below instead of using makeContextAware.", "author": "anuraaga", "createdAt": "2020-01-08T04:03:20Z", "path": "thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java", "diffHunk": "@@ -119,31 +124,51 @@ private Object invokeClientMethod(Method method, @Nullable Object[] args) throws\n             }\n         }\n \n-        try {\n-            final RpcResponse reply;\n-            if (fragment != null) {\n-                reply = delegate().executeMultiplexed(\n-                        path, params.clientType(), fragment, method.getName(), args);\n-            } else {\n-                reply = delegate().execute(path, params.clientType(), method.getName(), args);\n-            }\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            try {\n+                final RpcResponse reply;\n+                if (fragment != null) {\n+                    reply = delegate().executeMultiplexed(\n+                            path, params.clientType(), fragment, method.getName(), args);\n+                } else {\n+                    reply = delegate().execute(path, params.clientType(), method.getName(), args);\n+                }\n \n-            if (callback != null) {\n-                AsyncMethodCallbacks.transfer(reply, callback);\n-                return null;\n-            } else {\n-                try {\n-                    return reply.get();\n-                } catch (ExecutionException e) {\n-                    throw Exceptions.peel(e);\n+                final ClientRequestContext ctx = captor.get();\n+                if (callback != null) {\n+                    reply.handle(ctx.makeContextAware((res, cause) -> {", "originalCommit": "22b315e999c0ca4e78c7a69b469908cf3da2898a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2NzU1NA==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364067554", "bodyText": "https://github.com/line/armeria/pull/2383/files#diff-6ab8399d40ca91dd25785dc822606306R167\nThis line should be called by the same executor so I chose this way which is let the thread, which completes the reply, do the jobs in callback.\nBut I'm not so strong this and I can put the job in the executor.", "author": "minwoox", "createdAt": "2020-01-08T05:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2OTY3NQ==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364069675", "bodyText": "I'm not sure I understand, probably since I wasn't clear either - I didn't mean use the executor, but just something like this to directly mount the context without creating a wrapped callable\nreply.handle((res, cause) -> {\n  try (SafeCloseable unused = ctx.push()) {\n    if (cause != null) {\n                     invokeOnError(callback, cause);\n                } else {\n                    callback.onComplete(res);\n                            }\n                        } catch (Exception e) {\n                            CompletionActions.log(e);\n                        }\n                        return null;\n                    }));", "author": "anuraaga", "createdAt": "2020-01-08T05:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2OTg4MQ==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364069881", "bodyText": "Well actually, I can't get an executor in that case. Is it okay to execute the callback(invokeOnError(callback, cause);) with the different thread in this case?", "author": "minwoox", "createdAt": "2020-01-08T05:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDExMg==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070112", "bodyText": "By the way, as far as the thread, from what I understand, the thread running the handle callback will be the thread in delegate().execute( and isn't related to this code directly. Though I guess this code, delegate().execute will in practice be the same thread, which happens to be ctx.contextAwareExecutor too. JFYI, I don't think it affects how we mount the context here.", "author": "anuraaga", "createdAt": "2020-01-08T05:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDc4Ng==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070786", "bodyText": "Well, it could be the thread which calls reply.handle() (i,e, reply is completed when attaching callback. \ud83d\ude2d  This is why previous PR was not working )", "author": "minwoox", "createdAt": "2020-01-08T05:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MDkyOA==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364070928", "bodyText": "I'm not sure I understand, probably since I wasn't clear either - I didn't mean use the executor, but just something like this to directly mount the context without creating a wrapped callable\n\nYeah, I can do that and I misunderstood it. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-01-08T05:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA3MTY0OA==", "url": "https://github.com/line/armeria/pull/2383#discussion_r364071648", "bodyText": "Aha - thanks I understand the threading issue now. I never realized the non-async callback methods had such a dangerous caveat to them though I guess there isn't any way to implement them consistently", "author": "anuraaga", "createdAt": "2020-01-08T05:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA1NjI0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8ed3ac232e7a5c8dd51b8b7776558d10d07ced65", "chunk": "diff --git a/thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java b/thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java\nindex 7c4b3213d..2e39cc509 100644\n--- a/thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java\n+++ b/thrift/src/main/java/com/linecorp/armeria/client/thrift/THttpClientInvocationHandler.java\n\n@@ -136,8 +137,8 @@ final class THttpClientInvocationHandler\n \n                 final ClientRequestContext ctx = captor.get();\n                 if (callback != null) {\n-                    reply.handle(ctx.makeContextAware((res, cause) -> {\n-                        try {\n+                    reply.handle((res, cause) -> {\n+                        try (SafeCloseable ignored = ctx.push()) {\n                             if (cause != null) {\n                                 invokeOnError(callback, cause);\n                             } else {\n"}}, {"oid": "8ed3ac232e7a5c8dd51b8b7776558d10d07ced65", "url": "https://github.com/line/armeria/commit/8ed3ac232e7a5c8dd51b8b7776558d10d07ced65", "message": "Address comments by @trustin and @anuraaga", "committedDate": "2020-01-08T06:52:14Z", "type": "commit"}]}