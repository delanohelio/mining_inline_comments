{"pr_number": 2701, "pr_title": "Support Eureka service discovery", "pr_createdAt": "2020-05-11T13:51:34Z", "pr_url": "https://github.com/line/armeria/pull/2701", "timeline": [{"oid": "0241e2075f6c5f6ef7ee49443e4a2a2072ebf0a6", "url": "https://github.com/line/armeria/commit/0241e2075f6c5f6ef7ee49443e4a2a2072ebf0a6", "message": "Support Eureka service discovery\nMotivation:\nIt will be nice if a user can easily do the service discovery using Eureka.\n\nModifications:\n- Add `EurekEndointGroup` and `EurekaUpdatingListerner`.\n\nResult:\n- You can now use Eureka for service discovery with Ameria server and client.\n\nTo-do:\n- Support Eureka service discovery using a property file so that Spring users can easily migrate.\n- Add document.", "committedDate": "2020-05-11T13:51:13Z", "type": "commit"}, {"oid": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "url": "https://github.com/line/armeria/commit/e1d86e7bd8c552ecae204805938154c69c7f5b47", "message": "Fix javadoc and add license", "committedDate": "2020-05-12T03:58:23Z", "type": "commit"}, {"oid": "d5d24441f103a0998e3afef22e39bcce8d26dd36", "url": "https://github.com/line/armeria/commit/d5d24441f103a0998e3afef22e39bcce8d26dd36", "message": "Add test case", "committedDate": "2020-05-12T06:48:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzM1MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497351", "bodyText": "You need to respect content.length().", "author": "trustin", "createdAt": "2020-05-12T06:44:39Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Unexpected exception while fetching the registry from: {}.\" +\n+                                \" (requestHeaders: {})\", webClient.uri(), requestHeaders, cause);\n+                } else {\n+                    final HttpStatus status = aggregatedRes.status();\n+                    if (!status.isSuccess()) {\n+                        logger.warn(\"Unexpected response from: {}. (status: {}, content: {}, \" +\n+                                    \"requestHeaders: {})\", webClient.uri(), status,\n+                                    aggregatedRes.contentUtf8(), requestHeaders);\n+                    } else {\n+                        final HttpData content = aggregatedRes.content();\n+                        try {\n+                            final List<Endpoint> endpoints = responseConverter.apply(content.array());", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzYyNDM2MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423624361", "bodyText": "As we had a chat, content.array() has the regulation in which the length of the returned byte[] should be equal to the content.length().", "author": "minwoox", "createdAt": "2020-05-12T10:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\nindex 2bbf2ddde..6f378f7b5 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n\n@@ -25,7 +25,6 @@ import java.util.Set;\n import java.util.StringJoiner;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Predicate;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497482", "bodyText": "Probably an overkill to use with pooled objects?", "author": "trustin", "createdAt": "2020-05-12T06:44:58Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNDkwMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423534903", "bodyText": "Others two clients would be overkill, but this one has pretty much a lot of content.\nIsn't it better to use alloc instead of creating byte array in this case? This is not a streaming response. so the byte buffer will be released soon. \ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-12T07:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTc1Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423555756", "bodyText": "I see. No problem then. \ud83d\udc4d", "author": "trustin", "createdAt": "2020-05-12T08:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzQ4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\nindex 2bbf2ddde..6f378f7b5 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n\n@@ -25,7 +25,6 @@ import java.util.Set;\n import java.util.StringJoiner;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Predicate;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzcxOQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423497719", "bodyText": "parsing a response", "author": "trustin", "createdAt": "2020-05-12T06:45:29Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    private final long registryFetchIntervalSeconds;\n+\n+    private final RequestHeaders requestHeaders;\n+    private final Function<byte[], List<Endpoint>> responseConverter;\n+    private final WebClient webClient;\n+    @Nullable\n+    private volatile ScheduledFuture<?> scheduledFuture;\n+    private volatile boolean closed;\n+\n+    EurekaEndpointGroup(URI eurekaUri, long registryFetchIntervalSeconds, @Nullable String appName,\n+                        @Nullable String instanceId, @Nullable String vipAddress,\n+                        @Nullable String secureVipAddress, @Nullable List<String> regions,\n+                        @Nullable Consumer<WebClientBuilder> customizer) {\n+        this.registryFetchIntervalSeconds = registryFetchIntervalSeconds;\n+\n+        final RequestHeadersBuilder headersBuilder = RequestHeaders.builder();\n+        headersBuilder.method(HttpMethod.GET);\n+        headersBuilder.add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON_UTF_8);\n+        responseConverter = responseConverter(headersBuilder, appName, instanceId,\n+                                              vipAddress, secureVipAddress, regions);\n+        requestHeaders = headersBuilder.build();\n+\n+        final WebClientBuilder webClientBuilder = WebClient.builder(eurekaUri);\n+        if (customizer != null) {\n+            customizer.accept(webClientBuilder);\n+        }\n+        webClient = webClientBuilder.build();\n+        webClient.options().factory().whenClosed().thenRun(this::closeAsync);\n+        fetchRegistry();\n+    }\n+\n+    private void fetchRegistry() {\n+        final HttpResponse response;\n+        final ClientRequestContext ctx;\n+        try (ClientRequestContextCaptor captor = Clients.newContextCaptor()) {\n+            response = webClient.execute(requestHeaders);\n+            ctx = captor.get();\n+        }\n+\n+        final EventLoop eventLoop = ctx.eventLoop();\n+        response.aggregateWithPooledObjects(eventLoop, ctx.alloc()).handle((aggregatedRes, cause) -> {\n+            try {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Unexpected exception while fetching the registry from: {}.\" +\n+                                \" (requestHeaders: {})\", webClient.uri(), requestHeaders, cause);\n+                } else {\n+                    final HttpStatus status = aggregatedRes.status();\n+                    if (!status.isSuccess()) {\n+                        logger.warn(\"Unexpected response from: {}. (status: {}, content: {}, \" +\n+                                    \"requestHeaders: {})\", webClient.uri(), status,\n+                                    aggregatedRes.contentUtf8(), requestHeaders);\n+                    } else {\n+                        final HttpData content = aggregatedRes.content();\n+                        try {\n+                            final List<Endpoint> endpoints = responseConverter.apply(content.array());\n+                            setEndpoints(endpoints);\n+                        } catch (Exception e) {\n+                            logger.warn(\"Unexpected exception while parsing response from: {}. \" +", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNTc0Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423535746", "bodyText": "Thanks!", "author": "minwoox", "createdAt": "2020-05-12T07:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NzcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\nindex 2bbf2ddde..6f378f7b5 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n\n@@ -25,7 +25,6 @@ import java.util.Set;\n import java.util.StringJoiner;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Predicate;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTI2Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423499262", "bodyText": "Would it make sense to extend AbstractClientOptionsBuilder instead of exposing customizer(), like we did for ArmeriaRetrofitBuilder?", "author": "trustin", "createdAt": "2020-05-12T06:49:00Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+\n+/**\n+ * Builds a {@link EurekaEndpointGroup}.\n+ */\n+public final class EurekaEndpointGroupBuilder {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NzMxOA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423547318", "bodyText": "That's a good idea!", "author": "minwoox", "createdAt": "2020-05-12T08:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTI2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java\nindex d72fc8d40..fb5b4b94f 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java\n\n@@ -22,19 +22,37 @@ import static java.util.Objects.requireNonNull;\n import java.net.URI;\n import java.time.Duration;\n import java.util.List;\n+import java.util.Map.Entry;\n import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n \n import javax.annotation.Nullable;\n \n import com.google.common.collect.ImmutableList;\n \n+import com.linecorp.armeria.client.AbstractClientOptionsBuilder;\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.ClientOption;\n+import com.linecorp.armeria.client.ClientOptionValue;\n+import com.linecorp.armeria.client.ClientOptions;\n+import com.linecorp.armeria.client.DecoratingHttpClientFunction;\n+import com.linecorp.armeria.client.DecoratingRpcClientFunction;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.RpcClient;\n import com.linecorp.armeria.client.WebClient;\n import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.RequestId;\n+import com.linecorp.armeria.common.auth.BasicToken;\n+import com.linecorp.armeria.common.auth.OAuth1aToken;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n \n /**\n  * Builds a {@link EurekaEndpointGroup}.\n  */\n-public final class EurekaEndpointGroupBuilder {\n+public final class EurekaEndpointGroupBuilder extends AbstractClientOptionsBuilder {\n \n     private static final long DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS = 30;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423499831", "bodyText": "Is there any chance this could be an arbitrary string?", "author": "trustin", "createdAt": "2020-05-12T06:50:15Z", "path": "eureka/src/main/java/com/linecorp/armeria/common/eureka/DataCenterName.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.eureka;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The data center names.\n+ */\n+public enum DataCenterName {\n+    Netflix,\n+    Amazon,\n+    MyOwn;", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNzExMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423537113", "bodyText": "I just followed the code. https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/appinfo/DataCenterInfo.java#L35\nDo you think it's better to let a user just uses an arbitrary string?\ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-12T07:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NTUwMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423555503", "bodyText": "I'd prefer allowing an arbitrary string because:\n\neven AWS has multiple DCs\nthere are more cloud providers than AWS nowadays.", "author": "trustin", "createdAt": "2020-05-12T08:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU3MTYxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423571615", "bodyText": "Sounds good. Let me just use a String. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5OTgzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/common/eureka/DataCenterName.java b/eureka/src/main/java/com/linecorp/armeria/common/eureka/DataCenterName.java\ndeleted file mode 100644\nindex 33021cd1c..000000000\n--- a/eureka/src/main/java/com/linecorp/armeria/common/eureka/DataCenterName.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.common.eureka;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The data center names.\n- */\n-public enum DataCenterName {\n-    Netflix,\n-    Amazon,\n-    MyOwn;\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DataCenterName.class);\n-\n-    /**\n-     * Returns the {@link Enum} value corresponding to the specified {@code str}.\n-     * {@link #MyOwn} is returned if none of {@link Enum}s are matched.\n-     */\n-    public static DataCenterName toEnum(String str) {\n-        try {\n-            return valueOf(str);\n-        } catch (IllegalArgumentException e) {\n-            logger.warn(\"unknown enum value: {} (expected: {}), {} is set by default. \", str, values(), MyOwn);\n-        }\n-        return MyOwn;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTAwNA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501004", "bodyText": "This could be removed?", "author": "trustin", "createdAt": "2020-05-12T06:52:55Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTI0MA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501240", "bodyText": "This could be removed?\nderegisters", "author": "trustin", "createdAt": "2020-05-12T06:53:27Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzNzc3OQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423537779", "bodyText": "Thanks fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-12T08:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTI0MA=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTQ1Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501452", "bodyText": "a cancellation request?", "author": "trustin", "createdAt": "2020-05-12T06:53:59Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501818", "bodyText": "What's an instance ID? Is it possible to use the current hostname, IP address or some hashed value of them as the default instance ID?", "author": "trustin", "createdAt": "2020-05-12T06:54:46Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzODQzNw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423538437", "bodyText": "instanceID is the unique id associated with the instance. In AWS cloud, instanceID is the instance id of the instance and in other data centers, it is the hostname of the instance.\nSo I guess we can just use the hostname when it's not specified. Thanks!", "author": "minwoox", "createdAt": "2020-05-12T08:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1NDEwMA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423554100", "bodyText": "Sounds good. Should we move the instanceId parameter to the builder API?", "author": "trustin", "createdAt": "2020-05-12T08:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU2ODc4NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423568784", "bodyText": "Should we move the instanceId parameter to the builder API?\n\nYes, I'm working on it. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTgxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTk1Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423501957", "bodyText": "Ditto - overkill?", "author": "trustin", "createdAt": "2020-05-12T06:55:01Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUzODUyMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423538523", "bodyText": "Yeah. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMTk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423502727", "bodyText": "Would !...isSuccess() work here?", "author": "trustin", "createdAt": "2020-05-12T06:56:36Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0MDIzMg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423540232", "bodyText": "Have thought about it, but I guess I wanted to be as specific as I could.\nNot strong on this, though. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-05-12T08:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MzQxMw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423553413", "bodyText": "OK!", "author": "trustin", "createdAt": "2020-05-12T08:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMjcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423503187", "bodyText": "Curious if we need to renew the lease a little bit sooner than specified to avoid timing issues. Thoughts?", "author": "trustin", "createdAt": "2020-05-12T06:57:29Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                    newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                    }\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx, newInfo);\n+                    return null;\n+                } finally {\n+                    ReferenceCountUtil.release(res.content());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(ClientRequestContext ctx, InstanceInfo newInfo) {\n+        heartBeatFuture = ctx.eventLoop().schedule(new HeartBeatTask(ctx, newInfo),\n+                                                   newInfo.getLeaseInfo().getRenewalIntervalInSecs(),", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0Mjg3Mw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423542873", "bodyText": "If a user uses default values (Eureka does not recommend to change the value), the renewal interval is 30 seconds and if Eureka does not see this heart beat in 90 seconds, the registry is removed. Also Eureka client does not have that logic. So I guess it's okay?", "author": "minwoox", "createdAt": "2020-05-12T08:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1MzY3Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423553677", "bodyText": "I see. Then it's handled by the Eureka server. No problem.", "author": "trustin", "createdAt": "2020-05-12T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMzE4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNDU2MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423504561", "bodyText": "Ditto - overkill", "author": "trustin", "createdAt": "2020-05-12T07:00:18Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka. This\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, This {@link EurekaUpdatingListener} deregister the\n+ * {@link Server} from Eureka by sending the cancel request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri, String instanceId) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")), instanceId);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri} and\n+     * {@code instanceId}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri, String instanceId) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri, instanceId);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc()).handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                try {\n+                    if (cause != null) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                    newInfo.getHostName(), client.uri(), cause);\n+                        return null;\n+                    }\n+                    final ResponseHeaders headers = res.headers();\n+                    if (headers.status() != HttpStatus.NO_CONTENT) {\n+                        logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                    newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                    }\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx, newInfo);\n+                    return null;\n+                } finally {\n+                    ReferenceCountUtil.release(res.content());\n+                }\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(ClientRequestContext ctx, InstanceInfo newInfo) {\n+        heartBeatFuture = ctx.eventLoop().schedule(new HeartBeatTask(ctx, newInfo),\n+                                                   newInfo.getLeaseInfo().getRenewalIntervalInSecs(),\n+                                                   TimeUnit.SECONDS);\n+    }\n+\n+    private InstanceInfo fillAndCreateNewInfo(InstanceInfo oldInfo, Server server) {\n+        final String defaultHostname = server.defaultHostname();\n+        final String hostName = oldInfo.getHostName() != null ? oldInfo.getHostName() : defaultHostname;\n+        appName = oldInfo.getAppName() != null ? oldInfo.getAppName() : defaultHostname;\n+\n+        final Inet4Address defaultInet4Address = SystemInfo.defaultNonLoopbackIpV4Address();\n+        final String defaultIpAddr = defaultInet4Address != null ? defaultInet4Address.getHostAddress()\n+                                                                 : null;\n+        final String ipAddr = oldInfo.getIpAddr() != null ? oldInfo.getIpAddr() : defaultIpAddr;\n+        final PortWrapper oldPortWrapper = oldInfo.getPort();\n+        final PortWrapper portWrapper = portWrapper(server, oldPortWrapper, SessionProtocol.HTTP);\n+        final PortWrapper oldSecurePortWrapper = oldInfo.getSecurePort();\n+        final PortWrapper securePortWrapper = portWrapper(server, oldSecurePortWrapper, SessionProtocol.HTTPS);\n+\n+        final String vipAddress = vipAddress(oldInfo.getVipAddress(), hostName, portWrapper);\n+        final String secureVipAddress = vipAddress(oldInfo.getSecureVipAddress(), hostName, securePortWrapper);\n+\n+        final Optional<ServiceConfig> healthCheckService =\n+                server.serviceConfigs()\n+                      .stream()\n+                      .filter(cfg -> cfg.service().as(HealthCheckService.class) != null)\n+                      .findFirst();\n+\n+        final String hostnameOrIpAddr;\n+        if (oldInfo.getHostName() != null) {\n+            hostnameOrIpAddr = oldInfo.getHostName();\n+        } else if (ipAddr != null) {\n+            hostnameOrIpAddr = ipAddr;\n+        } else {\n+            hostnameOrIpAddr = hostName;\n+        }\n+        final String healthCheckUrl = healthCheckUrl(hostnameOrIpAddr, oldInfo.getHealthCheckUrl(), portWrapper,\n+                                                     healthCheckService, SessionProtocol.HTTP);\n+        final String secureHealthCheckUrl =\n+                healthCheckUrl(hostnameOrIpAddr, oldInfo.getSecureHealthCheckUrl(), securePortWrapper,\n+                               healthCheckService, SessionProtocol.HTTPS);\n+\n+        return new InstanceInfo(oldInfo.getInstanceId(), appName, oldInfo.getAppGroupName(), hostName, ipAddr,\n+                                vipAddress, secureVipAddress, portWrapper, securePortWrapper, InstanceStatus.UP,\n+                                oldInfo.getHomePageUrl(), oldInfo.getStatusPageUrl(), healthCheckUrl,\n+                                secureHealthCheckUrl, oldInfo.getDataCenterInfo(),\n+                                oldInfo.getLeaseInfo(), oldInfo.getMetadata());\n+    }\n+\n+    private static PortWrapper portWrapper(Server server, PortWrapper oldPortWrapper,\n+                                           SessionProtocol protocol) {\n+        if (oldPortWrapper.isEnabled()) {\n+            for (ServerPort serverPort : server.activePorts().values()) {\n+                if (serverPort.hasProtocol(protocol) &&\n+                    serverPort.localAddress().getPort() == oldPortWrapper.getPort()) {\n+                    return oldPortWrapper;\n+                }\n+            }\n+            logger.warn(\"The port number: {} (expected one of activePorts: {})\",\n+                        oldPortWrapper.getPort(), server.activePorts());\n+        }\n+\n+        final ServerPort serverPort = server.activePort(protocol);\n+        if (serverPort == null) {\n+            return disabledPort;\n+        }\n+        return new PortWrapper(true, serverPort.localAddress().getPort());\n+    }\n+\n+    @Nullable\n+    private static String vipAddress(@Nullable String vipAddress, String hostName, PortWrapper portWrapper) {\n+        if (!portWrapper.isEnabled()) {\n+            return null;\n+        }\n+        return vipAddress != null ? vipAddress : hostName + ':' + portWrapper.getPort();\n+    }\n+\n+    @Nullable\n+    private static String healthCheckUrl(String hostnameOrIpAddr, @Nullable String oldHealthCheckUrl,\n+                                         PortWrapper portWrapper,\n+                                         Optional<ServiceConfig> healthCheckService,\n+                                         SessionProtocol sessionProtocol) {\n+        if (oldHealthCheckUrl != null) {\n+            return oldHealthCheckUrl;\n+        }\n+        if (!portWrapper.isEnabled() || !healthCheckService.isPresent()) {\n+            return null;\n+        }\n+        final ServiceConfig healthCheckServiceConfig = healthCheckService.get();\n+        final Route route = healthCheckServiceConfig.route();\n+        if (route.pathType() != RoutePathType.EXACT && route.pathType() != RoutePathType.PREFIX) {\n+            return null;\n+        }\n+\n+        return sessionProtocol.uriText() + \"://\" + hostnameOrIpAddr + ':' + portWrapper.getPort() +\n+               route.paths().get(0);\n+    }\n+\n+    @Override\n+    public void serverStopping(Server server) throws Exception {\n+        closed = true;\n+        final ScheduledFuture<?> heartBeatFuture = this.heartBeatFuture;\n+        if (heartBeatFuture != null) {\n+            heartBeatFuture.cancel(false);\n+        }\n+        final String appName = this.appName;\n+        if (appName != null) {\n+            client.cancel(appName, instanceInfo.getInstanceId()).aggregate().handle((res, cause) -> {\n+                if (cause != null) {\n+                    logger.warn(\"Failed to deregister from Eureka: {}\", client.uri(), cause);\n+                } else if (!res.status().isSuccess()) {\n+                    logger.warn(\"Failed to deregister from Eureka: {} (status: {}, content: {})\",\n+                                client.uri(), res.status(), res.contentUtf8());\n+                }\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private class HeartBeatTask implements Runnable {\n+\n+        private final ClientRequestContext ctx;\n+        private final InstanceInfo instanceInfo;\n+\n+        HeartBeatTask(ClientRequestContext ctx, InstanceInfo instanceInfo) {\n+            this.ctx = ctx;\n+            this.instanceInfo = instanceInfo;\n+        }\n+\n+        @Override\n+        public void run() {\n+            final String appName = instanceInfo.getAppName();\n+            assert appName != null;\n+            client.sendHeartBeat(appName, instanceInfo.getInstanceId(), instanceInfo, null)\n+                  .aggregateWithPooledObjects(ctx.eventLoop(), ctx.alloc())", "originalCommit": "e1d86e7bd8c552ecae204805938154c69c7f5b47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 19461b86e..240b931c8 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -15,7 +15,7 @@\n  */\n package com.linecorp.armeria.server.eureka;\n \n-import static com.linecorp.armeria.internal.common.eureka.InstanceInfoBuilder.disabledPort;\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n import static java.util.Objects.requireNonNull;\n \n import java.net.Inet4Address;\n"}}, {"oid": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "url": "https://github.com/line/armeria/commit/c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "message": "Address the comments by @trustin", "committedDate": "2020-05-12T10:17:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2NTY4MA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423665680", "bodyText": "Could replace with String.join(\",\", regions)?", "author": "ikhoon", "createdAt": "2020-05-12T11:38:57Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public EurekaWebClient(WebClient webClient) {\n+        this.webClient = requireNonNull(webClient, \"webClient\");\n+    }\n+\n+    /**\n+     * Returns the {@link URI} of the Eureka registry.\n+     */\n+    public URI uri() {\n+        return webClient.uri();\n+    }\n+\n+    /**\n+     * Registers the specified {@link InstanceInfo} to the Eureka registry.\n+     */\n+    public HttpResponse register(InstanceInfo info) {\n+        requireNonNull(info, \"info\");\n+        final String path = APPS + info.getAppName();\n+        final RequestHeaders headers = RequestHeaders.builder(HttpMethod.POST, path)\n+                                                     .contentType(MediaType.JSON)\n+                                                     .build();\n+        try {\n+            return webClient.execute(headers, mapper.writeValueAsBytes(info));\n+        } catch (JsonProcessingException e) {\n+            return HttpResponse.ofFailure(e);\n+        }\n+    }\n+\n+    /**\n+     * Sends the heart beat to the Eureka registry.\n+     */\n+    public HttpResponse sendHeartBeat(String appName, String instanceId, InstanceInfo instanceInfo,\n+                                      @Nullable InstanceStatus overriddenStatus) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        requireNonNull(instanceInfo, \"instanceInfo\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        final QueryParamsBuilder queryBuilder =\n+                QueryParams.builder()\n+                           .add(\"status\", instanceInfo.getStatus().toString())\n+                           .addLong(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp());\n+        if (overriddenStatus != null) {\n+            queryBuilder.add(\"overriddenstatus\", overriddenStatus.toString());\n+        }\n+        final RequestHeaders headers =\n+                RequestHeaders.builder(HttpMethod.PUT, path + '?' + queryBuilder.toQueryString())\n+                              .add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON)\n+                              .build();\n+        return webClient.execute(headers);\n+    }\n+\n+    /**\n+     * Deregisters the specified {@code instanceId} in {@code appName} from the Eureka registry.\n+     */\n+    public HttpResponse cancel(String appName, String instanceId) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        return webClient.delete(path);\n+    }\n+\n+    /**\n+     * Retrieves the registry information whose regions are the specified {@code regions} from the Eureka.\n+     */\n+    public HttpResponse getApplications(Iterable<String> regions) {\n+        return getApplications(APPS, requireNonNull(regions, \"regions\"));\n+    }\n+\n+    private HttpResponse getApplications(String path, Iterable<String> regions) {\n+        if (!Iterables.isEmpty(regions)) {\n+            final StringJoiner joiner = new StringJoiner(\",\");\n+            regions.forEach(joiner::add);", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNTA1Mw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424135053", "bodyText": "Fixed. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-13T02:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2NTY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\nindex 82dfaf156..3b38aa5b7 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\n\n@@ -18,7 +18,6 @@ package com.linecorp.armeria.internal.common.eureka;\n import static java.util.Objects.requireNonNull;\n \n import java.net.URI;\n-import java.util.StringJoiner;\n \n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423668274", "bodyText": "I'd prefer deregister as this method name so that we can make consistency with register(InstanceInfo info).", "author": "ikhoon", "createdAt": "2020-05-12T11:44:06Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public EurekaWebClient(WebClient webClient) {\n+        this.webClient = requireNonNull(webClient, \"webClient\");\n+    }\n+\n+    /**\n+     * Returns the {@link URI} of the Eureka registry.\n+     */\n+    public URI uri() {\n+        return webClient.uri();\n+    }\n+\n+    /**\n+     * Registers the specified {@link InstanceInfo} to the Eureka registry.\n+     */\n+    public HttpResponse register(InstanceInfo info) {\n+        requireNonNull(info, \"info\");\n+        final String path = APPS + info.getAppName();\n+        final RequestHeaders headers = RequestHeaders.builder(HttpMethod.POST, path)\n+                                                     .contentType(MediaType.JSON)\n+                                                     .build();\n+        try {\n+            return webClient.execute(headers, mapper.writeValueAsBytes(info));\n+        } catch (JsonProcessingException e) {\n+            return HttpResponse.ofFailure(e);\n+        }\n+    }\n+\n+    /**\n+     * Sends the heart beat to the Eureka registry.\n+     */\n+    public HttpResponse sendHeartBeat(String appName, String instanceId, InstanceInfo instanceInfo,\n+                                      @Nullable InstanceStatus overriddenStatus) {\n+        requireNonNull(appName, \"appName\");\n+        requireNonNull(instanceId, \"instanceId\");\n+        requireNonNull(instanceInfo, \"instanceInfo\");\n+        final String path = APPS + appName + '/' + instanceId;\n+        final QueryParamsBuilder queryBuilder =\n+                QueryParams.builder()\n+                           .add(\"status\", instanceInfo.getStatus().toString())\n+                           .addLong(\"lastDirtyTimestamp\", instanceInfo.getLastDirtyTimestamp());\n+        if (overriddenStatus != null) {\n+            queryBuilder.add(\"overriddenstatus\", overriddenStatus.toString());\n+        }\n+        final RequestHeaders headers =\n+                RequestHeaders.builder(HttpMethod.PUT, path + '?' + queryBuilder.toQueryString())\n+                              .add(HttpHeaderNames.ACCEPT, MediaTypeNames.JSON)\n+                              .build();\n+        return webClient.execute(headers);\n+    }\n+\n+    /**\n+     * Deregisters the specified {@code instanceId} in {@code appName} from the Eureka registry.\n+     */\n+    public HttpResponse cancel(String appName, String instanceId) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNDU2Mw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424134563", "bodyText": "I used what they are using.\nhttps://github.com/Netflix/eureka/wiki/Understanding-eureka-client-server-communication#cancel\nhttps://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClient.java#L17", "author": "minwoox", "createdAt": "2020-05-13T02:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0ODA4NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424148084", "bodyText": "I see, then leave it as it is.", "author": "ikhoon", "createdAt": "2020-05-13T03:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2ODI3NA=="}], "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\nindex 82dfaf156..3b38aa5b7 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\n\n@@ -18,7 +18,6 @@ package com.linecorp.armeria.internal.common.eureka;\n import static java.util.Objects.requireNonNull;\n \n import java.net.URI;\n-import java.util.StringJoiner;\n \n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDI5OA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423670298", "bodyText": "Could be static?", "author": "ikhoon", "createdAt": "2020-05-12T11:47:54Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nullable;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.google.common.collect.Iterables;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.MediaType;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.QueryParamsBuilder;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+\n+/**\n+ * A Eureka {@link WebClient} which communicates to the\n+ * <a href=\"https://github.com/Netflix/eureka/wiki/Eureka-REST-operations\">Eureka registry</a>.\n+ */\n+public final class EurekaWebClient {\n+\n+    private static final String APPS = \"/apps/\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    private final WebClient webClient;\n+    private final ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.WRAP_ROOT_VALUE)\n+                                                          .setSerializationInclusion(Include.NON_NULL);", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMzgxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424133815", "bodyText": "Oops, thanks!", "author": "minwoox", "createdAt": "2020-05-13T02:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3MDI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\nindex 82dfaf156..3b38aa5b7 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/EurekaWebClient.java\n\n@@ -18,7 +18,6 @@ package com.linecorp.armeria.internal.common.eureka;\n import static java.util.Objects.requireNonNull;\n \n import java.net.URI;\n-import java.util.StringJoiner;\n \n import javax.annotation.Nullable;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NTUwMA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423675500", "bodyText": "Wow, TMI. \ud83d\ude4a", "author": "ikhoon", "createdAt": "2020-05-12T11:57:49Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * An instance information.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonRootName(\"instance\")\n+public final class InstanceInfo {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InstanceInfo.class);\n+\n+    private final String instanceId;\n+\n+    @Nullable\n+    private final String hostName;\n+    @Nullable\n+    private final String appName;\n+    @Nullable\n+    private final String appGroupName;\n+    @Nullable\n+    private final String ipAddr;\n+    @Nullable\n+    private final String vipAddress;\n+    @Nullable\n+    private final String secureVipAddress;\n+\n+    private final PortWrapper port;\n+    private final PortWrapper securePort;\n+    private final InstanceStatus status;\n+\n+    @Nullable\n+    private final String homePageUrl;\n+    @Nullable\n+    private final String statusPageUrl;\n+    @Nullable\n+    private final String healthCheckUrl;\n+    @Nullable\n+    private final String secureHealthCheckUrl;\n+    private final DataCenterInfo dataCenterInfo;\n+    private final LeaseInfo leaseInfo;\n+    private final Map<String, String> metadata;\n+\n+    private final long lastUpdatedTimestamp;\n+    private final long lastDirtyTimestamp;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+                        @Nullable @JsonProperty(\"app\") String appName,\n+                        @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n+                        @Nullable @JsonProperty(\"hostName\") String hostName,\n+                        @Nullable @JsonProperty(\"ipAddr\") String ipAddr,\n+                        @Nullable @JsonProperty(\"vipAddress\") String vipAddress,\n+                        @Nullable @JsonProperty(\"secureVipAddress\") String secureVipAddress,\n+                        @JsonProperty(\"port\") PortWrapper port,\n+                        @JsonProperty(\"securePort\") PortWrapper securePort,\n+                        @JsonProperty(\"status\") InstanceStatus status,\n+                        @Nullable @JsonProperty(\"homePageUrl\") String homePageUrl,\n+                        @Nullable @JsonProperty(\"statusPageUrl\") String statusPageUrl,\n+                        @Nullable @JsonProperty(\"healthCheckUrl\") String healthCheckUrl,\n+                        @Nullable @JsonProperty(\"secureHealthCheckUrl\") String secureHealthCheckUrl,\n+                        @JsonProperty(\"dataCenterInfo\") DataCenterInfo dataCenterInfo,\n+                        @JsonProperty(\"leaseInfo\") LeaseInfo leaseInfo,\n+                        @Nullable @JsonProperty(\"metadata\") Map<String, String> metadata) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\nindex 2e73a6e39..0a4e23c54 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\n\n@@ -79,7 +79,7 @@ public final class InstanceInfo {\n     /**\n      * Creates a new instance.\n      */\n-    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+    public InstanceInfo(@Nullable @JsonProperty(\"instanceId\") String instanceId,\n                         @Nullable @JsonProperty(\"app\") String appName,\n                         @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n                         @Nullable @JsonProperty(\"hostName\") String hostName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3ODU4Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423678587", "bodyText": "Do we need this information?  What do you think of ignoring this field from the JSON response?", "author": "ikhoon", "createdAt": "2020-05-12T12:03:39Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.internal.common.eureka;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonRootName;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.google.common.base.Objects;\n+import com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * An instance information.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonRootName(\"instance\")\n+public final class InstanceInfo {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(InstanceInfo.class);\n+\n+    private final String instanceId;\n+\n+    @Nullable\n+    private final String hostName;\n+    @Nullable\n+    private final String appName;\n+    @Nullable\n+    private final String appGroupName;\n+    @Nullable\n+    private final String ipAddr;\n+    @Nullable\n+    private final String vipAddress;\n+    @Nullable\n+    private final String secureVipAddress;\n+\n+    private final PortWrapper port;\n+    private final PortWrapper securePort;\n+    private final InstanceStatus status;\n+\n+    @Nullable\n+    private final String homePageUrl;\n+    @Nullable\n+    private final String statusPageUrl;\n+    @Nullable\n+    private final String healthCheckUrl;\n+    @Nullable\n+    private final String secureHealthCheckUrl;\n+    private final DataCenterInfo dataCenterInfo;\n+    private final LeaseInfo leaseInfo;\n+    private final Map<String, String> metadata;\n+\n+    private final long lastUpdatedTimestamp;\n+    private final long lastDirtyTimestamp;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+                        @Nullable @JsonProperty(\"app\") String appName,\n+                        @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n+                        @Nullable @JsonProperty(\"hostName\") String hostName,\n+                        @Nullable @JsonProperty(\"ipAddr\") String ipAddr,\n+                        @Nullable @JsonProperty(\"vipAddress\") String vipAddress,\n+                        @Nullable @JsonProperty(\"secureVipAddress\") String secureVipAddress,\n+                        @JsonProperty(\"port\") PortWrapper port,\n+                        @JsonProperty(\"securePort\") PortWrapper securePort,\n+                        @JsonProperty(\"status\") InstanceStatus status,\n+                        @Nullable @JsonProperty(\"homePageUrl\") String homePageUrl,\n+                        @Nullable @JsonProperty(\"statusPageUrl\") String statusPageUrl,\n+                        @Nullable @JsonProperty(\"healthCheckUrl\") String healthCheckUrl,\n+                        @Nullable @JsonProperty(\"secureHealthCheckUrl\") String secureHealthCheckUrl,\n+                        @JsonProperty(\"dataCenterInfo\") DataCenterInfo dataCenterInfo,\n+                        @JsonProperty(\"leaseInfo\") LeaseInfo leaseInfo,\n+                        @Nullable @JsonProperty(\"metadata\") Map<String, String> metadata) {\n+        this.instanceId = instanceId;\n+        this.hostName = hostName;\n+        this.appName = appName;\n+        this.appGroupName = appGroupName;\n+        this.ipAddr = ipAddr;\n+        this.vipAddress = vipAddress;\n+        this.secureVipAddress = secureVipAddress;\n+        this.port = requireNonNull(port, \"port\");\n+        this.securePort = requireNonNull(securePort, \"securePort\");\n+        this.status = requireNonNull(status, \"status\");\n+        this.homePageUrl = homePageUrl;\n+        this.statusPageUrl = statusPageUrl;\n+        this.healthCheckUrl = healthCheckUrl;\n+        this.secureHealthCheckUrl = secureHealthCheckUrl;\n+        this.dataCenterInfo = dataCenterInfo;\n+        this.leaseInfo = requireNonNull(leaseInfo, \"leaseInfo\");\n+        if (metadata != null) {\n+            this.metadata = metadata;\n+        } else {\n+            this.metadata = ImmutableMap.of();\n+        }\n+\n+        lastUpdatedTimestamp = System.currentTimeMillis();\n+        lastDirtyTimestamp = lastUpdatedTimestamp;\n+    }\n+\n+    /**\n+     * Returns the ID of this instance.\n+     */\n+    @Nullable\n+    public String getInstanceId() {\n+        return instanceId;\n+    }\n+\n+    /**\n+     * Return the name of the application which this instance belongs to.\n+     */\n+    @Nullable\n+    @JsonProperty(\"app\")\n+    public String getAppName() {\n+        return appName;\n+    }\n+\n+    /**\n+     * Return the group name of the application which this instance belongs to.\n+     */\n+    @Nullable\n+    public String getAppGroupName() {\n+        return appGroupName;\n+    }\n+\n+    /**\n+     * Return the hostname of this instance.\n+     */\n+    @Nullable\n+    public String getHostName() {\n+        return hostName;\n+    }\n+\n+    /**\n+     * Returns the IP address of this instance.\n+     */\n+    @Nullable\n+    public String getIpAddr() {\n+        return ipAddr;\n+    }\n+\n+    /**\n+     * Returns the VIP address of this instance.\n+     */\n+    @Nullable\n+    public String getVipAddress() {\n+        return vipAddress;\n+    }\n+\n+    /**\n+     * Returns the secure VIP address of this instance.\n+     */\n+    @Nullable\n+    public String getSecureVipAddress() {\n+        return secureVipAddress;\n+    }\n+\n+    /**\n+     * Returns the {@link PortWrapper} of this instance.\n+     */\n+    public PortWrapper getPort() {\n+        return port;\n+    }\n+\n+    /**\n+     * Returns the secure {@link PortWrapper} of this instance.\n+     */\n+    public PortWrapper getSecurePort() {\n+        return securePort;\n+    }\n+\n+    /**\n+     * Returns the {@link InstanceStatus} of this instance.\n+     */\n+    public InstanceStatus getStatus() {\n+        return status;\n+    }\n+\n+    /**\n+     * Returns the home page URL of this instance.\n+     */\n+    @Nullable\n+    public String getHomePageUrl() {\n+        return homePageUrl;\n+    }", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNjQ3Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424136476", "bodyText": "The clients who are using other implementation (not EurekaEndpointGroup) might need this information.", "author": "minwoox", "createdAt": "2020-05-13T02:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3ODU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\nindex 2e73a6e39..0a4e23c54 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\n\n@@ -79,7 +79,7 @@ public final class InstanceInfo {\n     /**\n      * Creates a new instance.\n      */\n-    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+    public InstanceInfo(@Nullable @JsonProperty(\"instanceId\") String instanceId,\n                         @Nullable @JsonProperty(\"app\") String appName,\n                         @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n                         @Nullable @JsonProperty(\"hostName\") String hostName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r423698690", "bodyText": "Question: Don't we need to take multiple eureka URIs? From the HA spec of eureka, a client should attempt to connect other eureka servers if a eureka is sitting idle.\nhttps://blog.asarkar.org/technical/netflix-eureka/#high-availability-ha", "author": "ikhoon", "createdAt": "2020-05-12T12:38:14Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.URI;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.AbstractClientOptionsBuilder;\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.ClientOption;\n+import com.linecorp.armeria.client.ClientOptionValue;\n+import com.linecorp.armeria.client.ClientOptions;\n+import com.linecorp.armeria.client.DecoratingHttpClientFunction;\n+import com.linecorp.armeria.client.DecoratingRpcClientFunction;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.HttpClient;\n+import com.linecorp.armeria.client.RpcClient;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.WebClientBuilder;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.RequestId;\n+import com.linecorp.armeria.common.auth.BasicToken;\n+import com.linecorp.armeria.common.auth.OAuth1aToken;\n+import com.linecorp.armeria.common.auth.OAuth2Token;\n+\n+/**\n+ * Builds a {@link EurekaEndpointGroup}.\n+ */\n+public final class EurekaEndpointGroupBuilder extends AbstractClientOptionsBuilder {\n+\n+    private static final long DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS = 30;\n+\n+    private final URI eurekaUri;\n+\n+    @Nullable\n+    private String appName;\n+\n+    @Nullable\n+    private String instanceId;\n+\n+    @Nullable\n+    private String vipAddress;\n+\n+    @Nullable\n+    private String secureVipAddress;\n+\n+    private long registryFetchIntervalSeconds = DEFAULT_REGISTRY_FETCH_INTERVAL_SECONDS;\n+\n+    @Nullable\n+    private List<String> regions;\n+    @Nullable\n+    private Consumer<WebClientBuilder> customizer;\n+\n+    EurekaEndpointGroupBuilder(URI eurekaUri) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDE4NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424140184", "bodyText": "That's a good idea. How about adding a constructor that takes an EndpointGroup?", "author": "minwoox", "createdAt": "2020-05-13T02:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NzYxOQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424147619", "bodyText": "SGTM :-)", "author": "ikhoon", "createdAt": "2020-05-13T03:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY5ODY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java\nindex fb5b4b94f..f119ebf1d 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroupBuilder.java\n\n@@ -23,7 +23,6 @@ import java.net.URI;\n import java.time.Duration;\n import java.util.List;\n import java.util.Map.Entry;\n-import java.util.function.Consumer;\n import java.util.function.Function;\n import java.util.function.Supplier;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424130591", "bodyText": "Case sensitive or insensitive?", "author": "trustin", "createdAt": "2020-05-13T01:59:25Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/DataCenterInfoSerializer.java", "diffHunk": "@@ -37,12 +35,12 @@\n     public void serialize(DataCenterInfo value, JsonGenerator gen, SerializerProvider provider)\n             throws IOException {\n         gen.writeStartObject();\n-        if (value.getName() == DataCenterName.Amazon) {\n+        if (\"Amazon\".equalsIgnoreCase(value.getName())) {", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNzU4OA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424137588", "bodyText": "I just followed their logic. https://github.com/Netflix/eureka/blob/master/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java#L497\n\ud83e\udd14", "author": "minwoox", "createdAt": "2020-05-13T02:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0OTIxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424149215", "bodyText": "It looks like JSON format in Eureka has a backward compatibility issue.\nNetflix/eureka#1051", "author": "ikhoon", "createdAt": "2020-05-13T03:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MDAwMg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424150002", "bodyText": "Yes, they have that a lot. For the overriddenstatus you gave the link, if we use the camel case the test suite fails. https://github.com/Netflix/eureka/blob/master/eureka-test-utils/src/main/java/com/netflix/discovery/shared/transport/SimpleEurekaHttpServer.java#L174", "author": "minwoox", "createdAt": "2020-05-13T03:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDU5MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDcxNQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424130715", "bodyText": "Missing space before @", "author": "trustin", "createdAt": "2020-05-13T01:59:51Z", "path": "eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java", "diffHunk": "@@ -79,7 +79,7 @@\n     /**\n      * Creates a new instance.\n      */\n-    public InstanceInfo(@JsonProperty(\"instanceId\") String instanceId,\n+    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,", "originalCommit": "c83e5dac7b97d2a440a9358cbc1e52e4703386e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzNzczMA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424137730", "bodyText": "OOps. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-05-13T02:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMDcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "161f7636495c4b4cb832403e14d5998dfc4e7674", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\nindex 2e73a6e39..0a4e23c54 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/internal/common/eureka/InstanceInfo.java\n\n@@ -79,7 +79,7 @@ public final class InstanceInfo {\n     /**\n      * Creates a new instance.\n      */\n-    public InstanceInfo(@Nullable@JsonProperty(\"instanceId\") String instanceId,\n+    public InstanceInfo(@Nullable @JsonProperty(\"instanceId\") String instanceId,\n                         @Nullable @JsonProperty(\"app\") String appName,\n                         @Nullable @JsonProperty(\"appGroupName\") String appGroupName,\n                         @Nullable @JsonProperty(\"hostName\") String hostName,\n"}}, {"oid": "161f7636495c4b4cb832403e14d5998dfc4e7674", "url": "https://github.com/line/armeria/commit/161f7636495c4b4cb832403e14d5998dfc4e7674", "message": "Address comments by @trustin and @ikhoon", "committedDate": "2020-05-13T04:06:30Z", "type": "commit"}, {"oid": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "url": "https://github.com/line/armeria/commit/244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "message": "Returns non local port first", "committedDate": "2020-05-13T04:18:39Z", "type": "commit"}, {"oid": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "url": "https://github.com/line/armeria/commit/269360b72da27d34a632f4b26b2ae3b8de0efe7a", "message": "Fix import", "committedDate": "2020-05-13T05:52:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzkxMQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424187911", "bodyText": "Should we add a variant that does not require path and make path here non-null?", "author": "trustin", "createdAt": "2020-05-13T05:53:41Z", "path": "eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client.eureka;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.Endpoint;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.client.endpoint.DynamicEndpointGroup;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.MediaTypeNames;\n+import com.linecorp.armeria.common.QueryParams;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.RequestHeadersBuilder;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.common.eureka.Application;\n+import com.linecorp.armeria.internal.common.eureka.Applications;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n+import com.linecorp.armeria.server.eureka.EurekaUpdatingListenerBuilder;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A Eureka-based {@link EndpointGroup} implementation. This {@link EndpointGroup} retrieves the list of\n+ * {@link Endpoint}s from a Eureka registry.\n+ *\n+ * @see EurekaUpdatingListener\n+ */\n+public final class EurekaEndpointGroup extends DynamicEndpointGroup {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaEndpointGroup.class);\n+\n+    private static final ObjectMapper mapper =\n+            new ObjectMapper().enable(DeserializationFeature.UNWRAP_ROOT_VALUE)\n+                              .setSerializationInclusion(Include.NON_NULL);\n+\n+    private static final Predicate<InstanceInfo> allInstances = instanceInfo -> true;\n+\n+    private static final String APPS = \"/apps\";\n+    private static final String VIPS = \"/vips/\";\n+    private static final String SVIPS = \"/svips/\";\n+    private static final String INSTANCES = \"/instances/\";\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroup} that retrieves the {@link Endpoint} list from the specified\n+     * {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroup of(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(URI eurekaUri) {\n+        return new EurekaEndpointGroupBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaEndpointGroupBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaEndpointGroupBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, @Nullable String path) {", "originalCommit": "244d88f37e48ffa51b0f4e7eee9b386e1e2ca521", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MTI1MQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424191251", "bodyText": "I was just worried about having too much static method. \ud83d\ude04 Let me add the one.", "author": "minwoox", "createdAt": "2020-05-13T06:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a715a618147a77fab8b7f9aecff8f20b0a9dda69", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\nindex d9f224554..784c35cd0 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/client/eureka/EurekaEndpointGroup.java\n\n@@ -61,7 +61,6 @@ import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n import com.linecorp.armeria.server.eureka.EurekaUpdatingListener;\n-import com.linecorp.armeria.server.eureka.EurekaUpdatingListenerBuilder;\n \n import io.netty.channel.EventLoop;\n import io.netty.util.ReferenceCountUtil;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA1OA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424188058", "bodyText": "How about adding some comment about priority?", "author": "trustin", "createdAt": "2020-05-13T05:54:13Z", "path": "core/src/main/java/com/linecorp/armeria/server/Server.java", "diffHunk": "@@ -180,9 +179,36 @@ public String defaultHostname() {\n      */\n     @Nullable\n     public ServerPort activePort() {\n+        return activePort0(null);\n+    }\n+\n+    /**\n+     * Returns the primary {@link ServerPort} which serves the given {@link SessionProtocol}\n+     * that this {@link Server} is listening to.\n+     *\n+     * @return the primary {@link ServerPort}, or {@code null} if there is no active port available for\n+     *         the given {@link SessionProtocol}.\n+     */\n+    @Nullable\n+    public ServerPort activePort(SessionProtocol protocol) {\n+        return activePort0(requireNonNull(protocol, \"protocol\"));\n+    }\n+\n+    @Nullable\n+    private ServerPort activePort0(@Nullable SessionProtocol protocol) {\n         synchronized (activePorts) {\n-            return Iterables.getFirst(activePorts.values(), null);\n+            for (ServerPort serverPort : activePorts.values()) {\n+                if (!isLocalPort(serverPort, protocol)) {", "originalCommit": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MzY2Nw==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424253667", "bodyText": "Added!", "author": "minwoox", "createdAt": "2020-05-13T08:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "a715a618147a77fab8b7f9aecff8f20b0a9dda69", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Server.java b/core/src/main/java/com/linecorp/armeria/server/Server.java\nindex b28d5dce7..315f48b53 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Server.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Server.java\n\n@@ -172,8 +172,8 @@ public final class Server implements ListenableAsyncCloseable {\n     }\n \n     /**\n-     * Returns the primary {@link ServerPort} that this {@link Server} is listening to. This method is useful\n-     * when a {@link Server} listens to only one {@link ServerPort}.\n+     * Returns the primary {@link ServerPort} that this {@link Server} is listening to. If this {@link Server}\n+     * has both a local port and a non-local port, the non-local port is returned.\n      *\n      * @return the primary {@link ServerPort}, or {@code null} if this {@link Server} did not start.\n      */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDA3Mg==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424190072", "bodyText": "Please handle the case of IPv6 address.", "author": "trustin", "createdAt": "2020-05-13T06:00:16Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka.\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, {@link EurekaUpdatingListener} deregisters the\n+ * {@link Server} from Eureka by sending a cancellation request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, @Nullable String path) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, path);\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregate().handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                newInfo.getHostName(), client.uri(), cause);\n+                    return null;\n+                }\n+                final ResponseHeaders headers = res.headers();\n+                if (headers.status() != HttpStatus.NO_CONTENT) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());\n+                } else {\n+                    logger.info(\"Registered {} to Eureka: {}\", newInfo.getHostName(), client.uri());\n+                    scheduleHeartBeat(ctx.eventLoop(), newInfo);\n+                }\n+                return null;\n+            });\n+        }\n+    }\n+\n+    private void scheduleHeartBeat(EventLoop eventLoop, InstanceInfo newInfo) {\n+        heartBeatFuture = eventLoop.schedule(new HeartBeatTask(eventLoop, newInfo),\n+                                             newInfo.getLeaseInfo().getRenewalIntervalInSecs(),\n+                                             TimeUnit.SECONDS);\n+    }\n+\n+    private InstanceInfo fillAndCreateNewInfo(InstanceInfo oldInfo, Server server) {\n+        final String defaultHostname = server.defaultHostname();\n+        final String hostName = oldInfo.getHostName() != null ? oldInfo.getHostName() : defaultHostname;\n+        appName = oldInfo.getAppName() != null ? oldInfo.getAppName() : hostName;\n+        final String instanceId = oldInfo.getInstanceId() != null ? oldInfo.getInstanceId() : hostName;\n+\n+        final Inet4Address defaultInet4Address = SystemInfo.defaultNonLoopbackIpV4Address();\n+        final String defaultIpAddr = defaultInet4Address != null ? defaultInet4Address.getHostAddress()\n+                                                                 : null;\n+        final String ipAddr = oldInfo.getIpAddr() != null ? oldInfo.getIpAddr() : defaultIpAddr;\n+        final PortWrapper oldPortWrapper = oldInfo.getPort();\n+        final PortWrapper portWrapper = portWrapper(server, oldPortWrapper, SessionProtocol.HTTP);\n+        final PortWrapper oldSecurePortWrapper = oldInfo.getSecurePort();\n+        final PortWrapper securePortWrapper = portWrapper(server, oldSecurePortWrapper, SessionProtocol.HTTPS);\n+\n+        final String vipAddress = vipAddress(oldInfo.getVipAddress(), hostName, portWrapper);\n+        final String secureVipAddress = vipAddress(oldInfo.getSecureVipAddress(), hostName, securePortWrapper);\n+\n+        final Optional<ServiceConfig> healthCheckService =\n+                server.serviceConfigs()\n+                      .stream()\n+                      .filter(cfg -> cfg.service().as(HealthCheckService.class) != null)\n+                      .findFirst();\n+\n+        final String hostnameOrIpAddr;\n+        if (oldInfo.getHostName() != null) {\n+            hostnameOrIpAddr = oldInfo.getHostName();\n+        } else if (ipAddr != null) {\n+            hostnameOrIpAddr = ipAddr;\n+        } else {\n+            hostnameOrIpAddr = hostName;\n+        }\n+        final String healthCheckUrl = healthCheckUrl(hostnameOrIpAddr, oldInfo.getHealthCheckUrl(), portWrapper,\n+                                                     healthCheckService, SessionProtocol.HTTP);\n+        final String secureHealthCheckUrl =\n+                healthCheckUrl(hostnameOrIpAddr, oldInfo.getSecureHealthCheckUrl(), securePortWrapper,\n+                               healthCheckService, SessionProtocol.HTTPS);\n+\n+        return new InstanceInfo(instanceId, appName, oldInfo.getAppGroupName(), hostName, ipAddr,\n+                                vipAddress, secureVipAddress, portWrapper, securePortWrapper, InstanceStatus.UP,\n+                                oldInfo.getHomePageUrl(), oldInfo.getStatusPageUrl(), healthCheckUrl,\n+                                secureHealthCheckUrl, oldInfo.getDataCenterInfo(),\n+                                oldInfo.getLeaseInfo(), oldInfo.getMetadata());\n+    }\n+\n+    private static PortWrapper portWrapper(Server server, PortWrapper oldPortWrapper,\n+                                           SessionProtocol protocol) {\n+        if (oldPortWrapper.isEnabled()) {\n+            for (ServerPort serverPort : server.activePorts().values()) {\n+                if (serverPort.hasProtocol(protocol) &&\n+                    serverPort.localAddress().getPort() == oldPortWrapper.getPort()) {\n+                    return oldPortWrapper;\n+                }\n+            }\n+            logger.warn(\"The port number: {} (expected one of activePorts: {})\",\n+                        oldPortWrapper.getPort(), server.activePorts());\n+        }\n+\n+        final ServerPort serverPort = server.activePort(protocol);\n+        if (serverPort == null) {\n+            return disabledPort;\n+        }\n+        return new PortWrapper(true, serverPort.localAddress().getPort());\n+    }\n+\n+    @Nullable\n+    private static String vipAddress(@Nullable String vipAddress, String hostName, PortWrapper portWrapper) {\n+        if (!portWrapper.isEnabled()) {\n+            return null;\n+        }\n+        return vipAddress != null ? vipAddress : hostName + ':' + portWrapper.getPort();\n+    }\n+\n+    @Nullable\n+    private static String healthCheckUrl(String hostnameOrIpAddr, @Nullable String oldHealthCheckUrl,\n+                                         PortWrapper portWrapper,\n+                                         Optional<ServiceConfig> healthCheckService,\n+                                         SessionProtocol sessionProtocol) {\n+        if (oldHealthCheckUrl != null) {\n+            return oldHealthCheckUrl;\n+        }\n+        if (!portWrapper.isEnabled() || !healthCheckService.isPresent()) {\n+            return null;\n+        }\n+        final ServiceConfig healthCheckServiceConfig = healthCheckService.get();\n+        final Route route = healthCheckServiceConfig.route();\n+        if (route.pathType() != RoutePathType.EXACT && route.pathType() != RoutePathType.PREFIX) {\n+            return null;\n+        }\n+\n+        return sessionProtocol.uriText() + \"://\" + hostnameOrIpAddr + ':' + portWrapper.getPort() +", "originalCommit": "269360b72da27d34a632f4b26b2ae3b8de0efe7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MzYxOQ==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424253619", "bodyText": "Oops, didn't know about it. Thanks!", "author": "minwoox", "createdAt": "2020-05-13T08:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a715a618147a77fab8b7f9aecff8f20b0a9dda69", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex e251a7d30..63f80d401 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -51,6 +51,7 @@ import com.linecorp.armeria.server.ServiceConfig;\n import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n \n import io.netty.channel.EventLoop;\n+import io.netty.util.NetUtil;\n import io.netty.util.ReferenceCountUtil;\n import io.netty.util.concurrent.ScheduledFuture;\n \n"}}, {"oid": "a715a618147a77fab8b7f9aecff8f20b0a9dda69", "url": "https://github.com/line/armeria/commit/a715a618147a77fab8b7f9aecff8f20b0a9dda69", "message": "Address the comment by @trustin", "committedDate": "2020-05-13T08:12:54Z", "type": "commit"}, {"oid": "2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c", "url": "https://github.com/line/armeria/commit/2ff3bbbdcac6d17e4317669bccbdc71fc4b79b2c", "message": "Merge branch 'master' into eureka", "committedDate": "2020-05-13T08:17:00Z", "type": "commit"}, {"oid": "523facbfe131a28f9ad250ad402e012fcce0baad", "url": "https://github.com/line/armeria/commit/523facbfe131a28f9ad250ad402e012fcce0baad", "message": "Add publish tag", "committedDate": "2020-05-13T08:28:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NjA1Ng==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424276056", "bodyText": "Don't we need to retry to other eureka servers? Or, does it happen in EurekaWebClient?", "author": "ikhoon", "createdAt": "2020-05-13T08:48:58Z", "path": "eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server.eureka;\n+\n+import static com.linecorp.armeria.server.eureka.InstanceInfoBuilder.disabledPort;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.Inet4Address;\n+import java.net.URI;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.ClientRequestContextCaptor;\n+import com.linecorp.armeria.client.Clients;\n+import com.linecorp.armeria.client.endpoint.EndpointGroup;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.util.SystemInfo;\n+import com.linecorp.armeria.internal.common.eureka.EurekaWebClient;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.InstanceStatus;\n+import com.linecorp.armeria.internal.common.eureka.InstanceInfo.PortWrapper;\n+import com.linecorp.armeria.server.Route;\n+import com.linecorp.armeria.server.RoutePathType;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServerListener;\n+import com.linecorp.armeria.server.ServerListenerAdapter;\n+import com.linecorp.armeria.server.ServerPort;\n+import com.linecorp.armeria.server.ServiceConfig;\n+import com.linecorp.armeria.server.healthcheck.HealthCheckService;\n+\n+import io.netty.channel.EventLoop;\n+import io.netty.util.NetUtil;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.ScheduledFuture;\n+\n+/**\n+ * A {@link ServerListener} which registers the current {@link Server} to Eureka.\n+ * {@link EurekaUpdatingListener} sends renewal requests periodically so that the {@link Server} is not removed\n+ * from the registry. When the {@link Server} stops, {@link EurekaUpdatingListener} deregisters the\n+ * {@link Server} from Eureka by sending a cancellation request.\n+ */\n+public final class EurekaUpdatingListener extends ServerListenerAdapter {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(String eurekaUri) {\n+        return builder(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol}\n+     * and {@link EndpointGroup}.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, null);\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@link SessionProtocol},\n+     * {@link EndpointGroup} and path.\n+     */\n+    public static EurekaUpdatingListenerBuilder builder(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, String path) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, requireNonNull(path, \"path\"));\n+    }\n+\n+    private final EurekaWebClient client;\n+    private final InstanceInfo instanceInfo;\n+    @Nullable\n+    private volatile ScheduledFuture<?> heartBeatFuture;\n+\n+    @Nullable\n+    private volatile String appName; // Set when serverStarted is called.\n+    private volatile boolean closed;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    EurekaUpdatingListener(EurekaWebClient client, InstanceInfo instanceInfo) {\n+        this.client = client;\n+        this.instanceInfo = instanceInfo;\n+    }\n+\n+    @Override\n+    public void serverStarted(Server server) throws Exception {\n+        final InstanceInfo newInfo = fillAndCreateNewInfo(instanceInfo, server);\n+\n+        try (ClientRequestContextCaptor contextCaptor = Clients.newContextCaptor()) {\n+            final HttpResponse response = client.register(newInfo);\n+            final ClientRequestContext ctx = contextCaptor.get();\n+            response.aggregate().handle((res, cause) -> {\n+                if (closed) {\n+                    return null;\n+                }\n+                if (cause != null) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}\",\n+                                newInfo.getHostName(), client.uri(), cause);\n+                    return null;\n+                }\n+                final ResponseHeaders headers = res.headers();\n+                if (headers.status() != HttpStatus.NO_CONTENT) {\n+                    logger.warn(\"Failed to register {} to Eureka: {}. (status: {}, content: {})\",\n+                                newInfo.getHostName(), client.uri(), headers.status(), res.contentUtf8());", "originalCommit": "523facbfe131a28f9ad250ad402e012fcce0baad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyMzE5NA==", "url": "https://github.com/line/armeria/pull/2701#discussion_r424423194", "bodyText": "Add RetryingClient if the user didn't specify one. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-05-13T13:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI3NjA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "chunk": "diff --git a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\nindex 63f80d401..8b691a384 100644\n--- a/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n+++ b/eureka/src/main/java/com/linecorp/armeria/server/eureka/EurekaUpdatingListener.java\n\n@@ -65,6 +65,41 @@ public final class EurekaUpdatingListener extends ServerListenerAdapter {\n \n     private static final Logger logger = LoggerFactory.getLogger(EurekaUpdatingListener.class);\n \n+    /**\n+     * Returns a new {@link EurekaUpdatingListener} which registers the current {@link Server} to\n+     * the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListener of(String eurekaUri) {\n+        return of(URI.create(requireNonNull(eurekaUri, \"eurekaUri\")));\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListener} which registers the current {@link Server} to\n+     * the specified {@code eurekaUri}.\n+     */\n+    public static EurekaUpdatingListener of(URI eurekaUri) {\n+        return new EurekaUpdatingListenerBuilder(eurekaUri).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListener} which registers the current {@link Server} to\n+     * the specified {@link EndpointGroup}.\n+     */\n+    public static EurekaUpdatingListener of(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup) {\n+        return new EurekaUpdatingListenerBuilder(sessionProtocol, endpointGroup, null).build();\n+    }\n+\n+    /**\n+     * Returns a new {@link EurekaUpdatingListener} which registers the current {@link Server} to\n+     * the specified {@link EndpointGroup} under the specified {@code path}.\n+     */\n+    public static EurekaUpdatingListener of(\n+            SessionProtocol sessionProtocol, EndpointGroup endpointGroup, String path) {\n+        return new EurekaUpdatingListenerBuilder(\n+                sessionProtocol, endpointGroup, requireNonNull(path, \"path\")).build();\n+    }\n+\n     /**\n      * Returns a new {@link EurekaUpdatingListenerBuilder} created with the specified {@code eurekaUri}.\n      */\n"}}, {"oid": "d38ecc0c64c652a7d202e19d7e483df2a3105a2c", "url": "https://github.com/line/armeria/commit/d38ecc0c64c652a7d202e19d7e483df2a3105a2c", "message": "Add retryingClient if not specified", "committedDate": "2020-05-13T13:08:44Z", "type": "commit"}, {"oid": "baf699cd8956f2dc9cc02238264c559ddbf8879f", "url": "https://github.com/line/armeria/commit/baf699cd8956f2dc9cc02238264c559ddbf8879f", "message": "Fix import", "committedDate": "2020-05-14T01:50:39Z", "type": "commit"}, {"oid": "c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "url": "https://github.com/line/armeria/commit/c3b62d87401fe19dca21ee16b66c2a7d8071f82c", "message": "Add static factory methods", "committedDate": "2020-05-14T03:43:37Z", "type": "commit"}]}