{"pr_number": 2409, "pr_title": "Send an HTTP/2 PING frame on an idle connection", "pr_createdAt": "2020-01-18T03:39:16Z", "pr_url": "https://github.com/line/armeria/pull/2409", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzQyMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368203421", "bodyText": "Is it ok to cancel, or should I have a check in shutdownRunnable to check if state is IDLE and then do not close the channel (basically do nothing)", "author": "sivaalli", "createdAt": "2020-01-18T03:41:10Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2017 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {\n+        final EventLoop el = future.channel().eventLoop();\n+        if (future.isSuccess()) {\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInNanos, TimeUnit.NANOSECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // write failed, likely the channel is closed.\n+            logger.debug(\"PING write failed for channel: {}\", channel);\n+        }\n+    };\n+\n+    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInNanos = pingTimeoutInNanos;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Waiting for PING ACK or shutdown\");\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} event triggered on channel: {}. Sending PING\", event, channel);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throw new Http2Exception(Http2Error.PROTOCOL_ERROR,\n+                                     \"State expected PENDING_PING_ACK but is \" + state);\n+        }\n+        if (lastPingPayload != data) {\n+            throw new Http2Exception(Http2Error.PROTOCOL_ERROR,\n+                                     \"PING received but payload does not match. \" + \"Expected: \" +\n+                                     lastPingPayload + ' ' + \"Received :\" + data);\n+        }\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);", "originalCommit": "5ea7b48ef5ac6207a90da0807c06e47d1ca8d8a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTAyOA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205028", "bodyText": "How about checking the return value of cancel() and log like 'Received a late PING(ACK=1) in {}ns?\nI think it's better cancelling here.", "author": "trustin", "createdAt": "2020-01-18T04:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMzQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 453a8ac84f..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -1,5 +1,5 @@\n /*\n- * Copyright 2017 LINE Corporation\n+ * Copyright 2020 LINE Corporation\n  *\n  * LINE Corporation licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDY5OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204699", "bodyText": "Our logging convention is to put the current channel or context at the first place, e.g.\nlogger.debug(\"{} Closing channel due to PING timeout\", channel);", "author": "trustin", "createdAt": "2020-01-18T04:13:25Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex b536bd52dc..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.server;\n+package com.linecorp.armeria.internal;\n \n import static com.google.common.base.Preconditions.checkState;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDcyNQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204725", "bodyText": "nit: Could be merged into a single line?\nchannel.close().addListener(future -> {\n    ...\n}", "author": "trustin", "createdAt": "2020-01-18T04:13:53Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex b536bd52dc..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.server;\n+package com.linecorp.armeria.internal;\n \n import static com.google.common.base.Preconditions.checkState;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDczMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204732", "bodyText": "Could use ChannelFutureListener instead.", "author": "trustin", "createdAt": "2020-01-18T04:14:16Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex b536bd52dc..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.server;\n+package com.linecorp.armeria.internal;\n \n import static com.google.common.base.Preconditions.checkState;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDczOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204739", "bodyText": "Could get this inside the if block.", "author": "trustin", "createdAt": "2020-01-18T04:14:37Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {\n+        final EventLoop el = future.channel().eventLoop();", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex b536bd52dc..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.server;\n+package com.linecorp.armeria.internal;\n \n import static com.google.common.base.Preconditions.checkState;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDc2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368204764", "bodyText": "How about logging the cause, if channel.isActive()?", "author": "trustin", "createdAt": "2020-01-18T04:15:28Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>\n+ * This class is not thread-safe and all methods are to be called from single thread such as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInNanos;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private long lastPingPayload;\n+\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"Closing channel: {} as PING timed out.\", channel);\n+        final ChannelFuture close = channel.close();\n+        close.addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"Closed channel: {} as PING timed out.\", channel);\n+            } else {\n+                logger.debug(\"Cannot close channel: {}.\", channel, future.cause());\n+            }\n+        });\n+    };\n+\n+    private final GenericFutureListener<ChannelFuture> pingWriteListener = future -> {\n+        final EventLoop el = future.channel().eventLoop();\n+        if (future.isSuccess()) {\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInNanos, TimeUnit.NANOSECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // write failed, likely the channel is closed.\n+            logger.debug(\"PING write failed for channel: {}\", channel);", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex b536bd52dc..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.server;\n+package com.linecorp.armeria.internal;\n \n import static com.google.common.base.Preconditions.checkState;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTEyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205122", "bodyText": "This seems really short. How about 10 seconds? How about making it configurable via ServerBuilder (and ClientFactoryBuilder if you're gonna implement the client side as well), preferably with a new Flags property?", "author": "trustin", "createdAt": "2020-01-18T04:23:45Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java", "diffHunk": "@@ -16,26 +16,32 @@\n \n package com.linecorp.armeria.server;\n \n+import java.time.Duration;\n+\n import com.linecorp.armeria.internal.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ServerConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final GracefulShutdownSupport gracefulShutdownSupport;\n     private final Http2RequestDecoder requestDecoder;\n+    private final Http2KeepAliveHandler keepAlive;\n \n     Http2ServerConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel, ServerConfig config,\n                                  GracefulShutdownSupport gracefulShutdownSupport, String scheme) {\n \n         super(decoder, encoder, initialSettings);\n-\n         this.gracefulShutdownSupport = gracefulShutdownSupport;\n-        requestDecoder = new Http2RequestDecoder(config, channel, encoder(), scheme);\n+        keepAlive = new Http2KeepAliveHandler(channel, encoder().frameWriter(),\n+                                              Duration.ofSeconds(1).toNanos());", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTM5Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205396", "bodyText": "This was hardcoded for local testing. I will use Flags property.", "author": "sivaalli", "createdAt": "2020-01-18T04:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java\nindex 5a3ae17417..c00a37f326 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java\n\n@@ -16,9 +16,10 @@\n \n package com.linecorp.armeria.server;\n \n-import java.time.Duration;\n-\n-import com.linecorp.armeria.internal.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n+import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.internal.common.IdleTimeoutHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNTIyMw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368205223", "bodyText": "Missing space before <\nThe first </p> does not have its peer?", "author": "trustin", "createdAt": "2020-01-18T04:25:54Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.server;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.GenericFutureListener;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured pingTimeOut. If timeout exceeds then channel will be closed.\n+ *</p>\n+ * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n+ *</p>", "originalCommit": "109638c80853e19fd1e8d0e809c1271a832c9aac", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex b536bd52dc..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.server;\n+package com.linecorp.armeria.internal;\n \n import static com.google.common.base.Preconditions.checkState;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MTUyMA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368391520", "bodyText": "... but was %s\", state so that string concatenation does not occur when state is correct.", "author": "trustin", "createdAt": "2020-01-20T06:55:48Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -94,22 +92,30 @@\n             }\n         }\n     };\n+    private long lastPingPayload;\n \n-    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n         this.channel = channel;\n         this.frameWriter = frameWriter;\n         this.pingTimeoutInNanos = pingTimeoutInNanos;\n     }\n \n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     */\n     public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        checkState(state == State.IDLE, \"Waiting for PING ACK or shutdown\");\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was \" + state);", "originalCommit": "312cb19b32ac17d9feabafbd3ddc087175256e95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 1974cf75ff..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -77,27 +76,28 @@ public class Http2KeepAliveHandler {\n             } else {\n                 logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n             }\n+            state = State.SHUTDOWN;\n         });\n     };\n     private final ChannelFutureListener pingWriteListener = future -> {\n-        final Channel ch = future.channel();\n         if (future.isSuccess()) {\n-            final EventLoop el = ch.eventLoop();\n-            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInNanos, TimeUnit.NANOSECONDS);\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n             state = State.PENDING_PING_ACK;\n             stopwatch.reset().start();\n         } else {\n-            if (ch.isActive()) {\n-                logger.debug(\"{} PING write failed\", channel, future.cause());\n-            }\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n         }\n     };\n     private long lastPingPayload;\n \n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInNanos) {\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n         this.channel = channel;\n         this.frameWriter = frameWriter;\n-        this.pingTimeoutInNanos = pingTimeoutInNanos;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n     }\n \n     private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MTc2Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368391767", "bodyText": "Could be:\n *\n * <p>This class is ...\n\nto make Checkstyle happy", "author": "trustin", "createdAt": "2020-01-20T06:56:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -46,10 +46,8 @@\n /**\n  * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n  * Specifically, it will write a PING frame to remote and then expects an ACK back within\n- * configured pingTimeOut. If timeout exceeds then channel will be closed.\n- * </p>\n- * This constructor will fail to initialize when pipeline does not have {@link IdleStateHandler}.\n- * </p>\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ * <p>\n  * This class is <b>not</b> thread-safe and all methods are to be called from single thread such as", "originalCommit": "06ee5cfe443bfee6003ee99d83f295746ad2eb14", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex c64122f8dd..450fd27452 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -47,8 +48,8 @@ import io.netty.handler.timeout.IdleStateHandler;\n  * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n  * Specifically, it will write a PING frame to remote and then expects an ACK back within\n  * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n- * <p>\n- * This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n  * {@link EventLoop}.\n  */\n @NotThreadSafe\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368758564", "bodyText": "This is for when a client upgrades the connection from http1.1 to http2. If there is a better way to deal with this situation, please do let me know.", "author": "sivaalli", "createdAt": "2020-01-20T23:37:24Z", "path": "core/src/main/java/com/linecorp/armeria/internal/AbstractHttp2ConnectionHandler.java", "diffHunk": "@@ -125,6 +125,27 @@ public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exce\n         super.close(ctx, promise);\n     }\n \n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        super.handlerAdded(ctx);\n+        changeIdleStateHandlerToHttp2(ctx);", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNTUxMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368905511", "bodyText": "Probably better passing whether it's HTTP/2 in HttpClientPipelinfConfigurator.finishSuccessfully()?", "author": "trustin", "createdAt": "2020-01-21T09:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwOTQ4Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369309482", "bodyText": "Sorry, did not get your comment. Let me elaborate the problem:\nFor client, there is change to set isHttp2 flag in HttpClientPipelinfConfigurator.finishSuccessfully(), please see here .\nOn server side, the change is here. But when http client upgrades the connection using upgrade header, then Http2ConnectionHandler is added to pipeline and HttpServerCodec is removed. Since adding Http2ConnectionHandler to pipeline indicates a successful upgrade, I though to flip the state of isHttp2 from false to true in AbstractHttp2ConnectionHandler\nNow that I'm thinking about it, I think we should not have this logic in AbstractHttp2ConnectionHandler but rather in Http2ServerConnectionHandler. Please let me know what do you think \ud83d\ude04", "author": "sivaalli", "createdAt": "2020-01-22T00:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyODg3Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369328876", "bodyText": "Sorry, did not get your comment.\n\nAh, you were asking about the server-side. I thought the problem was in the client side. My bad \ud83d\ude05\n\nNow that I'm thinking about it, I think we should not have this logic in AbstractHttp2ConnectionHandler but rather in Http2ServerConnectionHandler. Please let me know what do you think \ud83d\ude04\n\n+1", "author": "trustin", "createdAt": "2020-01-22T01:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODU2NA=="}], "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/AbstractHttp2ConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/AbstractHttp2ConnectionHandler.java\nsimilarity index 85%\nrename from core/src/main/java/com/linecorp/armeria/internal/AbstractHttp2ConnectionHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/AbstractHttp2ConnectionHandler.java\nindex dbe3d2bdf0..f89ac7da6c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/AbstractHttp2ConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/AbstractHttp2ConnectionHandler.java\n\n@@ -125,27 +125,6 @@ public abstract class AbstractHttp2ConnectionHandler extends Http2ConnectionHand\n         super.close(ctx, promise);\n     }\n \n-    @Override\n-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n-        super.handlerAdded(ctx);\n-        changeIdleStateHandlerToHttp2(ctx);\n-    }\n-\n-    /**\n-     * This is helper method that is used when application level protocol is upgraded. For ex:\n-     * http1.1 to http2. In this case, we also leverage http2 ping by setting\n-     * {@code idleTimeoutHandler.setHttp2(true)} which will send pings.\n-     */\n-    private static void changeIdleStateHandlerToHttp2(ChannelHandlerContext ctx) {\n-        final IdleTimeoutHandler idleTimeoutHandler = ctx.pipeline().get(\n-                IdleTimeoutHandler.class);\n-        if (idleTimeoutHandler == null) {\n-            // Means that config.idleTimeoutMillis() < 0; So ignore\n-            return;\n-        }\n-        idleTimeoutHandler.setHttp2(true);\n-    }\n-\n     /**\n      * Returns {@code true} if the connection has to be closed immediately rather than sending a GOAWAY\n      * frame and waiting for the remaining streams. This method should return {@code true} when:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODkwNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368758906", "bodyText": "I had 2 options:\n\nI can use isHttp2 flag to indicate that connection is http2.\nOr I could remove IdleTimeoutHandler and add IdleStateHandler (netty's base implementation).\n\nI choose (1), please let me know if there are better alternatives.", "author": "sivaalli", "createdAt": "2020-01-20T23:39:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java", "diffHunk": "@@ -32,14 +32,24 @@\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n+    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n+        this.isHttp2 = isHttp2;\n     }\n \n+    /**\n+     * If the channel is serving http2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n+     * but if it is http1.1 channel then we will close the channel\n+     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n+        if (isHttp2) {", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNTg3Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368905876", "bodyText": "+1 for using a flag. \ud83d\ude04", "author": "trustin", "createdAt": "2020-01-21T09:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwNjA2MQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368906061", "bodyText": "(Because it's better keeping the length of a Netty pipeline short for performance's sake)", "author": "trustin", "createdAt": "2020-01-21T09:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc1ODkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\nsimilarity index 87%\nrename from core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\nindex fbe9444458..2b339667aa 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\n\n@@ -41,8 +43,8 @@ public abstract class IdleTimeoutHandler extends IdleStateHandler {\n     }\n \n     /**\n-     * If the channel is serving http2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n-     * but if it is http1.1 channel then we will close the channel\n+     * If the channel is serving HTTP/2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n+     * but if it is HTTP/1.1 channel then we will close the channel\n      */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzEzOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368903139", "bodyText": "http2 -> HTTP/2", "author": "trustin", "createdAt": "2020-01-21T09:54:11Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +665,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for http2 PING timeout.", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cf2684f605..314167aade 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -666,16 +682,16 @@ public final class Flags {\n     }\n \n     /**\n-     * Returns the default value for http2 PING timeout.\n-     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n-     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0\n+     * Returns the default value for HTTP2 PING timeout.\n+     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n+     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n      *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_NANOS}. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutNanos=<integer>} JVM option to override\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n+     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n      * the default value.\n      */\n-    public static long defaultHttp2PingTimeoutNanos() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_NANOS;\n+    public static long defaultHttp2PingTimeoutMillis() {\n+        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzY3Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368903672", "bodyText": "Perhaps better using {@link #defaultServerIdleTimeoutMillis()} ... {@link #defaultClientIdleTimeoutMillis()} ?", "author": "trustin", "createdAt": "2020-01-21T09:55:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +665,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for http2 PING timeout.\n+     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n+     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cf2684f605..314167aade 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -666,16 +682,16 @@ public final class Flags {\n     }\n \n     /**\n-     * Returns the default value for http2 PING timeout.\n-     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n-     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0\n+     * Returns the default value for HTTP2 PING timeout.\n+     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n+     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n      *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_NANOS}. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutNanos=<integer>} JVM option to override\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n+     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n      * the default value.\n      */\n-    public static long defaultHttp2PingTimeoutNanos() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_NANOS;\n+    public static long defaultHttp2PingTimeoutMillis() {\n+        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzk4OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r368903988", "bodyText": "Do we need sub-millisecond precision for ping timeouts? How about using milliseconds, like other idle timeout flags?", "author": "trustin", "createdAt": "2020-01-21T09:55:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +665,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for http2 PING timeout.\n+     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n+     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0\n+     *\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_NANOS}. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutNanos=<integer>} JVM option to override\n+     * the default value.\n+     */\n+    public static long defaultHttp2PingTimeoutNanos() {\n+        return DEFAULT_HTTP2_PING_TIMEOUT_NANOS;", "originalCommit": "5dc2d4a29b91cdd0cd8aabecc7b1d883bab7807c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAyMDIwMw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369020203", "bodyText": "Sure. Let me change this.", "author": "sivaalli", "createdAt": "2020-01-21T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMzk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cf2684f605..314167aade 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -666,16 +682,16 @@ public final class Flags {\n     }\n \n     /**\n-     * Returns the default value for http2 PING timeout.\n-     * Note that this flag is only in effect when DEFAULT_SERVER_IDLE_TIMEOUT_MILLIS for server and\n-     * DEFAULT_DEFAULT_CLIENT_IDLE_TIMEOUT_MILLIS for client are greater than 0\n+     * Returns the default value for HTTP2 PING timeout.\n+     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n+     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n      *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_NANOS}. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutNanos=<integer>} JVM option to override\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n+     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n      * the default value.\n      */\n-    public static long defaultHttp2PingTimeoutNanos() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_NANOS;\n+    public static long defaultHttp2PingTimeoutMillis() {\n+        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDgwMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369980801", "bodyText": "nit: Could be prettier if broken right after the comma?", "author": "trustin", "createdAt": "2020-01-23T08:23:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java", "diffHunk": "@@ -341,7 +341,8 @@ void finishSuccessfully(ChannelPipeline pipeline, SessionProtocol protocol) {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis, protocol == H2 ||\n+                                                                                  protocol == H2C));", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java b/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\nindex c3bc677c83..457b07f63b 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n\n@@ -341,8 +339,8 @@ final class HttpClientPipelineConfigurator extends ChannelDuplexHandler {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis, protocol == H2 ||\n-                                                                                  protocol == H2C));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n+                                                               protocol == H2 || protocol == H2C));\n         }\n \n         pipeline.channel().eventLoop().execute(() -> pipeline.fireUserEventTriggered(protocol));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MTE4Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369981187", "bodyText": "...MILLIS} milliseconds.", "author": "trustin", "createdAt": "2020-01-23T08:24:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -658,6 +664,19 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value for HTTP2 PING timeout.\n+     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n+     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n+     *\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS}. Specify the", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 2a19d2555f..314167aade 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -669,8 +686,8 @@ public final class Flags {\n      * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n      * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n      *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS}. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n+     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n+     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n      * the default value.\n      */\n     public static long defaultHttp2PingTimeoutMillis() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDI0Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369984242", "bodyText": "assertThat(ch.finish()).isFalse()", "author": "trustin", "createdAt": "2020-01-23T08:31:33Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup() throws Exception {\n+        ch = new EmbeddedChannel();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, pingTimeout);\n+        promise = ch.newPromise();\n+\n+        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n+\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @AfterEach\n+    public void after() {\n+        Assertions.assertFalse(ch.finish());", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\nindex 6efe090480..ae95503a37 100644\n--- a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n\n@@ -26,7 +26,6 @@ import static org.mockito.Mockito.when;\n import java.io.IOException;\n \n import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDY2MA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369984660", "bodyText": "nit: Maybe more readable if we swap the two lines?", "author": "trustin", "createdAt": "2020-01-23T08:32:29Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup() throws Exception {\n+        ch = new EmbeddedChannel();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, pingTimeout);\n+        promise = ch.newPromise();", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\nindex 6efe090480..ae95503a37 100644\n--- a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n\n@@ -26,7 +26,6 @@ import static org.mockito.Mockito.when;\n import java.io.IOException;\n \n import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDg3Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369984876", "bodyText": "Cruft?", "author": "trustin", "createdAt": "2020-01-23T08:33:03Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup() throws Exception {\n+        ch = new EmbeddedChannel();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, pingTimeout);\n+        promise = ch.newPromise();\n+\n+        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n+\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @AfterEach\n+    public void after() {\n+        Assertions.assertFalse(ch.finish());\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingTimesOut_ShouldCloseConnection() throws InterruptedException {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+\n+        promise.setSuccess();\n+        waitUntilPingTimeout();\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+        assertThat(keepAlive.getState()).isEqualTo(State.SHUTDOWN);\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenWritePingFails_ShouldCloseConnection() throws InterruptedException {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        promise.setFailure(new IOException());\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+        assertThat(keepAlive.getState()).isEqualTo(State.SHUTDOWN);\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingAckIsReceivedWithinTimeout_ShouldNotCloseConnection()\n+            throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        promise.setSuccess();\n+        //ch.runPendingTasks();", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\nindex 6efe090480..ae95503a37 100644\n--- a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n\n@@ -26,7 +26,6 @@ import static org.mockito.Mockito.when;\n import java.io.IOException;\n \n import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NTQ0Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r369985447", "bodyText": "Not sure, but I guess 10 ms might be too short for CI environment which runs much slower machines.", "author": "trustin", "createdAt": "2020-01-23T08:34:31Z", "path": "core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final long pingTimeout = 10;", "originalCommit": "62bc69438e31a0dc11d3ab7bb9819a0bb85de9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\nindex 6efe090480..ae95503a37 100644\n--- a/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/internal/Http2KeepAliveHandlerTest.java\n\n@@ -26,7 +26,6 @@ import static org.mockito.Mockito.when;\n import java.io.IOException;\n \n import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.mockito.Mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzgzOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371113839", "bodyText": "Why do we return here?", "author": "anuraaga", "createdAt": "2020-01-27T08:41:37Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -66,4 +72,19 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n     protected boolean needsImmediateDisconnection() {\n         return clientFactory.isClosing() || responseDecoder.goAwayHandler().receivedErrorGoAway();\n     }\n+\n+    @Override\n+    public void channelInactive(final ChannelHandlerContext ctx) throws Exception {\n+        keepAlive.onChannelInactive();\n+        super.channelInactive(ctx);\n+    }\n+\n+    @Override\n+    public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) throws Exception {\n+        if (evt instanceof IdleStateEvent) {\n+            keepAlive.onChannelIdle(ctx, (IdleStateEvent) evt);\n+            return;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4NTYyMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372185621", "bodyText": "Previously this event was not emitted and I modified code to do so here. No downstream handlers would be interested in this event except for Http2ClientConnectionHandler.", "author": "sivaalli", "createdAt": "2020-01-29T04:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExMzgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\nindex c5c815f031..3021d792e5 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n\n@@ -75,14 +80,18 @@ final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler\n \n     @Override\n     public void channelInactive(final ChannelHandlerContext ctx) throws Exception {\n-        keepAlive.onChannelInactive();\n+        if (keepAlive != null) {\n+            keepAlive.onChannelInactive();\n+        }\n         super.channelInactive(ctx);\n     }\n \n     @Override\n     public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) throws Exception {\n         if (evt instanceof IdleStateEvent) {\n-            keepAlive.onChannelIdle(ctx, (IdleStateEvent) evt);\n+            if (keepAlive != null) {\n+                keepAlive.onChannelIdle(ctx, (IdleStateEvent) evt);\n+            }\n             return;\n         }\n         super.userEventTriggered(ctx, evt);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNDE1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371114157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                                           protocol == H2 || protocol == H2C));\n          \n          \n            \n                                                                           protocol.isMultiplex()));", "author": "anuraaga", "createdAt": "2020-01-27T08:42:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java", "diffHunk": "@@ -341,7 +341,8 @@ void finishSuccessfully(ChannelPipeline pipeline, SessionProtocol protocol) {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n+                                                               protocol == H2 || protocol == H2C));", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java b/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\nindex 674991e9a3..b0524dd893 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n\n@@ -341,8 +339,7 @@ final class HttpClientPipelineConfigurator extends ChannelDuplexHandler {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n-                                                               protocol == H2 || protocol == H2C));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n         }\n \n         pipeline.channel().eventLoop().execute(() -> pipeline.fireUserEventTriggered(protocol));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNDQ4OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371114488", "bodyText": "If timeout exceeds -> If no response is received in this time,", "author": "anuraaga", "createdAt": "2020-01-27T08:43:23Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTEzNQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581135", "bodyText": "{@code pingTimeoutInNanos} -> {@code pingTimeoutInMillis} ?", "author": "ikhoon", "createdAt": "2020-01-28T02:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNDQ4OA=="}], "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTAzOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private long pingTimeoutInMs;\n          \n          \n            \n                private final long pingTimeoutInMs;", "author": "anuraaga", "createdAt": "2020-01-27T08:44:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTExNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581116", "bodyText": "nit: pingTimeoutInMs -> pingTimeoutInMillis?", "author": "ikhoon", "createdAt": "2020-01-28T02:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5MjExNA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372192114", "bodyText": "or pingTimeoutMillis like other variables in our codebase?", "author": "trustin", "createdAt": "2020-01-29T05:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTI3Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Channel channel;\n          \n          \n            \n                private final Channel channel;", "author": "anuraaga", "createdAt": "2020-01-27T08:45:25Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTQ0MQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115441", "bodyText": "Move all non-final fields into a group after the final ones.", "author": "anuraaga", "createdAt": "2020-01-27T08:45:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTY4Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371115683", "bodyText": "I would go ahead and initialize all the fields in the constructor. Especially since these are quite a lot of code, it's hard to see what fields are in this class at a glance.", "author": "anuraaga", "createdAt": "2020-01-27T08:46:23Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4NTY5Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372185696", "bodyText": "I will fix this to make it more clear. Thanks.", "author": "sivaalli", "createdAt": "2020-01-29T04:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNTY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNjM1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371116357", "bodyText": "Is it ok not to have something like\nif (state != PING_SCHEDULED) {\n  return;\n}", "author": "anuraaga", "createdAt": "2020-01-27T08:48:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzE5NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371117194", "bodyText": "I don't think we should close the channel in this class for anything other than ping ack timeout, I don't think it's easy to reason about why we are in this branch and it's probably someone else's responsibility to take care of this.", "author": "anuraaga", "createdAt": "2020-01-27T08:50:26Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzM3Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371117373", "bodyText": "Do we need this?\nif (state != State.PENDING_PING_ACK) {\n  return;\n}", "author": "anuraaga", "createdAt": "2020-01-27T08:50:54Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzc1Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371117753", "bodyText": "Does it make sense to also have onChannelRead where we clear the ping?\nhttps://http2.github.io/http2-spec/#rfc.section.6.7\nNote, a PING ack SHOULD be prioritized by the other end, but it might not be and could come after the timeout even though the connection is very active.", "author": "anuraaga", "createdAt": "2020-01-27T08:51:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMjgyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385532822", "bodyText": "Will you be addressing this? Clearing ping when any data is received, not necessarily ping ack.", "author": "anuraaga", "createdAt": "2020-02-28T06:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExNzc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTExODEwMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371118101", "bodyText": "I think we should just return instead of throwing an exception, I don't think it's clear enough why we would be in such a state.", "author": "anuraaga", "createdAt": "2020-01-27T08:52:47Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyMDA1NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371120054", "bodyText": "Same theme ;) I'm not sure we should throw an exception for these two branches. The first seems like it could just happen, and the second doesn't seem like an actual protocol error\nhttps://http2.github.io/http2-spec/#rfc.section.6.7\nThe only protocol error is when the stream ID is set and a server sending random ping acks doesn't seem to be explicitly banned. I think it's fine for us to just check \"get expected ping ack within timeout\", not \"don't get unexpected ping ack\"", "author": "anuraaga", "createdAt": "2020-01-27T08:57:35Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Validates the PING ACK.\n+     * @param data data received with the PING ACK\n+     * @throws Http2Exception when the PING ACK data does not match to PING data or\n+     *                        when a PING ACK is received without PING sent.\n+     */\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throwProtocolErrorException(\"State expected PENDING_PING_ACK but is %s\", state);", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyNTQxNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371125417", "bodyText": "This might be why grpc had a flag for whether keepalive applies to idle connections or not. If I'm not mistaken, an HTTP/2 connection will never ever be closed if pings are working ok? This seems like reasonable behavior for internal RPC but not for example, externally-exposed RPC.\nDoes IdleStateHandler take into account active streams? I think I would expect different behavior when there are active streams vs not for an externally exposed server that may not want to support infinite length HTTP/2 connections. I'm not sure I see the logic for it\n\nActive streams -> check pings and close if pings aren't acked (connection is busted)\nNo active streams -> close after timeout regardless of pings (reduce resource usage instead of having tons of idle, but pingable connections. For internal RPC, I'm ok with having idle connections to reduce latency, but not for external RPC)\n\nSo far I've been using idle timeout to intentionally close idle HTTP/2 connections when supporting streaming APIs.", "author": "anuraaga", "createdAt": "2020-01-27T09:10:01Z", "path": "core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java", "diffHunk": "@@ -32,14 +32,24 @@\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n+    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n+        this.isHttp2 = isHttp2;\n     }\n \n+    /**\n+     * If the channel is serving HTTP/2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n+     * but if it is HTTP/1.1 channel then we will close the channel\n+     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n+        if (isHttp2) {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwMDk3OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372900978", "bodyText": "Does IdleStateHandler take into account active streams?\n\nNope.\n\nreduce resource usage instead of having tons of idle, but pingable connections.\n\nNever though about this. Nice thought. I think for a client/server that has a occasional traffic, holding a connection which is idle is just waste of resources. But for a server/client that is active like a reverse-proxy, this could be beneficial. Active meaning it could go idle for a while but will eventually make calls to same host.\nIs it reasonable to have 2 different implementations:\n\nTo PING occasionally on idle connections, regardless of active streams. - This helps to maintain connection liveliness instead of creating a brand new http2 connection which comes with certain cost. Which should be covered as this PR.\nTo PING on when there are active streams.(Like you said) and not PING when active streams=0 and let IdleStateHandler close connections? - This helps to close IDLE connections for cases where a client makes occasional requests.\n\nAnd let users decide on what is best for their use case.\nPlease let me know your thoughts @trustin @anuraaga @ikhoon . Thanks for your suggestions @anuraaga .\nSome interesting conversation over here: golang/go#31643\nAlso, apologies for my late replies. I'm currently on vacation and will be back to work from Feb 15th onwards. Please bear me for the time being :)", "author": "sivaalli", "createdAt": "2020-01-30T11:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyNTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyMTI0Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r372921243", "bodyText": "Yup that sounds good to me, including the reasoning. And I don't think we can add #1 without also having #2. Actually #1 is technically implementable by a user using normal no-op payloads instead of ping. But IIUC #2, is nearly impossible for a user to do (nearly since I think it might be possible by examining the channel of a request in a state manager but I definitely don't want anyone to do that...)", "author": "anuraaga", "createdAt": "2020-01-30T12:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTEyNTQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\nsimilarity index 82%\nrename from core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\nindex e16c769b0d..22728a0c58 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/IdleTimeoutHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\n\n@@ -41,12 +45,13 @@ public abstract class IdleTimeoutHandler extends IdleStateHandler {\n     }\n \n     /**\n-     * If the channel is serving HTTP/2 the we will leverage sending PING's using {@link Http2KeepAliveHandler}\n-     * but if it is HTTP/1.1 channel then we will close the channel\n+     * If the channel is serving HTTP/2 and {@link Flags#defaultUseHttp2PingOnIdle()}\n+     * then we will leverage sending PING's using {@link Http2KeepAliveHandler}\n+     * but if it is HTTP/1.1 channel then we will close the channel.\n      */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n-        if (isHttp2) {\n+        if (isHttp2 && defaultUseHttp2PingOnIdle()) {\n             ctx.fireUserEventTriggered(evt);\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNzkyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r370717922", "bodyText": "nit: We prefer to split creating newProtocolErrorException and throwing it.\nFor example:\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n    \n    \n        Lines 240 to 241\n      in\n      f9b38ea\n    \n    \n    \n    \n\n        \n          \n           throw newIllegalStateException( \n        \n\n        \n          \n                   \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);", "author": "ikhoon", "createdAt": "2020-01-24T16:17:01Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU3Njk1Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371576952", "bodyText": "nit: Move keepAlive over responseDecoder to preserve the initialization orders?", "author": "ikhoon", "createdAt": "2020-01-28T01:53:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -16,27 +16,33 @@\n \n package com.linecorp.armeria.client;\n \n+import com.linecorp.armeria.common.Flags;\n import com.linecorp.armeria.internal.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final HttpClientFactory clientFactory;\n     private final Http2ResponseDecoder responseDecoder;\n+    private final Http2KeepAliveHandler keepAlive;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\nindex c5c815f031..71445e5201 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n\n@@ -17,7 +17,7 @@\n package com.linecorp.armeria.client;\n \n import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.internal.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n \n import io.netty.channel.Channel;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTkyOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581929", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                State getState() {\n          \n          \n            \n                State state() {", "author": "ikhoon", "createdAt": "2020-01-28T02:18:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Validates the PING ACK.\n+     * @param data data received with the PING ACK\n+     * @throws Http2Exception when the PING ACK data does not match to PING data or\n+     *                        when a PING ACK is received without PING sent.\n+     */\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throwProtocolErrorException(\"State expected PENDING_PING_ACK but is %s\", state);\n+        }\n+        if (lastPingPayload != data) {\n+            throwProtocolErrorException(\"PING received but payload does not match. Expected %d Received %d\",\n+                                        lastPingPayload, data);\n+        }\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    @VisibleForTesting\n+    State getState() {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU4MTk3OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371581978", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                long getLastPingPayload() {\n          \n          \n            \n                long lastPingPayload() {", "author": "ikhoon", "createdAt": "2020-01-28T02:18:23Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Validates the PING ACK.\n+     * @param data data received with the PING ACK\n+     * @throws Http2Exception when the PING ACK data does not match to PING data or\n+     *                        when a PING ACK is received without PING sent.\n+     */\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+\n+        if (state != State.PENDING_PING_ACK) {\n+            throwProtocolErrorException(\"State expected PENDING_PING_ACK but is %s\", state);\n+        }\n+        if (lastPingPayload != data) {\n+            throwProtocolErrorException(\"PING received but payload does not match. Expected %d Received %d\",\n+                                        lastPingPayload, data);\n+        }\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    @VisibleForTesting\n+    State getState() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long getLastPingPayload() {", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NTU5NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r371595595", "bodyText": "I think pingWriteListener might be called synchronously if an error has occurred while writing.\nHow about setting State.PING_SCHEDULED before writing ping?", "author": "ikhoon", "createdAt": "2020-01-28T03:33:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Error;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link IdleStateHandler}.\n+ * Specifically, it will write a PING frame to remote and then expects an ACK back within\n+ * configured {@code pingTimeoutInNanos}. If timeout exceeds then channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such as\n+ * {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long pingTimeoutInMs;\n+    private State state = State.IDLE;\n+    private Channel channel;\n+    private final Runnable shutdownRunnable = () -> {\n+        logger.debug(\"{} Closing channel due to PING timeout\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel due to PING timeout\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    };\n+    private final ChannelFutureListener pingWriteListener = future -> {\n+        if (future.isSuccess()) {\n+            final EventLoop el = channel.eventLoop();\n+            shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutInMs, TimeUnit.MILLISECONDS);\n+            state = State.PENDING_PING_ACK;\n+            stopwatch.reset().start();\n+        } else {\n+            // Mostly because the channel is already closed.\n+            logger.debug(\"{} Channel PING write failed. Closing channel\", channel);\n+            state = State.SHUTDOWN;\n+            channel.close();\n+        }\n+    };\n+    private long lastPingPayload;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, long pingTimeoutInMs) {\n+        this.channel = channel;\n+        this.frameWriter = frameWriter;\n+        this.pingTimeoutInMs = pingTimeoutInMs;\n+    }\n+\n+    private static void throwProtocolErrorException(String msg, Object... args) throws Http2Exception {\n+        throw new Http2Exception(Http2Error.PROTOCOL_ERROR, String.format(msg, args));\n+    }\n+\n+    /**\n+     * Callback for when the channel is idle.\n+     * @throws IllegalStateException when subsequent {@link IdleStateEvent} is less than round trip time.\n+     *      For ex:\n+     *      <ol>\n+     *          <li>IdleStateEvent occurred.</li>\n+     *          <li>PING is sent to peer.</li>\n+     *          <li>IdleStateEvent occurred, before ACK is sent by peer.</li>\n+     *      </ol>\n+     */\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        checkState(state == State.IDLE, \"Invalid state. Expecting IDLE but was %s\", state);\n+\n+        // Only interested in ALL_IDLE event.\n+        if (event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        logger.debug(\"{} {} event triggered on channel. Sending PING(ACK=0)\", channel, event);\n+        writePing(ctx);\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        state = State.PING_SCHEDULED;", "originalCommit": "b5c5786f3740b128c32013f313c7b8b9c0446483", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\nindex 450fd27452..f1c8274de2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n\n@@ -16,6 +16,7 @@\n \n package com.linecorp.armeria.internal;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n \n import java.util.concurrent.Future;\n"}}, {"oid": "878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "url": "https://github.com/line/armeria/commit/878d7b96d62a5bdc2e51d7f2f12099c8d14c3c1a", "message": "fixing imports", "committedDate": "2020-02-17T14:21:27Z", "type": "forcePushed"}, {"oid": "d3a320ab4c012b035757907efa1c1d347d9fd17d", "url": "https://github.com/line/armeria/commit/d3a320ab4c012b035757907efa1c1d347d9fd17d", "message": "adding necessary changes to handle pings on http2 connection. Tests pending.", "committedDate": "2020-02-25T03:24:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MTQ1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r384941457", "bodyText": "How about:\n\ndefaultUseHttp2PingOnIdleStream\ndefaultUseHttp2PingOnIdleConnection\n\n..?", "author": "trustin", "createdAt": "2020-02-27T06:54:57Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -247,6 +253,10 @@\n \n     private static final boolean DEFAULT_USE_HTTP2_PREFACE = getBoolean(\"defaultUseHttp2Preface\", true);\n     private static final boolean DEFAULT_USE_HTTP1_PIPELINING = getBoolean(\"defaultUseHttp1Pipelining\", false);\n+    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE =\n+            getBoolean(\"defaultUseHttp2PingOnIdle\", false);\n+    private static final boolean DEFAULT_USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS =\n+            getBoolean(\"defaultUseHttp2PingOnNoActiveStreams\", false);", "originalCommit": "b3377d0c3bdabf5685018fbe314c9aea9894cfed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex ed6187abeb..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -253,10 +247,6 @@ public final class Flags {\n \n     private static final boolean DEFAULT_USE_HTTP2_PREFACE = getBoolean(\"defaultUseHttp2Preface\", true);\n     private static final boolean DEFAULT_USE_HTTP1_PIPELINING = getBoolean(\"defaultUseHttp1Pipelining\", false);\n-    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE =\n-            getBoolean(\"defaultUseHttp2PingOnIdle\", false);\n-    private static final boolean DEFAULT_USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS =\n-            getBoolean(\"defaultUseHttp2PingOnNoActiveStreams\", false);\n \n     private static final String DEFAULT_DEFAULT_BACKOFF_SPEC =\n             \"exponential=200:10000,jitter=0.2\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MzYxMA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385493610", "bodyText": "Could remove throws Http2Exception?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onPingAck(long data) throws Http2Exception {\n          \n          \n            \n                public void onPingAck(long data) {", "author": "ikhoon", "createdAt": "2020-02-28T03:39:21Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5MzY5Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385493692", "bodyText": "Could remove throws Http2Exception?", "author": "ikhoon", "createdAt": "2020-02-28T03:39:55Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2RequestDecoder.java", "diffHunk": "@@ -316,4 +321,11 @@ public void onGoAwaySent(int lastStreamId, long errorCode, ByteBuf debugData) {\n     public void onGoAwayReceived(int lastStreamId, long errorCode, ByteBuf debugData) {\n         goAwayHandler.onGoAwayReceived(channel, lastStreamId, errorCode, debugData);\n     }\n+\n+    @Override\n+    public void onPingAckRead(final ChannelHandlerContext ctx, final long data) throws Http2Exception {", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2RequestDecoder.java b/core/src/main/java/com/linecorp/armeria/server/Http2RequestDecoder.java\nindex 820c29bf75..49365ed794 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2RequestDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Http2RequestDecoder.java\n\n@@ -321,11 +316,4 @@ final class Http2RequestDecoder extends Http2EventAdapter {\n     public void onGoAwayReceived(int lastStreamId, long errorCode, ByteBuf debugData) {\n         goAwayHandler.onGoAwayReceived(channel, lastStreamId, errorCode, debugData);\n     }\n-\n-    @Override\n-    public void onPingAckRead(final ChannelHandlerContext ctx, final long data) throws Http2Exception {\n-        if (keepAlive != null) {\n-            keepAlive.onPingAck(data);\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NTI0OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385495249", "bodyText": "Now it seems only to use for debugging. Could we remove stopwatch?", "author": "ikhoon", "createdAt": "2020-02-28T03:48:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDI1OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385500258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n          \n          \n            \n                public void onPingAckRead(ChannelHandlerContext ctx, long data) {", "author": "ikhoon", "createdAt": "2020-02-28T04:16:30Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ResponseDecoder.java", "diffHunk": "@@ -287,7 +292,11 @@ public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDe\n     public void onPingRead(ChannelHandlerContext ctx, long data) {}\n \n     @Override\n-    public void onPingAckRead(ChannelHandlerContext ctx, long data) {}\n+    public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http2ResponseDecoder.java b/core/src/main/java/com/linecorp/armeria/client/Http2ResponseDecoder.java\nindex 137daed586..8db315f8d3 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http2ResponseDecoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http2ResponseDecoder.java\n\n@@ -292,11 +287,7 @@ final class Http2ResponseDecoder extends HttpResponseDecoder implements Http2Con\n     public void onPingRead(ChannelHandlerContext ctx, long data) {}\n \n     @Override\n-    public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n-        if (keepAlive != null) {\n-            keepAlive.onPingAck(data);\n-        }\n-    }\n+    public void onPingAckRead(ChannelHandlerContext ctx, long data) {}\n \n     @Override\n     public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData) {}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzE5NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497195", "bodyText": "nit: Perhaps better not using a static import? It's used only once.", "author": "trustin", "createdAt": "2020-02-28T03:59:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -16,27 +16,38 @@\n \n package com.linecorp.armeria.client;\n \n+import static com.linecorp.armeria.common.Flags.defaultUseHttp2PingOnIdleConnection;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final HttpClientFactory clientFactory;\n     private final Http2ResponseDecoder responseDecoder;\n+    @Nullable\n+    private Http2KeepAliveHandler keepAlive;\n \n     Http2ClientConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel,\n                                  HttpClientFactory clientFactory) {\n \n         super(decoder, encoder, initialSettings);\n-\n         this.clientFactory = clientFactory;\n-        responseDecoder = new Http2ResponseDecoder(channel, encoder(), clientFactory);\n+\n+        if (defaultUseHttp2PingOnIdleConnection()) {", "originalCommit": "c73b467215ad3eaf6ebe6f13c4551954998181f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\nindex b561e21edd..0ffef988b5 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n\n@@ -16,11 +16,6 @@\n \n package com.linecorp.armeria.client;\n \n-import static com.linecorp.armeria.common.Flags.defaultUseHttp2PingOnIdleConnection;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzM2NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497365", "bodyText": "Could you rephrase this so that Javadoc summary is more useful to a user?", "author": "trustin", "createdAt": "2020-02-28T04:00:28Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cb5a8ac4ba..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,42 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n-     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n-     * the timeout interval. The default is 3 seconds.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleConnection() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n-    }\n-\n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n-     * HTTP 2.0 stream, no otherwise.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleStream() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzM3NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497375", "bodyText": "Could you rephrase this so that Javadoc summary is more useful to a user?", "author": "trustin", "createdAt": "2020-02-28T04:00:33Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n+     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n+     * the timeout interval. The default is 3 seconds.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleConnection() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n+    }\n+\n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n+     * HTTP 2.0 stream, no otherwise.", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cb5a8ac4ba..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,42 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n-     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n-     * the timeout interval. The default is 3 seconds.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleConnection() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n-    }\n-\n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n-     * HTTP 2.0 stream, no otherwise.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleStream() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzQ4Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497486", "bodyText": "HTTP2 -> HTTP/2", "author": "trustin", "createdAt": "2020-02-28T04:01:02Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n+     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n+     * the timeout interval. The default is 3 seconds.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleConnection() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n+    }\n+\n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n+     * HTTP 2.0 stream, no otherwise.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleStream() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM;\n+    }\n+\n+    /**\n+     * Returns the default value for HTTP2 PING timeout.", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cb5a8ac4ba..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,42 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n-     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n-     * the timeout interval. The default is 3 seconds.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleConnection() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n-    }\n-\n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n-     * HTTP 2.0 stream, no otherwise.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleStream() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5NzUzNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497537", "bodyText": "This will send -> Sends an", "author": "trustin", "createdAt": "2020-02-28T04:01:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5Nzk2OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385497969", "bodyText": "IdleStateEvent.toString() returns a string like: IdleStateEvent(...), so the following log message format would be better:\n\"{} {} triggered.\", channel, event", "author": "trustin", "createdAt": "2020-02-28T04:03:45Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5ODQ3NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385498474", "bodyText": "Closing an idle connection ?", "author": "trustin", "createdAt": "2020-02-28T04:06:36Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5ODU3Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385498577", "bodyText": "Closed an idle channel and Failed to close an idle channel: ?", "author": "trustin", "createdAt": "2020-02-28T04:07:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5ODkxNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385498916", "bodyText": "How about not logging if cause is Exceptions.isExpected() returns true? Otherwise, we could log with the cause.", "author": "trustin", "createdAt": "2020-02-28T04:08:56Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    enum State {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n+                state = State.PENDING_PING_ACK;\n+                stopwatch.reset().start();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n+                logger.debug(\"{} Channel PING write failed\", channel);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTE3OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499178", "bodyText": "How about logging the current channel as well?\n\"{} Unexpected PING(ACK=1, DATA={}) received\", channel, data\n\"{} Unexpected PING(ACK=1, DATA={}) received ....", "author": "trustin", "createdAt": "2020-02-28T04:10:28Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTU2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499564", "bodyText": "If stopwatch is used only for debug logging, how about assigning null to this field when logger.isDebugEnabled() is false?", "author": "trustin", "createdAt": "2020-02-28T04:12:30Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTY3Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499673", "bodyText": "Ditto - no need to use a static import.", "author": "trustin", "createdAt": "2020-02-28T04:13:05Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java", "diffHunk": "@@ -32,14 +36,25 @@\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n+    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n+        this.isHttp2 = isHttp2;\n     }\n \n+    /**\n+     * If the channel is serving HTTP/2 and {@link Flags#defaultUseHttp2PingOnIdleConnection()} is set\n+     * then we will forward event to {@link Http2KeepAliveHandler} to start sending PING's.\n+     * But if it is HTTP/1.1 channel then we will close the channel.\n+     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n+        if (isHttp2 && defaultUseHttp2PingOnIdleConnection()) {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\nindex 30070b533c..f41c081774 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/IdleTimeoutHandler.java\n\n@@ -36,25 +32,14 @@ public abstract class IdleTimeoutHandler extends IdleStateHandler {\n     private static final Logger logger = LoggerFactory.getLogger(IdleTimeoutHandler.class);\n \n     private final String name;\n-    private boolean isHttp2;\n \n-    protected IdleTimeoutHandler(String name, long idleTimeoutMillis, boolean isHttp2) {\n+    protected IdleTimeoutHandler(String name, long idleTimeoutMillis) {\n         super(0, 0, idleTimeoutMillis, TimeUnit.MILLISECONDS);\n         this.name = requireNonNull(name, \"name\");\n-        this.isHttp2 = isHttp2;\n     }\n \n-    /**\n-     * If the channel is serving HTTP/2 and {@link Flags#defaultUseHttp2PingOnIdleConnection()} is set\n-     * then we will forward event to {@link Http2KeepAliveHandler} to start sending PING's.\n-     * But if it is HTTP/1.1 channel then we will close the channel.\n-     */\n     @Override\n     protected final void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) throws Exception {\n-        if (isHttp2 && defaultUseHttp2PingOnIdleConnection()) {\n-            ctx.fireUserEventTriggered(evt);\n-            return;\n-        }\n         if (!evt.isFirst()) {\n             return;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5OTc4Ng==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385499786", "bodyText": "Ditto - no need to use a static import.", "author": "trustin", "createdAt": "2020-02-28T04:13:40Z", "path": "core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java", "diffHunk": "@@ -16,26 +16,40 @@\n \n package com.linecorp.armeria.server;\n \n+import static com.linecorp.armeria.common.Flags.defaultUseHttp2PingOnIdleConnection;\n+\n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n+import com.linecorp.armeria.internal.common.IdleTimeoutHandler;\n \n import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ServerConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final GracefulShutdownSupport gracefulShutdownSupport;\n     private final Http2RequestDecoder requestDecoder;\n \n+    @Nullable\n+    private Http2KeepAliveHandler keepAlive;\n+\n     Http2ServerConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel, ServerConfig config,\n                                  GracefulShutdownSupport gracefulShutdownSupport, String scheme) {\n \n         super(decoder, encoder, initialSettings);\n-\n         this.gracefulShutdownSupport = gracefulShutdownSupport;\n-        requestDecoder = new Http2RequestDecoder(config, channel, encoder(), scheme);\n+\n+        if (defaultUseHttp2PingOnIdleConnection()) {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java\nindex 3d60fc85bf..d9b502bd1c 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/Http2ServerConnectionHandler.java\n\n@@ -16,40 +16,26 @@\n \n package com.linecorp.armeria.server;\n \n-import static com.linecorp.armeria.common.Flags.defaultUseHttp2PingOnIdleConnection;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n-import com.linecorp.armeria.internal.common.IdleTimeoutHandler;\n \n import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n-import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ServerConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final GracefulShutdownSupport gracefulShutdownSupport;\n     private final Http2RequestDecoder requestDecoder;\n \n-    @Nullable\n-    private Http2KeepAliveHandler keepAlive;\n-\n     Http2ServerConnectionHandler(Http2ConnectionDecoder decoder, Http2ConnectionEncoder encoder,\n                                  Http2Settings initialSettings, Channel channel, ServerConfig config,\n                                  GracefulShutdownSupport gracefulShutdownSupport, String scheme) {\n \n         super(decoder, encoder, initialSettings);\n-        this.gracefulShutdownSupport = gracefulShutdownSupport;\n \n-        if (defaultUseHttp2PingOnIdleConnection()) {\n-            keepAlive = new Http2KeepAliveHandler(channel, encoder().frameWriter(), connection());\n-        }\n-        requestDecoder = new Http2RequestDecoder(config, channel, encoder(), scheme, keepAlive);\n+        this.gracefulShutdownSupport = gracefulShutdownSupport;\n+        requestDecoder = new Http2RequestDecoder(config, channel, encoder(), scheme);\n         connection().addListener(requestDecoder);\n         decoder().frameListener(requestDecoder);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDY2Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385500667", "bodyText": "Oh, I misunderstood how this flag works when I suggested a rename. defaultUseHttp2PingOnNoActiveStreams is correct indeed. Sorry about giving a wrong suggestion. \ud83d\ude47\u200d\u2642\ufe0f", "author": "trustin", "createdAt": "2020-02-28T04:18:51Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,42 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n+     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n+     * the timeout interval. The default is 3 seconds.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleConnection() {\n+        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n+    }\n+\n+    /**\n+     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n+     * HTTP 2.0 stream, no otherwise.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n+     */\n+    public static boolean defaultUseHttp2PingOnIdleStream() {", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NDU4OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385984589", "bodyText": "No problem \ud83d\ude04", "author": "sivaalli", "createdAt": "2020-02-29T00:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMDY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cb5a8ac4ba..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,42 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent on connection, no otherwise.\n-     * Note that if this is set to true, you may use {@link Flags#defaultHttp2PingTimeoutMillis()} to tune\n-     * the timeout interval. The default is 3 seconds.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleConnection=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleConnection() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION;\n-    }\n-\n-    /**\n-     * Returns the default value. If true then HTTP 2.0 PING frames are sent even there are no active\n-     * HTTP 2.0 stream, no otherwise.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.defaultUseHttp2PingOnIdleStream=true} JVM option to enable it.\n-     */\n-    public static boolean defaultUseHttp2PingOnIdleStream() {\n-        return DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMjMyMQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385532321", "bodyText": "I don't think we need default for any of the new flags - our request / response timeout we do since a user can control them at runtime too but these I think are only controllable by flags.", "author": "anuraaga", "createdAt": "2020-02-28T06:48:48Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -247,6 +253,10 @@\n \n     private static final boolean DEFAULT_USE_HTTP2_PREFACE = getBoolean(\"defaultUseHttp2Preface\", true);\n     private static final boolean DEFAULT_USE_HTTP1_PIPELINING = getBoolean(\"defaultUseHttp1Pipelining\", false);\n+    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION =\n+            getBoolean(\"defaultUseHttp2PingOnIdleConnection\", false);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex cb5a8ac4ba..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -253,10 +247,6 @@ public final class Flags {\n \n     private static final boolean DEFAULT_USE_HTTP2_PREFACE = getBoolean(\"defaultUseHttp2Preface\", true);\n     private static final boolean DEFAULT_USE_HTTP1_PIPELINING = getBoolean(\"defaultUseHttp1Pipelining\", false);\n-    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE_CONNECTION =\n-            getBoolean(\"defaultUseHttp2PingOnIdleConnection\", false);\n-    private static final boolean DEFAULT_USE_HTTP2_PING_ON_IDLE_STREAM =\n-            getBoolean(\"defaultUseHttp2PingOnIdleStream\", false);\n \n     private static final String DEFAULT_DEFAULT_BACKOFF_SPEC =\n             \"exponential=200:10000,jitter=0.2\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMzgxNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385533816", "bodyText": "I don't think we need warnings for these since they don't seem particularly bad, maybe debug?", "author": "anuraaga", "createdAt": "2020-02-28T06:54:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzNDkyNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385534927", "bodyText": "This is hard to read, how about just\nif (state != state.SHUTDOWN) {\n  state = State.IDLE;\n}", "author": "anuraaga", "createdAt": "2020-02-28T06:58:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2Exception;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n+ * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n+ * channel will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    private State state = State.IDLE;\n+    private long lastPingPayload;\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+                Flags.defaultUseHttp2PingOnIdleStream());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n+        // more faster than ping acks are received.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) throws Http2Exception {\n+        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n+                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed channel\", channel);\n+            } else {\n+                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    enum State {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n+                state = State.PENDING_PING_ACK;\n+                stopwatch.reset().start();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n+                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n+                logger.debug(\"{} Channel PING write failed\", channel);\n+                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;", "originalCommit": "51f850f3640d559c1c843faefb2f2f7c38119041", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 50dc7e74a0..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler}. Specifically, it will write a PING frame to remote and then expects an ACK\n- * back within configured {@code pingTimeoutMillis}. If no valid response is received in time, then\n- * channel will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Stopwatch stopwatch = Stopwatch.createUnstarted();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    private State state = State.IDLE;\n-    private long lastPingPayload;\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-                Flags.defaultUseHttp2PingOnIdleStream());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} event triggered on channel.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler will not be ready because IdleStateEvent events are emitted\n-        // more faster than ping acks are received.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) throws Http2Exception {\n-        final long elapsed = stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received\", data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.warn(\"Unexpected PING(ACK=1, DATA={}) received, \" +\n-                    \"but expecting PING(ACK=1, DATA={})\", data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed channel\", channel);\n-            } else {\n-                logger.debug(\"{} Channel cannot be closed\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                stopwatch.reset().start();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                logger.debug(\"{} Channel PING write failed\", channel);\n-                state = state == State.SHUTDOWN ? State.SHUTDOWN : State.IDLE;\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NTY4MA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r385985680", "bodyText": "Sorry for not fixing this in earlier PR fixes and thanks for doing it \ud83d\ude47", "author": "sivaalli", "createdAt": "2020-02-29T01:07:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java", "diffHunk": "@@ -339,7 +339,8 @@ void finishSuccessfully(ChannelPipeline pipeline, SessionProtocol protocol) {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n+                                                               protocol.isMultiplex()));", "originalCommit": "f90b1d2f88c058bf04731f7d812e2e98ae4944fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java b/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\nindex 23d0e80647..b0524dd893 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n\n@@ -339,8 +339,7 @@ final class HttpClientPipelineConfigurator extends ChannelDuplexHandler {\n \n         final long idleTimeoutMillis = clientFactory.idleTimeoutMillis();\n         if (idleTimeoutMillis > 0) {\n-            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis,\n-                                                               protocol.isMultiplex()));\n+            pipeline.addFirst(new HttpClientIdleTimeoutHandler(idleTimeoutMillis));\n         }\n \n         pipeline.channel().eventLoop().execute(() -> pipeline.fireUserEventTriggered(protocol));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTQ5NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195495", "bodyText": "are sent", "author": "anuraaga", "createdAt": "2020-03-02T04:44:34Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTY5NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195694", "bodyText": "Can just return , no otherwise", "author": "anuraaga", "createdAt": "2020-03-02T04:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex d221cad3be..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,47 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on an idle HTTP/2 connection.\n-     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n-     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n-     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnIdle() {\n-        return USE_HTTP2_PING_ON_IDLE;\n-    }\n-\n-    /**\n-     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n-     * A connection is considered having no active streams means that are no requests and responses pending.\n-     * This does not necessarily indicate end of life of a HTTP/2 connection.\n-     * \\A client could create a new stream if it intends to use the same connection.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnNoActiveStreams=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnNoActiveStreams() {\n-        return USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTU1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195557", "bodyText": "Remove a boolean indicating", "author": "anuraaga", "createdAt": "2020-03-02T04:45:13Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTcxNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195717", "bodyText": "For all the flags", "author": "anuraaga", "createdAt": "2020-03-02T04:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex d221cad3be..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,47 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on an idle HTTP/2 connection.\n-     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n-     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n-     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnIdle() {\n-        return USE_HTTP2_PING_ON_IDLE;\n-    }\n-\n-    /**\n-     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n-     * A connection is considered having no active streams means that are no requests and responses pending.\n-     * This does not necessarily indicate end of life of a HTTP/2 connection.\n-     * \\A client could create a new stream if it intends to use the same connection.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnNoActiveStreams=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnNoActiveStreams() {\n-        return USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTg5Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195897", "bodyText": "I rhink for both flags we can use when instead of on.", "author": "anuraaga", "createdAt": "2020-03-02T04:47:08Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n+     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n+     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n+     */\n+    public static boolean useHttp2PingOnIdle() {", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex d221cad3be..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,47 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on an idle HTTP/2 connection.\n-     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n-     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n-     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnIdle() {\n-        return USE_HTTP2_PING_ON_IDLE;\n-    }\n-\n-    /**\n-     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n-     * A connection is considered having no active streams means that are no requests and responses pending.\n-     * This does not necessarily indicate end of life of a HTTP/2 connection.\n-     * \\A client could create a new stream if it intends to use the same connection.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnNoActiveStreams=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnNoActiveStreams() {\n-        return USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTk3Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386195972", "bodyText": "Do we need to document any interaction between this and the other flag?", "author": "anuraaga", "createdAt": "2020-03-02T04:47:41Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n+     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n+     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n+     *\n+     * <p>This flag is disabled by default. Specify the\n+     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n+     */\n+    public static boolean useHttp2PingOnIdle() {\n+        return USE_HTTP2_PING_ON_IDLE;\n+    }\n+\n+    /**\n+     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n+     * A connection is considered having no active streams means that are no requests and responses pending.\n+     * This does not necessarily indicate end of life of a HTTP/2 connection.\n+     * \\A client could create a new stream if it intends to use the same connection.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIzMzc4Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386233787", "bodyText": "nit: backslash", "author": "trustin", "createdAt": "2020-03-02T07:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NTk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex d221cad3be..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,47 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on an idle HTTP/2 connection.\n-     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n-     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n-     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnIdle() {\n-        return USE_HTTP2_PING_ON_IDLE;\n-    }\n-\n-    /**\n-     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n-     * A connection is considered having no active streams means that are no requests and responses pending.\n-     * This does not necessarily indicate end of life of a HTTP/2 connection.\n-     * \\A client could create a new stream if it intends to use the same connection.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnNoActiveStreams=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnNoActiveStreams() {\n-        return USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNjI1OA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386216258", "bodyText": "nit: I think we can make this final by assigning null in the constructor.", "author": "minwoox", "createdAt": "2020-03-02T06:32:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java", "diffHunk": "@@ -16,27 +16,37 @@\n \n package com.linecorp.armeria.client;\n \n+import javax.annotation.Nullable;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.http2.Http2ConnectionDecoder;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Settings;\n+import io.netty.handler.timeout.IdleStateEvent;\n \n final class Http2ClientConnectionHandler extends AbstractHttp2ConnectionHandler {\n \n     private final HttpClientFactory clientFactory;\n     private final Http2ResponseDecoder responseDecoder;\n+    @Nullable\n+    private Http2KeepAliveHandler keepAlive;", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\nindex 7fc7144011..0ffef988b5 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/Http2ClientConnectionHandler.java\n\n@@ -16,10 +16,6 @@\n \n package com.linecorp.armeria.client;\n \n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.internal.Http2KeepAliveHandler;\n import com.linecorp.armeria.internal.common.AbstractHttp2ConnectionHandler;\n \n import io.netty.channel.Channel;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxODA5Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386218097", "bodyText": "nit: need to remove ()}", "author": "minwoox", "createdAt": "2020-03-02T06:40:12Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,47 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n+     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n+     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex d221cad3be..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,47 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns a boolean indicating whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on an idle HTTP/2 connection.\n-     * If true, then PINGs are send when the connection is idle, no otherwise. Connection is considered idle\n-     * when there is no read or write for at least {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n-     * {@link Flags#defaultServerIdleTimeoutMillis()} ()} for server.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnIdle=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnIdle() {\n-        return USE_HTTP2_PING_ON_IDLE;\n-    }\n-\n-    /**\n-     * Returns a boolean indicating whether to <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n-     * A connection is considered having no active streams means that are no requests and responses pending.\n-     * This does not necessarily indicate end of life of a HTTP/2 connection.\n-     * \\A client could create a new stream if it intends to use the same connection.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnNoActiveStreams=true} JVM option to enable it.\n-     */\n-    public static boolean useHttp2PingOnNoActiveStreams() {\n-        return USE_HTTP2_PING_ON_NO_ACTIVE_STREAMS;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxOTE3OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386219179", "bodyText": "nit: linkplain -> link", "author": "minwoox", "createdAt": "2020-03-02T06:45:07Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxOTIxOQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386219219", "bodyText": "nit: a -> an", "author": "minwoox", "createdAt": "2020-03-02T06:45:19Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxOTUxNg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386219516", "bodyText": "ditto a -> an", "author": "minwoox", "createdAt": "2020-03-02T06:46:25Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMDQ2Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386220462", "bodyText": "We can remove public here and add @VisibleForTesting", "author": "minwoox", "createdAt": "2020-03-02T06:50:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMDg1Nw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386220857", "bodyText": "nit: HTTP/2 (there's no .0 for HTTP/2)", "author": "minwoox", "createdAt": "2020-03-02T06:51:52Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMTEwNw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386221107", "bodyText": "an -> a", "author": "minwoox", "createdAt": "2020-03-02T06:52:58Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler may not be ready because it is currently handling\n+        // sending a PING or expecting a PING ACK on channel.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public void onChannelRead() {\n+        state = State.IDLE;\n+        cancelFutures();\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) {\n+        final long elapsed = getStopwatchElapsedInNanos();\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        // This condition can be true when channel read some data other than PING ACK frame\n+        // or a PING ACK is received without sending PING in first place.\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n+                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an channel\", channel);", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNTE2OQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386225169", "bodyText": "I think we can add pingWriteFuture = null;.", "author": "minwoox", "createdAt": "2020-03-02T07:09:06Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler may not be ready because it is currently handling\n+        // sending a PING or expecting a PING ACK on channel.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public void onChannelRead() {\n+        state = State.IDLE;\n+        cancelFutures();\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) {\n+        final long elapsed = getStopwatchElapsedInNanos();\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIzNDA2NQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386234065", "bodyText": "Could be moved to internal.common", "author": "trustin", "createdAt": "2020-03-02T07:39:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIzNDg1MQ==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386234851", "bodyText": "Perhaps we should not log anything if the write future has been cancelled by cancelFutures()?", "author": "trustin", "createdAt": "2020-03-02T07:42:11Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingOnIdle()\n+ * @see Flags#useHttp2PingOnNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingOnNoActiveStreams());\n+    }\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n+        this.channel = requireNonNull(channel, \"channel\");\n+        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n+        this.pingTimeoutMillis = pingTimeoutMillis;\n+        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n+        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n+    }\n+\n+    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n+        logger.debug(\"{} {} triggered.\", channel, event);\n+\n+        if (!canSendPing()) {\n+            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n+            // So preserving the behaviour.\n+            closeChannelAndLog();\n+            return;\n+        }\n+\n+        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n+        // Http2KeepAliveHandler may not be ready because it is currently handling\n+        // sending a PING or expecting a PING ACK on channel.\n+        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n+            return;\n+        }\n+\n+        writePing(ctx);\n+    }\n+\n+    private boolean canSendPing() {\n+        if (http2Connection.numActiveStreams() == 0) {\n+            return sendPingsOnNoActiveStreams;\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    private void writePing(ChannelHandlerContext ctx) {\n+        lastPingPayload = random.nextLong();\n+        state = State.PING_SCHEDULED;\n+        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n+                                     .addListener(pingWriteListener);\n+        ctx.flush();\n+    }\n+\n+    /**\n+     * Callback for when channel is in-active to cleans up resources.\n+     */\n+    public void onChannelInactive() {\n+        state = State.SHUTDOWN;\n+        cancelFutures();\n+    }\n+\n+    public void onChannelRead() {\n+        state = State.IDLE;\n+        cancelFutures();\n+    }\n+\n+    private void cancelFutures() {\n+        if (shutdownFuture != null) {\n+            shutdownFuture.cancel(false);\n+            shutdownFuture = null;\n+        }\n+        if (pingWriteFuture != null) {\n+            pingWriteFuture.cancel(false);\n+            pingWriteFuture = null;\n+        }\n+    }\n+\n+    public void onPingAck(long data) {\n+        final long elapsed = getStopwatchElapsedInNanos();\n+        if (!isGoodPingAck(data)) {\n+            return;\n+        }\n+\n+        if (shutdownFuture != null) {\n+            final boolean isCancelled = shutdownFuture.cancel(false);\n+            if (!isCancelled) {\n+                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n+            }\n+        }\n+        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n+        state = State.IDLE;\n+    }\n+\n+    private boolean isGoodPingAck(long data) {\n+        // This condition can be true when channel read some data other than PING ACK frame\n+        // or a PING ACK is received without sending PING in first place.\n+        if (state != State.PENDING_PING_ACK) {\n+            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n+            return false;\n+        }\n+        if (lastPingPayload != data) {\n+            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n+                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @VisibleForTesting\n+    State state() {\n+        return state;\n+    }\n+\n+    @VisibleForTesting\n+    long lastPingPayload() {\n+        return lastPingPayload;\n+    }\n+\n+    private void closeChannelAndLog() {\n+        if (state == State.SHUTDOWN) {\n+            return;\n+        }\n+        logger.debug(\"{} Closing an idle channel\", channel);\n+        channel.close().addListener(future -> {\n+            if (future.isSuccess()) {\n+                logger.debug(\"{} Closed an channel\", channel);\n+            } else {\n+                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n+            }\n+            state = State.SHUTDOWN;\n+        });\n+    }\n+\n+    private long getStopwatchElapsedInNanos() {\n+        if (stopwatch == null) {\n+            return -1;\n+        }\n+        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n+    }\n+\n+    /**\n+     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n+     * channel is inactive then the state changes to SHUTDOWN.\n+     */\n+    enum State {\n+        /* Nothing happening, but waiting for IdleStateEvent */\n+        IDLE,\n+\n+        /* PING is scheduled */\n+        PING_SCHEDULED,\n+\n+        /* PING is sent and is pending ACK */\n+        PENDING_PING_ACK,\n+\n+        /* Not active anymore */\n+        SHUTDOWN\n+    }\n+\n+    private class PingWriteListener implements ChannelFutureListener {\n+\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+            if (future.isSuccess()) {\n+                final EventLoop el = channel.eventLoop();\n+                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n+                state = State.PENDING_PING_ACK;\n+                resetStopwatch();\n+            } else {\n+                // Mostly because the channel is already closed. So ignore and change state to IDLE.", "originalCommit": "89bbf588fad52d23fdf3f8b14ce4d431c61e4c71", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 6f8a1d9608..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,276 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@linkplain Flags#useHttp2PingOnIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@linkplain Flags#useHttp2PingOnNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingOnIdle()\n- * @see Flags#useHttp2PingOnNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingOnNoActiveStreams());\n-    }\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP 2.0 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2NTU2Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386765563", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <p>Connection is considered idle when there is no read or write for at least\n          \n          \n            \n                 * <p>A connection is considered idle when there is no read or write for at least", "author": "ikhoon", "createdAt": "2020-03-03T02:24:29Z", "path": "core/src/main/java/com/linecorp/armeria/common/Flags.java", "diffHunk": "@@ -675,6 +685,58 @@ public static boolean defaultUseHttp1Pipelining() {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n+    /**\n+     * Returns whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n+     * frames on an idle HTTP/2 connection.\n+     *\n+     * <p>Connection is considered idle when there is no read or write for at least", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/Flags.java b/core/src/main/java/com/linecorp/armeria/common/Flags.java\nindex 0ff225dc3e..c18ec5f05e 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/Flags.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/Flags.java\n\n@@ -685,58 +675,6 @@ public final class Flags {\n         return DEFAULT_USE_HTTP1_PIPELINING;\n     }\n \n-    /**\n-     * Returns whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on an idle HTTP/2 connection.\n-     *\n-     * <p>Connection is considered idle when there is no read or write for at least\n-     * {@link Flags#defaultClientIdleTimeoutMillis()} for client and\n-     * {@link Flags#defaultServerIdleTimeoutMillis()} for server.\n-     *\n-     * <p>Note that even when the connection is idle PING may not be sent because number of open streams\n-     * may be zero and {@link Flags#useHttp2PingWhenNoActiveStreams()} is set to false.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingWhenIdle=true} JVM option to enable it.\n-     *\n-     * @see Flags#useHttp2PingWhenNoActiveStreams()\n-     */\n-    public static boolean useHttp2PingWhenIdle() {\n-        return USE_HTTP2_PING_WHEN_IDLE;\n-    }\n-\n-    /**\n-     * Returns whether to send <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a>\n-     * frames on a HTTP/2 connection when it is idle and there are no active HTTP/2 stream.\n-     *\n-     * <p>A connection is considered having no active streams means that are no requests and responses pending.\n-     * This does not necessarily indicate end of life of a HTTP/2 connection.\n-     * A client could create a new stream if it intends to use the same connection.\n-     *\n-     * <p>Note that this flag is only in effect when {@link Flags#useHttp2PingWhenIdle()} is set to true.\n-     *\n-     * <p>This flag is disabled by default. Specify the\n-     * {@code -Dcom.linecorp.armeria.useHttp2PingOnWhenActiveStreams=true} JVM option to enable it.\n-     *\n-     * @see Flags#useHttp2PingWhenIdle()\n-     */\n-    public static boolean useHttp2PingWhenNoActiveStreams() {\n-        return USE_HTTP2_PING_WHEN_NO_ACTIVE_STREAMS;\n-    }\n-\n-    /**\n-     * Returns the default value for HTTP2 PING timeout.\n-     * Note that this flag is only in effect when {@link #defaultServerIdleTimeoutMillis()} for server and\n-     * {@link #defaultClientIdleTimeoutMillis()} for client are greater than 0.\n-     *\n-     * <p>The default value of this flag is {@value #DEFAULT_DEFAULT_HTTP2_PING_TIMEOUT_MILLIS} milliseconds.\n-     * Specify the {@code -Dcom.linecorp.armeria.defaultHttp2PingTimeoutMillis=<integer>} JVM option to override\n-     * the default value.\n-     */\n-    public static long defaultHttp2PingTimeoutMillis() {\n-        return DEFAULT_HTTP2_PING_TIMEOUT_MILLIS;\n-    }\n-\n     /**\n      * Returns the default value of the {@link ServerBuilder#http2InitialConnectionWindowSize(int)} and\n      * {@link ClientFactoryBuilder#http2InitialConnectionWindowSize(int)} option.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3MTgyMg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386771822", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {\n          \n          \n            \n                private static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {", "author": "ikhoon", "createdAt": "2020-03-03T02:49:05Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.common.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final String sendPingsOnNoActiveStreams = \"sendPingsOnNoActiveStreams\";\n+\n+    private static final long pingTimeout = 100;\n+    @Mock\n+    private Http2FrameWriter frameWriter;\n+    @Mock\n+    private Http2Connection connection;\n+    private EmbeddedChannel ch;\n+    private ChannelPromise promise;\n+\n+    private Http2KeepAliveHandler keepAlive;\n+\n+    @BeforeEach\n+    public void setup(TestInfo testInfo) throws Exception {\n+        ch = new EmbeddedChannel();\n+        promise = ch.newPromise();\n+        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, connection, pingTimeout,\n+                                              !testInfo.getTags().contains(sendPingsOnNoActiveStreams));\n+\n+        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n+\n+        assertThat(ch.isOpen()).isTrue();\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+    }\n+\n+    @AfterEach\n+    public void after() {\n+        assertThat(ch.finish()).isFalse();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingTimesOut_ShouldCloseConnection() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+        waitUntilPingTimeout();\n+        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenWritePingFailsBecauseChannelIsClosed_ShouldSetStateToShutdown() throws\n+                                                                                               Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        ch.close();\n+        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenWritePingFailsOfUnknownReason_ShouldSetStateToIdle() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setFailure(new Exception(\"Unknown reason\"));\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenPingAckIsReceivedBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+\n+        keepAlive.onPingAck(keepAlive.lastPingPayload());\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @Test\n+    void testOnChannelIdle_WhenAnyDataReadBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+\n+        keepAlive.onChannelRead();\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    @Test\n+    @Tag(\"sendPingsOnNoActiveStreams\")\n+    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleAndActiveStreamsAreZero_ShouldCloseConnection()\n+            throws Exception {\n+        when(connection.numActiveStreams()).thenReturn(0);\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+\n+        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n+\n+        verify(frameWriter, never()).writePing(any(), anyBoolean(), anyLong(), any());\n+        assertThat(ch.isOpen()).isFalse();\n+    }\n+\n+    @Test\n+    @Tag(\"sendPingsOnNoActiveStreams\")\n+    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleWithActiveStreams_ShouldCloseConnection()\n+            throws Exception {\n+        when(connection.numActiveStreams()).thenReturn(1);\n+        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n+\n+        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n+        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n+\n+        promise.setSuccess();\n+        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n+\n+        keepAlive.onPingAck(keepAlive.lastPingPayload());\n+        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n+\n+        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n+        assertThat(ch.isOpen()).isTrue();\n+    }\n+\n+    private void waitUntilPingTimeout() throws InterruptedException {\n+        Thread.sleep(pingTimeout * 3 / 2);\n+        ch.runPendingTasks();\n+    }\n+\n+    public static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java\ndeleted file mode 100644\nindex 928110cfcb..0000000000\n--- a/core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal.common;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyBoolean;\n-import static org.mockito.ArgumentMatchers.anyLong;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Tag;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.TestInfo;\n-import org.mockito.Mock;\n-\n-import com.linecorp.armeria.internal.common.Http2KeepAliveHandler.State;\n-\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.embedded.EmbeddedChannel;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.timeout.IdleStateEvent;\n-\n-class Http2KeepAliveHandlerTest {\n-\n-    private static final String sendPingsOnNoActiveStreams = \"sendPingsOnNoActiveStreams\";\n-\n-    private static final long pingTimeout = 100;\n-    @Mock\n-    private Http2FrameWriter frameWriter;\n-    @Mock\n-    private Http2Connection connection;\n-    private EmbeddedChannel ch;\n-    private ChannelPromise promise;\n-\n-    private Http2KeepAliveHandler keepAlive;\n-\n-    @BeforeEach\n-    public void setup(TestInfo testInfo) throws Exception {\n-        ch = new EmbeddedChannel();\n-        promise = ch.newPromise();\n-        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, connection, pingTimeout,\n-                                              !testInfo.getTags().contains(sendPingsOnNoActiveStreams));\n-\n-        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n-\n-        assertThat(ch.isOpen()).isTrue();\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-    }\n-\n-    @AfterEach\n-    public void after() {\n-        assertThat(ch.finish()).isFalse();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenPingTimesOut_ShouldCloseConnection() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-        waitUntilPingTimeout();\n-        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isFalse();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenWritePingFailsBecauseChannelIsClosed_ShouldSetStateToShutdown() throws\n-                                                                                               Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        ch.close();\n-        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isFalse();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenWritePingFailsOfUnknownReason_ShouldSetStateToIdle() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setFailure(new Exception(\"Unknown reason\"));\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenPingAckIsReceivedBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-\n-        keepAlive.onPingAck(keepAlive.lastPingPayload());\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenAnyDataReadBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-\n-        keepAlive.onChannelRead();\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    @Test\n-    @Tag(\"sendPingsOnNoActiveStreams\")\n-    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleAndActiveStreamsAreZero_ShouldCloseConnection()\n-            throws Exception {\n-        when(connection.numActiveStreams()).thenReturn(0);\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-\n-        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n-\n-        verify(frameWriter, never()).writePing(any(), anyBoolean(), anyLong(), any());\n-        assertThat(ch.isOpen()).isFalse();\n-    }\n-\n-    @Test\n-    @Tag(\"sendPingsOnNoActiveStreams\")\n-    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleWithActiveStreams_ShouldCloseConnection()\n-            throws Exception {\n-        when(connection.numActiveStreams()).thenReturn(1);\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-\n-        keepAlive.onPingAck(keepAlive.lastPingPayload());\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    private void waitUntilPingTimeout() throws InterruptedException {\n-        Thread.sleep(pingTimeout * 3 / 2);\n-        ch.runPendingTasks();\n-    }\n-\n-    public static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {\n-        private final Http2KeepAliveHandler keepAlive;\n-\n-        TestIdleStateHandler(Http2KeepAliveHandler keepAlive) {\n-            this.keepAlive = keepAlive;\n-        }\n-\n-        @Override\n-        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n-            keepAlive.onChannelIdle(ctx, (IdleStateEvent) evt);\n-        }\n-\n-        @Override\n-        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-            keepAlive.onChannelInactive();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3MTk2NA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386771964", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final long pingTimeout = 100;\n          \n          \n            \n                private static final long pingTimeoutMillis = 100;", "author": "ikhoon", "createdAt": "2020-03-03T02:49:44Z", "path": "core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n+\n+import com.linecorp.armeria.internal.common.Http2KeepAliveHandler.State;\n+\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.timeout.IdleStateEvent;\n+\n+class Http2KeepAliveHandlerTest {\n+\n+    private static final String sendPingsOnNoActiveStreams = \"sendPingsOnNoActiveStreams\";\n+\n+    private static final long pingTimeout = 100;", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java b/core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java\ndeleted file mode 100644\nindex 928110cfcb..0000000000\n--- a/core/src/test/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandlerTest.java\n+++ /dev/null\n\n@@ -1,210 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal.common;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyBoolean;\n-import static org.mockito.ArgumentMatchers.anyLong;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Tag;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.TestInfo;\n-import org.mockito.Mock;\n-\n-import com.linecorp.armeria.internal.common.Http2KeepAliveHandler.State;\n-\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.embedded.EmbeddedChannel;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.timeout.IdleStateEvent;\n-\n-class Http2KeepAliveHandlerTest {\n-\n-    private static final String sendPingsOnNoActiveStreams = \"sendPingsOnNoActiveStreams\";\n-\n-    private static final long pingTimeout = 100;\n-    @Mock\n-    private Http2FrameWriter frameWriter;\n-    @Mock\n-    private Http2Connection connection;\n-    private EmbeddedChannel ch;\n-    private ChannelPromise promise;\n-\n-    private Http2KeepAliveHandler keepAlive;\n-\n-    @BeforeEach\n-    public void setup(TestInfo testInfo) throws Exception {\n-        ch = new EmbeddedChannel();\n-        promise = ch.newPromise();\n-        keepAlive = new Http2KeepAliveHandler(ch, frameWriter, connection, pingTimeout,\n-                                              !testInfo.getTags().contains(sendPingsOnNoActiveStreams));\n-\n-        ch.pipeline().addLast(new TestIdleStateHandler(keepAlive));\n-\n-        assertThat(ch.isOpen()).isTrue();\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-    }\n-\n-    @AfterEach\n-    public void after() {\n-        assertThat(ch.finish()).isFalse();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenPingTimesOut_ShouldCloseConnection() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-        waitUntilPingTimeout();\n-        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isFalse();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenWritePingFailsBecauseChannelIsClosed_ShouldSetStateToShutdown() throws\n-                                                                                               Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        ch.close();\n-        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isFalse();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenWritePingFailsOfUnknownReason_ShouldSetStateToIdle() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setFailure(new Exception(\"Unknown reason\"));\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenPingAckIsReceivedBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-\n-        keepAlive.onPingAck(keepAlive.lastPingPayload());\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    @Test\n-    void testOnChannelIdle_WhenAnyDataReadBeforeTimeout_ShouldResetStateToIdle() throws Exception {\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-\n-        keepAlive.onChannelRead();\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    @Test\n-    @Tag(\"sendPingsOnNoActiveStreams\")\n-    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleAndActiveStreamsAreZero_ShouldCloseConnection()\n-            throws Exception {\n-        when(connection.numActiveStreams()).thenReturn(0);\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-\n-        assertThat(keepAlive.state()).isEqualTo(State.SHUTDOWN);\n-\n-        verify(frameWriter, never()).writePing(any(), anyBoolean(), anyLong(), any());\n-        assertThat(ch.isOpen()).isFalse();\n-    }\n-\n-    @Test\n-    @Tag(\"sendPingsOnNoActiveStreams\")\n-    void testOnChannelIdle_WhenShouldNotSendPingsOnIdleWithActiveStreams_ShouldCloseConnection()\n-            throws Exception {\n-        when(connection.numActiveStreams()).thenReturn(1);\n-        when(frameWriter.writePing(any(), eq(false), anyLong(), any())).thenReturn(promise);\n-\n-        ch.pipeline().fireUserEventTriggered(IdleStateEvent.FIRST_ALL_IDLE_STATE_EVENT);\n-        assertThat(keepAlive.state()).isEqualTo(State.PING_SCHEDULED);\n-\n-        promise.setSuccess();\n-        assertThat(keepAlive.state()).isEqualTo(State.PENDING_PING_ACK);\n-\n-        keepAlive.onPingAck(keepAlive.lastPingPayload());\n-        assertThat(keepAlive.state()).isEqualTo(State.IDLE);\n-\n-        verify(frameWriter).writePing(any(), eq(false), anyLong(), any());\n-        assertThat(ch.isOpen()).isTrue();\n-    }\n-\n-    private void waitUntilPingTimeout() throws InterruptedException {\n-        Thread.sleep(pingTimeout * 3 / 2);\n-        ch.runPendingTasks();\n-    }\n-\n-    public static final class TestIdleStateHandler extends ChannelInboundHandlerAdapter {\n-        private final Http2KeepAliveHandler keepAlive;\n-\n-        TestIdleStateHandler(Http2KeepAliveHandler keepAlive) {\n-            this.keepAlive = keepAlive;\n-        }\n-\n-        @Override\n-        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n-            keepAlive.onChannelIdle(ctx, (IdleStateEvent) evt);\n-        }\n-\n-        @Override\n-        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-            keepAlive.onChannelInactive();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc3NDI4Mg==", "url": "https://github.com/line/armeria/pull/2409#discussion_r386774282", "bodyText": "nit: Indent", "author": "ikhoon", "createdAt": "2020-03-03T02:58:49Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@link Flags#useHttp2PingWhenIdle()} is true.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@link Flags#useHttp2PingWhenNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingWhenIdle()\n+ * @see Flags#useHttp2PingWhenNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n+                                 Http2Connection http2Connection) {\n+        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n+             Flags.useHttp2PingWhenNoActiveStreams());\n+    }\n+\n+    @VisibleForTesting\n+    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {", "originalCommit": "46577d53e21a6472072d03cc4eb47ca678f28c62", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\ndeleted file mode 100644\nindex 554fb9cc93..0000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n+++ /dev/null\n\n@@ -1,283 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal.common;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-import javax.annotation.Nullable;\n-import javax.annotation.concurrent.NotThreadSafe;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Stopwatch;\n-\n-import com.linecorp.armeria.common.Flags;\n-import com.linecorp.armeria.common.util.Exceptions;\n-\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.EventLoop;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2FrameWriter;\n-import io.netty.handler.codec.http2.Http2PingFrame;\n-import io.netty.handler.timeout.IdleState;\n-import io.netty.handler.timeout.IdleStateEvent;\n-import io.netty.handler.timeout.IdleStateHandler;\n-\n-/**\n- * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n- * IdleStateHandler} and {@link Flags#useHttp2PingWhenIdle()} is true.\n- *\n- * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n- * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n- * {@link Flags#useHttp2PingWhenNoActiveStreams()}.\n- *\n- * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n- * is read on connection will invalidate the condition that triggers connection closure. If either of the\n- * conditions are not met then the connection will be closed.\n- *\n- * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n- * as {@link EventLoop}.\n- *\n- * @see Flags#useHttp2PingWhenIdle()\n- * @see Flags#useHttp2PingWhenNoActiveStreams()\n- * @see Flags#defaultHttp2PingTimeoutMillis()\n- */\n-@NotThreadSafe\n-public class Http2KeepAliveHandler {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n-\n-    @Nullable\n-    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n-    private final boolean sendPingsOnNoActiveStreams;\n-    private final long pingTimeoutMillis;\n-    private final Http2FrameWriter frameWriter;\n-    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n-    private final Http2Connection http2Connection;\n-    private final Channel channel;\n-    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n-    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n-\n-    @Nullable\n-    private ChannelFuture pingWriteFuture;\n-    @Nullable\n-    private Future<?> shutdownFuture;\n-    private long lastPingPayload;\n-    private State state = State.IDLE;\n-\n-    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter,\n-                                 Http2Connection http2Connection) {\n-        this(channel, frameWriter, http2Connection, Flags.defaultHttp2PingTimeoutMillis(),\n-             Flags.useHttp2PingWhenNoActiveStreams());\n-    }\n-\n-    @VisibleForTesting\n-    Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n-        checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n-        this.channel = requireNonNull(channel, \"channel\");\n-        this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n-        this.pingTimeoutMillis = pingTimeoutMillis;\n-        this.http2Connection = requireNonNull(http2Connection, \"http2Connection\");\n-        this.sendPingsOnNoActiveStreams = sendPingsOnNoActiveStreams;\n-    }\n-\n-    public void onChannelIdle(ChannelHandlerContext ctx, IdleStateEvent event) {\n-        logger.debug(\"{} {} triggered.\", channel, event);\n-\n-        if (!canSendPing()) {\n-            // The default behaviour is to shutdown the channel on idle timeout if not HTTP/2 conn.\n-            // So preserving the behaviour.\n-            closeChannelAndLog();\n-            return;\n-        }\n-\n-        // Only interested in ALL_IDLE event and when Http2KeepAliveHandler is ready.\n-        // Http2KeepAliveHandler may not be ready because it is currently handling\n-        // sending a PING or expecting a PING ACK on channel.\n-        if (state != State.IDLE || event.state() != IdleState.ALL_IDLE) {\n-            return;\n-        }\n-\n-        writePing(ctx);\n-    }\n-\n-    private boolean canSendPing() {\n-        if (http2Connection.numActiveStreams() == 0) {\n-            return sendPingsOnNoActiveStreams;\n-        } else {\n-            return true;\n-        }\n-    }\n-\n-    private void writePing(ChannelHandlerContext ctx) {\n-        lastPingPayload = random.nextLong();\n-        state = State.PING_SCHEDULED;\n-        pingWriteFuture = frameWriter.writePing(ctx, false, lastPingPayload, ctx.newPromise())\n-                                     .addListener(pingWriteListener);\n-        ctx.flush();\n-    }\n-\n-    /**\n-     * Callback for when channel is in-active to cleans up resources.\n-     */\n-    public void onChannelInactive() {\n-        state = State.SHUTDOWN;\n-        cancelFutures();\n-    }\n-\n-    public void onChannelRead() {\n-        state = State.IDLE;\n-        cancelFutures();\n-    }\n-\n-    private void resetFutures() {\n-        shutdownFuture = null;\n-        pingWriteFuture = null;\n-    }\n-\n-    private void cancelFutures() {\n-        if (shutdownFuture != null) {\n-            shutdownFuture.cancel(false);\n-            shutdownFuture = null;\n-        }\n-        if (pingWriteFuture != null) {\n-            pingWriteFuture.cancel(false);\n-            pingWriteFuture = null;\n-        }\n-    }\n-\n-    public void onPingAck(long data) {\n-        final long elapsed = getStopwatchElapsedInNanos();\n-        if (!isGoodPingAck(data)) {\n-            return;\n-        }\n-\n-        if (shutdownFuture != null) {\n-            final boolean isCancelled = shutdownFuture.cancel(false);\n-            if (!isCancelled) {\n-                logger.debug(\"{} shutdownFuture cannot be cancelled because of late PING ACK\", channel);\n-            }\n-        }\n-        logger.debug(\"{} Received PING(ACK=1) in {} ns\", channel, elapsed);\n-        state = State.IDLE;\n-        resetFutures();\n-    }\n-\n-    private boolean isGoodPingAck(long data) {\n-        // This condition can be true when channel read some data other than PING ACK frame\n-        // or a PING ACK is received without sending PING in first place.\n-        if (state != State.PENDING_PING_ACK) {\n-            logger.debug(\"{} Ignoring PING(ACK=1, DATA={}) received\", channel, data);\n-            return false;\n-        }\n-        if (lastPingPayload != data) {\n-            logger.debug(\"{} Unexpected PING(ACK=1, DATA={}) received, \" +\n-                         \"but expecting PING(ACK=1, DATA={})\", channel, data, lastPingPayload);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    @VisibleForTesting\n-    State state() {\n-        return state;\n-    }\n-\n-    @VisibleForTesting\n-    long lastPingPayload() {\n-        return lastPingPayload;\n-    }\n-\n-    private void closeChannelAndLog() {\n-        if (state == State.SHUTDOWN) {\n-            return;\n-        }\n-        logger.debug(\"{} Closing an idle channel\", channel);\n-        channel.close().addListener(future -> {\n-            if (future.isSuccess()) {\n-                logger.debug(\"{} Closed an idle channel\", channel);\n-            } else {\n-                logger.debug(\"{} Failed to close an idle channel\", channel, future.cause());\n-            }\n-            state = State.SHUTDOWN;\n-        });\n-    }\n-\n-    private long getStopwatchElapsedInNanos() {\n-        if (stopwatch == null) {\n-            return -1;\n-        }\n-        return stopwatch.elapsed(TimeUnit.NANOSECONDS);\n-    }\n-\n-    /**\n-     * State changes from IDLE -> PING_SCHEDULED -> PENDING_PING_ACK -> IDLE and so on. When the\n-     * channel is inactive then the state changes to SHUTDOWN.\n-     */\n-    enum State {\n-        /* Nothing happening, but waiting for IdleStateEvent */\n-        IDLE,\n-\n-        /* PING is scheduled */\n-        PING_SCHEDULED,\n-\n-        /* PING is sent and is pending ACK */\n-        PENDING_PING_ACK,\n-\n-        /* Not active anymore */\n-        SHUTDOWN\n-    }\n-\n-    private class PingWriteListener implements ChannelFutureListener {\n-\n-        @Override\n-        public void operationComplete(ChannelFuture future) throws Exception {\n-            if (future.isSuccess()) {\n-                final EventLoop el = channel.eventLoop();\n-                shutdownFuture = el.schedule(shutdownRunnable, pingTimeoutMillis, TimeUnit.MILLISECONDS);\n-                state = State.PENDING_PING_ACK;\n-                resetStopwatch();\n-            } else {\n-                // Mostly because the channel is already closed. So ignore and change state to IDLE.\n-                // If the channel is closed, we change state to SHUTDOWN on onChannelInactive.\n-                if (!future.isCancelled() && Exceptions.isExpected(future.cause())) {\n-                    logger.debug(\"{} Channel PING write failed\", channel, future.cause());\n-                }\n-                if (state != State.SHUTDOWN) {\n-                    state = State.IDLE;\n-                }\n-            }\n-        }\n-\n-        private void resetStopwatch() {\n-            if (stopwatch != null) {\n-                stopwatch.reset().start();\n-            }\n-        }\n-    }\n-}\n"}}, {"oid": "c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "url": "https://github.com/line/armeria/commit/c60d91c6d88ae34a99ca14cbc5a176fb311535b3", "message": "adding Http2KeepAlivePinger but mostly incomplete.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "d16c8be67f4d60be9f89eb831904afeb789bb586", "url": "https://github.com/line/armeria/commit/d16c8be67f4d60be9f89eb831904afeb789bb586", "message": "adding some changes but not working yet", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "18c25d1494c37ad049cf2b85d2018f34117e3fd5", "url": "https://github.com/line/armeria/commit/18c25d1494c37ad049cf2b85d2018f34117e3fd5", "message": "Finishing up Http2KeepAlivePinger. Some cosmetic changes are pending.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "9cb48b05732ce3f162ae6b7be85a7f9053693975", "url": "https://github.com/line/armeria/commit/9cb48b05732ce3f162ae6b7be85a7f9053693975", "message": "fixing up a small error.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b9d2fd7b5685ff201aae33effccf5f7727088cd2", "url": "https://github.com/line/armeria/commit/b9d2fd7b5685ff201aae33effccf5f7727088cd2", "message": "Finishing up Http2KeepAliveHandler", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "44179dfba4e9d0c4c5a419159d14b5ccf8665545", "url": "https://github.com/line/armeria/commit/44179dfba4e9d0c4c5a419159d14b5ccf8665545", "message": "changing state=State.PING_SCHEDULED after flushing.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "cf2b40f35014451a28ae5218659f49b4bd58ce07", "url": "https://github.com/line/armeria/commit/cf2b40f35014451a28ae5218659f49b4bd58ce07", "message": "plugging in Http2KeepAliveHandler into decoders", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "3f5ab2deb3acc13ee912553fff22eab9bdf1e28c", "url": "https://github.com/line/armeria/commit/3f5ab2deb3acc13ee912553fff22eab9bdf1e28c", "message": "Update license version", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "f9196d504c7a43a9f3c0f1ecea29629910a5febd", "url": "https://github.com/line/armeria/commit/f9196d504c7a43a9f3c0f1ecea29629910a5febd", "message": "making some suggestions requested.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "d0c9250dde23800a5e789ed3eebf135cc0a5b274", "url": "https://github.com/line/armeria/commit/d0c9250dde23800a5e789ed3eebf135cc0a5b274", "message": "removing some comments which are obvious", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "7888ab01c737b979df318e009007afcbb4e1a8cb", "url": "https://github.com/line/armeria/commit/7888ab01c737b979df318e009007afcbb4e1a8cb", "message": "implementing changes. Still changes pending with client", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "802543c30e09a8a0df6e07a37352f0da2e4a2620", "url": "https://github.com/line/armeria/commit/802543c30e09a8a0df6e07a37352f0da2e4a2620", "message": "handling client keep-alive.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "75fb9b17c5f467b45cd859becf9dc97281437671", "url": "https://github.com/line/armeria/commit/75fb9b17c5f467b45cd859becf9dc97281437671", "message": "Documentation update.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "fdabf751c3e6113a04b90155696cca9205441f9c", "url": "https://github.com/line/armeria/commit/fdabf751c3e6113a04b90155696cca9205441f9c", "message": "adding the property in Flags.java", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "42f289310280791d97c482d854bc0af10ff08894", "url": "https://github.com/line/armeria/commit/42f289310280791d97c482d854bc0af10ff08894", "message": "fixing checkstyle errors.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b520d249757f3b16a1022b8046e9792d6145263f", "url": "https://github.com/line/armeria/commit/b520d249757f3b16a1022b8046e9792d6145263f", "message": "Setting IdleTimeoutHandler.isHttp2 to true when AbstractHttp2ConnectionHandler.handlerAdded.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "ca0ef211ea0795cfc18a0e057b27cadc023376d7", "url": "https://github.com/line/armeria/commit/ca0ef211ea0795cfc18a0e057b27cadc023376d7", "message": "finishing up some edge cases after testing", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "5d5431a38e777a0f379ae5c169efe03e04b788a0", "url": "https://github.com/line/armeria/commit/5d5431a38e777a0f379ae5c169efe03e04b788a0", "message": "using milli seconds for ping timeout and making other changes as suggested.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "9bf5895c9a30e151a9e0a176354d3705199d82e4", "url": "https://github.com/line/armeria/commit/9bf5895c9a30e151a9e0a176354d3705199d82e4", "message": "Adding test and moving IdleTimeoutHandler.setHttp2 to Http2ServerConnectionHandler instead of AbstractHttp2ConnectionHandler", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "7d7989d5193caba716df143d5aec10e8011bc8ea", "url": "https://github.com/line/armeria/commit/7d7989d5193caba716df143d5aec10e8011bc8ea", "message": "Adding more docs.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "1fe68c24af2a47d98173c8c94a919715409d0781", "url": "https://github.com/line/armeria/commit/1fe68c24af2a47d98173c8c94a919715409d0781", "message": "capitalizing http verbs", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "3a3d39616deecb4346da3852338fe4024feeea7a", "url": "https://github.com/line/armeria/commit/3a3d39616deecb4346da3852338fe4024feeea7a", "message": "Making suggested changes from @trustin", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "bdc2da4934a053b0c28abe123503818f6fe6d723", "url": "https://github.com/line/armeria/commit/bdc2da4934a053b0c28abe123503818f6fe6d723", "message": "making small typo change", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "16fa1859d9b91ec64ee0d2cbb1afd0aa99db25e0", "url": "https://github.com/line/armeria/commit/16fa1859d9b91ec64ee0d2cbb1afd0aa99db25e0", "message": "fixing imports", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "0eccd07eddec3a702fd9137930dc080ca8eb8506", "url": "https://github.com/line/armeria/commit/0eccd07eddec3a702fd9137930dc080ca8eb8506", "message": "adding necessary changes to handle pings on http2 connection. Tests pending.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "8116abef15a5468bebd3ff644c66554642ff9514", "url": "https://github.com/line/armeria/commit/8116abef15a5468bebd3ff644c66554642ff9514", "message": "mostly finalizing everything. Tests are still pending.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "cb29ae04c75de0c26da549444b87c45cfaaf90f0", "url": "https://github.com/line/armeria/commit/cb29ae04c75de0c26da549444b87c45cfaaf90f0", "message": "fixing an import", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "69fae8ef00901b0d6ed43927783e2d58cac90023", "url": "https://github.com/line/armeria/commit/69fae8ef00901b0d6ed43927783e2d58cac90023", "message": "moving log to start of method.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "5705d3cf8eac0fe42e449ccb4c1f0c4cc42edf7a", "url": "https://github.com/line/armeria/commit/5705d3cf8eac0fe42e449ccb4c1f0c4cc42edf7a", "message": "adding all tests and making final changes.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "236a6b42506844d3ea2b0481d8c3544fa6f0a48f", "url": "https://github.com/line/armeria/commit/236a6b42506844d3ea2b0481d8c3544fa6f0a48f", "message": "fixing names.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "819af8eff49477f010f00c22a9a4db8b72b2a8cb", "url": "https://github.com/line/armeria/commit/819af8eff49477f010f00c22a9a4db8b72b2a8cb", "message": "Update core/src/main/java/com/linecorp/armeria/client/HttpClientPipelineConfigurator.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "83efb5f316dd189691ffc78e32c8f348a4b56de6", "url": "https://github.com/line/armeria/commit/83efb5f316dd189691ffc78e32c8f348a4b56de6", "message": "addressing some suggested changes. More on the way", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "97d447f1b7b999fe78404150687e60b3253e5573", "url": "https://github.com/line/armeria/commit/97d447f1b7b999fe78404150687e60b3253e5573", "message": "renaming to defaultUseHttp2PingOnNoActiveStreams", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "0d14d3bc4bbf15252f3c5509a747ae09d3a8b467", "url": "https://github.com/line/armeria/commit/0d14d3bc4bbf15252f3c5509a747ae09d3a8b467", "message": "not using default for Flags.java", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "4074180bd06684b41affb8dda7859398fc579161", "url": "https://github.com/line/armeria/commit/4074180bd06684b41affb8dda7859398fc579161", "message": "formatting code, but no functional changes", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b42c13801aa6beba0e7eb7b141d98fb05a0079fc", "url": "https://github.com/line/armeria/commit/b42c13801aa6beba0e7eb7b141d98fb05a0079fc", "message": "implementing onChannelRead changes to reset ping and also fixing a flag name issue", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "2e566b19eeb4501ea55373c8aa953077e3af0baf", "url": "https://github.com/line/armeria/commit/2e566b19eeb4501ea55373c8aa953077e3af0baf", "message": "addressing some missed suggestions", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "a65dda197149b6318115be7b13b7bd90234b63a0", "url": "https://github.com/line/armeria/commit/a65dda197149b6318115be7b13b7bd90234b63a0", "message": "Improving the docs", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "b4fcb85da16809e3a5cc2e7a550870d0aea43730", "url": "https://github.com/line/armeria/commit/b4fcb85da16809e3a5cc2e7a550870d0aea43730", "message": "implementing some suggestions.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "6f2056b7327131670deea5067b2a8300e81b52aa", "url": "https://github.com/line/armeria/commit/6f2056b7327131670deea5067b2a8300e81b52aa", "message": "making suggested java doc changes for flags etc.", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "5b73c619ce4d253023cc86248c9cf4f8fa32c987", "url": "https://github.com/line/armeria/commit/5b73c619ce4d253023cc86248c9cf4f8fa32c987", "message": "implementing suggestions from @ikhoon", "committedDate": "2020-03-05T22:38:08Z", "type": "commit"}, {"oid": "68364342e20f5b8665084dd1609d4f6a340640e2", "url": "https://github.com/line/armeria/commit/68364342e20f5b8665084dd1609d4f6a340640e2", "message": "adding http2 ping related configs on ServerConfig and ClientFactoryBuilder", "committedDate": "2020-03-05T22:40:38Z", "type": "commit"}, {"oid": "68364342e20f5b8665084dd1609d4f6a340640e2", "url": "https://github.com/line/armeria/commit/68364342e20f5b8665084dd1609d4f6a340640e2", "message": "adding http2 ping related configs on ServerConfig and ClientFactoryBuilder", "committedDate": "2020-03-05T22:40:38Z", "type": "forcePushed"}, {"oid": "dbf57b76e2e74b7c9c4a03544199a4a17f5dcdab", "url": "https://github.com/line/armeria/commit/dbf57b76e2e74b7c9c4a03544199a4a17f5dcdab", "message": "removing extra line", "committedDate": "2020-03-05T22:46:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMTY5Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r388701693", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-03-06T03:54:47Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+\n+import com.linecorp.armeria.common.Flags;\n+import com.linecorp.armeria.common.util.Exceptions;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2FrameWriter;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleState;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+\n+/**\n+ * This will send an {@link Http2PingFrame} when an {@link IdleStateEvent} is emitted by {@link\n+ * IdleStateHandler} and {@link Flags#defaultHttp2PingTimeoutMillis()} is greater that zero.\n+ *\n+ * <p>Once an {@link IdleStateEvent} is triggered and when there are active streams open then a\n+ * {@link Http2PingFrame} will be written on connection. When there are no active streams then it depends on\n+ * {@link Flags#useHttp2PingWhenNoActiveStreams()}.\n+ *\n+ * <p>Once a {@link Http2PingFrame} is written, then either an ACK for the {@link Http2PingFrame} or any data\n+ * is read on connection will invalidate the condition that triggers connection closure. If either of the\n+ * conditions are not met then the connection will be closed.\n+ *\n+ * <p>This class is <b>not</b> thread-safe and all methods are to be called from single thread such\n+ * as {@link EventLoop}.\n+ *\n+ * @see Flags#useHttp2PingWhenNoActiveStreams()\n+ * @see Flags#defaultHttp2PingTimeoutMillis()\n+ */\n+@NotThreadSafe\n+public class Http2KeepAliveHandler {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(Http2KeepAliveHandler.class);\n+\n+    @Nullable\n+    private final Stopwatch stopwatch = logger.isDebugEnabled() ? Stopwatch.createUnstarted() : null;\n+    private final boolean sendPingsOnNoActiveStreams;\n+    private final long pingTimeoutMillis;\n+    private final Http2FrameWriter frameWriter;\n+    private final ThreadLocalRandom random = ThreadLocalRandom.current();\n+    private final Http2Connection http2Connection;\n+    private final Channel channel;\n+    private final ChannelFutureListener pingWriteListener = new PingWriteListener();\n+    private final Runnable shutdownRunnable = this::closeChannelAndLog;\n+\n+    @Nullable\n+    private ChannelFuture pingWriteFuture;\n+    @Nullable\n+    private Future<?> shutdownFuture;\n+    private long lastPingPayload;\n+    private State state = State.IDLE;\n+\n+    public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n+                          long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {", "originalCommit": "dbf57b76e2e74b7c9c4a03544199a4a17f5dcdab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMjY5Mw==", "url": "https://github.com/line/armeria/pull/2409#discussion_r388702693", "bodyText": "Fixed :)", "author": "sivaalli", "createdAt": "2020-03-06T03:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwMTY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "141ca3959a59e1897767066f6a63eacddd25bc7a", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\nindex 73931499da..ec7210e2c0 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2KeepAliveHandler.java\n\n@@ -89,7 +89,7 @@ public class Http2KeepAliveHandler {\n     private State state = State.IDLE;\n \n     public Http2KeepAliveHandler(Channel channel, Http2FrameWriter frameWriter, Http2Connection http2Connection,\n-                          long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n+                                 long pingTimeoutMillis, boolean sendPingsOnNoActiveStreams) {\n         checkArgument(pingTimeoutMillis > 0, pingTimeoutMillis);\n         this.channel = requireNonNull(channel, \"channel\");\n         this.frameWriter = requireNonNull(frameWriter, \"frameWriter\");\n"}}, {"oid": "141ca3959a59e1897767066f6a63eacddd25bc7a", "url": "https://github.com/line/armeria/commit/141ca3959a59e1897767066f6a63eacddd25bc7a", "message": "fixed indentation", "committedDate": "2020-03-06T03:59:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2ODQwMA==", "url": "https://github.com/line/armeria/pull/2409#discussion_r388768400", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    requireNonNull(http2PingTimeout);\n          \n          \n            \n                    requireNonNull(http2PingTimeout, \"http2PingTimeout\");", "author": "ikhoon", "createdAt": "2020-03-06T08:27:15Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -412,6 +412,40 @@ public ClientFactoryBuilder idleTimeoutMillis(long idleTimeoutMillis) {\n         return this;\n     }\n \n+    /**\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     *\n+     * @param http2PingTimeoutMillis the timeout in milliseconds. {@code 0} disables the timeout.\n+     */\n+    public ClientFactoryBuilder http2PingTimeoutMillis(long http2PingTimeoutMillis) {\n+        checkArgument(http2PingTimeoutMillis >= 0,\n+                      \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeoutMillis);\n+        option(ClientFactoryOption.HTTP2_PING_TIMEOUT_MILLIS, http2PingTimeoutMillis);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP/2 <a href=\"https://httpwg.org/specs/rfc7540.html#PING\">PING</a> timeout.\n+     *\n+     * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n+     */\n+    public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n+        requireNonNull(http2PingTimeout);", "originalCommit": "141ca3959a59e1897767066f6a63eacddd25bc7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5b786c697f2e28a048cb3fdddee1d5b55fad8fd6", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex 26102559d3..b0a6c9ec86 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -430,7 +430,7 @@ public final class ClientFactoryBuilder {\n      * @param http2PingTimeout the timeout. {@code 0} disables the timeout.\n      */\n     public ClientFactoryBuilder http2PingTimeout(Duration http2PingTimeout) {\n-        requireNonNull(http2PingTimeout);\n+        requireNonNull(http2PingTimeout, \"http2PingTimeout\");\n         checkArgument(http2PingTimeout.toMillis() >= 0,\n                       \"http2PingTimeoutMillis: %s (expected: >= 0)\", http2PingTimeout.toMillis());\n         http2PingTimeoutMillis(http2PingTimeout.toMillis());\n"}}, {"oid": "5b786c697f2e28a048cb3fdddee1d5b55fad8fd6", "url": "https://github.com/line/armeria/commit/5b786c697f2e28a048cb3fdddee1d5b55fad8fd6", "message": "committing @ikhoon 's changes", "committedDate": "2020-03-06T13:25:50Z", "type": "commit"}]}