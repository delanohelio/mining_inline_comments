{"pr_number": 3112, "pr_title": "Support prefix option for Logback integration", "pr_createdAt": "2020-10-15T03:16:51Z", "pr_url": "https://github.com/line/armeria/pull/3112", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyNzM4Ng==", "url": "https://github.com/line/armeria/pull/3112#discussion_r506127386", "bodyText": "How about just prefix? IIUC, the following example:\n              RequestContextExporter\n                      .builder()\n                      .setDefaultExportPrefix(\"foo\")\n                      .addExportGroup(\n                              ExportGroup\n                                      .builder()\n                                      .keyPattern(\"client.*\")\n                                      .build()\n                      )\n.. does not make client.* have foo prefix, so it'll be confusing to say foo is the default prefix.\nset could be omitted.", "author": "trustin", "createdAt": "2020-10-16T07:36:01Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -134,16 +122,17 @@ public RequestContextExporterBuilder responseHeader(CharSequence headerName) {\n     public RequestContextExporterBuilder responseHeader(CharSequence headerName, String alias) {\n         requireNonNull(headerName, \"headerName\");\n         requireNonNull(alias, \"alias\");\n-        return addResponseHeader(toHeaderName(headerName), alias);\n-    }\n-\n-    private RequestContextExporterBuilder addResponseHeader(AsciiString headerKey, String alias) {\n-        resHeaders.add(new ExportEntry<>(headerKey, alias));\n+        defaultExportGroupBuilder.responseHeader(headerName, alias);\n         return this;\n     }\n \n-    private static AsciiString toHeaderName(CharSequence name) {\n-        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public void setDefaultExportPrefix(String defaultExportPrefix) {", "originalCommit": "33afe47fa7486ce6bd683a24861655b81935f4a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4NDQxNw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r506184417", "bodyText": "Yeah, .setDefaultExportPrefix(String) should be renamed to .prefix(String).", "author": "okue", "createdAt": "2020-10-16T08:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyNzM4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex 534a05707..d5dd8b477 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -129,10 +133,10 @@ public final class RequestContextExporterBuilder {\n     /**\n      * Specifies a prefix of the default export group.\n      */\n-    public void setDefaultExportPrefix(String defaultExportPrefix) {\n-        requireNonNull(defaultExportPrefix, \"defaultExportPrefix\");\n-        checkArgument(!defaultExportPrefix.isEmpty(), \"defaultExportPrefix must not be empty\");\n-        defaultExportGroupBuilder.setPrefix(defaultExportPrefix);\n+    public void prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        defaultExportGroupBuilder.prefix(prefix);\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzMDE5NQ==", "url": "https://github.com/line/armeria/pull/3112#discussion_r506130195", "bodyText": "I think we need to separate the core API from Logback integration. Could we ensure this builder API doesn't expose the default constructor and doesn't have the set prefix? Instead, we could define some additional public class that provides a bridge between this class and Logback configuration, e.g.\nprivate ExportGroupBuilder builder = ExportGroup.builder();\npublic void setPrefix(String prefix) {\n  builder.prefix(prefix);\n}", "author": "trustin", "createdAt": "2020-10-16T07:40:53Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    /**\n+     * Returns a new {@link ExportGroupBuilder}.\n+     */\n+    public ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();\n+    }", "originalCommit": "33afe47fa7486ce6bd683a24861655b81935f4a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex 9cfea5a75..ae3445b46 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -18,14 +18,13 @@ package com.linecorp.armeria.common.logging;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.HashSet;\n import java.util.Set;\n import java.util.function.Function;\n-import java.util.stream.Collectors;\n \n import javax.annotation.Nullable;\n \n import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM3OTY0Mw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r507379643", "bodyText": "We can make those collections immutable.\nFor example:\nbuiltIns = ImmutableSet.builder();\nbuiltIns.add(...)\nnew ExportGroup(builtIns.build(), ...)", "author": "ikhoon", "createdAt": "2020-10-19T02:41:02Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns, attrs, reqHeaders, resHeaders);", "originalCommit": "aabb9c9b39aedc13eb5cd0110d08919e095a1941", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex 794fc9449..ae3445b46 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -18,14 +18,13 @@ package com.linecorp.armeria.common.logging;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.HashSet;\n import java.util.Set;\n import java.util.function.Function;\n-import java.util.stream.Collectors;\n \n import javax.annotation.Nullable;\n \n import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM4MTEyNg==", "url": "https://github.com/line/armeria/pull/3112#discussion_r507381126", "bodyText": "We can optimize this a bit by initializing this lazily. I think some features are not used when a user does not customize heavily. In that case, we can use ImmutableSet.of().", "author": "ikhoon", "createdAt": "2020-10-19T02:43:37Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();", "originalCommit": "aabb9c9b39aedc13eb5cd0110d08919e095a1941", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex 794fc9449..ae3445b46 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -18,14 +18,13 @@ package com.linecorp.armeria.common.logging;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.HashSet;\n import java.util.Set;\n import java.util.function.Function;\n-import java.util.stream.Collectors;\n \n import javax.annotation.Nullable;\n \n import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM4NzA4NQ==", "url": "https://github.com/line/armeria/pull/3112#discussion_r507387085", "bodyText": "Use ImmutableSet.toImmutableSet()?", "author": "ikhoon", "createdAt": "2020-10-19T02:55:15Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = new HashSet<>();\n+        attrs = new HashSet<>();\n+        reqHeaders = new HashSet<>();\n+        resHeaders = new HashSet<>();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns, attrs, reqHeaders, resHeaders);\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns, prefix),\n+                    ExportEntry.withPrefix(attrs, prefix),\n+                    ExportEntry.withPrefix(reqHeaders, prefix),\n+                    ExportEntry.withPrefix(resHeaders, prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)\n+                    .forEach(keyPattern -> {\n+                        checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n+                        keyPattern(keyPattern);\n+                    });\n+        return this;\n+    }\n+\n+    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n+        final String[] components = keyPattern.split(\":\");\n+        if (components.length < 2 || components.length > 3) {\n+            if (exportKey == null) {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            }\n+        }\n+\n+        if (exportKey == null) {\n+            exportKey = components[0];\n+        }\n+        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n+        if (components.length == 3) {\n+            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n+        } else {\n+            return new ExportEntry<>(attributeKey, exportKey);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Function<?, String> newStringifier(String keyPattern, String className) {\n+        final Function<?, String> stringifier;\n+        try {\n+            stringifier = (Function<?, String>)\n+                    Class.forName(className, true, getClass().getClassLoader())\n+                         .getDeclaredConstructor()\n+                         .newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n+                                               keyPattern, e);\n+        }\n+        return stringifier;\n+    }\n+\n+    static final class ExportEntry<T> {\n+        final T key;\n+        final String exportKey;\n+        @Nullable\n+        final Function<Object, String> stringifier;\n+\n+        ExportEntry(T key, String exportKey) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            stringifier = null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ExportEntry(T key, String exportKey, Function<?, ?> stringifier) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            requireNonNull(stringifier);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            this.stringifier = (Function<Object, String>) stringifier;\n+        }\n+\n+        @Nullable\n+        String stringify(@Nullable Object value) {\n+            if (stringifier == null) {\n+                return value != null ? value.toString() : null;\n+            } else {\n+                return stringifier.apply(value);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() * 31 + exportKey.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof ExportEntry)) {\n+                return false;\n+            }\n+\n+            return key.equals(((ExportEntry<?>) o).key) &&\n+                   exportKey.equals(((ExportEntry<?>) o).exportKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return exportKey + ':' + key;\n+        }\n+\n+        public ExportEntry<T> withPrefix(String exportPrefix) {\n+            checkArgument(!exportPrefix.isEmpty(), \"exportPrefix must not be empty\");\n+\n+            if (stringifier == null) {\n+                return new ExportEntry<>(key, exportPrefix + exportKey);\n+            } else {\n+                return new ExportEntry<>(key, exportPrefix + exportKey, stringifier);\n+            }\n+        }\n+\n+        public static <T> Set<ExportEntry<T>> withPrefix(Set<ExportEntry<T>> entries, String exportPrefix) {\n+            checkArgument(!exportPrefix.isEmpty(), \"exportPrefix must not be empty\");\n+\n+            return entries.stream().map(entry -> entry.withPrefix(exportPrefix)).collect(Collectors.toSet());", "originalCommit": "aabb9c9b39aedc13eb5cd0110d08919e095a1941", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex 794fc9449..ae3445b46 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -18,14 +18,13 @@ package com.linecorp.armeria.common.logging;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.HashSet;\n import java.util.Set;\n import java.util.function.Function;\n-import java.util.stream.Collectors;\n \n import javax.annotation.Nullable;\n \n import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM5MDY4Mw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r507390683", "bodyText": "I think <exportGroup> is an optional feature. Don't we need to initialize this by default.\nHow about make it @Nullable and initailzed it when it is actually used.", "author": "ikhoon", "createdAt": "2020-10-19T03:01:28Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -15,34 +15,23 @@\n  */\n package com.linecorp.armeria.common.logging;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.logging.RequestContextExporter.ExportEntry;\n-\n-import io.netty.util.AsciiString;\n import io.netty.util.AttributeKey;\n \n /**\n  * Builds a new {@link RequestContextExporter}.\n  */\n public final class RequestContextExporterBuilder {\n \n-    static final String PREFIX_ATTRS = \"attrs.\";\n-    private static final String ATTR_NAMESPACE = \"attr:\";\n-    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n-    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n-\n-    private final Set<ExportEntry<BuiltInProperty>> builtIns = new HashSet<>();\n-    private final Set<ExportEntry<AttributeKey<?>>> attrs = new HashSet<>();\n-    private final Set<ExportEntry<AsciiString>> reqHeaders = new HashSet<>();\n-    private final Set<ExportEntry<AsciiString>> resHeaders = new HashSet<>();\n+    private final ExportGroupBuilder defaultExportGroupBuilder = ExportGroup.builder();\n+    private final List<ExportGroup> exportGroups = new ArrayList<>();", "originalCommit": "aabb9c9b39aedc13eb5cd0110d08919e095a1941", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex ef1dec9a0..d5dd8b477 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -21,7 +21,10 @@ import static java.util.Objects.requireNonNull;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.function.Function;\n-import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.collect.ImmutableSet;\n \n import io.netty.util.AttributeKey;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM5MTAwOA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r507391008", "bodyText": "Ditto. Use toImmutableSet()?", "author": "ikhoon", "createdAt": "2020-10-19T03:01:55Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +142,39 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public RequestContextExporterBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n+        checkArgument(!keyPatterns.isEmpty(), \"keyPatterns must not be empty\");\n+        defaultExportGroupBuilder.keyPatterns(keyPatterns);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n-        }\n-        return stringifier;\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder addExportGroup(ExportGroup exportGroup) {\n+        exportGroups.add(exportGroup);\n+        return this;\n     }\n \n     /**\n      * Returns a newly-created {@link RequestContextExporter} instance.\n      */\n     public RequestContextExporter build() {\n-        return new RequestContextExporter(builtIns, attrs, reqHeaders, resHeaders);\n+        exportGroups.add(defaultExportGroupBuilder.build());\n+        return new RequestContextExporter(\n+                exportGroups.stream().flatMap(it -> it.getBuiltIns().stream()).collect(Collectors.toSet()),", "originalCommit": "aabb9c9b39aedc13eb5cd0110d08919e095a1941", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex ef1dec9a0..d5dd8b477 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -161,6 +165,9 @@ public final class RequestContextExporterBuilder {\n      * Adds the export group.\n      */\n     public RequestContextExporterBuilder addExportGroup(ExportGroup exportGroup) {\n+        if (exportGroups == null) {\n+            exportGroups = new ArrayList<>();\n+        }\n         exportGroups.add(exportGroup);\n         return this;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzM5MTIwNg==", "url": "https://github.com/line/armeria/pull/3112#discussion_r507391206", "bodyText": "Add final?", "author": "ikhoon", "createdAt": "2020-10-19T03:02:17Z", "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfiguration)\n+ */\n+public class ExportGroupConfiguration {", "originalCommit": "aabb9c9b39aedc13eb5cd0110d08919e095a1941", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b571b262014ce8093511b282b464b2ba3811922", "chunk": "diff --git a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java\nindex c49a04680..ac5d312da 100644\n--- a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java\n+++ b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java\n\n@@ -26,7 +26,7 @@ import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n  *\n  * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfiguration)\n  */\n-public class ExportGroupConfiguration {\n+public final class ExportGroupConfiguration {\n \n     private final ExportGroupBuilder builder = ExportGroup.builder();\n \n"}}, {"oid": "7b571b262014ce8093511b282b464b2ba3811922", "url": "https://github.com/line/armeria/commit/7b571b262014ce8093511b282b464b2ba3811922", "message": "address comments by @ikhoon", "committedDate": "2020-10-19T03:46:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMDM5MA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r509030390", "bodyText": "Could we remove the get prefixes from the methods in this class for consistency?", "author": "trustin", "createdAt": "2020-10-21T06:53:25Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Holds a set of {@link ExportEntry}s.\n+ *\n+ * @see RequestContextExporterBuilder\n+ */\n+public final class ExportGroup {\n+\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroup(Set<ExportEntry<BuiltInProperty>> builtIns,\n+                Set<ExportEntry<AttributeKey<?>>> attrs,\n+                Set<ExportEntry<AsciiString>> reqHeaders,\n+                Set<ExportEntry<AsciiString>> resHeaders) {\n+        requireNonNull(builtIns, \"builtIns\");\n+        requireNonNull(attrs, \"attrs\");\n+        requireNonNull(reqHeaders, \"reqHeaders\");\n+        requireNonNull(resHeaders, \"resHeaders\");\n+        this.builtIns = builtIns;\n+        this.attrs = attrs;\n+        this.reqHeaders = reqHeaders;\n+        this.resHeaders = resHeaders;\n+    }\n+\n+    /**\n+     * Returns a new {@link ExportGroupBuilder}.\n+     */\n+    public static ExportGroupBuilder builder() {\n+        return new ExportGroupBuilder();\n+    }\n+\n+    /**\n+     * Returns a set of {@link ExportEntry} of {@link BuiltInProperty}.\n+     */\n+    public Set<ExportEntry<BuiltInProperty>> getBuiltIns() {", "originalCommit": "7b571b262014ce8093511b282b464b2ba3811922", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\nindex 4c9ef0b15..b7b91c7d5 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\n\n@@ -60,28 +60,28 @@ public final class ExportGroup {\n     /**\n      * Returns a set of {@link ExportEntry} of {@link BuiltInProperty}.\n      */\n-    public Set<ExportEntry<BuiltInProperty>> getBuiltIns() {\n+    public Set<ExportEntry<BuiltInProperty>> builtIns() {\n         return builtIns;\n     }\n \n     /**\n      * Returns a set of {@link ExportEntry} of {@link AttributeKey}.\n      */\n-    public Set<ExportEntry<AttributeKey<?>>> getAttrs() {\n+    public Set<ExportEntry<AttributeKey<?>>> attrs() {\n         return attrs;\n     }\n \n     /**\n      * Returns a set of {@link ExportEntry} of request headers.\n      */\n-    public Set<ExportEntry<AsciiString>> getReqHeaders() {\n+    public Set<ExportEntry<AsciiString>> reqHeaders() {\n         return reqHeaders;\n     }\n \n     /**\n      * Returns a set of {@link ExportEntry} of response headers.\n      */\n-    public Set<ExportEntry<AsciiString>> getResHeaders() {\n+    public Set<ExportEntry<AsciiString>> resHeaders() {\n         return resHeaders;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMTE5Ng==", "url": "https://github.com/line/armeria/pull/3112#discussion_r509031196", "bodyText": "nit: how about just ExportGroupConfig?", "author": "trustin", "createdAt": "2020-10-21T06:55:04Z", "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfiguration)\n+ */\n+public final class ExportGroupConfiguration {", "originalCommit": "7b571b262014ce8093511b282b464b2ba3811922", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48231cd70b1f753096be26634a38cdf04dc24920", "chunk": "diff --git a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java\ndeleted file mode 100644\nindex ac5d312da..000000000\n--- a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfiguration.java\n+++ /dev/null\n\n@@ -1,69 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.common.logback;\n-\n-import static com.google.common.base.Preconditions.checkArgument;\n-import static java.util.Objects.requireNonNull;\n-\n-import com.linecorp.armeria.common.logging.ExportGroup;\n-import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n-\n-/**\n- * Bridge class for Logback configuration.\n- *\n- * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfiguration)\n- */\n-public final class ExportGroupConfiguration {\n-\n-    private final ExportGroupBuilder builder = ExportGroup.builder();\n-\n-    /**\n-     * Specifies a prefix of the default export group.\n-     * Note: this method is meant to be used for XML configuration.\n-     */\n-    public void setPrefix(String prefix) {\n-        requireNonNull(prefix, \"prefix\");\n-        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n-        builder.prefix(prefix);\n-    }\n-\n-    /**\n-     * Adds the property represented by the specified MDC key to the export list.\n-     * Note: this method is meant to be used for XML configuration.\n-     */\n-    public void setExport(String mdcKey) {\n-        requireNonNull(mdcKey, \"mdcKey\");\n-        checkArgument(!mdcKey.isEmpty(), \"mdcKey must not be empty\");\n-        builder.keyPattern(mdcKey);\n-    }\n-\n-    /**\n-     * Adds the properties represented by the specified comma-separated MDC keys to the export list.\n-     * Note: this method is meant to be used for XML configuration.\n-     */\n-    public void setExports(String mdcKeys) {\n-        requireNonNull(mdcKeys, \"mdcKeys\");\n-        checkArgument(!mdcKeys.isEmpty(), \"mdcKeys must not be empty\");\n-        builder.keyPatterns(mdcKeys);\n-    }\n-\n-    /**\n-     * Returns {@link ExportGroup}.\n-     */\n-    ExportGroup exportGroup() {\n-        return builder.build();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzMTM3Nw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r509031377", "bodyText": "How about just exportGroup()?", "author": "trustin", "createdAt": "2020-10-21T06:55:25Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +146,52 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public RequestContextExporterBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n+        checkArgument(!keyPatterns.isEmpty(), \"keyPatterns must not be empty\");\n+        defaultExportGroupBuilder.keyPatterns(keyPatterns);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder addExportGroup(ExportGroup exportGroup) {", "originalCommit": "7b571b262014ce8093511b282b464b2ba3811922", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48231cd70b1f753096be26634a38cdf04dc24920", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex d5dd8b477..534a05707 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -165,9 +161,6 @@ public final class RequestContextExporterBuilder {\n      * Adds the export group.\n      */\n     public RequestContextExporterBuilder addExportGroup(ExportGroup exportGroup) {\n-        if (exportGroups == null) {\n-            exportGroups = new ArrayList<>();\n-        }\n         exportGroups.add(exportGroup);\n         return this;\n     }\n"}}, {"oid": "48231cd70b1f753096be26634a38cdf04dc24920", "url": "https://github.com/line/armeria/commit/48231cd70b1f753096be26634a38cdf04dc24920", "message": "Support prefix option for Logback integration", "committedDate": "2020-10-22T02:58:05Z", "type": "commit"}, {"oid": "a12535d3240e325f766ce69a04cfa4644e2c1277", "url": "https://github.com/line/armeria/commit/a12535d3240e325f766ce69a04cfa4644e2c1277", "message": "address comments by @trustin", "committedDate": "2020-10-22T02:58:06Z", "type": "commit"}, {"oid": "9ead1671d483255493ed143002d767d98e10a20e", "url": "https://github.com/line/armeria/commit/9ead1671d483255493ed143002d767d98e10a20e", "message": "address comments by @ikhoon", "committedDate": "2020-10-22T02:58:06Z", "type": "commit"}, {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "url": "https://github.com/line/armeria/commit/2d74ad4385820fb0366ecc9e788b382c6856be9c", "message": "address comments by @trustin", "committedDate": "2020-10-22T03:30:58Z", "type": "commit"}, {"oid": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "url": "https://github.com/line/armeria/commit/2d74ad4385820fb0366ecc9e788b382c6856be9c", "message": "address comments by @trustin", "committedDate": "2020-10-22T03:30:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY5NDgxNg==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511694816", "bodyText": "nit: could remove public and could you move this up to right under the class definition as we usually to?", "author": "minwoox", "createdAt": "2020-10-26T02:47:39Z", "path": "logback/src/test/java/com/linecorp/armeria/common/logback/CustomObject.java", "diffHunk": "@@ -33,4 +35,8 @@ public String toString() {\n                           .add(\"name\", name)\n                           .add(\"value\", value).toString();\n     }\n+\n+    public static final AttributeKey<CustomObject> ATTR = AttributeKey.valueOf(CustomObject.class, \"ATTR\");", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/logback/src/test/java/com/linecorp/armeria/common/logback/CustomObject.java b/logback/src/test/java/com/linecorp/armeria/common/logback/CustomObject.java\nindex f4bcf5e8f..19ff5ae9c 100644\n--- a/logback/src/test/java/com/linecorp/armeria/common/logback/CustomObject.java\n+++ b/logback/src/test/java/com/linecorp/armeria/common/logback/CustomObject.java\n\n@@ -35,8 +38,4 @@ public class CustomObject {\n                           .add(\"name\", name)\n                           .add(\"value\", value).toString();\n     }\n-\n-    public static final AttributeKey<CustomObject> ATTR = AttributeKey.valueOf(CustomObject.class, \"ATTR\");\n-\n-    public static final AttributeKey<String> FOO = AttributeKey.valueOf(CustomObject.class, \"FOO\");\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTY5NTg3Mg==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511695872", "bodyText": "nit: requireNonNull?", "author": "minwoox", "createdAt": "2020-10-26T02:52:57Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex ae3445b46..ac6ddf399 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -235,6 +235,7 @@ public final class ExportGroupBuilder {\n      * Adds the property represented by the specified key pattern to the export list.\n      */\n     public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n         KEY_SPLITTER.split(keyPatterns)\n                     .forEach(keyPattern -> {\n                         checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwMzAyMw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511703023", "bodyText": "nit: we could just do this.builtIns = requireNonNull(builtIns, \"builtIns\"); if you want. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-10-26T03:28:54Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Holds a set of {@link ExportEntry}s.\n+ *\n+ * @see RequestContextExporterBuilder\n+ */\n+public final class ExportGroup {\n+\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroup(Set<ExportEntry<BuiltInProperty>> builtIns,\n+                Set<ExportEntry<AttributeKey<?>>> attrs,\n+                Set<ExportEntry<AsciiString>> reqHeaders,\n+                Set<ExportEntry<AsciiString>> resHeaders) {\n+        requireNonNull(builtIns, \"builtIns\");", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\nindex b7b91c7d5..9461f9c14 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\n\n@@ -40,14 +40,10 @@ public final class ExportGroup {\n                 Set<ExportEntry<AttributeKey<?>>> attrs,\n                 Set<ExportEntry<AsciiString>> reqHeaders,\n                 Set<ExportEntry<AsciiString>> resHeaders) {\n-        requireNonNull(builtIns, \"builtIns\");\n-        requireNonNull(attrs, \"attrs\");\n-        requireNonNull(reqHeaders, \"reqHeaders\");\n-        requireNonNull(resHeaders, \"resHeaders\");\n-        this.builtIns = builtIns;\n-        this.attrs = attrs;\n-        this.reqHeaders = reqHeaders;\n-        this.resHeaders = resHeaders;\n+        this.builtIns = requireNonNull(builtIns, \"builtIns\");\n+        this.attrs = requireNonNull(attrs, \"attrs\");\n+        this.reqHeaders = requireNonNull(reqHeaders, \"reqHeaders\");\n+        this.resHeaders = requireNonNull(resHeaders, \"resHeaders\");\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNTk1OA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511705958", "bodyText": "Could just build()?", "author": "minwoox", "createdAt": "2020-10-26T03:44:42Z", "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfig)\n+ */\n+public final class ExportGroupConfig {\n+\n+    private final ExportGroupBuilder builder = ExportGroup.builder();\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     * Note: this method is meant to be used for XML configuration.\n+     */\n+    public void setPrefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        builder.prefix(prefix);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified MDC key to the export list.\n+     * Note: this method is meant to be used for XML configuration.\n+     */\n+    public void setExport(String mdcKey) {\n+        requireNonNull(mdcKey, \"mdcKey\");\n+        checkArgument(!mdcKey.isEmpty(), \"mdcKey must not be empty\");\n+        builder.keyPattern(mdcKey);\n+    }\n+\n+    /**\n+     * Adds the properties represented by the specified comma-separated MDC keys to the export list.\n+     * Note: this method is meant to be used for XML configuration.\n+     */\n+    public void setExports(String mdcKeys) {\n+        requireNonNull(mdcKeys, \"mdcKeys\");\n+        checkArgument(!mdcKeys.isEmpty(), \"mdcKeys must not be empty\");\n+        builder.keyPatterns(mdcKeys);\n+    }\n+\n+    /**\n+     * Returns {@link ExportGroup}.\n+     */\n+    ExportGroup exportGroup() {", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java\nindex ff3a554bc..39210e3ca 100644\n--- a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java\n+++ b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java\n\n@@ -63,7 +63,7 @@ public final class ExportGroupConfig {\n     /**\n      * Returns {@link ExportGroup}.\n      */\n-    ExportGroup exportGroup() {\n+    ExportGroup build() {\n         return builder.build();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511707663", "bodyText": "I think we can make some methods in this class as package-private. Could you check it, please?", "author": "minwoox", "createdAt": "2020-10-26T03:54:18Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1MTA5MA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r513951090", "bodyText": "Could remove public?", "author": "minwoox", "createdAt": "2020-10-29T04:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMzE3OQ==", "url": "https://github.com/line/armeria/pull/3112#discussion_r515023179", "bodyText": "Really? Why? I guess these methods are supposed to be invoked manually by a user code, not by Logback.", "author": "trustin", "createdAt": "2020-10-30T11:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA2Nzc5MA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r515067790", "bodyText": "Ah, I missed that a user could use this call manually. \ud83d\ude05\nSorry @okue for the inappropriate comments. Could you revert 5f8c1a3\nwhich removes the public modifier? \ud83d\ude4f", "author": "minwoox", "createdAt": "2020-10-30T12:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3MDQ5Ng==", "url": "https://github.com/line/armeria/pull/3112#discussion_r515070496", "bodyText": "I see \ud83d\ude04", "author": "okue", "createdAt": "2020-10-30T12:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex ae3445b46..ac6ddf399 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -235,6 +235,7 @@ public final class ExportGroupBuilder {\n      * Adds the property represented by the specified key pattern to the export list.\n      */\n     public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n         KEY_SPLITTER.split(keyPatterns)\n                     .forEach(keyPattern -> {\n                         checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzk5MA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511707990", "bodyText": "Could be private?", "author": "minwoox", "createdAt": "2020-10-26T03:56:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)\n+                    .forEach(keyPattern -> {\n+                        checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n+                        keyPattern(keyPattern);\n+                    });\n+        return this;\n+    }\n+\n+    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n+        final String[] components = keyPattern.split(\":\");\n+        if (components.length < 2 || components.length > 3) {\n+            if (exportKey == null) {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            }\n+        }\n+\n+        if (exportKey == null) {\n+            exportKey = components[0];\n+        }\n+        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n+        if (components.length == 3) {\n+            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n+        } else {\n+            return new ExportEntry<>(attributeKey, exportKey);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Function<?, String> newStringifier(String keyPattern, String className) {\n+        final Function<?, String> stringifier;\n+        try {\n+            stringifier = (Function<?, String>)\n+                    Class.forName(className, true, getClass().getClassLoader())\n+                         .getDeclaredConstructor()\n+                         .newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n+                                               keyPattern, e);\n+        }\n+        return stringifier;\n+    }\n+\n+    static final class ExportEntry<T> {\n+        final T key;\n+        final String exportKey;\n+        @Nullable\n+        final Function<Object, String> stringifier;\n+\n+        ExportEntry(T key, String exportKey) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            stringifier = null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ExportEntry(T key, String exportKey, Function<?, ?> stringifier) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            requireNonNull(stringifier);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            this.stringifier = (Function<Object, String>) stringifier;\n+        }\n+\n+        @Nullable\n+        String stringify(@Nullable Object value) {\n+            if (stringifier == null) {\n+                return value != null ? value.toString() : null;\n+            } else {\n+                return stringifier.apply(value);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() * 31 + exportKey.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof ExportEntry)) {\n+                return false;\n+            }\n+\n+            return key.equals(((ExportEntry<?>) o).key) &&\n+                   exportKey.equals(((ExportEntry<?>) o).exportKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return exportKey + ':' + key;\n+        }\n+\n+        public ExportEntry<T> withPrefix(String exportPrefix) {", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex ae3445b46..ac6ddf399 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -235,6 +235,7 @@ public final class ExportGroupBuilder {\n      * Adds the property represented by the specified key pattern to the export list.\n      */\n     public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n         KEY_SPLITTER.split(keyPatterns)\n                     .forEach(keyPattern -> {\n                         checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwNzk5OQ==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511707999", "bodyText": "Could be private?", "author": "minwoox", "createdAt": "2020-10-26T03:56:08Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";\n+    private static final String ATTR_NAMESPACE = \"attr:\";\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n+    @Nullable\n+    private String prefix;\n+    private final ImmutableSet.Builder<ExportEntry<BuiltInProperty>> builtIns;\n+    private final ImmutableSet.Builder<ExportEntry<AttributeKey<?>>> attrs;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> reqHeaders;\n+    private final ImmutableSet.Builder<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroupBuilder() {\n+        builtIns = ImmutableSet.builder();\n+        attrs = ImmutableSet.builder();\n+        reqHeaders = ImmutableSet.builder();\n+        resHeaders = ImmutableSet.builder();\n+    }\n+\n+    /**\n+     * Builds a new {@link ExportGroup}.\n+     * If a prefix is specified, returns entries with the prefix.\n+     */\n+    public ExportGroup build() {\n+        if (prefix == null) {\n+            return new ExportGroup(builtIns.build(), attrs.build(), reqHeaders.build(), resHeaders.build());\n+        } else {\n+            return new ExportGroup(\n+                    ExportEntry.withPrefix(builtIns.build(), prefix),\n+                    ExportEntry.withPrefix(attrs.build(), prefix),\n+                    ExportEntry.withPrefix(reqHeaders.build(), prefix),\n+                    ExportEntry.withPrefix(resHeaders.build(), prefix));\n+        }\n+    }\n+\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public ExportGroupBuilder prefix(String prefix) {\n+        requireNonNull(prefix, \"prefix\");\n+        checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n+        this.prefix = prefix;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link BuiltInProperty} to the export list.\n+     * The specified {@code alias} will be used for the export key.\n+     */\n+    public ExportGroupBuilder builtIn(BuiltInProperty property, String alias) {\n+        requireNonNull(property, \"BuiltInProperty\");\n+        requireNonNull(alias, \"alias\");\n+        builtIns.add(new ExportEntry<>(property, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        attrs.add(new ExportEntry<>(attrKey, alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified {@link AttributeKey} to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     *\n+     * @param alias the alias of the attribute to export\n+     * @param attrKey the key of the attribute to export\n+     * @param stringifier the {@link Function} that converts the attribute value into a {@link String}\n+     */\n+    public ExportGroupBuilder attr(String alias, AttributeKey<?> attrKey, Function<?, String> stringifier) {\n+        requireNonNull(alias, \"alias\");\n+        requireNonNull(attrKey, \"attrKey\");\n+        requireNonNull(stringifier, \"stringifier\");\n+        attrs.add(new ExportEntry<>(attrKey, alias, stringifier));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        reqHeaders.add(new ExportEntry<>(key, PREFIX_REQ_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP request header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder requestHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        reqHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName) {\n+        requireNonNull(headerName, \"headerName\");\n+        final AsciiString key = toHeaderName(headerName);\n+        resHeaders.add(new ExportEntry<>(key, PREFIX_RES_HEADERS + key));\n+        return this;\n+    }\n+\n+    /**\n+     * Adds the specified HTTP response header name to the export list.\n+     * The specified {@code alias} is used for the export key.\n+     */\n+    public ExportGroupBuilder responseHeader(CharSequence headerName, String alias) {\n+        requireNonNull(headerName, \"headerName\");\n+        requireNonNull(alias, \"alias\");\n+        resHeaders.add(new ExportEntry<>(toHeaderName(headerName), alias));\n+        return this;\n+    }\n+\n+    private static AsciiString toHeaderName(CharSequence name) {\n+        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list. Please refer to the\n+     * <a href=\"https://armeria.dev/docs/advanced-logging\">Logging contextual information</a>\n+     * in order to learn how to specify a key pattern.\n+     */\n+    public ExportGroupBuilder keyPattern(String keyPattern) {\n+        requireNonNull(keyPattern, \"keyPattern\");\n+\n+        final int exportKeyPos = keyPattern.indexOf('=');\n+\n+        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n+            if (exportKeyPos > 0) {\n+                throw new IllegalArgumentException(\n+                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n+            }\n+            BuiltInProperty.findByKeyPattern(keyPattern)\n+                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n+                           .forEach(builtIns::add);\n+            return this;\n+        }\n+\n+        String exportKey = null;\n+        if (exportKeyPos > 0) {\n+            exportKey = keyPattern.substring(0, exportKeyPos);\n+            keyPattern = keyPattern.substring(exportKeyPos + 1);\n+        }\n+\n+        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n+        if (property != null) {\n+            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n+            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n+            attrs.add(attrExportEntry);\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n+            if (exportKey == null) {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n+            } else {\n+                requestHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n+            }\n+            return this;\n+        }\n+\n+        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+    }\n+\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        KEY_SPLITTER.split(keyPatterns)\n+                    .forEach(keyPattern -> {\n+                        checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n+                        keyPattern(keyPattern);\n+                    });\n+        return this;\n+    }\n+\n+    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n+        final String[] components = keyPattern.split(\":\");\n+        if (components.length < 2 || components.length > 3) {\n+            if (exportKey == null) {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"invalid attribute export: \" + keyPattern +\n+                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n+            }\n+        }\n+\n+        if (exportKey == null) {\n+            exportKey = components[0];\n+        }\n+        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n+        if (components.length == 3) {\n+            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n+        } else {\n+            return new ExportEntry<>(attributeKey, exportKey);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Function<?, String> newStringifier(String keyPattern, String className) {\n+        final Function<?, String> stringifier;\n+        try {\n+            stringifier = (Function<?, String>)\n+                    Class.forName(className, true, getClass().getClassLoader())\n+                         .getDeclaredConstructor()\n+                         .newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n+                                               keyPattern, e);\n+        }\n+        return stringifier;\n+    }\n+\n+    static final class ExportEntry<T> {\n+        final T key;\n+        final String exportKey;\n+        @Nullable\n+        final Function<Object, String> stringifier;\n+\n+        ExportEntry(T key, String exportKey) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            stringifier = null;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ExportEntry(T key, String exportKey, Function<?, ?> stringifier) {\n+            requireNonNull(key);\n+            requireNonNull(exportKey);\n+            requireNonNull(stringifier);\n+            this.key = key;\n+            this.exportKey = exportKey;\n+            this.stringifier = (Function<Object, String>) stringifier;\n+        }\n+\n+        @Nullable\n+        String stringify(@Nullable Object value) {\n+            if (stringifier == null) {\n+                return value != null ? value.toString() : null;\n+            } else {\n+                return stringifier.apply(value);\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() * 31 + exportKey.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(@Nullable Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+\n+            if (!(o instanceof ExportEntry)) {\n+                return false;\n+            }\n+\n+            return key.equals(((ExportEntry<?>) o).key) &&\n+                   exportKey.equals(((ExportEntry<?>) o).exportKey);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return exportKey + ':' + key;\n+        }\n+\n+        public ExportEntry<T> withPrefix(String exportPrefix) {\n+            checkArgument(!exportPrefix.isEmpty(), \"exportPrefix must not be empty\");\n+\n+            if (stringifier == null) {\n+                return new ExportEntry<>(key, exportPrefix + exportKey);\n+            } else {\n+                return new ExportEntry<>(key, exportPrefix + exportKey, stringifier);\n+            }\n+        }\n+\n+        public static <T> Set<ExportEntry<T>> withPrefix(Set<ExportEntry<T>> entries, String exportPrefix) {", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex ae3445b46..ac6ddf399 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -235,6 +235,7 @@ public final class ExportGroupBuilder {\n      * Adds the property represented by the specified key pattern to the export list.\n      */\n     public ExportGroupBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n         KEY_SPLITTER.split(keyPatterns)\n                     .forEach(keyPattern -> {\n                         checkArgument(!keyPattern.isEmpty(), \"comma-separated keyPattern must not be empty\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcwODYzNg==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511708636", "bodyText": "How about using a separate list so that if build() is called twice, defaultExportGroupBuilder is not added twice.", "author": "minwoox", "createdAt": "2020-10-26T03:59:28Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +146,52 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+    /**\n+     * Adds the property represented by the specified key pattern to the export list.\n+     */\n+    public RequestContextExporterBuilder keyPatterns(String keyPatterns) {\n+        requireNonNull(keyPatterns, \"keyPatterns\");\n+        checkArgument(!keyPatterns.isEmpty(), \"keyPatterns must not be empty\");\n+        defaultExportGroupBuilder.keyPatterns(keyPatterns);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder exportGroup(ExportGroup exportGroup) {\n+        if (exportGroups == null) {\n+            exportGroups = new ArrayList<>();\n         }\n-        return stringifier;\n+        exportGroups.add(exportGroup);\n+        return this;\n     }\n \n     /**\n      * Returns a newly-created {@link RequestContextExporter} instance.\n      */\n     public RequestContextExporter build() {\n-        return new RequestContextExporter(builtIns, attrs, reqHeaders, resHeaders);\n+        if (exportGroups == null) {\n+            final ExportGroup defaultExportGroup = defaultExportGroupBuilder.build();\n+            return new RequestContextExporter(\n+                    defaultExportGroup.builtIns(), defaultExportGroup.attrs(),\n+                    defaultExportGroup.reqHeaders(), defaultExportGroup.resHeaders());\n+        }\n+        exportGroups.add(defaultExportGroupBuilder.build());", "originalCommit": "2d74ad4385820fb0366ecc9e788b382c6856be9c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex ee4f031a2..db0248ae5 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -182,16 +182,17 @@ public final class RequestContextExporterBuilder {\n                     defaultExportGroup.builtIns(), defaultExportGroup.attrs(),\n                     defaultExportGroup.reqHeaders(), defaultExportGroup.resHeaders());\n         }\n-        exportGroups.add(defaultExportGroupBuilder.build());\n+        final List<ExportGroup> exportGroupList = new ArrayList<>(exportGroups);\n+        exportGroupList.add(defaultExportGroupBuilder.build());\n         return new RequestContextExporter(\n-                exportGroups.stream().flatMap(it -> it.builtIns().stream())\n-                            .collect(ImmutableSet.toImmutableSet()),\n-                exportGroups.stream().flatMap(it -> it.attrs().stream())\n-                            .collect(ImmutableSet.toImmutableSet()),\n-                exportGroups.stream().flatMap(it -> it.reqHeaders().stream())\n-                            .collect(ImmutableSet.toImmutableSet()),\n-                exportGroups.stream().flatMap(it -> it.resHeaders().stream())\n-                            .collect(ImmutableSet.toImmutableSet())\n+                exportGroupList.stream().flatMap(it -> it.builtIns().stream())\n+                               .collect(ImmutableSet.toImmutableSet()),\n+                exportGroupList.stream().flatMap(it -> it.attrs().stream())\n+                               .collect(ImmutableSet.toImmutableSet()),\n+                exportGroupList.stream().flatMap(it -> it.reqHeaders().stream())\n+                               .collect(ImmutableSet.toImmutableSet()),\n+                exportGroupList.stream().flatMap(it -> it.resHeaders().stream())\n+                               .collect(ImmutableSet.toImmutableSet())\n         );\n     }\n }\n"}}, {"oid": "9db88f5696ce9ebbbddc984b5286668c4381c4fb", "url": "https://github.com/line/armeria/commit/9db88f5696ce9ebbbddc984b5286668c4381c4fb", "message": "address comments by @minwoox", "committedDate": "2020-10-26T05:11:36Z", "type": "commit"}, {"oid": "96833fb8fcea46c63229801a8750f21dcd0f7768", "url": "https://github.com/line/armeria/commit/96833fb8fcea46c63229801a8750f21dcd0f7768", "message": "make ExportGroup methods package-private", "committedDate": "2020-10-26T05:16:58Z", "type": "commit"}, {"oid": "381f03231ead868a94d18c9482ce1604a72aef89", "url": "https://github.com/line/armeria/commit/381f03231ead868a94d18c9482ce1604a72aef89", "message": "Remove keyPatterns method from ExportGroupBuilder & RequestContextExporterBuilder", "committedDate": "2020-10-26T05:40:55Z", "type": "commit"}, {"oid": "381f03231ead868a94d18c9482ce1604a72aef89", "url": "https://github.com/line/armeria/commit/381f03231ead868a94d18c9482ce1604a72aef89", "message": "Remove keyPatterns method from ExportGroupBuilder & RequestContextExporterBuilder", "committedDate": "2020-10-26T05:40:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk2MjI1Mw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r508962253", "bodyText": "Could be private?", "author": "ikhoon", "createdAt": "2020-10-21T03:10:22Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.ImmutableSet;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Builds a new {@link ExportGroup}.\n+ */\n+public final class ExportGroupBuilder {\n+\n+    private static final String PREFIX_REQ_HEADERS = \"req.headers.\";\n+    private static final String PREFIX_RES_HEADERS = \"res.headers.\";\n+\n+    static final String PREFIX_ATTRS = \"attrs.\";", "originalCommit": "7b571b262014ce8093511b282b464b2ba3811922", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48231cd70b1f753096be26634a38cdf04dc24920", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\nindex ae3445b46..9cfea5a75 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroupBuilder.java\n\n@@ -18,13 +18,14 @@ package com.linecorp.armeria.common.logging;\n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n+import java.util.HashSet;\n import java.util.Set;\n import java.util.function.Function;\n+import java.util.stream.Collectors;\n \n import javax.annotation.Nullable;\n \n import com.google.common.base.Splitter;\n-import com.google.common.collect.ImmutableSet;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczNTEwMA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511735100", "bodyText": "nit: Declare static before the member field?", "author": "ikhoon", "createdAt": "2020-10-26T06:07:05Z", "path": "logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logback;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.base.Splitter;\n+\n+import com.linecorp.armeria.common.logging.ExportGroup;\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n+\n+/**\n+ * Bridge class for Logback configuration.\n+ *\n+ * @see RequestContextExportingAppender#setExportGroup(ExportGroupConfig)\n+ */\n+public final class ExportGroupConfig {\n+\n+    private final ExportGroupBuilder builder = ExportGroup.builder();\n+\n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();", "originalCommit": "381f03231ead868a94d18c9482ce1604a72aef89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2571a029e6781e2a6ffa53dfc3d201714e897e98", "chunk": "diff --git a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java\nindex 73eab5f4c..bd77afbbf 100644\n--- a/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java\n+++ b/logback/src/main/java/com/linecorp/armeria/common/logback/ExportGroupConfig.java\n\n@@ -30,10 +30,10 @@ import com.linecorp.armeria.common.logging.ExportGroupBuilder;\n  */\n public final class ExportGroupConfig {\n \n-    private final ExportGroupBuilder builder = ExportGroup.builder();\n-\n     private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n \n+    private final ExportGroupBuilder builder = ExportGroup.builder();\n+\n     /**\n      * Specifies a prefix of the default export group.\n      * Note: this method is meant to be used for XML configuration.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczNTMzMA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r511735330", "bodyText": "nit: Declare static before the member field?", "author": "ikhoon", "createdAt": "2020-10-26T06:08:13Z", "path": "logback/src/main/java/com/linecorp/armeria/common/logback/RequestContextExportingAppender.java", "diffHunk": "@@ -66,13 +66,13 @@\n         }\n     }\n \n-    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n-\n     private final AppenderAttachableImpl<ILoggingEvent> aai = new AppenderAttachableImpl<>();\n     private final RequestContextExporterBuilder builder = RequestContextExporter.builder();\n     @Nullable\n     private RequestContextExporter exporter;\n \n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();", "originalCommit": "381f03231ead868a94d18c9482ce1604a72aef89", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2571a029e6781e2a6ffa53dfc3d201714e897e98", "chunk": "diff --git a/logback/src/main/java/com/linecorp/armeria/common/logback/RequestContextExportingAppender.java b/logback/src/main/java/com/linecorp/armeria/common/logback/RequestContextExportingAppender.java\nindex be9f37ffe..18023da96 100644\n--- a/logback/src/main/java/com/linecorp/armeria/common/logback/RequestContextExportingAppender.java\n+++ b/logback/src/main/java/com/linecorp/armeria/common/logback/RequestContextExportingAppender.java\n\n@@ -66,13 +66,13 @@ public final class RequestContextExportingAppender\n         }\n     }\n \n+    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n+\n     private final AppenderAttachableImpl<ILoggingEvent> aai = new AppenderAttachableImpl<>();\n     private final RequestContextExporterBuilder builder = RequestContextExporter.builder();\n     @Nullable\n     private RequestContextExporter exporter;\n \n-    private static final Splitter KEY_SPLITTER = Splitter.on(',').trimResults();\n-\n     @VisibleForTesting\n     RequestContextExporter exporter() {\n         checkState(exporter != null);\n"}}, {"oid": "2571a029e6781e2a6ffa53dfc3d201714e897e98", "url": "https://github.com/line/armeria/commit/2571a029e6781e2a6ffa53dfc3d201714e897e98", "message": "address comments by @ikhoon", "committedDate": "2020-10-26T06:16:36Z", "type": "commit"}, {"oid": "63216459662423b894bab015d9a53c80356d2656", "url": "https://github.com/line/armeria/commit/63216459662423b894bab015d9a53c80356d2656", "message": "Add documentation for exportGroup", "committedDate": "2020-10-26T07:32:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1ODIxNw==", "url": "https://github.com/line/armeria/pull/3112#discussion_r513958217", "bodyText": "How about iterating only once using foreach?\nfinal Builder<ExportEntry<BuiltInProperty>> builtInBuilder = ImmutableSet.builder();\n...\nfor (ExportGroup exportGroup : exportGroupList) {\n    builtInBuilder.addAll(exportGroup.builtIns());\n    ...\n}\nreturn new RequestContextExporter(builtInBuilder.build(), ...);", "author": "minwoox", "createdAt": "2020-10-29T04:30:45Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -153,103 +146,43 @@ private static AsciiString toHeaderName(CharSequence name) {\n      */\n     public RequestContextExporterBuilder keyPattern(String keyPattern) {\n         requireNonNull(keyPattern, \"keyPattern\");\n-\n-        final int exportKeyPos = keyPattern.indexOf('=');\n-\n-        if (keyPattern.contains(BuiltInProperty.WILDCARD_STR)) {\n-            if (exportKeyPos > 0) {\n-                throw new IllegalArgumentException(\n-                        \"A custom export key is unsupported for the wildcard: \" + keyPattern);\n-            }\n-            BuiltInProperty.findByKeyPattern(keyPattern)\n-                           .stream().map(prop -> new ExportEntry<>(prop, prop.key))\n-                           .forEach(builtIns::add);\n-            return this;\n-        }\n-\n-        String exportKey = null;\n-        if (exportKeyPos > 0) {\n-            exportKey = keyPattern.substring(0, exportKeyPos);\n-            keyPattern = keyPattern.substring(exportKeyPos + 1);\n-        }\n-\n-        final BuiltInProperty property = BuiltInProperty.findByKey(keyPattern);\n-        if (property != null) {\n-            builtIns.add(new ExportEntry<>(property, exportKey != null ? exportKey : property.key));\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_ATTRS) || keyPattern.startsWith(ATTR_NAMESPACE)) {\n-            final ExportEntry<AttributeKey<?>> attrExportEntry = parseAttrPattern(keyPattern, exportKey);\n-            attrs.add(attrExportEntry);\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_REQ_HEADERS)) {\n-            if (exportKey == null) {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()));\n-            } else {\n-                requestHeader(keyPattern.substring(PREFIX_REQ_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        if (keyPattern.startsWith(PREFIX_RES_HEADERS)) {\n-            if (exportKey == null) {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()));\n-            } else {\n-                responseHeader(keyPattern.substring(PREFIX_RES_HEADERS.length()), exportKey);\n-            }\n-            return this;\n-        }\n-\n-        throw new IllegalArgumentException(\"unknown key pattern: \" + keyPattern);\n-    }\n-\n-    private ExportEntry<AttributeKey<?>> parseAttrPattern(String keyPattern, @Nullable String exportKey) {\n-        final String[] components = keyPattern.split(\":\");\n-        if (components.length < 2 || components.length > 3) {\n-            if (exportKey == null) {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: attrs.<alias>:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            } else {\n-                throw new IllegalArgumentException(\n-                        \"invalid attribute export: \" + keyPattern +\n-                        \" (expected: <alias>=attr:<AttributeKey.name>[:<FQCN of Function<?, String>>])\");\n-            }\n-        }\n-\n-        if (exportKey == null) {\n-            exportKey = components[0];\n-        }\n-        final AttributeKey<Object> attributeKey = AttributeKey.valueOf(components[1]);\n-        if (components.length == 3) {\n-            return new ExportEntry<>(attributeKey, exportKey, newStringifier(keyPattern, components[2]));\n-        } else {\n-            return new ExportEntry<>(attributeKey, exportKey);\n-        }\n+        checkArgument(!keyPattern.isEmpty(), \"keyPattern must not be empty\");\n+        defaultExportGroupBuilder.keyPattern(keyPattern);\n+        return this;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    private Function<?, String> newStringifier(String keyPattern, String className) {\n-        final Function<?, String> stringifier;\n-        try {\n-            stringifier = (Function<?, String>)\n-                    Class.forName(className, true, getClass().getClassLoader())\n-                         .getDeclaredConstructor()\n-                         .newInstance();\n-        } catch (Exception e) {\n-            throw new IllegalArgumentException(\"failed to instantiate a stringifier function: \" +\n-                                               keyPattern, e);\n+    /**\n+     * Adds the export group.\n+     */\n+    public RequestContextExporterBuilder exportGroup(ExportGroup exportGroup) {\n+        if (exportGroups == null) {\n+            exportGroups = new ArrayList<>();\n         }\n-        return stringifier;\n+        exportGroups.add(exportGroup);\n+        return this;\n     }\n \n     /**\n      * Returns a newly-created {@link RequestContextExporter} instance.\n      */\n     public RequestContextExporter build() {\n-        return new RequestContextExporter(builtIns, attrs, reqHeaders, resHeaders);\n+        if (exportGroups == null) {\n+            final ExportGroup defaultExportGroup = defaultExportGroupBuilder.build();\n+            return new RequestContextExporter(\n+                    defaultExportGroup.builtIns(), defaultExportGroup.attrs(),\n+                    defaultExportGroup.reqHeaders(), defaultExportGroup.resHeaders());\n+        }\n+        final List<ExportGroup> exportGroupList = new ArrayList<>(exportGroups);\n+        exportGroupList.add(defaultExportGroupBuilder.build());\n+        return new RequestContextExporter(\n+                exportGroupList.stream().flatMap(it -> it.builtIns().stream())", "originalCommit": "63216459662423b894bab015d9a53c80356d2656", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5f8c1a3efaabd8b41d1997c9db9438bf56e1b798", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex 7cd739c44..3c27320b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -172,17 +176,24 @@ public final class RequestContextExporterBuilder {\n                     defaultExportGroup.builtIns(), defaultExportGroup.attrs(),\n                     defaultExportGroup.reqHeaders(), defaultExportGroup.resHeaders());\n         }\n+\n+        final Builder<ExportEntry<BuiltInProperty>> builtInProperties = ImmutableSet.builder();\n+        final Builder<ExportEntry<AttributeKey<?>>> attrs = ImmutableSet.builder();\n+        final Builder<ExportEntry<AsciiString>> reqHeaders = ImmutableSet.builder();\n+        final Builder<ExportEntry<AsciiString>> resHeaders = ImmutableSet.builder();\n+\n         final List<ExportGroup> exportGroupList = new ArrayList<>(exportGroups);\n         exportGroupList.add(defaultExportGroupBuilder.build());\n+\n+        for (ExportGroup exportGroup : exportGroupList) {\n+            builtInProperties.addAll(exportGroup.builtIns());\n+            attrs.addAll(exportGroup.attrs());\n+            reqHeaders.addAll(exportGroup.reqHeaders());\n+            resHeaders.addAll(exportGroup.resHeaders());\n+        }\n+\n         return new RequestContextExporter(\n-                exportGroupList.stream().flatMap(it -> it.builtIns().stream())\n-                               .collect(ImmutableSet.toImmutableSet()),\n-                exportGroupList.stream().flatMap(it -> it.attrs().stream())\n-                               .collect(ImmutableSet.toImmutableSet()),\n-                exportGroupList.stream().flatMap(it -> it.reqHeaders().stream())\n-                               .collect(ImmutableSet.toImmutableSet()),\n-                exportGroupList.stream().flatMap(it -> it.resHeaders().stream())\n-                               .collect(ImmutableSet.toImmutableSet())\n+                builtInProperties.build(), attrs.build(), reqHeaders.build(), resHeaders.build()\n         );\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMjYwNA==", "url": "https://github.com/line/armeria/pull/3112#discussion_r515022604", "bodyText": "Would it be safe to use ImmutableSet.copyOf() or accept ImmutableSets only?", "author": "trustin", "createdAt": "2020-10-30T11:11:55Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.common.logging;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Set;\n+\n+import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n+\n+import io.netty.util.AsciiString;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Holds a set of {@link ExportEntry}s.\n+ *\n+ * @see RequestContextExporterBuilder\n+ */\n+public final class ExportGroup {\n+\n+    private final Set<ExportEntry<BuiltInProperty>> builtIns;\n+    private final Set<ExportEntry<AttributeKey<?>>> attrs;\n+    private final Set<ExportEntry<AsciiString>> reqHeaders;\n+    private final Set<ExportEntry<AsciiString>> resHeaders;\n+\n+    ExportGroup(Set<ExportEntry<BuiltInProperty>> builtIns,\n+                Set<ExportEntry<AttributeKey<?>>> attrs,\n+                Set<ExportEntry<AsciiString>> reqHeaders,\n+                Set<ExportEntry<AsciiString>> resHeaders) {\n+        this.builtIns = requireNonNull(builtIns, \"builtIns\");\n+        this.attrs = requireNonNull(attrs, \"attrs\");\n+        this.reqHeaders = requireNonNull(reqHeaders, \"reqHeaders\");\n+        this.resHeaders = requireNonNull(resHeaders, \"resHeaders\");", "originalCommit": "63216459662423b894bab015d9a53c80356d2656", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a46535b95dabd048016f0d77c352ff67f8bf82e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\nindex 504f0c158..47e789a29 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/ExportGroup.java\n\n@@ -19,6 +19,8 @@ import static java.util.Objects.requireNonNull;\n \n import java.util.Set;\n \n+import com.google.common.collect.ImmutableSet;\n+\n import com.linecorp.armeria.common.logging.ExportGroupBuilder.ExportEntry;\n \n import io.netty.util.AsciiString;\n"}}, {"oid": "5f8c1a3efaabd8b41d1997c9db9438bf56e1b798", "url": "https://github.com/line/armeria/commit/5f8c1a3efaabd8b41d1997c9db9438bf56e1b798", "message": "address comments by @minwoox", "committedDate": "2020-10-30T12:26:55Z", "type": "commit"}, {"oid": "6a46535b95dabd048016f0d77c352ff67f8bf82e", "url": "https://github.com/line/armeria/commit/6a46535b95dabd048016f0d77c352ff67f8bf82e", "message": "use ImmutableSet.copyOf", "committedDate": "2020-10-30T12:40:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTExODg5MQ==", "url": "https://github.com/line/armeria/pull/3112#discussion_r515118891", "bodyText": "Don't we need to return RequestContextExporterBuilder?", "author": "ikhoon", "createdAt": "2020-10-30T14:00:52Z", "path": "core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java", "diffHunk": "@@ -134,16 +130,17 @@ public RequestContextExporterBuilder responseHeader(CharSequence headerName) {\n     public RequestContextExporterBuilder responseHeader(CharSequence headerName, String alias) {\n         requireNonNull(headerName, \"headerName\");\n         requireNonNull(alias, \"alias\");\n-        return addResponseHeader(toHeaderName(headerName), alias);\n-    }\n-\n-    private RequestContextExporterBuilder addResponseHeader(AsciiString headerKey, String alias) {\n-        resHeaders.add(new ExportEntry<>(headerKey, alias));\n+        defaultExportGroupBuilder.responseHeader(headerName, alias);\n         return this;\n     }\n \n-    private static AsciiString toHeaderName(CharSequence name) {\n-        return HttpHeaderNames.of(requireNonNull(name, \"name\").toString());\n+    /**\n+     * Specifies a prefix of the default export group.\n+     */\n+    public void prefix(String prefix) {", "originalCommit": "6a46535b95dabd048016f0d77c352ff67f8bf82e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f74ae1525f8e0591e18fc89b60d8d4b9b3da7e68", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\nindex 3c27320b9..38bfd5507 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/logging/RequestContextExporterBuilder.java\n\n@@ -137,10 +137,11 @@ public final class RequestContextExporterBuilder {\n     /**\n      * Specifies a prefix of the default export group.\n      */\n-    public void prefix(String prefix) {\n+    public RequestContextExporterBuilder prefix(String prefix) {\n         requireNonNull(prefix, \"prefix\");\n         checkArgument(!prefix.isEmpty(), \"prefix must not be empty\");\n         defaultExportGroupBuilder.prefix(prefix);\n+        return this;\n     }\n \n     /**\n"}}, {"oid": "f74ae1525f8e0591e18fc89b60d8d4b9b3da7e68", "url": "https://github.com/line/armeria/commit/f74ae1525f8e0591e18fc89b60d8d4b9b3da7e68", "message": "address comments by @ikhoon and @minwoox", "committedDate": "2020-10-31T04:59:03Z", "type": "commit"}]}