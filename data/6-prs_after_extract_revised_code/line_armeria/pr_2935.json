{"pr_number": 2935, "pr_title": "Add facility to capture dns metrics", "pr_createdAt": "2020-07-25T17:46:08Z", "pr_url": "https://github.com/line/armeria/pull/2935", "timeline": [{"oid": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "url": "https://github.com/line/armeria/commit/8d24a6844cd227561e20bda9ceaf920fe61224ae", "message": "Add facility to capture dns metrics", "committedDate": "2020-07-25T17:44:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648455", "bodyText": "I think this option is too early to introduce now. Could we hard-code for now and then add later when we get some user demands?", "author": "trustin", "createdAt": "2020-07-27T05:04:48Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -184,6 +185,10 @@\n     public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n             ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n \n+    public static final ClientFactoryOption<MeterIdPrefix> DEFAULT_METER_ID_PREFIX =\n+            ClientFactoryOption.define(\"DEFAULT_DNS_METER_ID_PREFIX\",\n+                    new MeterIdPrefix(\"armeria.client.dns.queries\"));", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4OTAwMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460989003", "bodyText": "Sounds good. I will make the change.", "author": "amitvc", "createdAt": "2020-07-27T15:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "78c156d413430822fe9088f60ea271c3442b3fbc", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\nindex 9f9ca4ac9..e6a9e9107 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\n\n@@ -179,16 +180,15 @@ public final class ClientFactoryOptions\n     public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n             ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n+    public static final ClientFactoryOption<PrometheusMeterRegistry> DNS_METRIC_REGISTRY =\n+            ClientFactoryOption.define(\"DNS_METER_REGISTRY\", PrometheusMeterRegistries.newRegistry());\n+\n     /**\n      * The {@link ProxyConfigSelector} which determines the {@link ProxyConfig} to be used.\n      */\n     public static final ClientFactoryOption<ProxyConfigSelector> PROXY_CONFIG_SELECTOR =\n             ClientFactoryOption.define(\"PROXY_CONFIG_SELECTOR\", ProxyConfigSelector.of(ProxyConfig.direct()));\n \n-    public static final ClientFactoryOption<MeterIdPrefix> DEFAULT_METER_ID_PREFIX =\n-            ClientFactoryOption.define(\"DEFAULT_DNS_METER_ID_PREFIX\",\n-                    new MeterIdPrefix(\"armeria.client.dns.queries\"));\n-\n     // Do not accept 1) the options that may break Armeria and 2) the deprecated options.\n     @SuppressWarnings(\"deprecation\")\n     private static final Set<ChannelOption<?>> PROHIBITED_SOCKET_OPTIONS = ImmutableSet.of(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460648962", "bodyText": "We never use IXFR or AXFR for DNS queries, so there's no way to tell if it's UDP or TCP. Let's remove protocol tag until the upstream provides a proper way to determine the protocol.", "author": "trustin", "createdAt": "2020-07-27T05:06:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();\n+    }\n+\n+    private static String getProtocolType(DnsRecordType type) {\n+        if (DnsRecordType.IXFR.equals(type) ||\n+                DnsRecordType.AXFR.equals(type)) {\n+            return \"tcp\";\n+        }\n+        return \"udp\";\n+    }", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4OTEwMg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460989102", "bodyText": "Ok. will do.", "author": "amitvc", "createdAt": "2020-07-27T15:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY0ODk2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "78c156d413430822fe9088f60ea271c3442b3fbc", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex a28188356..20124e6ee 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -16,15 +16,16 @@\n package com.linecorp.armeria.client;\n \n import java.net.InetSocketAddress;\n+import java.util.Arrays;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n-import io.micrometer.core.instrument.Counter;\n-import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n-import io.netty.handler.codec.dns.DnsRecordType;\n import io.netty.handler.codec.dns.DnsResponseCode;\n import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650131", "bodyText": "There are many incorrectness in this block, so I'm not sure how I can advise on this. Please make sure to re-read my suggestions about the names and tags and try re-writing this block completely.\nFor example, you should have different counter for each error code. To do this, you must get the counter lazily in the callback.", "author": "trustin", "createdAt": "2020-07-27T05:11:54Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Counter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsRecordType;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final Counter success;\n+    private final Counter failure;\n+    private final Counter protocolType;\n+    private final Counter dnsErrorCode;\n+    private final Counter queryWritten;\n+    private final Counter queryType;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry, DnsQuestion question, MeterIdPrefix prefix) {\n+        success = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"success\",\n+                        \"question\", question.name()).tags());\n+        failure = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"result\", \"failure\",\n+                        \"question\", question.name()).tags());\n+        dnsErrorCode = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"dns\", \"errorcodes\",\n+                        \"question\", question.name()).tags());\n+        queryWritten = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"written\", question.type().name()).tags());\n+        queryType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(),\n+                        \"type\", question.type().name()).tags());\n+        protocolType = meterRegistry.counter(prefix.name(),\n+                prefix.withTags(\"name\", question.name(), \"protocol\", getProtocolType(question.type()),\n+                        \"question\", question.name()).tags());\n+        protocolType.increment();", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxODMxNA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r462718314", "bodyText": "Regarding this - Your original comment -\nAll meters with the same name must have the same set of tags in Prometheus, i.e. this will fail. How about organizing like this:\nTIMER <prefix>{name=<domain name>, result=<success_or_failure>, cause=<cause_of_failure>}\nCOUNTER <prefix>.written{name=<domain_name>, server=<dns_server_ip_address>}\nCOUNTER <prefix>.cancelled{name=<domain_name>}\nCOUNTER <prefix>.cnamed{name=<domain_name>, cname=<name_in_cname_question>}\nCOUNTER <prefix>.redirected{name=<domain_name>, servers=<list_of_name_servers>}\nCOUNTER <prefix>.noanswer{name=<domain_name>, code=<response_code>}\n\nThe prefix here is something default like 'armeria.client.dns.queries'. So .cnamed is the name of the Counter ? and everything inside {} are the tags for that counter? Maybe we can pass the metricRegistry to DefaultDnsQueryLifecycleObserver and use it to instantiate the necessary counters when the appropriate dns lifecycle methods are being called?", "author": "amitvc", "createdAt": "2020-07-30T03:50:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3Njg1MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r463476850", "bodyText": "So .cnamed is the name of the Counter ?\n\nYes, its name will be armeria.client.dns.queries.cnamed and its tags will be name=<....> and cname=<...>. The counter will be increased when queryCNAMEd() method is invoked.\n\neverything inside {} are the tags for that counter?\n\nThat's correct. \ud83d\ude04\n\nMaybe we can pass the metricRegistry to DefaultDnsQueryLifecycleObserver and use it to instantiate the necessary counters when the appropriate dns lifecycle methods are being called?\n\nYes! \ud83d\udc4d", "author": "trustin", "createdAt": "2020-07-31T08:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDEzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "78c156d413430822fe9088f60ea271c3442b3fbc", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex a28188356..20124e6ee 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -16,15 +16,16 @@\n package com.linecorp.armeria.client;\n \n import java.net.InetSocketAddress;\n+import java.util.Arrays;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n-import io.micrometer.core.instrument.Counter;\n-import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n-import io.netty.handler.codec.dns.DnsRecordType;\n import io.netty.handler.codec.dns.DnsResponseCode;\n import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDIzNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650235", "bodyText": "Indentation", "author": "trustin", "createdAt": "2020-07-27T05:12:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,6 +369,7 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             }\n         };\n         return new RefreshingAddressResolverGroup(resolverConfigurator, minTtl, maxTtl, negativeTtl,\n-                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes);\n+                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes,\n+                                                   meterRegistry, meterIdPrefix);", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "78c156d413430822fe9088f60ea271c3442b3fbc", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\nindex 7a8c2b6a3..8d3b49631 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n\n@@ -369,7 +356,7 @@ public final class DnsResolverGroupBuilder {\n             }\n         };\n         return new RefreshingAddressResolverGroup(resolverConfigurator, minTtl, maxTtl, negativeTtl,\n-                                                  queryTimeoutMillis, refreshBackoff, resolvedAddressTypes,\n-                                                   meterRegistry, meterIdPrefix);\n+                                                  queryTimeoutMillis, refreshBackoff,\n+                                                    resolvedAddressTypes, dnsMeterRegistry);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460650551", "bodyText": "When you create a ClientFactory, you can specify a MeterRegistry. Create a new MeterRegistry so that ClientFactory does not use the default MeterRegistry, then check what's recorded in the MeterRegistry you specified. I'd recommend using PrometheusMeterRegistries.newRegistry() to create one.", "author": "trustin", "createdAt": "2020-07-27T05:13:53Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void test() throws ExecutionException, InterruptedException {\n+\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))", "originalCommit": "8d24a6844cd227561e20bda9ceaf920fe61224ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5MDAyNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r460990026", "bodyText": "Ok.", "author": "amitvc", "createdAt": "2020-07-27T15:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3NjU3MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467676570", "bodyText": "Isn't it just setting a new MeterRegistry like\nfinal MeterRegistry registry = PrometheusMeterRegistries.newRegistry():\nClientFactory.builder().meterRegistry(registry)...\n\ninstead of introducing a new MeterRegirstry? \ud83e\udd14", "author": "minwoox", "createdAt": "2020-08-10T03:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNDExNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467914115", "bodyText": "Not sure @minwoox. I think the default meter registry in the ClientFactory is used to collect various different stats. See example -\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0}\nAre we ok to reuse the same registry for DNS metrics? If yes then it makes sense. Let me know.", "author": "amitvc", "createdAt": "2020-08-10T13:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxNDUwMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467914503", "bodyText": "Example of DNS metric registry --\n{armeria.client.dns.queries.written#count{name=wikipedia.com.,server=/2001:558:feed:0:0:0:0:1}=2.0, armeria.client.dns.queries#count{cause=,name=wikipedia.com.,result=success}=2.0}", "author": "amitvc", "createdAt": "2020-08-10T13:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkxOTk5OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r467919999", "bodyText": "Are we ok to reuse the same registry for DNS metrics? If yes then it makes sense. Let me know.\n\nI think so. \ud83d\ude04  We can check whether the metric is recorded correctly or not using the combination of tags. This is an example:\nhttps://github.com/line/armeria/blob/master/grpc/src/test/java/com/linecorp/armeria/it/grpc/GrpcMetricsIntegrationTest.java#L201", "author": "minwoox", "createdAt": "2020-08-10T13:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY1MDU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "78c156d413430822fe9088f60ea271c3442b3fbc", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex 852cd4587..1009c26ec 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -15,42 +15,51 @@\n  */\n package com.linecorp.armeria.client;\n \n+import static org.assertj.core.api.Assertions.assertThat;\n+\n import java.util.concurrent.ExecutionException;\n \n import org.junit.jupiter.api.Test;\n \n-import com.linecorp.armeria.common.AggregatedHttpResponse;\n import com.linecorp.armeria.common.HttpMethod;\n import com.linecorp.armeria.common.RequestHeaders;\n-import com.linecorp.armeria.common.metric.MeterIdPrefix;\n import com.linecorp.armeria.common.metric.MoreMeters;\n \n public class DnsMetricsTest {\n \n     @Test\n-    void test() throws ExecutionException, InterruptedException {\n-\n+    void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n         final ClientFactory factory = ClientFactory.builder()\n-                .meterIdPrefix(new MeterIdPrefix(\"armeria.dns.metrics.test\"))\n                 .build();\n-        final WebClient client = WebClient.builder(\"https://google.com\")\n+\n+        final WebClient client2 = WebClient.builder()\n                 .factory(factory)\n                 .build();\n-        final AggregatedHttpResponse response =\n-                client.execute(RequestHeaders.of(HttpMethod.GET, \"/about\")).aggregate().get();\n-        System.out.println(response.headers());\n \n-        final AggregatedHttpResponse response22 =\n-                client.execute(RequestHeaders.of(HttpMethod.GET, \"/maps\")).aggregate().get();\n-        System.out.println(response22.headers());\n+        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+        System.out.println(MoreMeters.measureAll(factory.dnsMetricRegistry()));\n+        final double count = factory.dnsMetricRegistry().getPrometheusRegistry()\n+                .getSampleValue(\"armeria_client_dns_queries_total\",\n+                        new String[] {\"cause\",\"name\",\"result\"},\n+                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n+        assertThat(count > 1.0).isTrue();\n+    }\n \n-        final WebClient client2 = WebClient.builder(\"https://tesla.com\")\n-                .factory(factory)\n+    @Test\n+    void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n                 .build();\n-        final AggregatedHttpResponse response2 =\n-                client2.execute(RequestHeaders.of(HttpMethod.GET, \"/models\")).aggregate().get();\n-        System.out.println(\"***************************************************\");\n-        System.out.println(MoreMeters.measureAll(factory.meterRegistry()));\n-        System.out.println(\"***************************************************\");\n+        try {\n+            final WebClient client2 = WebClient.builder()\n+                    .factory(factory)\n+                    .build();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n+        } catch (Exception ex) {\n+            final double count = factory.dnsMetricRegistry().getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n+            assertThat(count > 1.0).isTrue();\n+        }\n     }\n }\n"}}, {"oid": "78c156d413430822fe9088f60ea271c3442b3fbc", "url": "https://github.com/line/armeria/commit/78c156d413430822fe9088f60ea271c3442b3fbc", "message": "changes made based on comments, added UT", "committedDate": "2020-08-09T05:05:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999136", "bodyText": "I don't think we need this at all. We can use the same MeterRegistry for DNS metrics.", "author": "trustin", "createdAt": "2020-08-12T04:32:55Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactory.java", "diffHunk": "@@ -177,6 +178,11 @@ static void disableShutdownHook() {\n      */\n     MeterRegistry meterRegistry();\n \n+    /**\n+     * Returns the {@link PrometheusMeterRegistry} that collects various DNS stats.\n+     */\n+    PrometheusMeterRegistry dnsMetricRegistry();\n+", "originalCommit": "78c156d413430822fe9088f60ea271c3442b3fbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3MzI1OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r470373259", "bodyText": "I have removed it.", "author": "amitvc", "createdAt": "2020-08-14T02:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTEzNg=="}], "type": "inlineReview", "revised_code": {"commit": "e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactory.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactory.java\nindex d88416b50..b58581a0c 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactory.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactory.java\n\n@@ -178,11 +177,6 @@ public interface ClientFactory extends Unwrappable, ListenableAsyncCloseable {\n      */\n     MeterRegistry meterRegistry();\n \n-    /**\n-     * Returns the {@link PrometheusMeterRegistry} that collects various DNS stats.\n-     */\n-    PrometheusMeterRegistry dnsMetricRegistry();\n-\n     /**\n      * Sets the {@link MeterRegistry} that collects various stats. Note that this method is intended to be\n      * used during the initialization phase of an application, so that the application gets a chance to\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk5OTI5MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r468999291", "bodyText": "Ditto - We don't need this.", "author": "trustin", "createdAt": "2020-08-12T04:33:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java", "diffHunk": "@@ -178,6 +180,9 @@\n     public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n             ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n+    public static final ClientFactoryOption<PrometheusMeterRegistry> DNS_METRIC_REGISTRY =\n+            ClientFactoryOption.define(\"DNS_METER_REGISTRY\", PrometheusMeterRegistries.newRegistry());\n+", "originalCommit": "78c156d413430822fe9088f60ea271c3442b3fbc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\nindex e6a9e9107..ee75aa276 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryOptions.java\n\n@@ -180,9 +178,6 @@ public final class ClientFactoryOptions\n     public static final ClientFactoryOption<MeterRegistry> METER_REGISTRY =\n             ClientFactoryOption.define(\"METER_REGISTRY\", Metrics.globalRegistry);\n \n-    public static final ClientFactoryOption<PrometheusMeterRegistry> DNS_METRIC_REGISTRY =\n-            ClientFactoryOption.define(\"DNS_METER_REGISTRY\", PrometheusMeterRegistries.newRegistry());\n-\n     /**\n      * The {@link ProxyConfigSelector} which determines the {@link ProxyConfig} to be used.\n      */\n"}}, {"oid": "e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "url": "https://github.com/line/armeria/commit/e1b3a01b5b6f221dce5de3aed8cbd32c9305e6c8", "message": "Removed dns specific metric registry and refactored some code based on feedback", "committedDate": "2020-08-13T03:50:58Z", "type": "commit"}, {"oid": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "url": "https://github.com/line/armeria/commit/1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "message": "Only enable DefaultDnsQueryLifecycleObserverFactory if user is expecting to capture dns metrics", "committedDate": "2020-08-15T23:51:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODA1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898051", "bodyText": "You can always do builder.metricRegistry(options.meterRegistry()).build(eventLoopGroup).", "author": "trustin", "createdAt": "2020-08-18T03:52:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return options.containsKey(ClientFactoryOptions.METER_REGISTRY) ? builder\n+                                .metricRegistry((PrometheusMeterRegistry)\n+                                        options.get(ClientFactoryOptions.METER_REGISTRY).value())\n+                                .build(eventLoopGroup) : builder.build(eventLoopGroup);", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex ef1ccc455..bc32affec 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -598,10 +598,10 @@ public final class ClientFactoryBuilder {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return options.containsKey(ClientFactoryOptions.METER_REGISTRY) ? builder\n-                                .metricRegistry((PrometheusMeterRegistry)\n-                                        options.get(ClientFactoryOptions.METER_REGISTRY).value())\n-                                .build(eventLoopGroup) : builder.build(eventLoopGroup);\n+                        return builder\n+                                .metricRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);\n                     };\n             return ClientFactoryOptions.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898151", "bodyText": "You can just accept MeterRegistry here.", "author": "trustin", "createdAt": "2020-08-18T03:52:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDg4MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r473064880", "bodyText": "Ok.", "author": "amitvc", "createdAt": "2020-08-19T14:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471898234", "bodyText": "Could you move these fields before the member fields in this class?", "author": "trustin", "createdAt": "2020-08-18T03:53:12Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA2NDc3Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r473064773", "bodyText": "Yes will do.", "author": "amitvc", "createdAt": "2020-08-19T14:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5ODIzNA=="}], "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDA5MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900090", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in an IP address?", "author": "trustin", "createdAt": "2020-08-18T04:01:06Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDE0Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900146", "bodyText": "Could you use .getAddress().getHostAddress() because we are only interested in IP addresses?", "author": "trustin", "createdAt": "2020-08-18T04:01:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900350", "bodyText": "intValue() instead of toString()?", "author": "trustin", "createdAt": "2020-08-18T04:02:11Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEzMTAwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r482131000", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-09-02T14:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDYwNw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900607", "bodyText": "Ditto - could use MeterRegistry", "author": "trustin", "createdAt": "2020-08-18T04:03:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.client;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserverFactory;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserverFactory} factory that helps create DnsQueryLifecycleObserver.\n+ */\n+final class DefaultDnsQueryLifecycleObserverFactory implements DnsQueryLifecycleObserverFactory {\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+\n+    DefaultDnsQueryLifecycleObserverFactory(PrometheusMeterRegistry meterRegistry,", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java\nindex 235d6c9bf..b7cffe99c 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserverFactory.java\n\n@@ -18,7 +18,7 @@ package com.linecorp.armeria.client;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n-import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.micrometer.core.instrument.MeterRegistry;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n import io.netty.resolver.dns.DnsQueryLifecycleObserverFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDg5Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471900893", "bodyText": "How about \"none\" instead of \"\"?", "author": "trustin", "createdAt": "2020-08-18T04:04:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"\"))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901100", "bodyText": "I'm somewhat concerned about using an exception message as a tag value because it can increase the cardinality dramatically. How about categorizing the exceptions into a few?", "author": "trustin", "createdAt": "2020-08-18T04:05:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+\n+    private final PrometheusMeterRegistry registry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(PrometheusMeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        registry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        registry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().toString()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        registry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        registry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().toString())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        registry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        registry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, code.toString()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        registry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, cause.getMessage()))).increment();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYzMjc2MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r481632760", "bodyText": "Can you elaborate on this, please?  If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?", "author": "amitvc", "createdAt": "2020-09-02T03:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjYzOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202638", "bodyText": "If I understand correctly we want to see what is the type of exception and use that to add CAUSE_TAG instead of cause.getMessage()?\n\nYes, if Netty gives different exception type for different causes. If not, we'll have to categorize all possible exception types and messages into a set of well-defined strings. Makes sense?", "author": "trustin", "createdAt": "2020-09-07T06:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI0Mjg4Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485242887", "bodyText": "Netty will return a runtimeexception of type DnsResolveContext::DnsResolveContextException which is RuntimeException. There are 5 different types of these exceptions defined in https://github.com/netty/netty/blob/fde6bc88859a41b2bdd5aae00beef09b1b17bda7/resolver-dns/src/main/java/io/netty/resolver/dns/DnsResolveContext.java#L65.  We also receive DnsNameResolverTimeoutException exception when there are time outs.", "author": "amitvc", "createdAt": "2020-09-08T23:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NTQ0MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485275441", "bodyText": "I see. Thanks for looking into. We need to do some text pattern matching in this case. You might want to contribute to Netty so that each case is distinguishable by exception type later, though.", "author": "trustin", "createdAt": "2020-09-09T00:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTEwMA=="}], "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 20124e6ee..1962d080e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -22,6 +22,7 @@ import java.util.stream.Collectors;\n \n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901501", "bodyText": "Should accept MeterRegistry.\nCould be package-private?", "author": "trustin", "createdAt": "2020-08-18T04:07:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param metricRegistry {@link PrometheusMeterRegistry}.\n+     * @return DnsResolverGroupBuilder.\n+     */\n+    public DnsResolverGroupBuilder metricRegistry(PrometheusMeterRegistry metricRegistry) {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYyMTUwNw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r481621507", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-09-02T03:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\nindex 3deba2e8e..83f7825c4 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n\n@@ -297,11 +297,11 @@ public final class DnsResolverGroupBuilder {\n \n     /**\n      * Sets MeterRegistry.\n-     * @param metricRegistry {@link PrometheusMeterRegistry}.\n+     * @param meterRegistry {@link MeterRegistry}.\n      * @return DnsResolverGroupBuilder.\n      */\n-    public DnsResolverGroupBuilder metricRegistry(PrometheusMeterRegistry metricRegistry) {\n-        this.metricRegistry = metricRegistry;\n+    public DnsResolverGroupBuilder metricRegistry(MeterRegistry meterRegistry) {\n+        this.meterRegistry = meterRegistry;\n         return this;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTYyMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901621", "bodyText": "@Nonnull is redundant. Everything in our code is nonnull.\nShould accept MeterRegistry\nmetricRegistry -> meterRegistry", "author": "trustin", "createdAt": "2020-08-18T04:08:02Z", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -99,11 +102,13 @@\n     private final Backoff refreshBackoff;\n     private final List<DnsRecordType> dnsRecordTypes;\n     private final Consumer<DnsNameResolverBuilder> resolverConfigurator;\n+    private final PrometheusMeterRegistry metricRegistry;\n \n     RefreshingAddressResolverGroup(Consumer<DnsNameResolverBuilder> resolverConfigurator,\n                                    int minTtl, int maxTtl, int negativeTtl, long queryTimeoutMillis,\n                                    Backoff refreshBackoff,\n-                                   @Nullable ResolvedAddressTypes resolvedAddressTypes) {\n+                                   @Nullable ResolvedAddressTypes resolvedAddressTypes,\n+                                   @Nonnull PrometheusMeterRegistry metricRegistry) {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java b/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\nindex c61280bbf..84bbbf7f2 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\n\n@@ -102,13 +101,13 @@ final class RefreshingAddressResolverGroup extends AddressResolverGroup<InetSock\n     private final Backoff refreshBackoff;\n     private final List<DnsRecordType> dnsRecordTypes;\n     private final Consumer<DnsNameResolverBuilder> resolverConfigurator;\n-    private final PrometheusMeterRegistry metricRegistry;\n+    private final MeterRegistry meterRegistry;\n \n     RefreshingAddressResolverGroup(Consumer<DnsNameResolverBuilder> resolverConfigurator,\n                                    int minTtl, int maxTtl, int negativeTtl, long queryTimeoutMillis,\n                                    Backoff refreshBackoff,\n                                    @Nullable ResolvedAddressTypes resolvedAddressTypes,\n-                                   @Nonnull PrometheusMeterRegistry metricRegistry) {\n+                                   MeterRegistry meterRegistry) {\n         this.resolverConfigurator = resolverConfigurator;\n         this.minTtl = minTtl;\n         this.maxTtl = maxTtl;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMTcyOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471901728", "bodyText": "metricRegistry is always non-null. No need to check nullness.", "author": "trustin", "createdAt": "2020-08-18T04:08:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +134,11 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        if (metricRegistry != null) {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java b/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\nindex c61280bbf..84bbbf7f2 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\n\n@@ -134,9 +133,9 @@ final class RefreshingAddressResolverGroup extends AddressResolverGroup<InetSock\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n-        if (metricRegistry != null) {\n+        if (meterRegistry != null) {\n             builder.dnsQueryLifecycleObserverFactory(\n-                    new DefaultDnsQueryLifecycleObserverFactory(metricRegistry,\n+                    new DefaultDnsQueryLifecycleObserverFactory(meterRegistry,\n                             new MeterIdPrefix(\"armeria.client.dns.queries\")));\n         }\n         resolverConfigurator.accept(builder);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902283", "bodyText": "Could you use the TestDnsServer instead of using a public DNS server? This way, we can test all life cycle observer callbacks easily.", "author": "trustin", "createdAt": "2020-08-18T04:11:05Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2ODg4Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r481468886", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-09-01T22:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjI4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex e08296b6d..842be02ba 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -15,74 +15,208 @@\n  */\n package com.linecorp.armeria.client;\n \n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n+import java.net.InetSocketAddress;\n+import java.util.Collections;\n+import java.util.Iterator;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Stream;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n \n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n import com.linecorp.armeria.common.HttpMethod;\n import com.linecorp.armeria.common.RequestHeaders;\n-import com.linecorp.armeria.common.metric.MoreMeters;\n import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+import com.linecorp.armeria.testing.junit5.common.EventLoopExtension;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.AddressResolver;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.Future;\n \n public class DnsMetricsTest {\n \n+    @RegisterExtension\n+    static final EventLoopExtension eventLoopExtension = new EventLoopExtension();\n+\n     @Test\n     void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n-        final ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n-                .build();\n-\n-        final WebClient client2 = WebClient.builder()\n-                .factory(factory)\n-                .build();\n-\n-        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-\n-        final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n-                .getPrometheusRegistry()\n-                .getSampleValue(\"armeria_client_dns_queries_total\",\n-                        new String[] {\"cause\",\"name\",\"result\"},\n-                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n-        assertThat(count > 1.0).isTrue();\n+\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"1.1.1.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\n+                    hostname -> DnsServerAddresses.sequential(\n+                            Stream.of(server).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n+            final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n+            final DnsResolverGroupBuilder builder = new DnsResolverGroupBuilder()\n+                    .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                    .metricRegistry(pm1)\n+                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\n+                    .traceEnabled(false);\n+\n+            final EventLoop eventLoop = eventLoopExtension.get();\n+            try (RefreshingAddressResolverGroup group = builder.build(eventLoop)) {\n+                final AddressResolver<InetSocketAddress> resolver = group.getResolver(eventLoop);\n+                final Future<InetSocketAddress> foo = resolver.resolve(\n+                        InetSocketAddress.createUnresolved(\"foo.com\", 36462));\n+                try (ClientFactory factory = ClientFactory.builder()\n+                        .addressResolverGroupFactory(builder::build)\n+                        .meterRegistry(pm1)\n+                        .build()) {\n+                    final WebClient client2 = WebClient.builder()\n+                            .factory(factory)\n+                            .build();\n+\n+                    client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\")).aggregate().get();\n+\n+                    final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+                    final double count = registry.getPrometheusRegistry()\n+                            .getSampleValue(\"armeria_client_dns_queries_total\",\n+                                    new String[] {\"cause\",\"name\",\"result\"},\n+                                    new String[] {\"\",\"foo.com.\", \"success\"});\n+                    assertThat(count > 1.0).isTrue();\n+                }\n+            }\n+        }\n     }\n \n     @Test\n     void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n-        final ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n-                .build();\n-        try {\n-            final WebClient client2 = WebClient.builder()\n-                    .factory(factory)\n-                    .build();\n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n-        } catch (Exception ex) {\n-            final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n-                    .getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n-            assertThat(count > 1.0).isTrue();\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(), new AlwaysTimeoutHandler())) {\n+            final DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\n+                    hostname -> DnsServerAddresses.sequential(\n+                            Stream.of(server).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n+            final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n+            final DnsResolverGroupBuilder builder = new DnsResolverGroupBuilder()\n+                    .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                    .metricRegistry(pm1)\n+                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\n+                    .traceEnabled(false);\n+\n+            final EventLoop eventLoop = eventLoopExtension.get();\n+            try (RefreshingAddressResolverGroup group = builder.build(eventLoop)) {\n+                final AddressResolver<InetSocketAddress> resolver = group.getResolver(eventLoop);\n+                final Future<InetSocketAddress> foo = resolver.resolve(\n+                        InetSocketAddress.createUnresolved(\"foo.com\", 36462));\n+                try (ClientFactory factory = ClientFactory.builder()\n+                        .addressResolverGroupFactory(builder::build)\n+                        .meterRegistry(pm1)\n+                        .build()) {\n+                    final WebClient client2 = WebClient.builder()\n+                            .factory(factory)\n+                            .build();\n+\n+                    assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                            .aggregate().join())\n+                            .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                            .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                    final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+\n+                    final Iterator var4 = Collections.list(registry.getPrometheusRegistry()\n+                            .metricFamilySamples()).iterator();\n+                    while (var4.hasNext()) {\n+                        System.out.println(var4.next());\n+                    }\n+\n+                    final double count = registry.getPrometheusRegistry()\n+                            .getSampleValue(\"armeria_client_dns_queries_total\",\n+                                    new String[] {\"cause\",\"name\",\"result\"},\n+                                    new String[] {\"No name servers returned an answer\",\"foo.com.\", \"failure\"});\n+                    assertThat(count > 1.0).isTrue();\n+                }\n+            }\n         }\n     }\n \n     @Test\n-    void no_dns_registry_used_when_not_provided_externally() throws ExecutionException, InterruptedException {\n-        final ClientFactory factory = ClientFactory.builder()\n-                .build();\n+    void dns_test_no_answer() throws ExecutionException, InterruptedException {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NOTZONE)\n+        ))) {\n+            final DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\n+                    hostname -> DnsServerAddresses.sequential(\n+                            Stream.of(server).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n+            final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n+            final DnsResolverGroupBuilder builder = new DnsResolverGroupBuilder()\n+                    .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                    .metricRegistry(pm1)\n+                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\n+                    .traceEnabled(false);\n \n-        final WebClient client2 = WebClient.builder()\n-                .factory(factory)\n-                .build();\n+            final EventLoop eventLoop = eventLoopExtension.get();\n+            try (RefreshingAddressResolverGroup group = builder.build(eventLoop)) {\n+                final AddressResolver<InetSocketAddress> resolver = group.getResolver(eventLoop);\n+                final Future<InetSocketAddress> foo = resolver.resolve(\n+                        InetSocketAddress.createUnresolved(\"bar.com\", 36462));\n+                try (ClientFactory factory = ClientFactory.builder()\n+                        .addressResolverGroupFactory(builder::build)\n+                        .meterRegistry(pm1)\n+                        .build()) {\n+                    final WebClient client2 = WebClient.builder()\n+                            .factory(factory)\n+                            .build();\n \n-        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+                    try {\n+                        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://bar.com\"))\n+                                .aggregate().get();\n+                    } catch (Exception ex) {\n+                        final PrometheusMeterRegistry registry =\n+                                (PrometheusMeterRegistry) factory.meterRegistry();\n+                        final Iterator var4 = Collections.list(registry.getPrometheusRegistry()\n+                                .metricFamilySamples()).iterator();\n+                        while (var4.hasNext()) {\n+                            System.out.println(var4.next());\n+                        }\n+                        final double count = registry.getPrometheusRegistry()\n+                                .getSampleValue(\"armeria_client_dns_queries_noanswer_total\",\n+                                        new String[] {\"code\",\"name\"},\n+                                        new String[] {\"NotZone(10)\",\"bar.com.\"});\n+                        assertThat(count > 1.0).isTrue();\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n-        assertThat(factory.meterRegistry() instanceof PrometheusMeterRegistry).isFalse();\n-        assertThat(MoreMeters.measureAll(factory.meterRegistry())\n-                   .toString().contains(\"armeria.client.connections.lifespan\")).isTrue();\n+    private static class AlwaysTimeoutHandler extends ChannelInboundHandlerAdapter {\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+            if (msg instanceof DatagramDnsQuery) {\n+                // Just release the msg and return so that the client request is timed out.\n+                ReferenceCountUtil.safeRelease(msg);\n+                return;\n+            }\n+            super.channelRead(ctx, msg);\n+        }\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMjQwMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r471902401", "bodyText": "Global comment: ClientFactory must be closed at the end of the test. Use try-with-resources on it.", "author": "trustin", "createdAt": "2020-08-18T04:11:37Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.concurrent.ExecutionException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+\n+        final WebClient client2 = WebClient.builder()\n+                .factory(factory)\n+                .build();\n+\n+        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+\n+        final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                .getPrometheusRegistry()\n+                .getSampleValue(\"armeria_client_dns_queries_total\",\n+                        new String[] {\"cause\",\"name\",\"result\"},\n+                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n+        assertThat(count > 1.0).isTrue();\n+    }\n+\n+    @Test\n+    void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build();\n+        try {\n+            final WebClient client2 = WebClient.builder()\n+                    .factory(factory)\n+                    .build();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n+        } catch (Exception ex) {\n+            final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n+                    .getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n+            assertThat(count > 1.0).isTrue();\n+        }\n+    }\n+\n+    @Test\n+    void no_dns_registry_used_when_not_provided_externally() throws ExecutionException, InterruptedException {\n+        final ClientFactory factory = ClientFactory.builder()\n+                .build();", "originalCommit": "1c5cb6e1f93896f4ba53da033d5cc03ae306dec0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51e2d7160aea93657a37175c4488cf81a162983", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex e08296b6d..842be02ba 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -15,74 +15,208 @@\n  */\n package com.linecorp.armeria.client;\n \n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n+import java.net.InetSocketAddress;\n+import java.util.Collections;\n+import java.util.Iterator;\n import java.util.concurrent.ExecutionException;\n+import java.util.stream.Stream;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n \n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n import com.linecorp.armeria.common.HttpMethod;\n import com.linecorp.armeria.common.RequestHeaders;\n-import com.linecorp.armeria.common.metric.MoreMeters;\n import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+import com.linecorp.armeria.testing.junit5.common.EventLoopExtension;\n \n+import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.AddressResolver;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.concurrent.Future;\n \n public class DnsMetricsTest {\n \n+    @RegisterExtension\n+    static final EventLoopExtension eventLoopExtension = new EventLoopExtension();\n+\n     @Test\n     void dns_metric_test_for_successful_query_writes() throws ExecutionException, InterruptedException {\n-        final ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n-                .build();\n-\n-        final WebClient client2 = WebClient.builder()\n-                .factory(factory)\n-                .build();\n-\n-        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-\n-        final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n-                .getPrometheusRegistry()\n-                .getSampleValue(\"armeria_client_dns_queries_total\",\n-                        new String[] {\"cause\",\"name\",\"result\"},\n-                        new String[] {\"\",\"wikipedia.com.\", \"success\"});\n-        assertThat(count > 1.0).isTrue();\n+\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"1.1.1.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\n+                    hostname -> DnsServerAddresses.sequential(\n+                            Stream.of(server).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n+            final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n+            final DnsResolverGroupBuilder builder = new DnsResolverGroupBuilder()\n+                    .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                    .metricRegistry(pm1)\n+                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\n+                    .traceEnabled(false);\n+\n+            final EventLoop eventLoop = eventLoopExtension.get();\n+            try (RefreshingAddressResolverGroup group = builder.build(eventLoop)) {\n+                final AddressResolver<InetSocketAddress> resolver = group.getResolver(eventLoop);\n+                final Future<InetSocketAddress> foo = resolver.resolve(\n+                        InetSocketAddress.createUnresolved(\"foo.com\", 36462));\n+                try (ClientFactory factory = ClientFactory.builder()\n+                        .addressResolverGroupFactory(builder::build)\n+                        .meterRegistry(pm1)\n+                        .build()) {\n+                    final WebClient client2 = WebClient.builder()\n+                            .factory(factory)\n+                            .build();\n+\n+                    client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\")).aggregate().get();\n+\n+                    final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+                    final double count = registry.getPrometheusRegistry()\n+                            .getSampleValue(\"armeria_client_dns_queries_total\",\n+                                    new String[] {\"cause\",\"name\",\"result\"},\n+                                    new String[] {\"\",\"foo.com.\", \"success\"});\n+                    assertThat(count > 1.0).isTrue();\n+                }\n+            }\n+        }\n     }\n \n     @Test\n     void dns_metric_test_for_query_failures() throws ExecutionException, InterruptedException {\n-        final ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n-                .build();\n-        try {\n-            final WebClient client2 = WebClient.builder()\n-                    .factory(factory)\n-                    .build();\n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://googleusercontent.com\")).aggregate().get();\n-        } catch (Exception ex) {\n-            final double count = ((PrometheusMeterRegistry) factory.meterRegistry())\n-                    .getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"No matching record type found\",\"googleusercontent.com.\", \"failure\"});\n-            assertThat(count > 1.0).isTrue();\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(), new AlwaysTimeoutHandler())) {\n+            final DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\n+                    hostname -> DnsServerAddresses.sequential(\n+                            Stream.of(server).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n+            final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n+            final DnsResolverGroupBuilder builder = new DnsResolverGroupBuilder()\n+                    .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                    .metricRegistry(pm1)\n+                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\n+                    .traceEnabled(false);\n+\n+            final EventLoop eventLoop = eventLoopExtension.get();\n+            try (RefreshingAddressResolverGroup group = builder.build(eventLoop)) {\n+                final AddressResolver<InetSocketAddress> resolver = group.getResolver(eventLoop);\n+                final Future<InetSocketAddress> foo = resolver.resolve(\n+                        InetSocketAddress.createUnresolved(\"foo.com\", 36462));\n+                try (ClientFactory factory = ClientFactory.builder()\n+                        .addressResolverGroupFactory(builder::build)\n+                        .meterRegistry(pm1)\n+                        .build()) {\n+                    final WebClient client2 = WebClient.builder()\n+                            .factory(factory)\n+                            .build();\n+\n+                    assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                            .aggregate().join())\n+                            .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                            .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                    final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+\n+                    final Iterator var4 = Collections.list(registry.getPrometheusRegistry()\n+                            .metricFamilySamples()).iterator();\n+                    while (var4.hasNext()) {\n+                        System.out.println(var4.next());\n+                    }\n+\n+                    final double count = registry.getPrometheusRegistry()\n+                            .getSampleValue(\"armeria_client_dns_queries_total\",\n+                                    new String[] {\"cause\",\"name\",\"result\"},\n+                                    new String[] {\"No name servers returned an answer\",\"foo.com.\", \"failure\"});\n+                    assertThat(count > 1.0).isTrue();\n+                }\n+            }\n         }\n     }\n \n     @Test\n-    void no_dns_registry_used_when_not_provided_externally() throws ExecutionException, InterruptedException {\n-        final ClientFactory factory = ClientFactory.builder()\n-                .build();\n+    void dns_test_no_answer() throws ExecutionException, InterruptedException {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NOTZONE)\n+        ))) {\n+            final DnsServerAddressStreamProvider dnsServerAddressStreamProvider =\n+                    hostname -> DnsServerAddresses.sequential(\n+                            Stream.of(server).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n+            final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n+            final DnsResolverGroupBuilder builder = new DnsResolverGroupBuilder()\n+                    .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                    .metricRegistry(pm1)\n+                    .resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY)\n+                    .traceEnabled(false);\n \n-        final WebClient client2 = WebClient.builder()\n-                .factory(factory)\n-                .build();\n+            final EventLoop eventLoop = eventLoopExtension.get();\n+            try (RefreshingAddressResolverGroup group = builder.build(eventLoop)) {\n+                final AddressResolver<InetSocketAddress> resolver = group.getResolver(eventLoop);\n+                final Future<InetSocketAddress> foo = resolver.resolve(\n+                        InetSocketAddress.createUnresolved(\"bar.com\", 36462));\n+                try (ClientFactory factory = ClientFactory.builder()\n+                        .addressResolverGroupFactory(builder::build)\n+                        .meterRegistry(pm1)\n+                        .build()) {\n+                    final WebClient client2 = WebClient.builder()\n+                            .factory(factory)\n+                            .build();\n \n-        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n+                    try {\n+                        client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://bar.com\"))\n+                                .aggregate().get();\n+                    } catch (Exception ex) {\n+                        final PrometheusMeterRegistry registry =\n+                                (PrometheusMeterRegistry) factory.meterRegistry();\n+                        final Iterator var4 = Collections.list(registry.getPrometheusRegistry()\n+                                .metricFamilySamples()).iterator();\n+                        while (var4.hasNext()) {\n+                            System.out.println(var4.next());\n+                        }\n+                        final double count = registry.getPrometheusRegistry()\n+                                .getSampleValue(\"armeria_client_dns_queries_noanswer_total\",\n+                                        new String[] {\"code\",\"name\"},\n+                                        new String[] {\"NotZone(10)\",\"bar.com.\"});\n+                        assertThat(count > 1.0).isTrue();\n+                    }\n+                }\n+            }\n+        }\n+    }\n \n-        assertThat(factory.meterRegistry() instanceof PrometheusMeterRegistry).isFalse();\n-        assertThat(MoreMeters.measureAll(factory.meterRegistry())\n-                   .toString().contains(\"armeria.client.connections.lifespan\")).isTrue();\n+    private static class AlwaysTimeoutHandler extends ChannelInboundHandlerAdapter {\n+        @Override\n+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+            if (msg instanceof DatagramDnsQuery) {\n+                // Just release the msg and return so that the client request is timed out.\n+                ReferenceCountUtil.safeRelease(msg);\n+                return;\n+            }\n+            super.channelRead(ctx, msg);\n+        }\n     }\n }\n"}}, {"oid": "d51e2d7160aea93657a37175c4488cf81a162983", "url": "https://github.com/line/armeria/commit/d51e2d7160aea93657a37175c4488cf81a162983", "message": "Rewrote unit test using DnsTestServer and address several cr comments", "committedDate": "2020-08-31T03:41:55Z", "type": "commit"}, {"oid": "7c471878e873c79203b3f1bd591ca1365e836f63", "url": "https://github.com/line/armeria/commit/7c471878e873c79203b3f1bd591ca1365e836f63", "message": "Addressing code review comments", "committedDate": "2020-09-02T03:44:24Z", "type": "commit"}, {"oid": "6129f8a064a38c572db68762f0b3039daa69c31d", "url": "https://github.com/line/armeria/commit/6129f8a064a38c572db68762f0b3039daa69c31d", "message": "wrap ClientFactory with try with resource block, general cleanup", "committedDate": "2020-09-02T03:54:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r484201396", "bodyText": "Could avoid using PrometheusMeterRegistries here, because we don't have a hard dependency on it. It has to be like the following IIUC:\nreturn builder.meterRegistry(options.meterRegistry()).build(eventLoopGroup);", "author": "trustin", "createdAt": "2020-09-07T06:10:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -597,7 +598,10 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+                        return builder\n+                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n+                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n+                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);", "originalCommit": "6129f8a064a38c572db68762f0b3039daa69c31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzExNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485233116", "bodyText": "options is an Map<ClientFactoryOption, ClientFactoryOptionValue> options in this class.   Also the reason I was doing the null check is because there is a static ClientFactory that is being instantiated inside the https://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/DefaultClientFactory.java#L72 and that does not have the options Map built up.", "author": "amitvc", "createdAt": "2020-09-08T22:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NDgzMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485274831", "bodyText": "Ahh, OK. Then could we use ClientFactoryOptions.of().meterRegistry() instead of PrometheusMeterRegistries.newRegistry(), so that the default registry is chosen automatically?", "author": "trustin", "createdAt": "2020-09-09T00:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMTM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex 9bcf1fb74..973aaded9 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -599,9 +598,8 @@ public final class ClientFactoryBuilder {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n                         return builder\n-                                .meterRegistry(options.containsKey(ClientFactoryOptions.METER_REGISTRY) ?\n-                                        (MeterRegistry) options.get(ClientFactoryOptions.METER_REGISTRY).value()\n-                                        : PrometheusMeterRegistries.newRegistry()).build(eventLoopGroup);\n+                                .meterRegistry(ClientFactoryOptions.of().meterRegistry())\n+                                .build(eventLoopGroup);\n                     };\n             return ClientFactoryOptions.ADDRESS_RESOLVER_GROUP_FACTORY.newValue(addressResolverGroupFactory);\n         });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r484202094", "bodyText": "Shouldn't SERVER_TAG be replaced with SERVERS_TAG (\"servers\")?", "author": "trustin", "createdAt": "2020-09-07T06:12:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.prometheus.PrometheusMeterRegistry;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private final PrometheusMeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link PrometheusMeterRegistry} PrometheusMeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = (PrometheusMeterRegistry)meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVER_TAG,", "originalCommit": "6129f8a064a38c572db68762f0b3039daa69c31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzE4Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r485233182", "bodyText": "Yes I will make the change", "author": "amitvc", "createdAt": "2020-09-08T22:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwMjA5NA=="}], "type": "inlineReview", "revised_code": {"commit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 99049352d..641e0281e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -24,7 +24,6 @@ import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n-import io.micrometer.prometheus.PrometheusMeterRegistry;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.handler.codec.dns.DnsResponseCode;\n"}}, {"oid": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "url": "https://github.com/line/armeria/commit/b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "message": "Removed prometheus registry dependency and minor cleanup", "committedDate": "2020-09-10T04:17:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053200", "bodyText": "I do not see any metrics being recorded for this test. Where as if I pass in an external PrometheusMeterRegistries like I did in the other unit tests then I see the counters being incremented. Am I missing something here ?\n{armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.connections.lifespan#count{protocol=h1c}=0.0, armeria.client.connections.lifespan#total{protocol=h1c}=0.0, armeria.client.connections.lifespan#max{protocol=h1c}=0.0, armeria.client.dns.queries.written#count{name=google.com.,servers=2001:558:feed:0:0:0:0:1}=0.0, armeria.client.dns.queries#count{cause=none,name=google.com.,result=success}=0.0}", "author": "amitvc", "createdAt": "2020-09-10T04:19:10Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1Mzk4Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053983", "bodyText": "No you didn't miss out anything. This is a test case, so we need to specify a concrete meter registry implementation, like you did before. My comment about removing the PrometheusMeterRegistry was for the main sources, not the test sources. Sorry if it was confusing. \ud83d\ude47", "author": "trustin", "createdAt": "2020-09-10T04:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTIzMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486745233", "bodyText": "Ok. In a real use case how do we pass the meterRegistry down to the ClientFactory? Currently, we have the ClientFactoryBuilder::buildOptions method is where we set the meterRegistry in the DnsResolverGroupBuilder used for the factory. We do something like this\nbuilder\n.meterRegistry(ClientFactoryOptions.of().meterRegistry())\n.build(eventLoopGroup);\nClientFactoryOptions.of().meterRegistry() uses the default Metrics.globalRegistry.\nFor the UT I was creating DnsResolverGroupBuilder and setting a new PrometheusMeterRegistries into that object. Then I was using the DnsResolverGroupBuilder i just built and doing something like this\ntry (ClientFactory factory = ClientFactory.builder()\n.addressResolverGroupFactory(builder::build", "author": "amitvc", "createdAt": "2020-09-11T03:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1ODYxNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486758615", "bodyText": "Ah, of course we should use ClientFacrotyOptions.of().meterRegistry() only when a user did not specify one, i.e. should use options.getOrDefault().", "author": "trustin", "createdAt": "2020-09-11T03:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "084d9afad082712ba185ec3c65388b9bb95ad40c", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex 662825a96..d27de315c 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -196,15 +217,22 @@ public class DnsMetricsTest {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-\n-        try (ClientFactory factory = ClientFactory.builder().build()) {\n+        try (ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n             client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n-            final MeterRegistry registry = factory.meterRegistry();\n-            System.out.println(MoreMeters.measureAll(registry));\n+            final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+\n+            final double count = registry.getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"none\",\n+                                    \"google.com.\", \"success\"});\n+            assertThat(count > 1.0).isTrue();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzE0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053144", "bodyText": "You have to use SERVER_TAG here because this tag is for a single name server. \ud83d\ude09", "author": "trustin", "createdAt": "2020-09-10T04:18:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -61,7 +60,7 @@\n     public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n         meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n                 Arrays.asList(Tag.of(NAME_TAG, question.name()),\n-                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+                        Tag.of(SERVERS_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "084d9afad082712ba185ec3c65388b9bb95ad40c", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 641e0281e..15539b938 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -60,7 +80,7 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n         meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n                 Arrays.asList(Tag.of(NAME_TAG, question.name()),\n-                        Tag.of(SERVERS_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053244", "bodyText": "Bring the assertions back?", "author": "trustin", "createdAt": "2020-09-10T04:19:22Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n-            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://wikipedia.com\")).aggregate().get();\n-            final PrometheusMeterRegistry registry =\n-                    (PrometheusMeterRegistry) factory.meterRegistry();\n-\n-            final double count = registry.getPrometheusRegistry()\n-                    .getSampleValue(\"armeria_client_dns_queries_total\",\n-                            new String[] {\"cause\",\"name\",\"result\"},\n-                            new String[] {\"none\",\"wikipedia.com.\", \"success\"});\n-            assertThat(count > 1.0).isTrue();\n+            client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n+            final MeterRegistry registry = factory.meterRegistry();\n+            System.out.println(MoreMeters.measureAll(registry));", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NTI4Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486745287", "bodyText": "Yes I will bring it back.", "author": "amitvc", "createdAt": "2020-09-11T03:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "084d9afad082712ba185ec3c65388b9bb95ad40c", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex 662825a96..d27de315c 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -196,15 +217,22 @@ public class DnsMetricsTest {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-\n-        try (ClientFactory factory = ClientFactory.builder().build()) {\n+        try (ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n             client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n-            final MeterRegistry registry = factory.meterRegistry();\n-            System.out.println(MoreMeters.measureAll(registry));\n+            final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+\n+            final double count = registry.getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"none\",\n+                                    \"google.com.\", \"success\"});\n+            assertThat(count > 1.0).isTrue();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MzU4Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r486053582", "bodyText": "You can still use PrometheusMeterRegistries.newRegistry() here because this class is a test class, i.e. You can revert the changes in this class.", "author": "trustin", "createdAt": "2020-09-10T04:20:49Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -195,24 +196,15 @@ void dns_test_no_answer() throws ExecutionException, InterruptedException {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-        final MeterRegistry pm1 = PrometheusMeterRegistries.newRegistry();\n \n-        try (ClientFactory factory = ClientFactory.builder()\n-                .meterRegistry(pm1)\n-                .build()) {\n+        try (ClientFactory factory = ClientFactory.builder().build()) {", "originalCommit": "b2a51aeb4c6fd5baa7f6c1054c2d90e24d439379", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "084d9afad082712ba185ec3c65388b9bb95ad40c", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex 662825a96..d27de315c 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -196,15 +217,22 @@ public class DnsMetricsTest {\n \n     @Test\n     void test_with_real_dns_query() throws ExecutionException, InterruptedException {\n-\n-        try (ClientFactory factory = ClientFactory.builder().build()) {\n+        try (ClientFactory factory = ClientFactory.builder()\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())\n+                .build()) {\n             final WebClient client2 = WebClient.builder()\n                     .factory(factory)\n                     .build();\n \n             client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://google.com\")).aggregate().get();\n-            final MeterRegistry registry = factory.meterRegistry();\n-            System.out.println(MoreMeters.measureAll(registry));\n+            final PrometheusMeterRegistry registry = (PrometheusMeterRegistry) factory.meterRegistry();\n+\n+            final double count = registry.getPrometheusRegistry()\n+                    .getSampleValue(\"armeria_client_dns_queries_total\",\n+                            new String[] {\"cause\",\"name\",\"result\"},\n+                            new String[] {\"none\",\n+                                    \"google.com.\", \"success\"});\n+            assertThat(count > 1.0).isTrue();\n         }\n     }\n \n"}}, {"oid": "084d9afad082712ba185ec3c65388b9bb95ad40c", "url": "https://github.com/line/armeria/commit/084d9afad082712ba185ec3c65388b9bb95ad40c", "message": "code to categorize dns exceptions, cleanup unit tests", "committedDate": "2020-09-13T14:32:39Z", "type": "commit"}, {"oid": "25d4e0944fc4ff6da8d371f008c8314584f35c4c", "url": "https://github.com/line/armeria/commit/25d4e0944fc4ff6da8d371f008c8314584f35c4c", "message": "Fix UT for RefreshingAddressResolverTest", "committedDate": "2020-09-13T16:01:58Z", "type": "commit"}, {"oid": "593fe20ec4e78237b3943e900b91c308f490ebba", "url": "https://github.com/line/armeria/commit/593fe20ec4e78237b3943e900b91c308f490ebba", "message": "fix failing ut", "committedDate": "2020-09-16T00:58:16Z", "type": "commit"}, {"oid": "744beaf10990521be775265eb98049c8e4f140d3", "url": "https://github.com/line/armeria/commit/744beaf10990521be775265eb98049c8e4f140d3", "message": "Add debug code to investigate failing ut on CI pipeline", "committedDate": "2020-09-16T01:52:59Z", "type": "commit"}, {"oid": "34b8c5fff113c58f61490b1b203a8783ca2818a2", "url": "https://github.com/line/armeria/commit/34b8c5fff113c58f61490b1b203a8783ca2818a2", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-10-07T07:53:25Z", "type": "commit"}, {"oid": "4598719e5b45c0d715b485632293b24cc9d27744", "url": "https://github.com/line/armeria/commit/4598719e5b45c0d715b485632293b24cc9d27744", "message": "Trying to figure out which is null", "committedDate": "2020-10-07T08:55:06Z", "type": "commit"}, {"oid": "4598719e5b45c0d715b485632293b24cc9d27744", "url": "https://github.com/line/armeria/commit/4598719e5b45c0d715b485632293b24cc9d27744", "message": "Trying to figure out which is null", "committedDate": "2020-10-07T08:55:06Z", "type": "forcePushed"}, {"oid": "9aa502f6566931169e84ef79287e62d5c33034ff", "url": "https://github.com/line/armeria/commit/9aa502f6566931169e84ef79287e62d5c33034ff", "message": "Fix test failures\n\n- Use `MoreMeters.measureAll()` which is more convenient for testing.\n  - Fixed a `NullPointerException` which occurs when unboxing `Double`.\n    - `null` is returned instead of `Double` when a meter is missing.\n- Use `await()` where necessary.\n- Add a test case for `NXDOMAIN`", "committedDate": "2020-10-07T11:20:53Z", "type": "commit"}, {"oid": "6028e40959ecd997cf01b4e2516203d9c89bfd69", "url": "https://github.com/line/armeria/commit/6028e40959ecd997cf01b4e2516203d9c89bfd69", "message": "Remove flaky test method / Shorten the timeout", "committedDate": "2020-10-07T11:48:16Z", "type": "commit"}, {"oid": "932575fe080f1519d32dce0c8733975b9f8516c3", "url": "https://github.com/line/armeria/commit/932575fe080f1519d32dce0c8733975b9f8516c3", "message": "Adding unit test for cname", "committedDate": "2020-10-09T13:33:31Z", "type": "commit"}, {"oid": "cd789c06ec86cba2a89eb79a410cfda6adde4357", "url": "https://github.com/line/armeria/commit/cd789c06ec86cba2a89eb79a410cfda6adde4357", "message": "Fix timeout ut for dns metrics", "committedDate": "2020-10-09T19:40:51Z", "type": "commit"}, {"oid": "d55ee3f168892cb3b0a69b75e848c0d8a8568a03", "url": "https://github.com/line/armeria/commit/d55ee3f168892cb3b0a69b75e848c0d8a8568a03", "message": "Remove NAME_SERVERS_EXHAUSTED_EXCEPTION exception assertion from noAnswer ut", "committedDate": "2020-10-14T01:23:09Z", "type": "commit"}, {"oid": "6409f1ce95cd97099c79bfbdffe7699bf5491856", "url": "https://github.com/line/armeria/commit/6409f1ce95cd97099c79bfbdffe7699bf5491856", "message": "Change the loopback address to ipv4 instead of ipv6", "committedDate": "2020-10-14T02:05:02Z", "type": "commit"}, {"oid": "c7b9f15834f26408ce5a254bba5d4b60558e3a9c", "url": "https://github.com/line/armeria/commit/c7b9f15834f26408ce5a254bba5d4b60558e3a9c", "message": "Fix unit test for timeout", "committedDate": "2020-10-17T04:24:53Z", "type": "commit"}, {"oid": "8428c533153b0d9284668f5b0a2cde09508a8b36", "url": "https://github.com/line/armeria/commit/8428c533153b0d9284668f5b0a2cde09508a8b36", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-11-02T01:57:12Z", "type": "commit"}, {"oid": "5bd61790c1672d8f2ef33bb957516cf85505d564", "url": "https://github.com/line/armeria/commit/5bd61790c1672d8f2ef33bb957516cf85505d564", "message": "Fix flakiness", "committedDate": "2020-11-02T02:45:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716602", "bodyText": "How about inlining this method? It's used only in determineDNSExceptionTag.", "author": "trustin", "createdAt": "2020-11-02T02:50:27Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.DNS_TIMEOUT_EXCEPTION;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.DNS_RESOLVER_TIMEOUT_EXCEPTION;\n+        }\n+        return discoverExceptionType(cause.getMessage());\n+    }\n+\n+    private static DnsExceptionTypes discoverExceptionType(String message) {", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNDczOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516434739", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-03T05:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYwMg=="}], "type": "inlineReview", "revised_code": {"commit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 15539b938..3204ac541 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -21,6 +21,8 @@ import java.util.List;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import com.google.common.base.Ascii;\n+\n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjYzMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515716633", "bodyText": "DNS -> Dns (convention)", "author": "trustin", "createdAt": "2020-11-02T02:50:41Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDNSExceptionTag(Throwable cause) {", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 15539b938..3204ac541 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -21,6 +21,8 @@ import java.util.List;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import com.google.common.base.Ascii;\n+\n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNzkxMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515717911", "bodyText": "How about:\n\nremoving _QUERY_FAILED, _EXCEPTION and DNS_ from all values? e.g.\n\nNX_DOMAIN_QUERY_FAILED_EXCEPTION -> NX_DOMAIN\nDNS_TIMEOUT_EXCEPTION -> TIMEOUT\n\n\nrenaming DNS_EXCEPTION to OTHERS?\nrenaming DNS_TIMEOUT_EXCEPTION to SERVER_TIMEOUT so a user can distinguish it better from RESOLVER_TIMEOUT?\nproviding lower-cased values so we can use them as tag values? i.e.\nprivate enum DnsExceptionTypes {\n    ...;\n\n    final String lowerCasedName;\n\n    DnsExceptionTypes() {\n        tag = Ascii.toLowerCase(name());\n    }\n}\n...\n\nTag.of(CAUSE_TAG, type.lowerCasedName)", "author": "trustin", "createdAt": "2020-11-02T02:57:09Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 15539b938..3204ac541 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -21,6 +21,8 @@ import java.util.List;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import com.google.common.base.Ascii;\n+\n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxODkwNA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515718904", "bodyText": "I guess almost all failed queries will end up getting NAME_SERVERS_EXHAUSTED_EXCEPTION, which means it's a kind of duplicate. Could we ignore it until we have a clear reason why we would want to record it?", "author": "trustin", "createdAt": "2020-11-02T03:02:10Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+        NX_DOMAIN_QUERY_FAILED_EXCEPTION,\n+        CNAME_NOT_FOUND_QUERY_FAILED_EXCEPTION,\n+        NO_MATCHING_RECORD_QUERY_FAILED_EXCEPTION,\n+        UNRECOGNIZED_TYPE_QUERY_FAILED_EXCEPTION,\n+        NAME_SERVERS_EXHAUSTED_EXCEPTION,\n+        DNS_EXCEPTION,\n+        DNS_TIMEOUT_EXCEPTION,\n+        DNS_RESOLVER_TIMEOUT_EXCEPTION\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDNSExceptionTag(cause).name()))).increment();", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 15539b938..3204ac541 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -21,6 +21,8 @@ import java.util.List;\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n+import com.google.common.base.Ascii;\n+\n import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTMyOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r515719329", "bodyText": "If we're going to make this class public, we have to hide it from the public API. Could you move this class to internal.client? We could also merge it into internal.client.DnsUtil.", "author": "trustin", "createdAt": "2020-11-02T03:04:38Z", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {\n \n-    static void encodeName(String name, ByteBuf out) {\n+    public static void encodeName(String name, ByteBuf out) {", "originalCommit": "5bd61790c1672d8f2ef33bb957516cf85505d564", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java b/core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java\ndeleted file mode 100644\nindex 5858e908d..000000000\n--- a/core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java\n+++ /dev/null\n\n@@ -1,44 +0,0 @@\n-/*\n- * Copyright 2018 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.linecorp.armeria.client.endpoint.dns;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n-\n-public final class DnsNameEncoder {\n-\n-    public static void encodeName(String name, ByteBuf out) {\n-        DefaultDnsRecordEncoderTrampoline.INSTANCE.encodeName(name, out);\n-    }\n-\n-    private DnsNameEncoder() {}\n-\n-    // Hacky trampoline class to be able to access encodeName\n-    private static class DefaultDnsRecordEncoderTrampoline extends DefaultDnsRecordEncoder {\n-\n-        private static final DefaultDnsRecordEncoderTrampoline INSTANCE =\n-                new DefaultDnsRecordEncoderTrampoline();\n-\n-        @Override\n-        protected void encodeName(String name, ByteBuf buf) {\n-            try {\n-                super.encodeName(name, buf);\n-            } catch (Exception e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-    }\n-}\n"}}, {"oid": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "url": "https://github.com/line/armeria/commit/5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "message": "Removed DnsNameEncoder and reconciled the code to DnsUtil, Cleaned up DnsExceptionTypes enum for better readability", "committedDate": "2020-11-03T05:28:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516437289", "bodyText": "How about just using Metrics.globalRegistry?\nBecause I have to track down which registry will be used if it's not specified.\nfinal MeterRegistry registry;\nfinal ClientFactoryOptionValue<?> opt = options.get(\n        ClientFactoryOptions.METER_REGISTRY);\nif (opt != null) {\n    registry = (MeterRegistry) opt.value();\n} else {\n    registry = Metrics.globalRegistry;\n}\n\nreturn builder.meterRegistry(registry)\n              .build(eventLoopGroup);", "author": "minwoox", "createdAt": "2020-11-03T05:41:42Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1NzYwMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516457600", "bodyText": "It's basically same. I suggested this so that we can use the default MeterRegistry defined in ClientFactoryOptions, but I'm fine with @minwoox's suggestion given our default will not change.", "author": "trustin", "createdAt": "2020-11-03T07:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODM1OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458359", "bodyText": "I'm fine as it is. \ud83d\ude04  Just don't forget to indent the line. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-03T07:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MjY1Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517042657", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-04T01:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzNzI4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex ac6375514..175bb3384 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -619,8 +619,9 @@ public final class ClientFactoryBuilder {\n \n                         final ClientFactoryOptionValue<?> opt = options\n                                 .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n-                                ClientFactoryOptions.METER_REGISTRY\n-                                        .newValue(ClientFactoryOptions.of().meterRegistry()));\n+                                ClientFactoryOptions\n+                                .METER_REGISTRY\n+                                .newValue(ClientFactoryOptions.of().meterRegistry()));\n \n                         return builder\n                                 .meterRegistry((MeterRegistry) opt.value())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516439463", "bodyText": "THis is not used. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-11-03T05:51:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MjcyNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517042725", "bodyText": "\ud83d\ude04 Done.", "author": "amitvc", "createdAt": "2020-11-04T01:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMDQwNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519600405", "bodyText": "This needs to be brought back so that it doesn't fall into 'OTHERS' case.", "author": "trustin", "createdAt": "2020-11-09T07:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQzOTQ2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 3204ac541..6b3c8df55 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -27,6 +27,7 @@ import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.handler.codec.dns.DnsResponseCode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442260", "bodyText": "I think we should set this in DnsResolverGroupBuilder so that this factory is not overridden by the observer factory that the user configures.", "author": "minwoox", "createdAt": "2020-11-03T06:04:01Z", "path": "core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java", "diffHunk": "@@ -127,6 +133,9 @@\n         assert executor instanceof EventLoop;\n         final EventLoop eventLoop = (EventLoop) executor;\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n+        builder.dnsQueryLifecycleObserverFactory(", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzM2MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043361", "bodyText": "Can you please elaborate on this? You mean set the dnsQueryLifecycleObserverFactory in the DnsResolverGroupBuilder::build method ?", "author": "amitvc", "createdAt": "2020-11-04T01:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0ODE1OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517048159", "bodyText": "Sure. \ud83d\ude04\nAfter we set the observer factory resolverConfigurator.accept(builder); at line 139 is called.\nIn that method, another observer factory might be set\nhttps://github.com/line/armeria/blob/master/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java#L332\nSo I think we can do sort of:\nfinal DnsQueryLifecycleObserverFactory defaultObserverFactory =\n        new DefaultDnsQueryLifecycleObserverFactory(\n                meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));\nif (dnsQueryLifecycleObserverFactory == null) {\n    builder.dnsQueryLifecycleObserverFactory(defaultObserverFactory);\n} else {\n    builder.dnsQueryLifecycleObserverFactory(\n            new SomeWrapper(defaultObserverFactory, dnsQueryLifecycleObserverFactory));\n}", "author": "minwoox", "createdAt": "2020-11-04T01:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0OTEyMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517049121", "bodyText": "And we might need to add a boolean parameter to the setter so that a user can choose the behavior?\nDnsResolverGrouBuilder.dnsQueryLifecycleObserverFactory(observerFactory, overrideDefaultFactory)\nI'm not sure if it's a good idea though. \ud83d\ude05\nDo you have any suggestion? @trustin, @ikhoon", "author": "minwoox", "createdAt": "2020-11-04T01:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyNzY2OA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r518727668", "bodyText": "@trustin @ikhoon  can you please comment when you get a chance?", "author": "amitvc", "createdAt": "2020-11-06T12:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxNjc2Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519516766", "bodyText": "Sorry for the late reply. Let me take a look.", "author": "ikhoon", "createdAt": "2020-11-09T02:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTA4NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599084", "bodyText": "How about moving the modifications in this class to DnsResolverGroupBuilder, so that:\n\nRefreshingAddressResolverGroup doesn't change.\nDnsResolverGroupBuilder creates the default observer factory;\nDnsResolverGroupBuilder.build() creates the resolverConfigurator that calls DnsNameResolverBuilder.dnsQueryLifecycleObserverFactory() with the default observer factory.\n\nUse io.netty.resolver.dns.BiDnsQueryLifecycleObserverFactory to combine the default observer factory and the user-specified observer factory.\n\n\n\nMakes sense?", "author": "trustin", "createdAt": "2020-11-09T07:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMjc0Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519602742", "bodyText": "I didn't know there was BiDnsQueryLifecycleObserverFactory \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-09T07:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java b/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\nindex 507d4d4f7..9ed2cc9a3 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/RefreshingAddressResolverGroup.java\n\n@@ -135,7 +135,7 @@ final class RefreshingAddressResolverGroup extends AddressResolverGroup<InetSock\n         final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop);\n         builder.dnsQueryLifecycleObserverFactory(\n                 new DefaultDnsQueryLifecycleObserverFactory(meterRegistry,\n-                        new MeterIdPrefix(\"armeria.client.dns.queries\")));\n+                new MeterIdPrefix(\"armeria.client.dns.queries\")));\n         resolverConfigurator.accept(builder);\n         final DefaultDnsNameResolver resolver = new DefaultDnsNameResolver(builder.build(), eventLoop,\n                                                                            queryTimeoutMillis);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516442695", "bodyText": "Let's remove this return statement and just do:\nSets {@link MeterRegistry} to collect the DNS query metrics.", "author": "minwoox", "createdAt": "2020-11-03T06:05:45Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -292,6 +295,16 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets MeterRegistry.\n+     * @param meterRegistry {@link MeterRegistry}.\n+     * @return DnsResolverGroupBuilder.", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzM3OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043379", "bodyText": "done", "author": "amitvc", "createdAt": "2020-11-04T01:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MjY5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\nindex 85fd9ae75..ad4faf245 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n\n@@ -296,9 +296,7 @@ public final class DnsResolverGroupBuilder {\n     }\n \n     /**\n-     * Sets MeterRegistry.\n-     * @param meterRegistry {@link MeterRegistry}.\n-     * @return DnsResolverGroupBuilder.\n+     * Sets {@link MeterRegistry} to collect the DNS query metrics.\n      */\n     DnsResolverGroupBuilder meterRegistry(MeterRegistry meterRegistry) {\n         this.meterRegistry = meterRegistry;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzE3NQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443175", "bodyText": "Could you check the indentation of this class?", "author": "minwoox", "createdAt": "2020-11-03T06:07:44Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 3204ac541..6b3c8df55 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -27,6 +27,7 @@ import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.handler.codec.dns.DnsResponseCode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516443351", "bodyText": "Let's just use + as IDEA suggested which is more readable:\nmeterIdPrefix.name() + \".written\"", "author": "minwoox", "createdAt": "2020-11-03T06:08:35Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzQwNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043405", "bodyText": "done", "author": "amitvc", "createdAt": "2020-11-04T01:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MzM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 3204ac541..6b3c8df55 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -27,6 +27,7 @@ import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.handler.codec.dns.DnsResponseCode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516444740", "bodyText": "Perhaps we can make Tag.of(NAME_TAG, question.name()) in the constructor and reuse it?", "author": "minwoox", "createdAt": "2020-11-03T06:13:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4MTM1OA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517081358", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-11-04T03:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NDc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 3204ac541..6b3c8df55 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -27,6 +27,7 @@ import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.handler.codec.dns.DnsResponseCode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445444", "bodyText": "Can we remove this CAUSE_TAG?", "author": "minwoox", "createdAt": "2020-11-03T06:16:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern NS_EXHAUSTED_EXCEPTION = Pattern.compile(\"\\\\bname\\\\sservers\\\\b\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final DnsQuestion question;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        this.question = question;\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".written\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress()))).increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cancelled\"),\n+                NAME_TAG, question.name()).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".redirected\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(SERVERS_TAG,\n+                        nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                                .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".cnamed\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name().concat(\".noanswer\"),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()),\n+                        Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"failure\"),\n+                        Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                Arrays.asList(Tag.of(NAME_TAG, question.name()), Tag.of(RESULT_TAG, \"success\"),\n+                        Tag.of(CAUSE_TAG, \"none\"))).increment();", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODA0Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458042", "bodyText": "Can we? queryFailed() uses the same meter name, so we have to keep the same set of tags.", "author": "trustin", "createdAt": "2020-11-03T07:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODY3Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458677", "bodyText": "Oops, I missed that. \ud83d\ude05", "author": "minwoox", "createdAt": "2020-11-03T07:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTQ0NA=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 3204ac541..6b3c8df55 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -27,6 +27,7 @@ import com.linecorp.armeria.common.metric.MeterIdPrefix;\n \n import io.micrometer.core.instrument.MeterRegistry;\n import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.dns.DnsQuestion;\n import io.netty.handler.codec.dns.DnsResponseCode;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516445936", "bodyText": "How about moving this method and the class to a test class because they are only used by tests?", "author": "minwoox", "createdAt": "2020-11-03T06:19:03Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java", "diffHunk": "@@ -98,4 +99,24 @@ public static void warnInvalidRecord(Logger logger, String logPrefix, DnsRecordT\n     }\n \n     private DnsUtil() {}\n+\n+    public static void encodeName(String name, ByteBuf out) {", "originalCommit": "5cc124f460b4f7ccc7012bcf62cd9316cc3e7a4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ1ODUxMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r516458510", "bodyText": "Ahh, never knew that this is used only by test classes. Sorry, @amitvc, but could we revert this?", "author": "trustin", "createdAt": "2020-11-03T07:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA0MzU0Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r517043547", "bodyText": "No problem @trustin. I reverted this particular change.", "author": "amitvc", "createdAt": "2020-11-04T01:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4ODQyMQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519588421", "bodyText": "Thanks, @amitvc \ud83d\ude47", "author": "trustin", "createdAt": "2020-11-09T07:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTkzNg=="}], "type": "inlineReview", "revised_code": {"commit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java b/core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java\nindex db1d4e479..411be56df 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/DnsUtil.java\n\n@@ -99,24 +98,4 @@ public final class DnsUtil {\n     }\n \n     private DnsUtil() {}\n-\n-    public static void encodeName(String name, ByteBuf out) {\n-        DefaultDnsRecordEncoderTrampoline.INSTANCE.encodeName(name, out);\n-    }\n-\n-    // Hacky trampoline class to be able to access encodeName\n-    private static class DefaultDnsRecordEncoderTrampoline extends DefaultDnsRecordEncoder {\n-\n-        private static final DefaultDnsRecordEncoderTrampoline INSTANCE =\n-                new DefaultDnsRecordEncoderTrampoline();\n-\n-        @Override\n-        protected void encodeName(String name, ByteBuf buf) {\n-            try {\n-                super.encodeName(name, buf);\n-            } catch (Exception e) {\n-                throw new IllegalStateException(e);\n-            }\n-        }\n-    }\n }\n"}}, {"oid": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "url": "https://github.com/line/armeria/commit/8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "message": "Fix indentation, revert deleted code, initializing name tag for reuse", "committedDate": "2020-11-04T01:08:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519589596", "bodyText": "This seems unused as well \ud83d\ude09", "author": "trustin", "createdAt": "2020-11-09T07:11:51Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTY4MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801680", "bodyText": "Yes. I have removed it.", "author": "amitvc", "createdAt": "2020-11-12T03:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4OTU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590018", "bodyText": "How about keeping the names as member fields so we don't have to do string concatenation every time?", "author": "trustin", "createdAt": "2020-11-09T07:13:00Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTc2Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801767", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-12T03:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDAxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590323", "bodyText": "else is redundant.", "author": "trustin", "createdAt": "2020-11-09T07:13:46Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMTgzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521801836", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-12T03:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519590784", "bodyText": "Shouldn't we ignore the 'exhausted name servers' error here instead of returning OTHERS, so that the counter doesn't increase?", "author": "trustin", "createdAt": "2020-11-09T07:14:39Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),\n+                              Tag.of(CAUSE_TAG, \"none\"))).increment();\n+    }\n+\n+    private static DnsExceptionTypes determineDnsExceptionTag(Throwable cause) {\n+        if (cause instanceof DnsTimeoutException) {\n+            return DnsExceptionTypes.SERVER_TIMEOUT;\n+        } else if (cause instanceof DnsNameResolverTimeoutException) {\n+            return DnsExceptionTypes.RESOLVER_TIMEOUT;\n+        }\n+        final String message = cause.getMessage();\n+        if (NXDOMAIN_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NX_DOMAIN;\n+        }\n+\n+        if (CNAME_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.CNAME_NOT_FOUND;\n+        }\n+\n+        if (NO_MATCHING_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.NO_MATCHING_RECORD;\n+        }\n+\n+        if (UNRECOGNIZED_TYPE_EXCEPTION.matcher(message).find()) {\n+            return DnsExceptionTypes.UNRECOGNIZED_TYPE;\n+        }\n+", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgwMDgzNg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521800836", "bodyText": "Are you suggesting exhausted name servers exception should not be tagged in a counter that is incremented queryFailed callback ?\nI am also noticing this exception is being thrown \"No name servers returned an answer\" but we capture it as other. Don't know what we want to do here.", "author": "amitvc", "createdAt": "2020-11-12T03:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3NTEyOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r523975129", "bodyText": "Are you suggesting exhausted name servers exception should not be tagged in a counter that is incremented queryFailed callback ?\n\nYes, but see below:\n\nI am also noticing this exception is being thrown \"No name servers returned an answer\" but we capture it as other. Don't know what we want to do here.\n\nThat's a good point. Is it possible to count \"No name servers returned an answer\" as a separate counter, and ignore other 'exhausted name servers' exceptions?", "author": "trustin", "createdAt": "2020-11-16T08:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODQ4NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r524868484", "bodyText": "I have added a new tag for \"No name servers returned an answer\"", "author": "amitvc", "createdAt": "2020-11-17T03:55:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4NDE0NA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r524884144", "bodyText": "@trustin Sorry for the confusion the \"No name servers returned an answer\" is basically NAME_SERVERS_EXHAUSTED_EXCEPTION returned by the DnsResolveContext[netty class] that we had agreed to ignore.", "author": "amitvc", "createdAt": "2020-11-17T04:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5MDc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r519599835", "bodyText": "Global comment: Could we also make sure that no other unexpected counters are created or increased for all test cases? e.g. the meter with cause=others should be 0 or non-existent.", "author": "trustin", "createdAt": "2020-11-09T07:27:47Z", "path": "core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import static com.linecorp.armeria.client.endpoint.dns.TestDnsServer.newAddressRecord;\n+import static io.netty.handler.codec.dns.DnsRecordType.A;\n+import static io.netty.handler.codec.dns.DnsRecordType.AAAA;\n+import static io.netty.handler.codec.dns.DnsRecordType.CNAME;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.netty.handler.codec.dns.DnsSection.ANSWER;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+import static org.awaitility.Awaitility.await;\n+\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import com.linecorp.armeria.client.endpoint.dns.DnsNameEncoder;\n+import com.linecorp.armeria.client.endpoint.dns.TestDnsServer;\n+import com.linecorp.armeria.common.HttpMethod;\n+import com.linecorp.armeria.common.RequestHeaders;\n+import com.linecorp.armeria.common.metric.MoreMeters;\n+import com.linecorp.armeria.common.metric.PrometheusMeterRegistries;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.codec.dns.DatagramDnsQuery;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DefaultDnsRawRecord;\n+import io.netty.handler.codec.dns.DefaultDnsResponse;\n+import io.netty.handler.codec.dns.DnsOpCode;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DnsServerAddressStreamProvider;\n+import io.netty.resolver.dns.DnsServerAddresses;\n+import io.netty.util.ReferenceCountUtil;\n+\n+public class DnsMetricsTest {\n+\n+    @Test\n+    void success() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+                        .addRecord(ANSWER, newAddressRecord(\"unrelated.com\", \"1.2.3.4\")),\n+                new DefaultDnsQuestion(\"foo.com.\", AAAA),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"::1\"))\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String successMeterId =\n+                        \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId, successMeterId);\n+\n+                client.get(\"http://foo.com:1/\").aggregate();\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writeMeterId, 1.0)\n+                            .containsEntry(successMeterId, 1.0);\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void timeout() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"foo.com.\", A),\n+                new DefaultDnsResponse(0).addRecord(ANSWER, newAddressRecord(\"foo.com.\", \"127.0.0.1\"))\n+        ), new AlwaysTimeoutHandler())) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                        builder.queryTimeout(Duration.ofSeconds(1));\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client2 = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writeMeterId_ipv4_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=127.0.0.1}\";\n+                final String writeMeterId_ipv6_addr =\n+                        \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\";\n+                final String timeoutMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                assertThat(MoreMeters.measureAll(meterRegistry))\n+                        .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n+\n+                assertThatThrownBy(() -> client2.execute(RequestHeaders.of(HttpMethod.GET, \"http://foo.com\"))\n+                        .aggregate().join())\n+                        .hasCauseInstanceOf(UnprocessedRequestException.class)\n+                        .hasRootCauseExactlyInstanceOf(DnsTimeoutException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsAnyOf(entry(writeMeterId_ipv6_addr, 1.0),\n+                                    entry(writeMeterId_ipv4_addr, 1.0));\n+                });\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void nxDomain() {\n+        try (TestDnsServer server = new TestDnsServer(ImmutableMap.of(\n+                new DefaultDnsQuestion(\"bar.com.\", A),\n+                new DefaultDnsResponse(0, DnsOpCode.QUERY, DnsResponseCode.NXDOMAIN)\n+        ))) {\n+            final MeterRegistry meterRegistry = PrometheusMeterRegistries.newRegistry();\n+\n+            try (ClientFactory factory = ClientFactory.builder()\n+                    .domainNameResolverCustomizer(builder -> {\n+                        builder.dnsServerAddressStreamProvider(dnsServerList(server));\n+                        builder.searchDomains();\n+                        builder.resolvedAddressTypes(ResolvedAddressTypes.IPV4_ONLY);\n+                    })\n+                    .meterRegistry(meterRegistry)\n+                    .build()) {\n+\n+                final WebClient client = WebClient.builder()\n+                        .factory(factory)\n+                        .build();\n+\n+                final String writtenMeterId =\n+                        \"armeria.client.dns.queries.written#count{name=bar.com.,server=\" +\n+                        server.addr().getHostString() + '}';\n+                final String nxDomainMeterId =\n+                        \"armeria.client.dns.queries#count{\" +\n+                        \"cause=nx_domain,name=bar.com.,result=failure}\";\n+                assertThatThrownBy(() -> client.get(\"http://bar.com\").aggregate().join())\n+                        .hasRootCauseInstanceOf(UnknownHostException.class);\n+\n+                await().untilAsserted(() -> {\n+                    assertThat(MoreMeters.measureAll(meterRegistry))\n+                            .containsEntry(writtenMeterId, 2.0)\n+                            .containsEntry(nxDomainMeterId, 2.0);", "originalCommit": "8083589f4e7cfeee529d7e656ab85e5888c7cb3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk3Mjk1Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r523972957", "bodyText": "Gentle ping \ud83d\ude04", "author": "trustin", "createdAt": "2020-11-16T08:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg2ODc3OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r524868779", "bodyText": "I ran the test with some debug code to print the metric registry for each UT -\nThe results below confirm we do not see cause=others any more. Please ignore the no_name_server_found log. This output was added before I added fix to ignore no_name_server_found.\n----------------------------------------Running success----------------------------------------\n{armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}=1.0, armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}=1.0}\n----------------------------------------Running timeout----------------------------------------\n{armeria.client.dns.queries#count{cause=no_name_server_found,name=foo.com.,result=failure}=2.0, armeria.client.dns.queries#count{cause=resolver_timeout,name=foo.com.,result=failure}=1.0, armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}=1.0}\n----------------------------------------Running nxDomain----------------------------------------\n{armeria.client.dns.queries#count{cause=nx_domain,name=bar.com.,result=failure}=2.0, armeria.client.dns.queries#count{cause=no_name_server_found,name=bar.com.,result=failure}=3.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}\n22:46:37.220 [Test worker] DEBUG c.l.a.i.c.DefaultDnsNameResolver - [bar.com] Sending a DNS query: DnsQuestion(bar.com IN A)\n------------------------------------Running cname----------------------------------------\n{armeria.client.dns.queries.cnamed#count{cname=baz.com.,name=bar.com.}=1.0, armeria.client.connections.lifespan#count{protocol=h2c}=0.0, armeria.client.connections.lifespan#total{protocol=h2c}=0.0, armeria.client.connections.lifespan#max{protocol=h2c}=0.0, armeria.client.dns.queries#count{cause=none,name=bar.com.,result=success}=2.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}\n----------------------------------------Running noAnswer----------------------------------------\ncom.linecorp.armeria.client.RefreshingAddressResolver$CacheEntry$$Lambda$595/0x0000000800f9f040@710be18c\n{armeria.client.dns.queries.noanswer#count{code=10,name=bar.com.}=1.0, armeria.client.dns.queries#count{cause=nx_domain,name=bar.com.,result=failure}=1.0, armeria.client.dns.queries#count{cause=no_name_server_found,name=bar.com.,result=failure}=3.0, armeria.client.dns.queries.written#count{name=bar.com.,server=0:0:0:0:0:0:0:1}=2.0}", "author": "amitvc", "createdAt": "2020-11-17T03:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxOTgzMA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526619830", "bodyText": "Great, but could we automate the checks, like adding some assertions?", "author": "trustin", "createdAt": "2020-11-19T06:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTAyMjg0MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r529022841", "bodyText": "Yes I have added them now.", "author": "amitvc", "createdAt": "2020-11-23T21:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU5OTgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "chunk": "diff --git a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\nindex 01297ecb0..a198bc42c 100644\n--- a/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n+++ b/core/src/test/java/com/linecorp/armeria/client/DnsMetricsTest.java\n\n@@ -129,6 +129,9 @@ public class DnsMetricsTest {\n                 final String timeoutMeterId =\n                         \"armeria.client.dns.queries#count{\" +\n                         \"cause=resolver_timeout,name=foo.com.,result=failure}\";\n+                final String noNameServer =\n+                        \"armeria.client.dns.queries#count{cause=no_name_server_found,\" +\n+                        \"name=foo.com.,result=failure}\";\n                 assertThat(MoreMeters.measureAll(meterRegistry))\n                         .doesNotContainKeys(writeMeterId_ipv4_addr,writeMeterId_ipv6_addr, timeoutMeterId);\n \n"}}, {"oid": "4e6a235c83cecdd402ef5995d45ec218ac731252", "url": "https://github.com/line/armeria/commit/4e6a235c83cecdd402ef5995d45ec218ac731252", "message": "Merge master into 1887_dns_metrics_latest", "committedDate": "2020-11-12T01:46:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521776292", "bodyText": "Don't we need \\ after unrecognized?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n          \n          \n            \n                private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "author": "ikhoon", "createdAt": "2020-11-12T02:22:49Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");", "originalCommit": "4e6a235c83cecdd402ef5995d45ec218ac731252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzQ3OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797479", "bodyText": "Fixed.", "author": "amitvc", "createdAt": "2020-11-12T03:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NjI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777169", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"success\") and reuse?", "author": "ikhoon", "createdAt": "2020-11-12T02:25:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),\n+                              Tag.of(CAUSE_TAG, determineDnsExceptionTag(cause).lowerCasedName))).increment();\n+    }\n+\n+    @Override\n+    public void querySucceed() {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"success\"),", "originalCommit": "4e6a235c83cecdd402ef5995d45ec218ac731252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzM4OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797389", "bodyText": "Done", "author": "amitvc", "createdAt": "2020-11-12T03:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzE2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521777267", "bodyText": "How about creating a singleton instance for Tag.of(RESULT_TAG, \"failure\") and reuse?", "author": "ikhoon", "createdAt": "2020-11-12T02:26:15Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        NAME_SERVERS_EXHAUSTED,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".written\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))\n+                              .increment();\n+    }\n+\n+    @Override\n+    public void queryCancelled(int queriesRemaining) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cancelled\",\n+                              Tags.of(nameTag)).increment();\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryRedirected(List<InetSocketAddress> nameServers) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".redirected\",\n+                              Arrays.asList(nameTag, Tag.of(SERVERS_TAG,\n+                              nameServers.stream().map(addr -> addr.getAddress().getHostAddress())\n+                              .collect(Collectors.joining(\",\"))))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryCNAMEd(DnsQuestion cnameQuestion) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".cnamed\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CNAME_TAG, cnameQuestion.name()))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public DnsQueryLifecycleObserver queryNoAnswer(DnsResponseCode code) {\n+        meterRegistry.counter(meterIdPrefix.name() + \".noanswer\",\n+                              Arrays.asList(nameTag,\n+                              Tag.of(CODE_TAG, String.valueOf(code.intValue())))).increment();\n+        return this;\n+    }\n+\n+    @Override\n+    public void queryFailed(Throwable cause) {\n+        meterRegistry.counter(meterIdPrefix.name(),\n+                              Arrays.asList(nameTag, Tag.of(RESULT_TAG, \"failure\"),", "originalCommit": "4e6a235c83cecdd402ef5995d45ec218ac731252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc5NzMyMg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r521797322", "bodyText": "Done.", "author": "amitvc", "createdAt": "2020-11-12T03:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3NzI2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6b3c8df55..403c9d905 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -49,11 +49,18 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n     private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n \n     private final MeterRegistry meterRegistry;\n     private final MeterIdPrefix meterIdPrefix;\n     private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n \n     private enum DnsExceptionTypes {\n \n"}}, {"oid": "c87bff10cf7978200b5cce4469d3096ad01a01bf", "url": "https://github.com/line/armeria/commit/c87bff10cf7978200b5cce4469d3096ad01a01bf", "message": "addressing several code review comments - Moved meterRegistry from RefreshingAddressResolverGroup, move initialization of DefaultDnsQueryLifecycleObserverFactory to DnsResolverGroupBuilder", "committedDate": "2020-11-12T03:23:45Z", "type": "commit"}, {"oid": "48c4621c689b0c9e39b88f58c5f1ba2489679d3d", "url": "https://github.com/line/armeria/commit/48c4621c689b0c9e39b88f58c5f1ba2489679d3d", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-11-16T08:40:15Z", "type": "commit"}, {"oid": "e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "url": "https://github.com/line/armeria/commit/e67f3f650a8a2ca5eb7677ffbebd075ecff5d136", "message": "Added no name server tag to the counters and ut for it", "committedDate": "2020-11-17T03:54:54Z", "type": "commit"}, {"oid": "eee42f7ce0241a3edfb8ea9ca3d76efcfe190df9", "url": "https://github.com/line/armeria/commit/eee42f7ce0241a3edfb8ea9ca3d76efcfe190df9", "message": "Merge branch '1887_dns_metrics_latest' of https://github.com/amitvc/armeria into 1887_dns_metrics_latest", "committedDate": "2020-11-17T03:56:47Z", "type": "commit"}, {"oid": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "url": "https://github.com/line/armeria/commit/736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "message": "Ignore NAME_SERVERS_EXHAUSTED_EXCEPTION (No name servers returned an answer) exception from being measured with a metric", "committedDate": "2020-11-17T05:08:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0NzE2Ng==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526547166", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-11-19T02:14:46Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -616,7 +616,16 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions\n+                                .METER_REGISTRY", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex 175bb3384..07f91c1b2 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -618,8 +618,7 @@ public final class ClientFactoryBuilder {\n                         }\n \n                         final ClientFactoryOptionValue<?> opt = options\n-                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,\n-                                ClientFactoryOptions\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n                                 .METER_REGISTRY\n                                 .newValue(ClientFactoryOptions.of().meterRegistry()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU0OTk3MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526549971", "bodyText": "extra slash?", "author": "minwoox", "createdAt": "2020-11-19T02:23:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6e8ee143a..9116ae140 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -47,9 +47,9 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final String CNAME_TAG = \"cname\";\n \n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n-    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b\");\n     private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n     private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n     private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDAwOA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550008", "bodyText": "ditto", "author": "minwoox", "createdAt": "2020-11-19T02:23:58Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6e8ee143a..9116ae140 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -47,9 +47,9 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final String CNAME_TAG = \"cname\";\n \n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n-    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b\");\n     private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n     private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n     private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1MDM0MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526550340", "bodyText": "nit: indentation?", "author": "minwoox", "createdAt": "2020-11-19T02:24:53Z", "path": "core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.client;\n+\n+import java.net.InetSocketAddress;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.base.Ascii;\n+\n+import com.linecorp.armeria.common.metric.MeterIdPrefix;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Tag;\n+import io.micrometer.core.instrument.Tags;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.dns.DnsQuestion;\n+import io.netty.handler.codec.dns.DnsResponseCode;\n+import io.netty.resolver.dns.DnsNameResolverTimeoutException;\n+import io.netty.resolver.dns.DnsQueryLifecycleObserver;\n+\n+/**\n+ * A {@link DnsQueryLifecycleObserver} that helps capture custom dns metrics.\n+ */\n+final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserver {\n+    private static final String NAME_TAG = \"name\";\n+    private static final String RESULT_TAG = \"result\";\n+    private static final String SERVERS_TAG = \"servers\";\n+    private static final String SERVER_TAG = \"server\";\n+    private static final String CODE_TAG = \"code\";\n+    private static final String CAUSE_TAG = \"cause\";\n+    private static final String CNAME_TAG = \"cname\";\n+\n+    private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n+    private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n+    private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n+\n+    private final MeterRegistry meterRegistry;\n+    private final MeterIdPrefix meterIdPrefix;\n+    private final Tag nameTag;\n+    private final String meterIdPrefixWritten;\n+    private final String meterIdPrefixCancelled;\n+    private final String meterIdPrefixRedirected;\n+    private final String meterIdPrefixCnamed;\n+    private final String meterIdPrefixNoAnswer;\n+\n+    private enum DnsExceptionTypes {\n+\n+        NX_DOMAIN,\n+        CNAME_NOT_FOUND,\n+        NO_MATCHING_RECORD,\n+        UNRECOGNIZED_TYPE,\n+        OTHERS,\n+        SERVER_TIMEOUT,\n+        RESOLVER_TIMEOUT;\n+\n+        final String lowerCasedName;\n+\n+        DnsExceptionTypes() {\n+            lowerCasedName = Ascii.toLowerCase(name());\n+        }\n+    }\n+\n+    /**\n+     * Accepts meterRegistry.\n+     * @param meterRegistry {@link MeterRegistry} MeterRegistry to capture metrics.\n+     * @param question {@link DnsQuestion} DnsQuestion.\n+     */\n+    DefaultDnsQueryLifecycleObserver(MeterRegistry meterRegistry,\n+                                     DnsQuestion question, MeterIdPrefix prefix) {\n+        this.meterRegistry = meterRegistry;\n+        meterIdPrefix = prefix;\n+        nameTag = Tag.of(NAME_TAG, question.name());\n+        meterIdPrefixWritten = meterIdPrefix.name() + \".written\";\n+        meterIdPrefixCancelled = meterIdPrefix.name() + \".cancelled\";\n+        meterIdPrefixRedirected = meterIdPrefix.name() + \".redirected\";\n+        meterIdPrefixCnamed = meterIdPrefix.name() + \".cnamed\";\n+        meterIdPrefixNoAnswer = meterIdPrefix.name() + \".noanswer\";\n+    }\n+\n+    @Override\n+    public void queryWritten(InetSocketAddress dnsServerAddress, ChannelFuture future) {\n+        meterRegistry.counter(meterIdPrefixWritten,\n+                              Arrays.asList(nameTag,\n+                              Tag.of(SERVER_TAG, dnsServerAddress.getAddress().getHostAddress())))", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\nindex 6e8ee143a..9116ae140 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DefaultDnsQueryLifecycleObserver.java\n\n@@ -47,9 +47,9 @@ final class DefaultDnsQueryLifecycleObserver implements DnsQueryLifecycleObserve\n     private static final String CNAME_TAG = \"cname\";\n \n     private static final Pattern NXDOMAIN_EXCEPTION = Pattern.compile(\"\\\\bNXDOMAIN\\\\b\");\n-    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b/\");\n+    private static final Pattern CNAME_EXCEPTION = Pattern.compile(\"\\\\bCNAME\\\\b\");\n     private static final Pattern NO_MATCHING_EXCEPTION = Pattern.compile(\"\\\\bmatching\\\\b\");\n-    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b/\");\n+    private static final Pattern UNRECOGNIZED_TYPE_EXCEPTION = Pattern.compile(\"\\\\bunrecognized\\\\b\");\n     private static final Pattern NO_NS_RETURNED_EXCEPTION = Pattern.compile(\"\\\\bservers returned an answer\\\\b\");\n     private static final Tag TAG_SUCCESS = Tag.of(RESULT_TAG, \"success\");\n     private static final Tag TAG_FAILURE = Tag.of(RESULT_TAG, \"failure\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554369", "bodyText": "How about making this public?", "author": "minwoox", "createdAt": "2020-11-19T02:36:52Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -297,6 +302,14 @@ public DnsResolverGroupBuilder decodeIdn(boolean decodeIdn) {\n         return this;\n     }\n \n+    /**\n+     * Sets {@link MeterRegistry} to collect the DNS query metrics.\n+     */\n+    DnsResolverGroupBuilder meterRegistry(MeterRegistry meterRegistry) {", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4NTAwMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526585003", "bodyText": "No, because we should use the meterRegistry specified in ClientFactoryBuilder.meterRegistry().", "author": "trustin", "createdAt": "2020-11-19T04:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDM2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526554771", "bodyText": "Let's add assert meterRegistry != null so that IDE does not complain.\nLet's exctrat\nnew DefaultDnsQueryLifecycleObserverFactory(\n    meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\"))\nbefore line 359", "author": "minwoox", "createdAt": "2020-11-19T02:38:18Z", "path": "core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java", "diffHunk": "@@ -343,8 +356,15 @@ RefreshingAddressResolverGroup build(EventLoopGroup eventLoopGroup) {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n-            if (dnsQueryLifecycleObserverFactory != null) {\n-                builder.dnsQueryLifecycleObserverFactory(dnsQueryLifecycleObserverFactory);\n+            if (dnsQueryLifecycleObserverFactory == null) {\n+                builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n+                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM2NjI3OA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r527366278", "bodyText": "@minwoox Interesting observation. If I extract the construction of DefaultDnsQueryLifecycleObserverFactory and then pass the same DefaultDnsQueryLifecycleObserverFactory to both cases then the UT break because we are now using the same DnsQueryLifecycleObserverFactory. The UT break because the write counts are 2 times. Question is we should use the same DnsQueryLifecycleObserverFactory and not create it independently in both cases. I think this might be a bug. What do you think? The breaking UT when I extract the creation of dnsQueryLifecycleObserverFactory is below -\nio.micrometer.core.instrument.MeterRegistryjava.lang.String \nExpecting map:\n <{\"armeria.client.connections.lifespan#count{protocol=h2c}\"=0.0, \"armeria.client.connections.lifespan#max{protocol=h2c}\"=0.0, \"armeria.client.connections.lifespan#total{protocol=h2c}\"=0.0, \"armeria.client.dns.queries#count{cause=none,name=foo.com.,result=success}\"=2.0, \"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\"=2.0}>\nto contain:\n <[MapEntry[key=\"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\", value=1.0]]>\nbut could not find the following map entries:\n <[MapEntry[key=\"armeria.client.dns.queries.written#count{name=foo.com.,server=0:0:0:0:0:0:0:1}\", value=1.0]]>", "author": "amitvc", "createdAt": "2020-11-20T03:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM3MzM1MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r527373350", "bodyText": "Had a chat with @amitvc and I hope it succeeds this time. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-20T03:39:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwNDQ5Mg==", "url": "https://github.com/line/armeria/pull/2935#discussion_r527704492", "bodyText": "@minwoox the build is successful I think. https://ci.appveyor.com/project/line/armeria/builds/36414924/job/82eers20is37trhi", "author": "amitvc", "createdAt": "2020-11-20T13:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NDc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\nindex 707e65991..ebbc717b7 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/DnsResolverGroupBuilder.java\n\n@@ -356,15 +356,17 @@ public final class DnsResolverGroupBuilder {\n             if (dnsServerAddressStreamProvider != null) {\n                 builder.nameServerProvider(dnsServerAddressStreamProvider);\n             }\n+            assert meterRegistry != null;\n             if (dnsQueryLifecycleObserverFactory == null) {\n                 builder.dnsQueryLifecycleObserverFactory(new DefaultDnsQueryLifecycleObserverFactory(\n-                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")));\n+                        meterRegistry,\n+                        new MeterIdPrefix(\"armeria.client.dns.queries\")));\n             } else {\n                 builder.dnsQueryLifecycleObserverFactory(\n                         new BiDnsQueryLifecycleObserverFactory(\n-                        new DefaultDnsQueryLifecycleObserverFactory(\n-                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")),\n-                        dnsQueryLifecycleObserverFactory));\n+                                new DefaultDnsQueryLifecycleObserverFactory(\n+                                        meterRegistry, new MeterIdPrefix(\"armeria.client.dns.queries\")),\n+                                dnsQueryLifecycleObserverFactory));\n             }\n             if (searchDomains != null) {\n                 builder.searchDomains(searchDomains);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526555980", "bodyText": "Let's move this class to a test package. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-19T02:42:04Z", "path": "core/src/test/java/com/linecorp/armeria/client/endpoint/dns/DnsNameEncoder.java", "diffHunk": "@@ -18,9 +18,9 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.handler.codec.dns.DefaultDnsRecordEncoder;\n \n-final class DnsNameEncoder {\n+public final class DnsNameEncoder {", "originalCommit": "736d7ae6f5a450a1ebc1e08aba47a63bb6b2aee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyMDMzMw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526620333", "bodyText": "There are classes that depends on this class in armeria.client.endpoint.dns, so moving this class will not help much.", "author": "trustin", "createdAt": "2020-11-19T06:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyNzU2MA==", "url": "https://github.com/line/armeria/pull/2935#discussion_r526627560", "bodyText": "Oops I thought this was in core/src/main....\nPlease forget about the comment. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-11-19T06:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU1NTk4MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "url": "https://github.com/line/armeria/commit/3b0a3d97cef107e56a4597105fb0d856c0c87cb3", "message": "removed unnessary chars from regex, indentation fixes", "committedDate": "2020-11-20T03:06:06Z", "type": "commit"}, {"oid": "d4a10dacf4ab1e87d737b91c02f3657ecba97637", "url": "https://github.com/line/armeria/commit/d4a10dacf4ab1e87d737b91c02f3657ecba97637", "message": "extract construction of DefaultDnsQueryLifecycleObserverFactory in build method of dnsresolvergroupbuilder so we don't create multiple instances of it", "committedDate": "2020-11-20T03:39:54Z", "type": "commit"}, {"oid": "bba534b85d278725ee203f9f7ffba2b8decc7cbd", "url": "https://github.com/line/armeria/commit/bba534b85d278725ee203f9f7ffba2b8decc7cbd", "message": "Merge branch 'master' into 1887_dns_metrics_latest", "committedDate": "2020-11-23T14:07:32Z", "type": "commit"}, {"oid": "4da165e7209dbe5339709b00a068c22a103953c0", "url": "https://github.com/line/armeria/commit/4da165e7209dbe5339709b00a068c22a103953c0", "message": "Add assertions to confirm exception type others is not being emitted", "committedDate": "2020-11-23T14:26:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530162619", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options\n          \n          \n            \n                                            .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n          \n          \n            \n                                            .METER_REGISTRY\n          \n          \n            \n                                            .newValue(ClientFactoryOptions.of().meterRegistry()));\n          \n          \n            \n                                    final ClientFactoryOptionValue<?> opt = options.getOrDefault(\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY,\n          \n          \n            \n                                            ClientFactoryOptions.METER_REGISTRY.newValue(\n          \n          \n            \n                                                    ClientFactoryOptions.of().meterRegistry()));", "author": "trustin", "createdAt": "2020-11-25T07:42:29Z", "path": "core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java", "diffHunk": "@@ -631,7 +631,15 @@ private ClientFactoryOptions buildOptions() {\n                         if (dnsResolverGroupCustomizers != null) {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n-                        return builder.build(eventLoopGroup);\n+\n+                        final ClientFactoryOptionValue<?> opt = options\n+                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n+                                .METER_REGISTRY\n+                                .newValue(ClientFactoryOptions.of().meterRegistry()));", "originalCommit": "4da165e7209dbe5339709b00a068c22a103953c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NjM1MQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530546351", "bodyText": "Fixed.", "author": "amitvc", "createdAt": "2020-11-25T17:41:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MjYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c9b744c92ae247a8e217108a09cf17cc515e63cf", "chunk": "diff --git a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\nindex f44344349..ba41ffdcb 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/ClientFactoryBuilder.java\n\n@@ -632,10 +632,10 @@ public final class ClientFactoryBuilder {\n                             dnsResolverGroupCustomizers.forEach(consumer -> consumer.accept(builder));\n                         }\n \n-                        final ClientFactoryOptionValue<?> opt = options\n-                                .getOrDefault(ClientFactoryOptions.METER_REGISTRY,ClientFactoryOptions\n-                                .METER_REGISTRY\n-                                .newValue(ClientFactoryOptions.of().meterRegistry()));\n+                        final ClientFactoryOptionValue<?> opt = options.getOrDefault(\n+                                ClientFactoryOptions.METER_REGISTRY,\n+                                ClientFactoryOptions.METER_REGISTRY.newValue(\n+                                        ClientFactoryOptions.of().meterRegistry()));\n \n                         return builder\n                                 .meterRegistry((MeterRegistry) opt.value())\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530163725", "bodyText": "Could you explain why we have this change? This test case doesn't seem to check and DNS metrics.", "author": "trustin", "createdAt": "2020-11-25T07:44:59Z", "path": "core/src/test/java/com/linecorp/armeria/client/RefreshingAddressResolverTest.java", "diffHunk": "@@ -405,6 +406,7 @@ private static DnsResolverGroupBuilder builder(TestDnsServer... servers) {\n                         Stream.of(servers).map(TestDnsServer::addr).collect(toImmutableList())).stream();\n         return new DnsResolverGroupBuilder()\n                 .dnsServerAddressStreamProvider(dnsServerAddressStreamProvider)\n+                .meterRegistry(PrometheusMeterRegistries.newRegistry())", "originalCommit": "4da165e7209dbe5339709b00a068c22a103953c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0NTU3Mw==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530545573", "bodyText": "Good question @trustin. The reason is DnsResolverGroupBuilder::build method we expect the meterRegistry to be not null. The question can DnsResolverGroupBuilder be constructed without meterRegistry.", "author": "amitvc", "createdAt": "2020-11-25T17:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc1MzkxNQ==", "url": "https://github.com/line/armeria/pull/2935#discussion_r530753915", "bodyText": "Ahh, I see. OK!", "author": "trustin", "createdAt": "2020-11-26T03:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE2MzcyNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "c9b744c92ae247a8e217108a09cf17cc515e63cf", "url": "https://github.com/line/armeria/commit/c9b744c92ae247a8e217108a09cf17cc515e63cf", "message": "Fix indentations", "committedDate": "2020-11-25T17:41:22Z", "type": "commit"}, {"oid": "4a1af56eb4037e780b90bf1076fc9b7f16828c83", "url": "https://github.com/line/armeria/commit/4a1af56eb4037e780b90bf1076fc9b7f16828c83", "message": "Merge master into the branch", "committedDate": "2020-11-26T05:23:53Z", "type": "commit"}, {"oid": "ad71406d3ea81235b2899fd74a0e5c01022386c4", "url": "https://github.com/line/armeria/commit/ad71406d3ea81235b2899fd74a0e5c01022386c4", "message": "increase clientfactory timeout", "committedDate": "2020-11-26T05:24:36Z", "type": "commit"}, {"oid": "64571bb7ab4790e99fcfa932ad6dbf3cc4545d10", "url": "https://github.com/line/armeria/commit/64571bb7ab4790e99fcfa932ad6dbf3cc4545d10", "message": "Fix flaky test and code format", "committedDate": "2020-11-27T03:22:30Z", "type": "commit"}, {"oid": "16455362b84dd0995c05be014d023ee68db77ff3", "url": "https://github.com/line/armeria/commit/16455362b84dd0995c05be014d023ee68db77ff3", "message": "Checkstyle", "committedDate": "2020-11-27T04:56:13Z", "type": "commit"}]}