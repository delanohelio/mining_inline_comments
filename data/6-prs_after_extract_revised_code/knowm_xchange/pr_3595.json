{"pr_number": 3595, "pr_title": "[Gemini] Orderbook stream fix", "pr_createdAt": "2020-07-06T22:42:32Z", "pr_url": "https://github.com/knowm/XChange/pull/3595", "timeline": [{"oid": "3da776091a7e59e3095d3db279af8a4adff99fdb", "url": "https://github.com/knowm/XChange/commit/3da776091a7e59e3095d3db279af8a4adff99fdb", "message": "[Gemini] Better fix for updates before initial orderbook", "committedDate": "2020-07-06T22:40:56Z", "type": "commit"}, {"oid": "0e4594753635e561bf0fecb16b1db48441e57401", "url": "https://github.com/knowm/XChange/commit/0e4594753635e561bf0fecb16b1db48441e57401", "message": "[Streaming][Gemini]Massive improvement in CPU and memory usage for orderbook processing.", "committedDate": "2020-07-07T09:25:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r451170573", "bodyText": "Are these updates published again after the image of the book is received? How are these then added back into the book?", "author": "earce", "createdAt": "2020-07-07T22:05:16Z", "path": "xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/GeminiStreamingMarketDataService.java", "diffHunk": "@@ -55,15 +56,21 @@ private boolean filterEventsByReason(JsonNode message, String type, String reaso\n   @Override\n   public Observable<OrderBook> getOrderBook(CurrencyPair currencyPair, Object... args) {\n \n+    Integer maxDepth = args.length > 0 ? (Integer) args[0] : null;\n+\n     Observable<GeminiOrderbook> subscribedOrderbookSnapshot =\n         service\n-            .subscribeChannel(currencyPair, args)\n+            .subscribeChannel(currencyPair, maxDepth, maxDepth)\n             .filter(\n                 s ->\n                     filterEventsByReason(s, \"change\", \"initial\")\n                         || filterEventsByReason(s, \"change\", \"place\")\n                         || filterEventsByReason(s, \"change\", \"cancel\")\n                         || filterEventsByReason(s, \"change\", \"trade\"))\n+            .filter(\n+                s -> // filter out updates that arrive before initial book\n+                orderbooks.get(currencyPair) != null\n+                        || filterEventsByReason(s, \"change\", \"initial\"))", "originalCommit": "0e4594753635e561bf0fecb16b1db48441e57401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwNDg1NA==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r451704854", "bodyText": "Not dealing with collecting out of order updates, just ignores them until it get an initial snapshot of the book.  Its better than the previous way of handling it, than created crossed books.  also since there is no guarantee it will ever get an initial (I have seen that) keep all the deltas until then would likely lead to massive memory consumption.", "author": "mdvx", "createdAt": "2020-07-08T17:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwNzYzNg==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r451707636", "bodyText": "Makes sense, is it possible to have an inaccurate book if the snapshot came after some updates which were intended to be updates to the book?", "author": "earce", "createdAt": "2020-07-08T17:24:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcxMzQ2OA==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r451713468", "bodyText": "this may occur, however I have not seen it yet, it would manifest itself as a crossed book (where a delete was missed), which i check for in my code.", "author": "mdvx", "createdAt": "2020-07-08T17:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxODY0OQ==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r453218649", "bodyText": "Some more color:  I have been using the v2 sockets api now.  When a connection is made it subscribes to l2 data, which includes both trades and order book depth.  The initial orderbook is send out, and then trades and orderbook updates follow.  Have to watch for how we implement here, because if the trades subscription goes out first, on the socket, the \"initial\" update will be missed by a subsequent subscription (for the orderbook as the observer is shared).\nthe only 100% safe solution is to have two sockets open (trades, and orderbook), but that means the data is sent twice from the server.  I am pretty certain v1 is behaving in same way, since it explains the weird stuff i have seen in past.\nOn this update:  Well, it's better than the previous implementation, however i have moved on to v2 api now,  so we can keep it or scrap it.", "author": "mdvx", "createdAt": "2020-07-11T17:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIzMTgyNQ==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r453231825", "bodyText": "@mdvx I would say if you are not observing race conditions as you were before from within a single record type (orderbook and its respective updates) this is an improvement.\nI would think even though it may redundant having two sockets for this may be better no? Alternatively you would have to keep the state of the world locally to give that to a new subscription as you say. Brainstorming here a bit but let me know if what I'm saying makes sense.", "author": "earce", "createdAt": "2020-07-11T20:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0NjAwMA==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r454046000", "bodyText": "So the messages handle both orderbook and trades, with one socket both states can be managed.\nHowever, that means that if someone only subscribes to trades, the orderbook has to be managed in the background as well, just in case they later subscribe to the orderbook.  The opposite order also suffers but is less of a problem, as the newest trades only will be received (only the supplied history is lost), and that is surely acceptable, since we dont model trade history.\nBut we can not ensure, that the user will subscribe to orderBook before trades, that's when two sockets are needed.\nso option a) manage the orderbook when trades are subscribed first, b) use two sockets, c) inform users to subscribe to the orderbook first (dont allow it to be second), d) others??", "author": "mdvx", "createdAt": "2020-07-14T01:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0ODUyNA==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r454048524", "bodyText": "Caveat:  I am basing this off my new experience with the v2 API, and assuming the same problem exist in V1.\nbut GeminiStreamingMarketDataService.getOrderBook & GeminiStreamingMarketDataService.getTrades could be combined into a single overarching method, to achieve this.", "author": "mdvx", "createdAt": "2020-07-14T01:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0ODgxNw==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r454048817", "bodyText": "NB: same problem will occur if we ever try to support candles", "author": "mdvx", "createdAt": "2020-07-14T01:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NjIyNg==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r454666226", "bodyText": "I wouldn't be able to speak to the extra load another socket would bring on but I think from a usability and maintainability it sounds easiest?", "author": "earce", "createdAt": "2020-07-14T21:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MDU3Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2ODgwMg==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r456968802", "bodyText": "why are you downgrading this do Double?\nlevel.getPrice().doubleValue() can lead to lost precision\nleave BigDecimal", "author": "walec51", "createdAt": "2020-07-19T23:25:39Z", "path": "xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java", "diffHunk": "@@ -1,50 +1,50 @@\n package info.bitrich.xchangestream.gemini.dto;\n \n-import static org.knowm.xchange.gemini.v1.GeminiAdapters.adaptOrders;\n-\n import java.math.BigDecimal;\n-import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n import java.util.List;\n import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n import org.knowm.xchange.currency.CurrencyPair;\n import org.knowm.xchange.dto.Order;\n import org.knowm.xchange.dto.marketdata.OrderBook;\n import org.knowm.xchange.dto.trade.LimitOrder;\n \n /** Created by Lukas Zaoralek on 15.11.17. */\n public class GeminiOrderbook {\n-  private final Map<BigDecimal, GeminiLimitOrder> asks;\n-  private final Map<BigDecimal, GeminiLimitOrder> bids;\n+  private final Map<Double, GeminiLimitOrder> asks;\n+  private final Map<Double, GeminiLimitOrder> bids;", "originalCommit": "0e4594753635e561bf0fecb16b1db48441e57401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NDIwMw==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r460564203", "bodyText": "yes, I was dealing with the horrible performance and trying different things.  BigDecimal is better", "author": "mdvx", "createdAt": "2020-07-26T19:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2ODgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "27b658bd7901651a8b47fc4c03037a4a7e5721ca", "chunk": "diff --git a/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java b/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java\nindex 6f7ab75291..53513fc273 100644\n--- a/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java\n+++ b/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java\n\n@@ -14,8 +14,8 @@ import org.knowm.xchange.dto.trade.LimitOrder;\n \n /** Created by Lukas Zaoralek on 15.11.17. */\n public class GeminiOrderbook {\n-  private final Map<Double, GeminiLimitOrder> asks;\n-  private final Map<Double, GeminiLimitOrder> bids;\n+  private final Map<BigDecimal, GeminiLimitOrder> asks;\n+  private final Map<BigDecimal, GeminiLimitOrder> bids;\n \n   private final CurrencyPair currencyPair;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2ODk2OQ==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r456968969", "bodyText": "this class cannot make up its mind is it an adapter or an DTO\ncan't we move this to GeminiAdapters?", "author": "walec51", "createdAt": "2020-07-19T23:27:27Z", "path": "xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java", "diffHunk": "@@ -54,15 +54,35 @@ public void updateLevels(GeminiLimitOrder[] levels) {\n     }\n   }\n \n-  public OrderBook toOrderbook() {\n-    GeminiLimitOrder[] askLevels = asks.values().toArray(new GeminiLimitOrder[asks.size()]);\n-    GeminiLimitOrder[] bidLevels = bids.values().toArray(new GeminiLimitOrder[bids.size()]);\n+  public OrderBook toOrderbook(int maxLevels, Date timestamp) {", "originalCommit": "0e4594753635e561bf0fecb16b1db48441e57401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU2NTcyMA==", "url": "https://github.com/knowm/XChange/pull/3595#discussion_r460565720", "bodyText": "created GeminiAdaptersX", "author": "mdvx", "createdAt": "2020-07-26T19:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2ODk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "93dfc2cae179f367a98cf23026243dc83c0e5c69", "chunk": "diff --git a/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java b/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java\nindex 6f7ab75291..75fd8a32b3 100644\n--- a/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java\n+++ b/xchange-stream-gemini/src/main/java/info/bitrich/xchangestream/gemini/dto/GeminiOrderbook.java\n\n@@ -54,35 +50,16 @@ public class GeminiOrderbook {\n     }\n   }\n \n-  public OrderBook toOrderbook(int maxLevels, Date timestamp) {\n-    List<LimitOrder> askOrders =\n-        asks.values().stream()\n-            .limit(maxLevels)\n-            .map(\n-                (GeminiLimitOrder geminiLimitOrder) ->\n-                    toLimitOrder(geminiLimitOrder, Order.OrderType.ASK))\n-            .collect(Collectors.toList());\n-\n-    List<LimitOrder> bidOrders =\n-        bids.values().stream()\n-            .limit(maxLevels)\n-            .map(\n-                (GeminiLimitOrder geminiLimitOrder) ->\n-                    toLimitOrder(geminiLimitOrder, Order.OrderType.BID))\n-            .collect(Collectors.toList());\n-\n-    return new OrderBook(timestamp, askOrders, bidOrders);\n+  public Collection<GeminiLimitOrder> getAsks() {\n+    return asks.values();\n   }\n \n-  private LimitOrder toLimitOrder(GeminiLimitOrder geminiLimitOrder, Order.OrderType side) {\n-    return new LimitOrder.Builder(side, currencyPair)\n-        .limitPrice(geminiLimitOrder.getPrice())\n-        .originalAmount(geminiLimitOrder.getAmount())\n-        .timestamp(convertBigDecimalTimestampToDate(geminiLimitOrder.getTimestamp()))\n-        .build();\n+  public Collection<GeminiLimitOrder> getBids() {\n+    return bids.values();\n   }\n \n-  static Date convertBigDecimalTimestampToDate(BigDecimal timestampInSeconds) {\n-    return new Date((long) Math.floor(timestampInSeconds.doubleValue() * 1000));\n+  public CurrencyPair getCurrencyPair() {\n+    return currencyPair;\n   }\n+\n }\n"}}, {"oid": "27b658bd7901651a8b47fc4c03037a4a7e5721ca", "url": "https://github.com/knowm/XChange/commit/27b658bd7901651a8b47fc4c03037a4a7e5721ca", "message": "Yes, I agree, BigDecimal is better - reverting", "committedDate": "2020-07-26T19:26:09Z", "type": "commit"}, {"oid": "93dfc2cae179f367a98cf23026243dc83c0e5c69", "url": "https://github.com/knowm/XChange/commit/93dfc2cae179f367a98cf23026243dc83c0e5c69", "message": "move adapter methods GeminiAdaptersX", "committedDate": "2020-07-26T19:42:52Z", "type": "commit"}, {"oid": "b6fcdda06454ec852e5ae4e29d70253a7fba2139", "url": "https://github.com/knowm/XChange/commit/b6fcdda06454ec852e5ae4e29d70253a7fba2139", "message": "formatting", "committedDate": "2020-07-27T04:40:20Z", "type": "commit"}, {"oid": "baf4c3e787d4a071be93fd50c26ba55cbdb8e87d", "url": "https://github.com/knowm/XChange/commit/baf4c3e787d4a071be93fd50c26ba55cbdb8e87d", "message": "[Bitmex] priceScale is derived from last price, however last price observed as null (NPE Fix)", "committedDate": "2020-07-29T17:09:27Z", "type": "commit"}, {"oid": "607b9d96a80313e7614ecd39e2fd774ac23e5e3a", "url": "https://github.com/knowm/XChange/commit/607b9d96a80313e7614ecd39e2fd774ac23e5e3a", "message": "[Bitmex] L2 25 only depth for performance, in an arg is supplied - accidental in previous checkin\ncheck the right field", "committedDate": "2020-07-29T17:18:22Z", "type": "commit"}, {"oid": "e777474c10e9cf2ba587a25ad4d6e288d2ca3f3e", "url": "https://github.com/knowm/XChange/commit/e777474c10e9cf2ba587a25ad4d6e288d2ca3f3e", "message": "squash! [Bitmex] priceScale is derived from last price, however last price observed as null (NPE Fix)", "committedDate": "2020-07-29T18:23:47Z", "type": "commit"}, {"oid": "b87d45b3e292f91a6a634eb7aebc6a6831b111e6", "url": "https://github.com/knowm/XChange/commit/b87d45b3e292f91a6a634eb7aebc6a6831b111e6", "message": "[Gemini] Implement getTicker using top of orderbook", "committedDate": "2020-08-02T12:37:49Z", "type": "commit"}, {"oid": "fe0706e4ebbf54bcc56b720bf580f34d015fe61a", "url": "https://github.com/knowm/XChange/commit/fe0706e4ebbf54bcc56b720bf580f34d015fe61a", "message": "[Gemini] Implement getTicker using top of orderbook - reformat - cascade errors", "committedDate": "2020-08-02T12:47:49Z", "type": "commit"}, {"oid": "b0899ed2caf7486b4734950d3959c2b1aedb15fa", "url": "https://github.com/knowm/XChange/commit/b0899ed2caf7486b4734950d3959c2b1aedb15fa", "message": "Merge branch 'develop' into Gemini-Stream-Fix", "committedDate": "2020-09-01T22:46:24Z", "type": "commit"}]}