{"pr_number": 18883, "pr_title": "#18846  local system event is broadcast on save", "pr_createdAt": "2020-07-15T15:28:19Z", "pr_url": "https://github.com/dotCMS/core/pull/18883", "timeline": [{"oid": "df38ad579129237a759cbdd63e19db64ba253b69", "url": "https://github.com/dotCMS/core/commit/df38ad579129237a759cbdd63e19db64ba253b69", "message": "#18846  local system even is broadcast on save", "committedDate": "2020-07-15T15:09:29Z", "type": "commit"}, {"oid": "780a70ba71f785cb81c15cc901e2a89ffe7c3ae2", "url": "https://github.com/dotCMS/core/commit/780a70ba71f785cb81c15cc901e2a89ffe7c3ae2", "message": "#18846 adding doc", "committedDate": "2020-07-15T15:53:40Z", "type": "commit"}, {"oid": "717e80e7ada3395d5fa213f3166cafe6999824bb", "url": "https://github.com/dotCMS/core/commit/717e80e7ada3395d5fa213f3166cafe6999824bb", "message": "#18846 key  filterable event", "committedDate": "2020-07-15T22:45:35Z", "type": "commit"}, {"oid": "fad7052521dc1caa8cb490cd4cbd1fc68a2ffc21", "url": "https://github.com/dotCMS/core/commit/fad7052521dc1caa8cb490cd4cbd1fc68a2ffc21", "message": "#18846 logger info", "committedDate": "2020-07-15T22:51:44Z", "type": "commit"}, {"oid": "9e6bc4f9801d55b8ecb36eb011820c40af7ec8d7", "url": "https://github.com/dotCMS/core/commit/9e6bc4f9801d55b8ecb36eb011820c40af7ec8d7", "message": "#18846 remove syste,ou.println", "committedDate": "2020-07-15T22:54:17Z", "type": "commit"}, {"oid": "9d59f9f0bd59767d1933a8da8784e718eba03478", "url": "https://github.com/dotCMS/core/commit/9d59f9f0bd59767d1933a8da8784e718eba03478", "message": "#18846  unused import", "committedDate": "2020-07-15T22:59:02Z", "type": "commit"}, {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258", "url": "https://github.com/dotCMS/core/commit/72e67eacfeb98a8579c885044511fa9a27e98258", "message": "#18846 fix broken test", "committedDate": "2020-07-16T02:56:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjUzNg==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492536", "bodyText": "level", "author": "jdotcms", "createdAt": "2020-07-16T03:46:42Z", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "diffHunk": "@@ -185,34 +190,88 @@ public void setOrphanEventSubscriber(final EventSubscriber<OrphanEvent> orphanEv\n \n \n     @Override\n-    public void asyncNotify(final Object event) {\n+    public void asyncNotify(final Object event, final EventCompletionHandler completionHandler) {\n \n         final DotSubmitter dotSubmitter = this.dotConcurrentFactory.getSubmitter(LOCAL_SYSTEM_EVENTS_THREAD_POOL_SUBMITTER_NAME);\n-        dotSubmitter.submit(()-> this.notify(event));\n+        if(null != completionHandler){\n+            dotSubmitter.submit(()-> this.notify(event, completionHandler));\n+        } else {\n+           dotSubmitter.submit(()-> this.notify(event));\n+        }\n     } // asyncNotify.\n \n-\n     @Override\n-    public void notify(final Object event) {\n-\n-        final CopyOnWriteArrayList<EventSubscriber> eventSubscribers =\n-                this.getEventSubscribersByEventType(event.getClass());\n-\n-        if (null != eventSubscribers) {\n-\n-            for (EventSubscriber eventSubscriber : eventSubscribers) {\n-\n-                if (null != eventSubscriber) {\n+    public void asyncNotify(final Object event) {\n+        asyncNotify(event, null);\n+    }\n \n-                    eventSubscriber.notify(event);\n+    /**\n+     * Private implementation that allows firing an event completion handler\n+     */\n+    private void notify(final Object event, final EventCompletionHandler completionHandler) {\n+        try {\n+            final List<EventSubscriber> eventSubscribers =\n+                    this.getEventSubscribersByEventType(event.getClass());\n+\n+            if (null != eventSubscribers) {\n+                if (event instanceof KeyFilterable) {\n+                    synchronized (this) {\n+                        //if we're broadcasting an event that is an instance of KeyFilterable\n+                        //it means it is intended to a limited audience.\n+                        //Both the even and the receiver must be an instance of KeyFilterable\n+                        final KeyFilterable keyFilterableEvent = (KeyFilterable) event;", "originalCommit": "72e67eacfeb98a8579c885044511fa9a27e98258", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "chunk": "diff --git a/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java b/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java\nindex 87235ade42..057744ae12 100644\n--- a/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java\n+++ b/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java\n\n@@ -217,7 +217,7 @@ class LocalSystemEventsAPIImpl implements LocalSystemEventsAPI {\n                 if (event instanceof KeyFilterable) {\n                     synchronized (this) {\n                         //if we're broadcasting an event that is an instance of KeyFilterable\n-                        //it means it is intended to a limited audience.\n+                        //it means it is intended for a limited audience.\n                         //Both the even and the receiver must be an instance of KeyFilterable\n                         final KeyFilterable keyFilterableEvent = (KeyFilterable) event;\n                         Logger.info(LocalSystemEventsAPIImpl.class, ()->\" Broadcasting a Filterable Event.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjYwNA==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492604", "bodyText": "typo", "author": "jdotcms", "createdAt": "2020-07-16T03:46:57Z", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "diffHunk": "@@ -185,34 +190,88 @@ public void setOrphanEventSubscriber(final EventSubscriber<OrphanEvent> orphanEv\n \n \n     @Override\n-    public void asyncNotify(final Object event) {\n+    public void asyncNotify(final Object event, final EventCompletionHandler completionHandler) {\n \n         final DotSubmitter dotSubmitter = this.dotConcurrentFactory.getSubmitter(LOCAL_SYSTEM_EVENTS_THREAD_POOL_SUBMITTER_NAME);\n-        dotSubmitter.submit(()-> this.notify(event));\n+        if(null != completionHandler){\n+            dotSubmitter.submit(()-> this.notify(event, completionHandler));\n+        } else {\n+           dotSubmitter.submit(()-> this.notify(event));\n+        }\n     } // asyncNotify.\n \n-\n     @Override\n-    public void notify(final Object event) {\n-\n-        final CopyOnWriteArrayList<EventSubscriber> eventSubscribers =\n-                this.getEventSubscribersByEventType(event.getClass());\n-\n-        if (null != eventSubscribers) {\n-\n-            for (EventSubscriber eventSubscriber : eventSubscribers) {\n-\n-                if (null != eventSubscriber) {\n+    public void asyncNotify(final Object event) {\n+        asyncNotify(event, null);\n+    }\n \n-                    eventSubscriber.notify(event);\n+    /**\n+     * Private implementation that allows firing an event completion handler\n+     */\n+    private void notify(final Object event, final EventCompletionHandler completionHandler) {\n+        try {\n+            final List<EventSubscriber> eventSubscribers =\n+                    this.getEventSubscribersByEventType(event.getClass());\n+\n+            if (null != eventSubscribers) {\n+                if (event instanceof KeyFilterable) {\n+                    synchronized (this) {\n+                        //if we're broadcasting an event that is an instance of KeyFilterable\n+                        //it means it is intended to a limited audience.\n+                        //Both the even and the receiver must be an instance of KeyFilterable\n+                        final KeyFilterable keyFilterableEvent = (KeyFilterable) event;\n+                        Logger.info(LocalSystemEventsAPIImpl.class, ()->\" Broadcasting a Filterable Event.\");\n+                        final Stream<KeyFilterable> keyAwareSubscribers = eventSubscribers.stream()\n+                                .filter(eventSubscriber -> eventSubscriber instanceof KeyFilterable)\n+                                .map(KeyFilterable.class::cast)\n+                                .filter(keyFilterable -> keyFilterable.getKey() != null);\n+\n+                        final List<EventSubscriber> eventAudience = keyAwareSubscribers\n+                                .filter(keyFilterable ->\n+                                        keyFilterable.getKey()\n+                                                .compareTo(keyFilterableEvent.getKey()) == 0)\n+                                .map(EventSubscriber.class::cast)\n+                                .collect(Collectors.toList());\n+                        broadcast(eventAudience, event);\n+                        Logger.info(LocalSystemEventsAPIImpl.class, () -> String\n+                                .format(\" Filtered Audience for event with key `%s`  is `%d` long. \",\n+                                        keyFilterableEvent.getKey(), eventAudience.size()));\n+                    }\n+                } else {\n+                    broadcast(eventSubscribers, event);\n                 }\n+            } else {\n+                this.orphanEventSubscriber.notify(new OrphanEvent(event));\n+            }\n+        } finally {\n+            if (null != completionHandler) {\n+                Try.of(() -> {\n+                    completionHandler.onComplete(event);\n+                    return true;\n+                }).get();\n             }\n-        } else {\n-\n-            this.orphanEventSubscriber.notify(new OrphanEvent(event));\n         }\n+\n     } // asyncNotify.\n \n+    /**\n+     * This method basically delivers the event to all the subscribers\n+     * @param subscibers\n+     * @param event\n+     */\n+    private void broadcast(final List<EventSubscriber> subscibers, final Object event){", "originalCommit": "72e67eacfeb98a8579c885044511fa9a27e98258", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "chunk": "diff --git a/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java b/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java\nindex 87235ade42..057744ae12 100644\n--- a/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java\n+++ b/dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java\n\n@@ -217,7 +217,7 @@ class LocalSystemEventsAPIImpl implements LocalSystemEventsAPI {\n                 if (event instanceof KeyFilterable) {\n                     synchronized (this) {\n                         //if we're broadcasting an event that is an instance of KeyFilterable\n-                        //it means it is intended to a limited audience.\n+                        //it means it is intended for a limited audience.\n                         //Both the even and the receiver must be an instance of KeyFilterable\n                         final KeyFilterable keyFilterableEvent = (KeyFilterable) event;\n                         Logger.info(LocalSystemEventsAPIImpl.class, ()->\" Broadcasting a Filterable Event.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjY4NQ==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492685", "bodyText": "Functional interface", "author": "jdotcms", "createdAt": "2020-07-16T03:47:19Z", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.dotcms.system.event.local.model;\n+\n+public interface KeyFilterable {", "originalCommit": "72e67eacfeb98a8579c885044511fa9a27e98258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5Mjc1MA==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492750", "bodyText": "Doc", "author": "jdotcms", "createdAt": "2020-07-16T03:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjY4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "chunk": "diff --git a/dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java b/dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java\nindex 2b4a950ce5..a0b4c244a8 100644\n--- a/dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java\n+++ b/dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java\n\n@@ -1,5 +1,11 @@\n package com.dotcms.system.event.local.model;\n \n+/**\n+ * Intended to provide a key to be used for filtering purposes.\n+ * e.g. We want to filter an event that can only be received by a group of subscribers\n+ * Both (The Event and the subscriber) need to provide the same key.\n+ */\n+@FunctionalInterface\n public interface KeyFilterable {\n \n     Comparable getKey();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjgxMw==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492813", "bodyText": "Doc", "author": "jdotcms", "createdAt": "2020-07-16T03:47:38Z", "path": "dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.dotcms.system.event.local;\n+\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+\n+public class KeyFilterableEvent implements KeyFilterable {", "originalCommit": "72e67eacfeb98a8579c885044511fa9a27e98258", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "chunk": "diff --git a/dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java b/dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java\nindex e493deccd1..33cf9cc2cc 100644\n--- a/dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java\n+++ b/dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java\n\n@@ -2,6 +2,9 @@ package com.dotcms.system.event.local;\n \n import com.dotcms.system.event.local.model.KeyFilterable;\n \n+/**\n+ * This implementation of KeyFilterable is intended for testing purposes\n+ */\n public class KeyFilterableEvent implements KeyFilterable {\n \n     private final String key;\n"}}, {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca", "url": "https://github.com/dotCMS/core/commit/0de1414e4a24aba954993f7c358eecd5302f15ca", "message": "#18846  feedback", "committedDate": "2020-07-16T14:28:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NjkxMw==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846913", "bodyText": "Codacy found an issue: The String literal \"subscriber1\" appears 5 times in this file; the first occurrence is on line 272", "author": "dev-dotcms", "createdAt": "2020-07-16T14:51:01Z", "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "diffHunk": "@@ -212,6 +215,103 @@ public void orphanSubscriberTest() throws DotDataException {\n         Assert.assertTrue(isCalled.get());\n     } // orphanSubscriberTest.\n \n+    /**\n+     * Given scenario: We're testing that even when no subscribers are added the asyncNotify callback gets called\n+     * Expected results: We expect that the callback gets called.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_No_Subscribers() {\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        final AtomicBoolean isOnCompleteCalled = new AtomicBoolean(false);\n+        final String message = \"Async notify Event.\";\n+        localSystemEventsAPI.asyncNotify(new TestEventType1(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType1);\n+            final TestEventType1 eventType1 = (TestEventType1)event;\n+            Assert.assertEquals(eventType1.getMsg(), message);\n+            isOnCompleteCalled.set(true);\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertTrue(isOnCompleteCalled.get());\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that even when subscribers are added  the asyncNotify callback gets called just once.\n+     * Expected results: We expect that the callback gets called exactly once.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_Subscribers() {\n+        final String message = \"Async notify Event 2.\";\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(new TestDelegateSubscriber(){\n+            @Override\n+            public void notify(final TestEventType2 event) {\n+                Assert.assertEquals(event.getMsg(), message);\n+            }\n+        });\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n \n-\n-} // E:O:F:LocalSystemEventsAPITest.\n+        localSystemEventsAPI.asyncNotify(new TestEventType2(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType2);\n+            final TestEventType2 eventType2 = (TestEventType2)event;\n+            Assert.assertEquals(eventType2.getMsg(), message);\n+            callsCount.incrementAndGet();\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that an event that implements KeyFilterable and is broadcast only reaches certain audience.\n+     * We creating a few subscribers each one of the provides a key. The Event must reach only those which have the same id.\n+     * Expected results: Only the subscribers with a matching id will be able to consume the event;\n+     */\n+    @Test\n+    public void Test_Send_Event_For_Limited_Audience() {\n+\n+        final Map<String, AtomicInteger> callsCounts = ImmutableMap\n+                .of(\"subscriber1\", new AtomicInteger(0), \"subscriber2\", new AtomicInteger(0),", "originalCommit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NjkyNQ==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846925", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertEquals' due to existing static import 'org.junit.Assert.assertEquals'", "author": "dev-dotcms", "createdAt": "2020-07-16T14:51:02Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -785,4 +792,72 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We subscribe an event listener and save an event\n+     * Expected Results: We expect that an event is fired and that after firing the event the AppsSecret that was initially passed to the save method is now destroyed\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test\n+    public void Test_Save_Secret_Expect_Event_Notification() throws DotDataException, DotSecurityException{\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(AppSecretSavedEvent.class, new AppsSecretEventSubscriber(){\n+            @Override\n+            public void notify(AppSecretSavedEvent event) {\n+                callsCount.incrementAndGet();\n+            }\n+        });\n+\n+        final String appKey = AppsSecretEventSubscriber.appKey;\n+\n+        final AppDescriptor descriptor = mock(AppDescriptor.class);\n+        when(descriptor.isAllowExtraParameters()).thenReturn(false);\n+        final Map<String, ParamDescriptor> params = of(\n+                \"requiredNoDefault\",newParam(null, false, Type.STRING, \"any\", \"hint\", true),\n+                \"requiredDefault\", newParam(\"default\", false, Type.STRING, \"any\", \"hint\", true),\n+                \"nonRequiredNoDefault\", newParam(null, false, Type.STRING, \"any\", \"hint\", false)\n+        );\n+        when(descriptor.getParams()).thenReturn(params);\n+        when(descriptor.getName()).thenReturn(\"any-name\");\n+        when(descriptor.getKey()).thenReturn(appKey);\n+\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final User admin = TestUserUtils.getAdminUser();\n+\n+        //Let's create a set of secrets for a service\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"requiredNoDefault\", \"value\") //We're providing the expected value\n+                .withHiddenSecret(\"requiredDefault\", \"secret-2\")\n+                .build();\n+        //Save it\n+        api.saveSecrets(secrets, site, admin);\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);", "originalCommit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk0MQ==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846941", "bodyText": "Codacy found an issue: The String literal \"subscriber3\" appears 7 times in this file; the first occurrence is on line 273", "author": "dev-dotcms", "createdAt": "2020-07-16T14:51:03Z", "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "diffHunk": "@@ -212,6 +215,103 @@ public void orphanSubscriberTest() throws DotDataException {\n         Assert.assertTrue(isCalled.get());\n     } // orphanSubscriberTest.\n \n+    /**\n+     * Given scenario: We're testing that even when no subscribers are added the asyncNotify callback gets called\n+     * Expected results: We expect that the callback gets called.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_No_Subscribers() {\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        final AtomicBoolean isOnCompleteCalled = new AtomicBoolean(false);\n+        final String message = \"Async notify Event.\";\n+        localSystemEventsAPI.asyncNotify(new TestEventType1(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType1);\n+            final TestEventType1 eventType1 = (TestEventType1)event;\n+            Assert.assertEquals(eventType1.getMsg(), message);\n+            isOnCompleteCalled.set(true);\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertTrue(isOnCompleteCalled.get());\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that even when subscribers are added  the asyncNotify callback gets called just once.\n+     * Expected results: We expect that the callback gets called exactly once.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_Subscribers() {\n+        final String message = \"Async notify Event 2.\";\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(new TestDelegateSubscriber(){\n+            @Override\n+            public void notify(final TestEventType2 event) {\n+                Assert.assertEquals(event.getMsg(), message);\n+            }\n+        });\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n \n-\n-} // E:O:F:LocalSystemEventsAPITest.\n+        localSystemEventsAPI.asyncNotify(new TestEventType2(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType2);\n+            final TestEventType2 eventType2 = (TestEventType2)event;\n+            Assert.assertEquals(eventType2.getMsg(), message);\n+            callsCount.incrementAndGet();\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that an event that implements KeyFilterable and is broadcast only reaches certain audience.\n+     * We creating a few subscribers each one of the provides a key. The Event must reach only those which have the same id.\n+     * Expected results: Only the subscribers with a matching id will be able to consume the event;\n+     */\n+    @Test\n+    public void Test_Send_Event_For_Limited_Audience() {\n+\n+        final Map<String, AtomicInteger> callsCounts = ImmutableMap\n+                .of(\"subscriber1\", new AtomicInteger(0), \"subscriber2\", new AtomicInteger(0),\n+                        \"subscriber3\", new AtomicInteger(0));", "originalCommit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk1Mw==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846953", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.system.event.local.model.EventSubscriber'", "author": "dev-dotcms", "createdAt": "2020-07-16T14:51:04Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -17,6 +17,8 @@\n import com.dotcms.datagen.SiteDataGen;\n import com.dotcms.datagen.TestUserUtils;\n import com.dotcms.datagen.UserDataGen;\n+import com.dotcms.system.event.local.business.LocalSystemEventsAPI;\n+import com.dotcms.system.event.local.model.EventSubscriber;", "originalCommit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk2NA==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846964", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "author": "dev-dotcms", "createdAt": "2020-07-16T14:51:05Z", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppSecretSavedEvent.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.dotcms.security.apps;\n+\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotmarketing.beans.Host;\n+import java.io.Serializable;\n+\n+/**\n+ * AppSecretSavedEvent\n+ * Broadcast when a secret is saved.\n+ */\n+public class AppSecretSavedEvent implements Serializable, KeyFilterable {", "originalCommit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk4MQ==", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846981", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "author": "dev-dotcms", "createdAt": "2020-07-16T14:51:06Z", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -785,4 +792,72 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We subscribe an event listener and save an event\n+     * Expected Results: We expect that an event is fired and that after firing the event the AppsSecret that was initially passed to the save method is now destroyed\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test\n+    public void Test_Save_Secret_Expect_Event_Notification() throws DotDataException, DotSecurityException{\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(AppSecretSavedEvent.class, new AppsSecretEventSubscriber(){\n+            @Override\n+            public void notify(AppSecretSavedEvent event) {\n+                callsCount.incrementAndGet();\n+            }\n+        });\n+\n+        final String appKey = AppsSecretEventSubscriber.appKey;\n+\n+        final AppDescriptor descriptor = mock(AppDescriptor.class);\n+        when(descriptor.isAllowExtraParameters()).thenReturn(false);\n+        final Map<String, ParamDescriptor> params = of(\n+                \"requiredNoDefault\",newParam(null, false, Type.STRING, \"any\", \"hint\", true),\n+                \"requiredDefault\", newParam(\"default\", false, Type.STRING, \"any\", \"hint\", true),\n+                \"nonRequiredNoDefault\", newParam(null, false, Type.STRING, \"any\", \"hint\", false)\n+        );\n+        when(descriptor.getParams()).thenReturn(params);\n+        when(descriptor.getName()).thenReturn(\"any-name\");\n+        when(descriptor.getKey()).thenReturn(appKey);\n+\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final User admin = TestUserUtils.getAdminUser();\n+\n+        //Let's create a set of secrets for a service\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"requiredNoDefault\", \"value\") //We're providing the expected value\n+                .withHiddenSecret(\"requiredDefault\", \"secret-2\")\n+                .build();\n+        //Save it\n+        api.saveSecrets(secrets, site, admin);\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+\n+        // Now Test Secret has been destroyed.\n+        final Map<String, Secret> secretsPostSave = secrets.getSecrets();\n+        for(final String key: secretsPostSave.keySet()){\n+            final char[] value = secretsPostSave.get(key).getValue();\n+            assertTrue(isSecretDestroyed(value));\n+        }\n+    }\n+\n+    /**\n+     * for internal use validate a secret has been destroyed\n+     * @param chars\n+     * @return\n+     */\n+    private boolean isSecretDestroyed(final char [] chars){", "originalCommit": "0de1414e4a24aba954993f7c358eecd5302f15ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}