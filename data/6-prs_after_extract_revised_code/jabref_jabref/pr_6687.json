{"pr_number": 6687, "pr_title": "Add testing interface, including a set of capabilities to tests for", "pr_createdAt": "2020-07-13T19:45:06Z", "pr_url": "https://github.com/JabRef/jabref/pull/6687", "timeline": [{"oid": "a60bdecce57ff73542a38ef49c1e0ff53870aeb8", "url": "https://github.com/JabRef/jabref/commit/a60bdecce57ff73542a38ef49c1e0ff53870aeb8", "message": "Add testing interface, including a set of capabilities to tests for\n\nAdd capability tests for the fetchers to determine whether they support the tested capability.\r\n\r\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-13T19:36:50Z", "type": "commit"}, {"oid": "4881f7bb0a1004a70b9fce168f93ca8391427671", "url": "https://github.com/JabRef/jabref/commit/4881f7bb0a1004a70b9fce168f93ca8391427671", "message": "Merge branch 'feat/add-capability-tests-for-fetchers' of https://github.com/DominikVoigt/jabref into DominikVoigt-feat/add-capability-tests-for-fetchers", "committedDate": "2020-07-13T19:55:19Z", "type": "commit"}, {"oid": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "url": "https://github.com/JabRef/jabref/commit/7c1327581da2d9ba359b7919c4d8df86d9be1133", "message": "Remove all interfaces", "committedDate": "2020-07-13T22:19:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NTM4Mg==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454485382", "bodyText": "As this is a special form of a SearchBasedParserFetcher I would suggest to also reflect it in the name: AdvancedSearchBasedParserFetcher (although it gets a bit long).\nMoreover, I think, it's a good idea to replicate the abstract interface and introduce a AdvancedSearchBasedFetcher as well. Finally, these Advanced* classes should probably overwrite the normal performSearch methods and rely them to the performAdvancedSearch methods in order to make implementation easier, or not?", "author": "tobiasdiez", "createdAt": "2020-07-14T16:29:31Z", "path": "src/main/java/org/jabref/logic/importer/AdvancedFetcher.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.jabref.logic.importer;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+\n+import org.jabref.logic.importer.fetcher.AdvancedSearchConfig;\n+import org.jabref.logic.net.URLDownload;\n+import org.jabref.model.entry.BibEntry;\n+\n+/**\n+ * This interface allows SearchBasedParserFetcher fetchers to test their corresponding\n+ * library APIs for their advanced search options, e.g. search in the \"title\" field.\n+ */\n+public interface AdvancedFetcher extends SearchBasedParserFetcher {", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0NTUyNQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454945525", "bodyText": "Yeah, I totally agree with the renaming of the interface and method.\nI can see your point regarding the introduction of advanced Fetcher classes, but I think that this might not work that simply, as these advanced fetchers would somehow have to parse the query, as it is a string in the standard performSearch method, into a ComplexQuery.\nI think this is out of the scope of the current PR as it just tries to make the fielded search capabilities of the external library APIs testable.\nBut I really like your idea and I believe it will be in the scope of the thesis, just not in scope of this PR. :)", "author": "DominikVoigt", "createdAt": "2020-07-15T10:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1MTg0OA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454951848", "bodyText": "Ok, we can leave it for now. What I was thinking was to simply pass the normal query as the \"default field\" and then call the \"advanced search\" method.\nOtherwise I agree, parsing complex queries should probably happen in the user interface (and should be consistent across fetchers to add even more value for users).", "author": "tobiasdiez", "createdAt": "2020-07-15T10:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NTM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java b/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java\ndeleted file mode 100644\nindex 4f3e40896..000000000\n--- a/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-package org.jabref.logic.importer;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.List;\n-\n-import org.jabref.logic.importer.fetcher.AdvancedSearchConfig;\n-import org.jabref.logic.net.URLDownload;\n-import org.jabref.model.entry.BibEntry;\n-\n-/**\n- * This interface allows SearchBasedParserFetcher fetchers to test their corresponding\n- * library APIs for their advanced search options, e.g. search in the \"title\" field.\n- */\n-public interface AdvancedFetcher extends SearchBasedParserFetcher {\n-\n-    /**\n-     * This method is used to send queries with advanced URL parameters.\n-     * This method is necessary as the performSearch method does not support certain URL parameters that are used for\n-     * fielded search, such as a title, author, or year parameter.\n-     *\n-     * @param advancedSearchConfig the search config defining all fielded search parameters\n-     */\n-    default List<BibEntry> performAdvancedSearch(AdvancedSearchConfig advancedSearchConfig) throws FetcherException {\n-        try (InputStream stream = getAdvancedURLDownload(advancedSearchConfig).asInputStream()) {\n-            List<BibEntry> fetchedEntries = getParser().parseEntries(stream);\n-            fetchedEntries.forEach(this::doPostCleanup);\n-            return fetchedEntries;\n-        } catch (IOException e) {\n-            // TODO: Catch HTTP Response 401/403 errors and report that user has no rights to access resource\n-            throw new FetcherException(\"A network error occurred\", e);\n-        } catch (ParseException e) {\n-            throw new FetcherException(\"An internal parser error occurred\", e);\n-        }\n-    }\n-\n-    URLDownload getAdvancedURLDownload(AdvancedSearchConfig advancedSearchConfig);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NTkzMA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454485930", "bodyText": "the Advanced in the name is not really necessary I guess.\nMoreover, I would rename the paramaer to ComplexQuery (or ComplexSearchQuery) since this is not really a configuration.", "author": "tobiasdiez", "createdAt": "2020-07-14T16:30:24Z", "path": "src/main/java/org/jabref/logic/importer/AdvancedFetcher.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.jabref.logic.importer;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+\n+import org.jabref.logic.importer.fetcher.AdvancedSearchConfig;\n+import org.jabref.logic.net.URLDownload;\n+import org.jabref.model.entry.BibEntry;\n+\n+/**\n+ * This interface allows SearchBasedParserFetcher fetchers to test their corresponding\n+ * library APIs for their advanced search options, e.g. search in the \"title\" field.\n+ */\n+public interface AdvancedFetcher extends SearchBasedParserFetcher {\n+\n+    /**\n+     * This method is used to send queries with advanced URL parameters.\n+     * This method is necessary as the performSearch method does not support certain URL parameters that are used for\n+     * fielded search, such as a title, author, or year parameter.\n+     *\n+     * @param advancedSearchConfig the search config defining all fielded search parameters\n+     */\n+    default List<BibEntry> performAdvancedSearch(AdvancedSearchConfig advancedSearchConfig) throws FetcherException {", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNjQyNg==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454936426", "bodyText": "Thanks, I modified the names accordingly.", "author": "DominikVoigt", "createdAt": "2020-07-15T10:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NTkzMA=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java b/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java\ndeleted file mode 100644\nindex 4f3e40896..000000000\n--- a/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-package org.jabref.logic.importer;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.List;\n-\n-import org.jabref.logic.importer.fetcher.AdvancedSearchConfig;\n-import org.jabref.logic.net.URLDownload;\n-import org.jabref.model.entry.BibEntry;\n-\n-/**\n- * This interface allows SearchBasedParserFetcher fetchers to test their corresponding\n- * library APIs for their advanced search options, e.g. search in the \"title\" field.\n- */\n-public interface AdvancedFetcher extends SearchBasedParserFetcher {\n-\n-    /**\n-     * This method is used to send queries with advanced URL parameters.\n-     * This method is necessary as the performSearch method does not support certain URL parameters that are used for\n-     * fielded search, such as a title, author, or year parameter.\n-     *\n-     * @param advancedSearchConfig the search config defining all fielded search parameters\n-     */\n-    default List<BibEntry> performAdvancedSearch(AdvancedSearchConfig advancedSearchConfig) throws FetcherException {\n-        try (InputStream stream = getAdvancedURLDownload(advancedSearchConfig).asInputStream()) {\n-            List<BibEntry> fetchedEntries = getParser().parseEntries(stream);\n-            fetchedEntries.forEach(this::doPostCleanup);\n-            return fetchedEntries;\n-        } catch (IOException e) {\n-            // TODO: Catch HTTP Response 401/403 errors and report that user has no rights to access resource\n-            throw new FetcherException(\"A network error occurred\", e);\n-        } catch (ParseException e) {\n-            throw new FetcherException(\"An internal parser error occurred\", e);\n-        }\n-    }\n-\n-    URLDownload getAdvancedURLDownload(AdvancedSearchConfig advancedSearchConfig);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4Njc1MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454486750", "bodyText": "In line with the other interfaces, I would suggest to change the return value to URL.", "author": "tobiasdiez", "createdAt": "2020-07-14T16:31:41Z", "path": "src/main/java/org/jabref/logic/importer/AdvancedFetcher.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.jabref.logic.importer;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+\n+import org.jabref.logic.importer.fetcher.AdvancedSearchConfig;\n+import org.jabref.logic.net.URLDownload;\n+import org.jabref.model.entry.BibEntry;\n+\n+/**\n+ * This interface allows SearchBasedParserFetcher fetchers to test their corresponding\n+ * library APIs for their advanced search options, e.g. search in the \"title\" field.\n+ */\n+public interface AdvancedFetcher extends SearchBasedParserFetcher {\n+\n+    /**\n+     * This method is used to send queries with advanced URL parameters.\n+     * This method is necessary as the performSearch method does not support certain URL parameters that are used for\n+     * fielded search, such as a title, author, or year parameter.\n+     *\n+     * @param advancedSearchConfig the search config defining all fielded search parameters\n+     */\n+    default List<BibEntry> performAdvancedSearch(AdvancedSearchConfig advancedSearchConfig) throws FetcherException {\n+        try (InputStream stream = getAdvancedURLDownload(advancedSearchConfig).asInputStream()) {\n+            List<BibEntry> fetchedEntries = getParser().parseEntries(stream);\n+            fetchedEntries.forEach(this::doPostCleanup);\n+            return fetchedEntries;\n+        } catch (IOException e) {\n+            // TODO: Catch HTTP Response 401/403 errors and report that user has no rights to access resource\n+            throw new FetcherException(\"A network error occurred\", e);\n+        } catch (ParseException e) {\n+            throw new FetcherException(\"An internal parser error occurred\", e);\n+        }\n+    }\n+\n+    URLDownload getAdvancedURLDownload(AdvancedSearchConfig advancedSearchConfig);", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNDkzMw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454934933", "bodyText": "Sorry, I do not understand the \"In line with the other interfaces\" as the method is just a modification of the WebFetcher interface that contains a getUrlDownload method that returns an URLDownload?", "author": "DominikVoigt", "createdAt": "2020-07-15T09:57:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4Njc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0NjM5Ng==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454946396", "bodyText": "The analog is\n\n  \n    \n      jabref/src/main/java/org/jabref/logic/importer/SearchBasedParserFetcher.java\n    \n    \n         Line 27\n      in\n      ec71351\n    \n    \n    \n    \n\n        \n          \n           URL getURLForQuery(String query) throws URISyntaxException, MalformedURLException, FetcherException; \n        \n    \n  \n\n\nThe getUrlDownload method converts the url then to a UrlDownload object.", "author": "tobiasdiez", "createdAt": "2020-07-15T10:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4Njc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java b/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java\ndeleted file mode 100644\nindex 4f3e40896..000000000\n--- a/src/main/java/org/jabref/logic/importer/AdvancedFetcher.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-package org.jabref.logic.importer;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.List;\n-\n-import org.jabref.logic.importer.fetcher.AdvancedSearchConfig;\n-import org.jabref.logic.net.URLDownload;\n-import org.jabref.model.entry.BibEntry;\n-\n-/**\n- * This interface allows SearchBasedParserFetcher fetchers to test their corresponding\n- * library APIs for their advanced search options, e.g. search in the \"title\" field.\n- */\n-public interface AdvancedFetcher extends SearchBasedParserFetcher {\n-\n-    /**\n-     * This method is used to send queries with advanced URL parameters.\n-     * This method is necessary as the performSearch method does not support certain URL parameters that are used for\n-     * fielded search, such as a title, author, or year parameter.\n-     *\n-     * @param advancedSearchConfig the search config defining all fielded search parameters\n-     */\n-    default List<BibEntry> performAdvancedSearch(AdvancedSearchConfig advancedSearchConfig) throws FetcherException {\n-        try (InputStream stream = getAdvancedURLDownload(advancedSearchConfig).asInputStream()) {\n-            List<BibEntry> fetchedEntries = getParser().parseEntries(stream);\n-            fetchedEntries.forEach(this::doPostCleanup);\n-            return fetchedEntries;\n-        } catch (IOException e) {\n-            // TODO: Catch HTTP Response 401/403 errors and report that user has no rights to access resource\n-            throw new FetcherException(\"A network error occurred\", e);\n-        } catch (ParseException e) {\n-            throw new FetcherException(\"An internal parser error occurred\", e);\n-        }\n-    }\n-\n-    URLDownload getAdvancedURLDownload(AdvancedSearchConfig advancedSearchConfig);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NzE5NQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454487195", "bodyText": "What's the purpose of this \"default field\" ?", "author": "tobiasdiez", "createdAt": "2020-07-14T16:32:19Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/AdvancedSearchConfig.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.jabref.model.strings.StringUtil;\n+\n+public class AdvancedSearchConfig {\n+    private final String defaultField;\n+    private final String author;\n+    private final String title;\n+    private final Integer fromYear;\n+    private final Integer toYear;\n+    private final String journal;\n+\n+    private AdvancedSearchConfig(String defaultField, String author, String title, Integer fromYear, Integer toYear, String journal) {\n+        this.defaultField = defaultField;\n+        this.author = author;\n+        this.title = title;\n+        this.fromYear = fromYear;\n+        this.toYear = toYear;\n+        this.journal = journal;\n+    }\n+\n+    public Optional<String> getDefaultField() {", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxMTI1OQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454911259", "bodyText": "The default field is used if no fielded search parameter is used. In most of the API's this results in searching in multiple (all) fields.", "author": "DominikVoigt", "createdAt": "2020-07-15T09:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NzE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMDk4Ng==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454930986", "bodyText": "Just add JavaDoc \ud83d\ude05", "author": "koppor", "createdAt": "2020-07-15T09:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4NzE5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/fetcher/AdvancedSearchConfig.java b/src/main/java/org/jabref/logic/importer/fetcher/AdvancedSearchConfig.java\ndeleted file mode 100644\nindex 42308dc3a..000000000\n--- a/src/main/java/org/jabref/logic/importer/fetcher/AdvancedSearchConfig.java\n+++ /dev/null\n\n@@ -1,125 +0,0 @@\n-package org.jabref.logic.importer.fetcher;\n-\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-import org.jabref.model.strings.StringUtil;\n-\n-public class AdvancedSearchConfig {\n-    private final String defaultField;\n-    private final String author;\n-    private final String title;\n-    private final Integer fromYear;\n-    private final Integer toYear;\n-    private final String journal;\n-\n-    private AdvancedSearchConfig(String defaultField, String author, String title, Integer fromYear, Integer toYear, String journal) {\n-        this.defaultField = defaultField;\n-        this.author = author;\n-        this.title = title;\n-        this.fromYear = fromYear;\n-        this.toYear = toYear;\n-        this.journal = journal;\n-    }\n-\n-    public Optional<String> getDefaultField() {\n-        return Optional.ofNullable(defaultField);\n-    }\n-\n-    public Optional<String> getAuthor() {\n-        return Optional.ofNullable(author);\n-    }\n-\n-    public Optional<String> getTitle() {\n-        return Optional.ofNullable(title);\n-    }\n-\n-    public Optional<Integer> getFromYear() {\n-        return Optional.ofNullable(fromYear);\n-    }\n-\n-    public Optional<Integer> getToYear() {\n-        return Optional.ofNullable(toYear);\n-    }\n-\n-    public Optional<String> getJournal() {\n-        return Optional.ofNullable(journal);\n-    }\n-\n-    public static AdvancedSearchConfigBuilder builder() {\n-        return new AdvancedSearchConfigBuilder();\n-    }\n-\n-    public static class AdvancedSearchConfigBuilder {\n-        private String defaultField;\n-        private String author;\n-        private String title;\n-        private String journal;\n-        private Integer fromYear;\n-        private Integer toYear;\n-\n-        public AdvancedSearchConfigBuilder() {\n-        }\n-\n-        public AdvancedSearchConfigBuilder defaultField(String defaultField) {\n-            if (Objects.requireNonNull(defaultField).isBlank()) {\n-                throw new IllegalArgumentException(\"Parameter must not be blank\");\n-            }\n-            this.defaultField = defaultField;\n-            return this;\n-        }\n-\n-        public AdvancedSearchConfigBuilder author(String author) {\n-            if (Objects.requireNonNull(author).isBlank()) {\n-                throw new IllegalArgumentException(\"Parameter must not be blank\");\n-            }\n-            this.author = author;\n-            return this;\n-        }\n-\n-        public AdvancedSearchConfigBuilder title(String title) {\n-            if (Objects.requireNonNull(title).isBlank()) {\n-                throw new IllegalArgumentException(\"Parameter must not be blank\");\n-            }\n-            this.title = title;\n-            return this;\n-        }\n-\n-        public AdvancedSearchConfigBuilder fromYear(Integer fromYear) {\n-            this.fromYear = Objects.requireNonNull(fromYear);\n-            return this;\n-        }\n-\n-        public AdvancedSearchConfigBuilder toYear(Integer toYear) {\n-            this.toYear = Objects.requireNonNull(toYear);\n-            return this;\n-        }\n-\n-        public AdvancedSearchConfigBuilder journal(String journal) {\n-            if (Objects.requireNonNull(journal).isBlank()) {\n-                throw new IllegalArgumentException(\"Parameter must not be blank\");\n-            }\n-            this.journal = journal;\n-            return this;\n-        }\n-\n-        /**\n-         * Instantiates the AdvancesSearchConfig from the provided Builder parameters\n-         * If all text fields are empty an empty optional is returned\n-         *\n-         * @return AdvancedSearchConfig instance with the fields set to the values defined in the building instance.\n-         * @throws IllegalStateException An IllegalStateException is thrown in case all text search fields are empty.\n-         *                               See: https://softwareengineering.stackexchange.com/questions/241309/builder-pattern-when-to-fail/241320#241320\n-         */\n-        public AdvancedSearchConfig build() throws IllegalStateException {\n-            if (textSearchFieldsAreEmpty()) {\n-                throw new IllegalStateException(\"At least one text field has to be set\");\n-            }\n-            return new AdvancedSearchConfig(defaultField, author, title, fromYear, toYear, journal);\n-        }\n-\n-        private boolean textSearchFieldsAreEmpty() {\n-            return StringUtil.isBlank(defaultField) && StringUtil.isBlank(title) && StringUtil.isBlank(author) && StringUtil.isBlank(journal);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454488508", "bodyText": "These new tests are fine, but they are not really using the new interface that you introduced. Is there are reason for this?", "author": "tobiasdiez", "createdAt": "2020-07-14T16:34:32Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/ArXivTest.java", "diffHunk": "@@ -13,210 +14,296 @@\n import org.jabref.model.entry.types.StandardEntryType;\n import org.jabref.testutils.category.FetcherTest;\n \n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @FetcherTest\n-class ArXivTest {\n-    private ArXiv finder;\n+class ArXivTest implements SearchBasedFetcherCapabilityTest {\n+    private ArXiv fetcher;\n     private BibEntry entry;\n     private BibEntry sliceTheoremPaper;\n \n     @BeforeEach\n     void setUp() {\n         ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n         when(importFormatPreferences.getKeywordSeparator()).thenReturn(',');\n-        finder = new ArXiv(importFormatPreferences);\n+        fetcher = new ArXiv(importFormatPreferences);\n         entry = new BibEntry();\n-\n-        sliceTheoremPaper = new BibEntry();\n-        sliceTheoremPaper.setType(StandardEntryType.Article);\n-        sliceTheoremPaper.setField(StandardField.AUTHOR, \"Tobias Diez\");\n-        sliceTheoremPaper.setField(StandardField.TITLE, \"Slice theorem for Fr\u00e9chet group actions and covariant symplectic field theory\");\n-        sliceTheoremPaper.setField(StandardField.DATE, \"2014-05-09\");\n-        sliceTheoremPaper.setField(StandardField.ABSTRACT, \"A general slice theorem for the action of a Fr\\\\'echet Lie group on a Fr\\\\'echet manifolds is established. The Nash-Moser theorem provides the fundamental tool to generalize the result of Palais to this infinite-dimensional setting. The presented slice theorem is illustrated by its application to gauge theories: the action of the gauge transformation group admits smooth slices at every point and thus the gauge orbit space is stratified by Fr\\\\'echet manifolds. Furthermore, a covariant and symplectic formulation of classical field theory is proposed and extensively discussed. At the root of this novel framework is the incorporation of field degrees of freedom F and spacetime M into the product manifold F * M. The induced bigrading of differential forms is used in order to carry over the usual symplectic theory to this new setting. The examples of the Klein-Gordon field and general Yang-Mills theory illustrate that the presented approach conveniently handles the occurring symmetries.\");\n-        sliceTheoremPaper.setField(StandardField.EPRINT, \"1405.2249\");\n-        sliceTheoremPaper.setField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/1405.2249v1:PDF\");\n-        sliceTheoremPaper.setField(StandardField.EPRINTTYPE, \"arXiv\");\n-        sliceTheoremPaper.setField(StandardField.EPRINTCLASS, \"math-ph\");\n-        sliceTheoremPaper.setField(StandardField.KEYWORDS, \"math-ph, math.DG, math.MP, math.SG, 58B99, 58Z05, 58B25, 22E65, 58D19, 53D20, 53D42\");\n+        sliceTheoremPaper = new BibEntry(StandardEntryType.Article)\n+                .withField(StandardField.AUTHOR, \"Tobias Diez\")\n+                .withField(StandardField.TITLE, \"Slice theorem for Fr\u00e9chet group actions and covariant symplectic field theory\")\n+                .withField(StandardField.DATE, \"2014-05-09\")\n+                .withField(StandardField.ABSTRACT, \"A general slice theorem for the action of a Fr\\\\'echet Lie group on a Fr\\\\'echet manifolds is established. The Nash-Moser theorem provides the fundamental tool to generalize the result of Palais to this infinite-dimensional setting. The presented slice theorem is illustrated by its application to gauge theories: the action of the gauge transformation group admits smooth slices at every point and thus the gauge orbit space is stratified by Fr\\\\'echet manifolds. Furthermore, a covariant and symplectic formulation of classical field theory is proposed and extensively discussed. At the root of this novel framework is the incorporation of field degrees of freedom F and spacetime M into the product manifold F * M. The induced bigrading of differential forms is used in order to carry over the usual symplectic theory to this new setting. The examples of the Klein-Gordon field and general Yang-Mills theory illustrate that the presented approach conveniently handles the occurring symmetries.\")\n+                .withField(StandardField.EPRINT, \"1405.2249\")\n+                .withField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/1405.2249v1:PDF\")\n+                .withField(StandardField.EPRINTTYPE, \"arXiv\")\n+                .withField(StandardField.EPRINTCLASS, \"math-ph\")\n+                .withField(StandardField.KEYWORDS, \"math-ph, math.DG, math.MP, math.SG, 58B99, 58Z05, 58B25, 22E65, 58D19, 53D20, 53D42\");\n     }\n \n     @Test\n     void findFullTextForEmptyEntryResultsEmptyOptional() throws IOException {\n-        assertEquals(Optional.empty(), finder.findFullText(entry));\n+        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextRejectsNullParameter() {\n-        assertThrows(NullPointerException.class, () -> finder.findFullText(null));\n+        assertThrows(NullPointerException.class, () -> fetcher.findFullText(null));\n     }\n \n     @Test\n     void findFullTextByDOI() throws IOException {\n         entry.setField(StandardField.DOI, \"10.1529/biophysj.104.047340\");\n         entry.setField(StandardField.TITLE, \"Pause Point Spectra in DNA Constant-Force Unzipping\");\n \n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), finder.findFullText(entry));\n+        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextByEprint() throws IOException {\n         entry.setField(StandardField.EPRINT, \"1603.06570\");\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), finder.findFullText(entry));\n+        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextByEprintWithPrefix() throws IOException {\n         entry.setField(StandardField.EPRINT, \"arXiv:1603.06570\");\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), finder.findFullText(entry));\n+        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextByEprintWithUnknownDOI() throws IOException {\n         entry.setField(StandardField.DOI, \"10.1529/unknown\");\n         entry.setField(StandardField.EPRINT, \"1603.06570\");\n \n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), finder.findFullText(entry));\n+        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextByTitle() throws IOException {\n         entry.setField(StandardField.TITLE, \"Pause Point Spectra in DNA Constant-Force Unzipping\");\n \n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), finder.findFullText(entry));\n+        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextByTitleAndPartOfAuthor() throws IOException {\n         entry.setField(StandardField.TITLE, \"Pause Point Spectra in DNA Constant-Force Unzipping\");\n         entry.setField(StandardField.AUTHOR, \"Weeks and Lucks\");\n \n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), finder.findFullText(entry));\n+        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void notFindFullTextByUnknownDOI() throws IOException {\n         entry.setField(StandardField.DOI, \"10.1529/unknown\");\n-        assertEquals(Optional.empty(), finder.findFullText(entry));\n+        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void notFindFullTextByUnknownId() throws IOException {\n         entry.setField(StandardField.EPRINT, \"1234.12345\");\n-        assertEquals(Optional.empty(), finder.findFullText(entry));\n+        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextByDOINotAvailableInCatalog() throws IOException {\n         entry.setField(StandardField.DOI, \"10.1016/0370-2693(77)90015-6\");\n         entry.setField(StandardField.TITLE, \"Superspace formulation of supergravity\");\n \n-        assertEquals(Optional.empty(), finder.findFullText(entry));\n+        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextEntityWithoutDoi() throws IOException {\n-        assertEquals(Optional.empty(), finder.findFullText(entry));\n+        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n     }\n \n     @Test\n     void findFullTextTrustLevel() {\n-        assertEquals(TrustLevel.PREPRINT, finder.getTrustLevel());\n+        assertEquals(TrustLevel.PREPRINT, fetcher.getTrustLevel());\n     }\n \n     @Test\n     void searchEntryByPartOfTitle() throws Exception {\n         assertEquals(Collections.singletonList(sliceTheoremPaper),\n-                finder.performSearch(\"ti:\\\"slice theorem for Frechet\\\"\"));\n+                fetcher.performSearch(\"ti:\\\"slice theorem for Frechet\\\"\"));\n     }\n \n     @Test\n     void searchEntryByPartOfTitleWithAcuteAccent() throws Exception {\n         assertEquals(Collections.singletonList(sliceTheoremPaper),\n-                finder.performSearch(\"ti:\\\"slice theorem for Fr\u00e9chet\\\"\"));\n+                fetcher.performSearch(\"ti:\\\"slice theorem for Fr\u00e9chet\\\"\"));\n     }\n \n     @Test\n     void searchEntryByOldId() throws Exception {\n-        BibEntry expected = new BibEntry();\n-        expected.setType(StandardEntryType.Article);\n-        expected.setField(StandardField.AUTHOR, \"H1 Collaboration\");\n-        expected.setField(StandardField.TITLE, \"Multi-Electron Production at High Transverse Momenta in ep Collisions at HERA\");\n-        expected.setField(StandardField.DATE, \"2003-07-07\");\n-        expected.setField(StandardField.ABSTRACT, \"Multi-electron production is studied at high electron transverse momentum in positron- and electron-proton collisions using the H1 detector at HERA. The data correspond to an integrated luminosity of 115 pb-1. Di-electron and tri-electron event yields are measured. Cross sections are derived in a restricted phase space region dominated by photon-photon collisions. In general good agreement is found with the Standard Model predictions. However, for electron pair invariant masses above 100 GeV, three di-electron events and three tri-electron events are observed, compared to Standard Model expectations of 0.30 \\\\pm 0.04 and 0.23 \\\\pm 0.04, respectively.\");\n-        expected.setField(StandardField.EPRINT, \"hep-ex/0307015\");\n-        expected.setField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/hep-ex/0307015v1:PDF\");\n-        expected.setField(StandardField.EPRINTTYPE, \"arXiv\");\n-        expected.setField(StandardField.EPRINTCLASS, \"hep-ex\");\n-        expected.setField(StandardField.KEYWORDS, \"hep-ex\");\n-        expected.setField(StandardField.DOI, \"10.1140/epjc/s2003-01326-x\");\n-        expected.setField(StandardField.JOURNALTITLE, \"Eur.Phys.J.C31:17-29,2003\");\n-\n-        assertEquals(Optional.of(expected), finder.performSearchById(\"hep-ex/0307015\"));\n+        BibEntry expected = new BibEntry(StandardEntryType.Article)\n+                .withField(StandardField.AUTHOR, \"H1 Collaboration\")\n+                .withField(StandardField.TITLE, \"Multi-Electron Production at High Transverse Momenta in ep Collisions at HERA\")\n+                .withField(StandardField.DATE, \"2003-07-07\")\n+                .withField(StandardField.ABSTRACT, \"Multi-electron production is studied at high electron transverse momentum in positron- and electron-proton collisions using the H1 detector at HERA. The data correspond to an integrated luminosity of 115 pb-1. Di-electron and tri-electron event yields are measured. Cross sections are derived in a restricted phase space region dominated by photon-photon collisions. In general good agreement is found with the Standard Model predictions. However, for electron pair invariant masses above 100 GeV, three di-electron events and three tri-electron events are observed, compared to Standard Model expectations of 0.30 \\\\pm 0.04 and 0.23 \\\\pm 0.04, respectively.\")\n+                .withField(StandardField.EPRINT, \"hep-ex/0307015\")\n+                .withField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/hep-ex/0307015v1:PDF\")\n+                .withField(StandardField.EPRINTTYPE, \"arXiv\")\n+                .withField(StandardField.EPRINTCLASS, \"hep-ex\")\n+                .withField(StandardField.KEYWORDS, \"hep-ex\")\n+                .withField(StandardField.DOI, \"10.1140/epjc/s2003-01326-x\")\n+                .withField(StandardField.JOURNALTITLE, \"Eur.Phys.J.C31:17-29,2003\");\n+\n+        assertEquals(Optional.of(expected), fetcher.performSearchById(\"hep-ex/0307015\"));\n     }\n \n     @Test\n     void searchEntryByIdWith4DigitsAndVersion() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"1405.2249v1\"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"1405.2249v1\"));\n     }\n \n     @Test\n     void searchEntryByIdWith4Digits() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"1405.2249\"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"1405.2249\"));\n     }\n \n     @Test\n     void searchEntryByIdWith4DigitsAndPrefix() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"arXiv:1405.2249\"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"arXiv:1405.2249\"));\n     }\n \n     @Test\n     void searchEntryByIdWith4DigitsAndPrefixAndNotTrimmed() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"arXiv : 1405. 2249\"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"arXiv : 1405. 2249\"));\n     }\n \n     @Test\n     void searchEntryByIdWith5Digits() throws Exception {\n         assertEquals(Optional.of(\n                 \"An Optimal Convergence Theorem for Mean Curvature Flow of Arbitrary Codimension in Hyperbolic Spaces\"),\n-                finder.performSearchById(\"1503.06747\").flatMap(entry -> entry.getField(StandardField.TITLE)));\n+                fetcher.performSearchById(\"1503.06747\").flatMap(entry -> entry.getField(StandardField.TITLE)));\n     }\n \n     @Test\n     void searchWithMalformedIdThrowsException() throws Exception {\n-        assertThrows(FetcherException.class, () -> finder.performSearchById(\"123412345\"));\n+        assertThrows(FetcherException.class, () -> fetcher.performSearchById(\"123412345\"));\n     }\n \n     @Test\n     void searchIdentifierForSlicePaper() throws Exception {\n         sliceTheoremPaper.clearField(StandardField.EPRINT);\n \n-        assertEquals(ArXivIdentifier.parse(\"1405.2249\"), finder.findIdentifier(sliceTheoremPaper));\n+        assertEquals(ArXivIdentifier.parse(\"1405.2249\"), fetcher.findIdentifier(sliceTheoremPaper));\n     }\n \n     @Test\n     void searchEmptyId() throws Exception {\n-        assertEquals(Optional.empty(), finder.performSearchById(\"\"));\n+        assertEquals(Optional.empty(), fetcher.performSearchById(\"\"));\n     }\n \n     @Test\n     void searchWithHttpUrl() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"http://arxiv.org/abs/1405.2249\"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"http://arxiv.org/abs/1405.2249\"));\n     }\n \n     @Test\n     void searchWithHttpsUrl() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"https://arxiv.org/abs/1405.2249\"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"https://arxiv.org/abs/1405.2249\"));\n     }\n \n     @Test\n     void searchWithHttpsUrlNotTrimmed() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), finder.performSearchById(\"https : // arxiv . org / abs / 1405 . 2249 \"));\n+        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"https : // arxiv . org / abs / 1405 . 2249 \"));\n+    }\n+\n+    @Test\n+    @Override\n+    public void supportsAuthorSearch() throws Exception {\n+        List<BibEntry> results = fetcher.performSearch(\"au:\\\"Tobias Diez\\\"\");", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzMjgzMA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454932830", "bodyText": "The AdvancedFetcher Interface is only used for fetchers that use URL parameters for fielded search. Since in this case arXiv uses the query string for fielded search, this is not necessary.\nAn example where this Interface will be used is the IEEE fetcher in the future. The IEEE Fetcher Tests that should be using the interface are not implemented yet, due to my IEEE API key not being activated until recently.", "author": "DominikVoigt", "createdAt": "2020-07-15T09:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNDE4NQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454934185", "bodyText": "This is contained in the JavaDoc from the interface the test implements, isn't it?", "author": "koppor", "createdAt": "2020-07-15T09:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0ODAxNA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454948014", "bodyText": "I thought the end goal was to support more complex search queries with a syntax that is the same across all \"advanced fetchers\" (and parsed to the \"AdvancedSearchQuery\" object). Thus, I think also the arXiv fetcher should implement the AdvancedFetcher interface, and then internally convert it to the correct query using \"au:\" etc.", "author": "tobiasdiez", "createdAt": "2020-07-15T10:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk2NTcwMw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454965703", "bodyText": "The thought behind the current state is, that the fetchers that support fielded search as part of the query string do not have to be changed.\nTo get closed to the end goal though, we can integrate the perfromComplexSearchQuery method into the SearchBasedFetcher interface. The problem with this is, that not all APIs and their corresponding fetchers will be able to support all fields that are included in the AdvancedSearchConfig/ComplexQuery.", "author": "DominikVoigt", "createdAt": "2020-07-15T10:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk2ODc5Ng==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454968796", "bodyText": "End goal: right. Breaking it up in smaller PRs to ease reviewing. Maybe, it was too much to include the search config now? - Howe6, to me, that part was already finished. Thus, I thought it is a good package to review. There will be follow up PRs.\n@DominikVoigt Maybe you can show one implementation this week or do the issues with keys prevent you from that?", "author": "koppor", "createdAt": "2020-07-15T11:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk3MjkxNw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454972917", "bodyText": "Solved the key issue yesterday. I'll work on one implementation this week.", "author": "DominikVoigt", "createdAt": "2020-07-15T11:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5OTU3Mg==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454999572", "bodyText": "We can leave it like this for the moment, but the tests should get rewritten to use the performComplexSearch method at some point.", "author": "tobiasdiez", "createdAt": "2020-07-15T12:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ4ODUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/test/java/org/jabref/logic/importer/fetcher/ArXivTest.java b/src/test/java/org/jabref/logic/importer/fetcher/ArXivTest.java\ndeleted file mode 100644\nindex 896698307..000000000\n--- a/src/test/java/org/jabref/logic/importer/fetcher/ArXivTest.java\n+++ /dev/null\n\n@@ -1,309 +0,0 @@\n-package org.jabref.logic.importer.fetcher;\n-\n-import java.io.IOException;\n-import java.net.URL;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import org.jabref.logic.importer.FetcherException;\n-import org.jabref.logic.importer.ImportFormatPreferences;\n-import org.jabref.model.entry.BibEntry;\n-import org.jabref.model.entry.field.StandardField;\n-import org.jabref.model.entry.identifier.ArXivIdentifier;\n-import org.jabref.model.entry.types.StandardEntryType;\n-import org.jabref.testutils.category.FetcherTest;\n-\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-@FetcherTest\n-class ArXivTest implements SearchBasedFetcherCapabilityTest {\n-    private ArXiv fetcher;\n-    private BibEntry entry;\n-    private BibEntry sliceTheoremPaper;\n-\n-    @BeforeEach\n-    void setUp() {\n-        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n-        when(importFormatPreferences.getKeywordSeparator()).thenReturn(',');\n-        fetcher = new ArXiv(importFormatPreferences);\n-        entry = new BibEntry();\n-        sliceTheoremPaper = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Tobias Diez\")\n-                .withField(StandardField.TITLE, \"Slice theorem for Fr\u00e9chet group actions and covariant symplectic field theory\")\n-                .withField(StandardField.DATE, \"2014-05-09\")\n-                .withField(StandardField.ABSTRACT, \"A general slice theorem for the action of a Fr\\\\'echet Lie group on a Fr\\\\'echet manifolds is established. The Nash-Moser theorem provides the fundamental tool to generalize the result of Palais to this infinite-dimensional setting. The presented slice theorem is illustrated by its application to gauge theories: the action of the gauge transformation group admits smooth slices at every point and thus the gauge orbit space is stratified by Fr\\\\'echet manifolds. Furthermore, a covariant and symplectic formulation of classical field theory is proposed and extensively discussed. At the root of this novel framework is the incorporation of field degrees of freedom F and spacetime M into the product manifold F * M. The induced bigrading of differential forms is used in order to carry over the usual symplectic theory to this new setting. The examples of the Klein-Gordon field and general Yang-Mills theory illustrate that the presented approach conveniently handles the occurring symmetries.\")\n-                .withField(StandardField.EPRINT, \"1405.2249\")\n-                .withField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/1405.2249v1:PDF\")\n-                .withField(StandardField.EPRINTTYPE, \"arXiv\")\n-                .withField(StandardField.EPRINTCLASS, \"math-ph\")\n-                .withField(StandardField.KEYWORDS, \"math-ph, math.DG, math.MP, math.SG, 58B99, 58Z05, 58B25, 22E65, 58D19, 53D20, 53D42\");\n-    }\n-\n-    @Test\n-    void findFullTextForEmptyEntryResultsEmptyOptional() throws IOException {\n-        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextRejectsNullParameter() {\n-        assertThrows(NullPointerException.class, () -> fetcher.findFullText(null));\n-    }\n-\n-    @Test\n-    void findFullTextByDOI() throws IOException {\n-        entry.setField(StandardField.DOI, \"10.1529/biophysj.104.047340\");\n-        entry.setField(StandardField.TITLE, \"Pause Point Spectra in DNA Constant-Force Unzipping\");\n-\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextByEprint() throws IOException {\n-        entry.setField(StandardField.EPRINT, \"1603.06570\");\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextByEprintWithPrefix() throws IOException {\n-        entry.setField(StandardField.EPRINT, \"arXiv:1603.06570\");\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextByEprintWithUnknownDOI() throws IOException {\n-        entry.setField(StandardField.DOI, \"10.1529/unknown\");\n-        entry.setField(StandardField.EPRINT, \"1603.06570\");\n-\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/1603.06570v1\")), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextByTitle() throws IOException {\n-        entry.setField(StandardField.TITLE, \"Pause Point Spectra in DNA Constant-Force Unzipping\");\n-\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextByTitleAndPartOfAuthor() throws IOException {\n-        entry.setField(StandardField.TITLE, \"Pause Point Spectra in DNA Constant-Force Unzipping\");\n-        entry.setField(StandardField.AUTHOR, \"Weeks and Lucks\");\n-\n-        assertEquals(Optional.of(new URL(\"http://arxiv.org/pdf/cond-mat/0406246v1\")), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void notFindFullTextByUnknownDOI() throws IOException {\n-        entry.setField(StandardField.DOI, \"10.1529/unknown\");\n-        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void notFindFullTextByUnknownId() throws IOException {\n-        entry.setField(StandardField.EPRINT, \"1234.12345\");\n-        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextByDOINotAvailableInCatalog() throws IOException {\n-        entry.setField(StandardField.DOI, \"10.1016/0370-2693(77)90015-6\");\n-        entry.setField(StandardField.TITLE, \"Superspace formulation of supergravity\");\n-\n-        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextEntityWithoutDoi() throws IOException {\n-        assertEquals(Optional.empty(), fetcher.findFullText(entry));\n-    }\n-\n-    @Test\n-    void findFullTextTrustLevel() {\n-        assertEquals(TrustLevel.PREPRINT, fetcher.getTrustLevel());\n-    }\n-\n-    @Test\n-    void searchEntryByPartOfTitle() throws Exception {\n-        assertEquals(Collections.singletonList(sliceTheoremPaper),\n-                fetcher.performSearch(\"ti:\\\"slice theorem for Frechet\\\"\"));\n-    }\n-\n-    @Test\n-    void searchEntryByPartOfTitleWithAcuteAccent() throws Exception {\n-        assertEquals(Collections.singletonList(sliceTheoremPaper),\n-                fetcher.performSearch(\"ti:\\\"slice theorem for Fr\u00e9chet\\\"\"));\n-    }\n-\n-    @Test\n-    void searchEntryByOldId() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"H1 Collaboration\")\n-                .withField(StandardField.TITLE, \"Multi-Electron Production at High Transverse Momenta in ep Collisions at HERA\")\n-                .withField(StandardField.DATE, \"2003-07-07\")\n-                .withField(StandardField.ABSTRACT, \"Multi-electron production is studied at high electron transverse momentum in positron- and electron-proton collisions using the H1 detector at HERA. The data correspond to an integrated luminosity of 115 pb-1. Di-electron and tri-electron event yields are measured. Cross sections are derived in a restricted phase space region dominated by photon-photon collisions. In general good agreement is found with the Standard Model predictions. However, for electron pair invariant masses above 100 GeV, three di-electron events and three tri-electron events are observed, compared to Standard Model expectations of 0.30 \\\\pm 0.04 and 0.23 \\\\pm 0.04, respectively.\")\n-                .withField(StandardField.EPRINT, \"hep-ex/0307015\")\n-                .withField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/hep-ex/0307015v1:PDF\")\n-                .withField(StandardField.EPRINTTYPE, \"arXiv\")\n-                .withField(StandardField.EPRINTCLASS, \"hep-ex\")\n-                .withField(StandardField.KEYWORDS, \"hep-ex\")\n-                .withField(StandardField.DOI, \"10.1140/epjc/s2003-01326-x\")\n-                .withField(StandardField.JOURNALTITLE, \"Eur.Phys.J.C31:17-29,2003\");\n-\n-        assertEquals(Optional.of(expected), fetcher.performSearchById(\"hep-ex/0307015\"));\n-    }\n-\n-    @Test\n-    void searchEntryByIdWith4DigitsAndVersion() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"1405.2249v1\"));\n-    }\n-\n-    @Test\n-    void searchEntryByIdWith4Digits() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"1405.2249\"));\n-    }\n-\n-    @Test\n-    void searchEntryByIdWith4DigitsAndPrefix() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"arXiv:1405.2249\"));\n-    }\n-\n-    @Test\n-    void searchEntryByIdWith4DigitsAndPrefixAndNotTrimmed() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"arXiv : 1405. 2249\"));\n-    }\n-\n-    @Test\n-    void searchEntryByIdWith5Digits() throws Exception {\n-        assertEquals(Optional.of(\n-                \"An Optimal Convergence Theorem for Mean Curvature Flow of Arbitrary Codimension in Hyperbolic Spaces\"),\n-                fetcher.performSearchById(\"1503.06747\").flatMap(entry -> entry.getField(StandardField.TITLE)));\n-    }\n-\n-    @Test\n-    void searchWithMalformedIdThrowsException() throws Exception {\n-        assertThrows(FetcherException.class, () -> fetcher.performSearchById(\"123412345\"));\n-    }\n-\n-    @Test\n-    void searchIdentifierForSlicePaper() throws Exception {\n-        sliceTheoremPaper.clearField(StandardField.EPRINT);\n-\n-        assertEquals(ArXivIdentifier.parse(\"1405.2249\"), fetcher.findIdentifier(sliceTheoremPaper));\n-    }\n-\n-    @Test\n-    void searchEmptyId() throws Exception {\n-        assertEquals(Optional.empty(), fetcher.performSearchById(\"\"));\n-    }\n-\n-    @Test\n-    void searchWithHttpUrl() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"http://arxiv.org/abs/1405.2249\"));\n-    }\n-\n-    @Test\n-    void searchWithHttpsUrl() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"https://arxiv.org/abs/1405.2249\"));\n-    }\n-\n-    @Test\n-    void searchWithHttpsUrlNotTrimmed() throws Exception {\n-        assertEquals(Optional.of(sliceTheoremPaper), fetcher.performSearchById(\"https : // arxiv . org / abs / 1405 . 2249 \"));\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsAuthorSearch() throws Exception {\n-        List<BibEntry> results = fetcher.performSearch(\"au:\\\"Tobias Diez\\\"\");\n-        assertFalse(results.isEmpty());\n-        results.forEach(bibEntry -> {\n-\n-            String author = bibEntry.getField(StandardField.AUTHOR).orElse(\"\");\n-\n-            // The co-authors differ, thus we check for the author present at all papers\n-            Assertions.assertTrue(author.contains(\"Tobias Diez\"));\n-        });\n-    }\n-\n-    @Disabled(\"Is not supported by the current API\")\n-    @Test\n-    @Override\n-    public void supportsYearSearch() throws Exception {\n-    }\n-\n-    @Disabled(\"Is not supported by the current API\")\n-    @Test\n-    @Override\n-    public void supportsYearRangeSearch() throws Exception {\n-\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsJournalSearch() throws Exception {\n-        List<BibEntry> results = fetcher.performSearch(\"jr: \\\"Journal of Geometry and Physics (2013)\\\"\");\n-        assertFalse(results.isEmpty());\n-        results.forEach(bibEntry -> {\n-            String journalTitle = bibEntry.getField(StandardField.JOURNALTITLE).orElse(\"\");\n-            // Throw away year and following information\n-            journalTitle = journalTitle.replaceFirst(\" \\\\(\\\\d\\\\d\\\\d\\\\d\\\\).*\", \"\");\n-            // Just check whether the returned entries contain the queried journal as journal title.\n-            assertEquals(\"Journal of Geometry and Physics\", journalTitle);\n-        });\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsPhraseSearch() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Tobias B\u00fcscher and Angel L. Diez and Gerhard Gompper and Jens Elgeti\")\n-                .withField(StandardField.TITLE, \"Instability and fingering of interfaces in growing tissue\")\n-                .withField(StandardField.DATE, \"2020-03-10\")\n-                .withField(StandardField.ABSTRACT, \"Interfaces in tissues are ubiquitous, both between tissue and environment as well as between populations of different cell types. The propagation of an interface can be driven mechanically. % e.g. by a difference in the respective homeostatic stress of the different cell types. Computer simulations of growing tissues are employed to study the stability of the interface between two tissues on a substrate. From a mechanical perspective, the dynamics and stability of this system is controlled mainly by four parameters of the respective tissues: (i) the homeostatic stress (ii) cell motility (iii) tissue viscosity and (iv) substrate friction. For propagation driven by a difference in homeostatic stress, the interface is stable for tissue-specific substrate friction even for very large differences of homeostatic stress; however, it becomes unstable above a critical stress difference when the tissue with the larger homeostatic stress has a higher viscosity. A small difference in directed bulk motility between the two tissues suffices to result in propagation with a stable interface, even for otherwise identical tissues. Larger differences in motility force, however, result in a finite-wavelength instability of the interface. Interestingly, the instability is apparently bound by nonlinear effects and the amplitude of the interface undulations only grows to a finite value in time.\")\n-                .withField(StandardField.EPRINT, \"2003.04601\")\n-                .withField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/2003.04601v1:PDF\")\n-                .withField(StandardField.EPRINTTYPE, \"arXiv\")\n-                .withField(StandardField.EPRINTCLASS, \"q-bio.TO\")\n-                .withField(StandardField.KEYWORDS, \"q-bio.TO\");\n-\n-        List<BibEntry> resultWithPhraseSearch = fetcher.performSearch(\"au:\\\"Tobias Diez\\\"\");\n-        List<BibEntry> resultWithOutPhraseSearch = fetcher.performSearch(\"au:Tobias Diez\");\n-        // Ensure that phrase search result is just a subset of the default search result\n-        assertTrue(resultWithOutPhraseSearch.containsAll(resultWithPhraseSearch));\n-        resultWithOutPhraseSearch.removeAll(resultWithPhraseSearch);\n-\n-        // There is only a single paper found by searching for Tobias Diez as author that is not authored by \"Tobias Diez\".\n-        assertEquals(Collections.singletonList(expected), resultWithOutPhraseSearch);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsBooleanANDSearch() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Tobias B\u00fcscher and Angel L. Diez and Gerhard Gompper and Jens Elgeti\")\n-                .withField(StandardField.TITLE, \"Instability and fingering of interfaces in growing tissue\")\n-                .withField(StandardField.DATE, \"2020-03-10\")\n-                .withField(StandardField.ABSTRACT, \"Interfaces in tissues are ubiquitous, both between tissue and environment as well as between populations of different cell types. The propagation of an interface can be driven mechanically. % e.g. by a difference in the respective homeostatic stress of the different cell types. Computer simulations of growing tissues are employed to study the stability of the interface between two tissues on a substrate. From a mechanical perspective, the dynamics and stability of this system is controlled mainly by four parameters of the respective tissues: (i) the homeostatic stress (ii) cell motility (iii) tissue viscosity and (iv) substrate friction. For propagation driven by a difference in homeostatic stress, the interface is stable for tissue-specific substrate friction even for very large differences of homeostatic stress; however, it becomes unstable above a critical stress difference when the tissue with the larger homeostatic stress has a higher viscosity. A small difference in directed bulk motility between the two tissues suffices to result in propagation with a stable interface, even for otherwise identical tissues. Larger differences in motility force, however, result in a finite-wavelength instability of the interface. Interestingly, the instability is apparently bound by nonlinear effects and the amplitude of the interface undulations only grows to a finite value in time.\")\n-                .withField(StandardField.EPRINT, \"2003.04601\")\n-                .withField(StandardField.FILE, \":http\\\\://arxiv.org/pdf/2003.04601v1:PDF\")\n-                .withField(StandardField.EPRINTTYPE, \"arXiv\")\n-                .withField(StandardField.EPRINTCLASS, \"q-bio.TO\")\n-                .withField(StandardField.KEYWORDS, \"q-bio.TO\");\n-\n-        List<BibEntry> result = fetcher.performSearch(\"au:\\\"Tobias B\u00fcscher\\\" AND ti:\\\"Instability and fingering of interfaces\\\"\");\n-\n-        // There is only one paper authored by Tobias B\u00fcscher with that phrase in the title\n-        assertEquals(Collections.singletonList(expected), result);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454493388", "bodyText": "I don't think it's a good strategy to have a test interface. As you have already noted not every fetcher supports all of these fields, and it is also not possible to make sure that the tests defined by this interface are consistent across the fetchers.\nWhat would make more sense is to have tests (against the interface itself) that checks that all implementing classes perform the same under certain conditions (e.g. empty query results in empty result etc). Personally I would restrict those general tests to simple test situations, although it should be possible to use parameterized tests to also check for more complex scenarios.", "author": "tobiasdiez", "createdAt": "2020-07-14T16:42:06Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/SearchBasedFetcherCapabilityTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Defines the set of capability tests that each tests a given search capability, e.g. author based search.", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzNjg1NA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454936854", "bodyText": "These tests are more low-level. That was tried to be explained there:\n\nHere, I am systematically evaluating the capabilities of fetchers. This is a) for documentation in code b) to check whether the fetchers change their capability over time. I accept that tests may fail due to changing external services.\n\n\"documentation as code\"\nThe screnario explained by you builds on the \"results\" of these tests. These test ensure that the idea of \"your\" tests can be implemented.", "author": "koppor", "createdAt": "2020-07-15T10:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkzOTM5NA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454939394", "bodyText": "In other words: Instead of documenting the features of a fetcher in markdown, Google Docs, Latex,  PDF or JavaDoc, the documentation is put as code. This ensures that one implementation aspect (query synatx) is checked, changes of the capabilities are detected at the level.of the query and that the list of capabilities (avail/unavail) are noted down as test case.\nWhen documenting in Markdown (or other text), a programmer has to update the documentation in case a capability changes. It is open who enforces this (e.g., do the reviewers know that there is documentation somewhere?) - With the \"documentation as code\" approach, the programmer is forced to update the documentation", "author": "koppor", "createdAt": "2020-07-15T10:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk1MDIyNQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454950225", "bodyText": "I'm in favor of adding these tests, but I don't see the value of the test interface. The interface methods don't say anything about the actual contract that the fetcher has to satisfy. At most they serve as a reminder to test certain aspects of the fetcher.", "author": "tobiasdiez", "createdAt": "2020-07-15T10:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk2OTI5MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454969290", "bodyText": "Therefore, more tests covering the contract will come in. These tests are one level above the current ones. This here is like testing Java Byte Code, the next tests will tests Java Code", "author": "koppor", "createdAt": "2020-07-15T11:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk3MzA2Mw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454973063", "bodyText": "Will be a \"research\" effort to compare the semantics. E.g. is \"year\" really the same for each fetcher? Submission date versus published date. - Is \"journal\" the same thing for all.\nWe can surely work on that. Then the PR will posaibly be ready in September if all other parts of the Theiss are finished.\nWith that, I surely accept that there might be changes in the future . They definitely need to be discussed.\nThe idea is to have rather small PRs than 10kLOC to review as a whole in September.", "author": "koppor", "createdAt": "2020-07-15T11:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5ODc0NA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454998744", "bodyText": "As I said above, the idea of the tests is good. I also agree with many small PRs instead of a big one.\nBut can you please explain to me what the advantages of the test interface are? The test interface is never used (only implemented), thus from an abstract object-oriented view it's meaningless, right?", "author": "tobiasdiez", "createdAt": "2020-07-15T12:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1MjcwMw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r455052703", "bodyText": "Implementation-only is also valid from oo perspective. The alternative would be an abstract class. In the concrete case,  the test classes implementing the interface implement also more tests. The interface just documents that the respective tests are implemented for the concrete fetcher. Documentation as code (answering the question for which fetchers a capability test is implemented)", "author": "koppor", "createdAt": "2020-07-15T13:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0MjYxOQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r455242619", "bodyText": "I strongly prefer that the interface adds real tests and not just serves as a reminder. See for example the StringTest at the end of https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-interfaces-and-default-methods. There the ComparableTest interface really defines how the object under test behaves. The implementing classes then only have to provide the correct input/output variables.\nFor now we can keep the simple interface, but this should be really improved as the project continuous.", "author": "tobiasdiez", "createdAt": "2020-07-15T18:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5MzM4OA=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/test/java/org/jabref/logic/importer/fetcher/SearchBasedFetcherCapabilityTest.java b/src/test/java/org/jabref/logic/importer/fetcher/SearchBasedFetcherCapabilityTest.java\ndeleted file mode 100644\nindex 8c5631cb3..000000000\n--- a/src/test/java/org/jabref/logic/importer/fetcher/SearchBasedFetcherCapabilityTest.java\n+++ /dev/null\n\n@@ -1,48 +0,0 @@\n-package org.jabref.logic.importer.fetcher;\n-\n-import org.junit.jupiter.api.Test;\n-\n-/**\n- * Defines the set of capability tests that each tests a given search capability, e.g. author based search.\n- * The idea is to code the capabilities of a fetcher into Java code.\n- * This way, a) the capbilities of a fetcher are checked automatically (because they can change from time-to-time by the provider)\n- * and b) the queries sent to the fetchers can be debugged directly without a route through to some fetcher code.\n- */\n-interface SearchBasedFetcherCapabilityTest {\n-\n-    /**\n-     * Test whether the library API supports author field search.\n-     */\n-    @Test\n-    void supportsAuthorSearch() throws Exception;\n-\n-    /**\n-     * Test whether the library API supports year field search.\n-     */\n-    @Test\n-    void supportsYearSearch() throws Exception;\n-\n-    /**\n-     * Test whether the library API supports year range search.\n-     */\n-    @Test\n-    void supportsYearRangeSearch() throws Exception;\n-\n-    /**\n-     * Test whether the library API supports journal based search.\n-     */\n-    @Test\n-    void supportsJournalSearch() throws Exception;\n-\n-    /**\n-     * Test whether the library API supports phrase search.\n-     */\n-    @Test\n-    void supportsPhraseSearch() throws Exception;\n-\n-    /**\n-     * Test whether the library API supports boolean AND connection in queries.\n-     */\n-    @Test\n-    void supportsBooleanANDSearch() throws Exception;\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5Mzg5Ng==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454493896", "bodyText": "remove empty line (here and at a few other instances).", "author": "tobiasdiez", "createdAt": "2020-07-14T16:42:57Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java", "diffHunk": "@@ -78,4 +82,110 @@ void testSpringerJSONToBibtex() {\n     void searchByEmptyQueryFindsNothing() throws Exception {\n         assertEquals(Collections.emptyList(), fetcher.performSearch(\"\"));\n     }\n+\n+    @Test\n+    @Override\n+    public void supportsAuthorSearch() throws Exception {\n+        BibEntry expected = new BibEntry(StandardEntryType.Article)\n+                .withField(StandardField.AUTHOR, \"Steinmacher, Igor and Gerosa, Marco and Conte, Tayana U. and Redmiles, David F.\")\n+                .withField(StandardField.DATE, \"2019-04-15\")\n+                .withField(StandardField.DOI, \"10.1007/s10606-018-9335-z\")\n+                .withField(StandardField.ISSN, \"0925-9724\")\n+                .withField(StandardField.JOURNAL, \"Computer Supported Cooperative Work (CSCW)\")\n+                .withField(StandardField.MONTH, \"#apr#\")\n+                .withField(StandardField.PAGES, \"247--290\")\n+                .withField(StandardField.NUMBER, \"1-2\")\n+                .withField(StandardField.VOLUME, \"28\")\n+                .withField(StandardField.PUBLISHER, \"Springer\")\n+                .withField(StandardField.TITLE, \"Overcoming Social Barriers When Contributing to Open Source Software Projects\")\n+                .withField(StandardField.YEAR, \"2019\")\n+                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/s10606-018-9335-z:PDF\")\n+                .withField(StandardField.ABSTRACT, \"An influx of newcomers is critical to the survival, long-term success, and continuity of many Open Source Software (OSS) community-based projects. However, newcomers face many barriers when making their first contribution, leading in many cases to dropouts. Due to the collaborative nature of community-based OSS projects, newcomers may be susceptible to social barriers, such as communication breakdowns and reception issues. In this article, we report a two-phase study aimed at better understanding social barriers faced by newcomers. In the first phase, we qualitatively analyzed the literature and data collected from practitioners to identify barriers that hinder newcomers\u2019 first contribution. We designed a model composed of 58 barriers, including 13 social barriers. In the second phase, based on the barriers model, we developed FLOSScoach, a portal to support newcomers making their first contribution. We evaluated the portal in a diary-based study and found that the portal guided the newcomers and reduced the need for communication. Our results provide insights for communities that want to support newcomers and lay a foundation for building better onboarding tools. The contributions of this paper include identifying and gathering empirical evidence of social barriers faced by newcomers; understanding how social barriers can be reduced or avoided by using a portal that organizes proper information for newcomers (FLOSScoach); presenting guidelines for communities and newcomers on how to reduce or avoid social barriers; and identifying new streams of research.\");\n+\n+        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND name:\\\"Conte, Tayana U.\\\"\");\n+\n+        Assertions.assertEquals(Collections.singletonList(expected), result);\n+    }\n+\n+    @Test\n+    @Override\n+    public void supportsYearSearch() throws Exception {\n+        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND year:2014\");\n+\n+        // There are 3 papers published by Igor Steinmacher and Marco Gerosa in 2014.\n+        assertEquals(3, result.size());\n+        long publicationsIn2014 = result.stream()\n+                                        .map(bibEntry -> bibEntry.getField(StandardField.YEAR))\n+                                        .filter(Optional::isPresent)\n+                                        .map(Optional::get)\n+                                        .filter(s -> s.equals(\"2014\"))\n+                                        .count();\n+        assertEquals(3, publicationsIn2014);\n+    }\n+\n+    @Test\n+    @Disabled(\"Is not natively supported by the API, can be emulated by multiple single year searches.\")\n+    @Override\n+    public void supportsYearRangeSearch() throws Exception {\n+    }\n+\n+    @Test\n+    @Override\n+    public void supportsJournalSearch() throws Exception {\n+", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java b/src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java\ndeleted file mode 100644\nindex 5a5bd5c4d..000000000\n--- a/src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java\n+++ /dev/null\n\n@@ -1,191 +0,0 @@\n-package org.jabref.logic.importer.fetcher;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import org.jabref.model.entry.BibEntry;\n-import org.jabref.model.entry.field.StandardField;\n-import org.jabref.model.entry.types.StandardEntryType;\n-import org.jabref.support.DisabledOnCIServer;\n-import org.jabref.testutils.category.FetcherTest;\n-\n-import kong.unirest.json.JSONObject;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-@FetcherTest\n-class SpringerFetcherTest implements SearchBasedFetcherCapabilityTest {\n-\n-    SpringerFetcher fetcher;\n-\n-    @BeforeEach\n-    void setUp() {\n-        fetcher = new SpringerFetcher();\n-    }\n-\n-    @DisabledOnCIServer(\"Disable on CI Server to not hit the API call limit\")\n-    @Test\n-    void searchByQueryFindsEntry() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Steinmacher, Igor and Gerosa, Marco and Conte, Tayana U. and Redmiles, David F.\")\n-                .withField(StandardField.DATE, \"2019-04-15\")\n-                .withField(StandardField.DOI, \"10.1007/s10606-018-9335-z\")\n-                .withField(StandardField.ISSN, \"0925-9724\")\n-                .withField(StandardField.JOURNAL, \"Computer Supported Cooperative Work (CSCW)\")\n-                .withField(StandardField.MONTH, \"#apr#\")\n-                .withField(StandardField.PAGES, \"247--290\")\n-                .withField(StandardField.NUMBER, \"1-2\")\n-                .withField(StandardField.VOLUME, \"28\")\n-                .withField(StandardField.PUBLISHER, \"Springer\")\n-                .withField(StandardField.TITLE, \"Overcoming Social Barriers When Contributing to Open Source Software Projects\")\n-                .withField(StandardField.YEAR, \"2019\")\n-                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/s10606-018-9335-z:PDF\")\n-                .withField(StandardField.ABSTRACT, \"An influx of newcomers is critical to the survival, long-term success, and continuity of many Open Source Software (OSS) community-based projects. However, newcomers face many barriers when making their first contribution, leading in many cases to dropouts. Due to the collaborative nature of community-based OSS projects, newcomers may be susceptible to social barriers, such as communication breakdowns and reception issues. In this article, we report a two-phase study aimed at better understanding social barriers faced by newcomers. In the first phase, we qualitatively analyzed the literature and data collected from practitioners to identify barriers that hinder newcomers\u2019 first contribution. We designed a model composed of 58 barriers, including 13 social barriers. In the second phase, based on the barriers model, we developed FLOSScoach, a portal to support newcomers making their first contribution. We evaluated the portal in a diary-based study and found that the portal guided the newcomers and reduced the need for communication. Our results provide insights for communities that want to support newcomers and lay a foundation for building better onboarding tools. The contributions of this paper include identifying and gathering empirical evidence of social barriers faced by newcomers; understanding how social barriers can be reduced or avoided by using a portal that organizes proper information for newcomers (FLOSScoach); presenting guidelines for communities and newcomers on how to reduce or avoid social barriers; and identifying new streams of research.\");\n-\n-        List<BibEntry> fetchedEntries = fetcher.performSearch(\"JabRef Social Barriers Steinmacher\");\n-        assertEquals(Collections.singletonList(expected), fetchedEntries);\n-    }\n-\n-    @DisabledOnCIServer(\"Disable on CI Server to not hit the API call limit\")\n-    @Test\n-    void testSpringerJSONToBibtex() {\n-        String jsonString = \"{\\r\\n\" + \"            \\\"identifier\\\":\\\"doi:10.1007/BF01201962\\\",\\r\\n\"\n-                + \"            \\\"title\\\":\\\"Book reviews\\\",\\r\\n\"\n-                + \"            \\\"publicationName\\\":\\\"World Journal of Microbiology & Biotechnology\\\",\\r\\n\"\n-                + \"            \\\"issn\\\":\\\"1573-0972\\\",\\r\\n\" + \"            \\\"isbn\\\":\\\"\\\",\\r\\n\"\n-                + \"            \\\"doi\\\":\\\"10.1007/BF01201962\\\",\\r\\n\" + \"            \\\"publisher\\\":\\\"Springer\\\",\\r\\n\"\n-                + \"            \\\"publicationDate\\\":\\\"1992-09-01\\\",\\r\\n\" + \"            \\\"volume\\\":\\\"8\\\",\\r\\n\"\n-                + \"            \\\"number\\\":\\\"5\\\",\\r\\n\" + \"            \\\"startingPage\\\":\\\"550\\\",\\r\\n\"\n-                + \"            \\\"url\\\":\\\"http://dx.doi.org/10.1007/BF01201962\\\",\\\"copyright\\\":\\\"\u00a91992 Rapid Communications of Oxford Ltd.\\\"\\r\\n\"\n-                + \"        }\";\n-\n-        JSONObject jsonObject = new JSONObject(jsonString);\n-        BibEntry bibEntry = SpringerFetcher.parseSpringerJSONtoBibtex(jsonObject);\n-        assertEquals(Optional.of(\"1992\"), bibEntry.getField(StandardField.YEAR));\n-        assertEquals(Optional.of(\"5\"), bibEntry.getField(StandardField.NUMBER));\n-        assertEquals(Optional.of(\"#sep#\"), bibEntry.getField(StandardField.MONTH));\n-        assertEquals(Optional.of(\"10.1007/BF01201962\"), bibEntry.getField(StandardField.DOI));\n-        assertEquals(Optional.of(\"8\"), bibEntry.getField(StandardField.VOLUME));\n-        assertEquals(Optional.of(\"Springer\"), bibEntry.getField(StandardField.PUBLISHER));\n-        assertEquals(Optional.of(\"1992-09-01\"), bibEntry.getField(StandardField.DATE));\n-    }\n-\n-    @DisabledOnCIServer(\"Disable on CI Server to not hit the API call limit\")\n-    @Test\n-    void searchByEmptyQueryFindsNothing() throws Exception {\n-        assertEquals(Collections.emptyList(), fetcher.performSearch(\"\"));\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsAuthorSearch() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Steinmacher, Igor and Gerosa, Marco and Conte, Tayana U. and Redmiles, David F.\")\n-                .withField(StandardField.DATE, \"2019-04-15\")\n-                .withField(StandardField.DOI, \"10.1007/s10606-018-9335-z\")\n-                .withField(StandardField.ISSN, \"0925-9724\")\n-                .withField(StandardField.JOURNAL, \"Computer Supported Cooperative Work (CSCW)\")\n-                .withField(StandardField.MONTH, \"#apr#\")\n-                .withField(StandardField.PAGES, \"247--290\")\n-                .withField(StandardField.NUMBER, \"1-2\")\n-                .withField(StandardField.VOLUME, \"28\")\n-                .withField(StandardField.PUBLISHER, \"Springer\")\n-                .withField(StandardField.TITLE, \"Overcoming Social Barriers When Contributing to Open Source Software Projects\")\n-                .withField(StandardField.YEAR, \"2019\")\n-                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/s10606-018-9335-z:PDF\")\n-                .withField(StandardField.ABSTRACT, \"An influx of newcomers is critical to the survival, long-term success, and continuity of many Open Source Software (OSS) community-based projects. However, newcomers face many barriers when making their first contribution, leading in many cases to dropouts. Due to the collaborative nature of community-based OSS projects, newcomers may be susceptible to social barriers, such as communication breakdowns and reception issues. In this article, we report a two-phase study aimed at better understanding social barriers faced by newcomers. In the first phase, we qualitatively analyzed the literature and data collected from practitioners to identify barriers that hinder newcomers\u2019 first contribution. We designed a model composed of 58 barriers, including 13 social barriers. In the second phase, based on the barriers model, we developed FLOSScoach, a portal to support newcomers making their first contribution. We evaluated the portal in a diary-based study and found that the portal guided the newcomers and reduced the need for communication. Our results provide insights for communities that want to support newcomers and lay a foundation for building better onboarding tools. The contributions of this paper include identifying and gathering empirical evidence of social barriers faced by newcomers; understanding how social barriers can be reduced or avoided by using a portal that organizes proper information for newcomers (FLOSScoach); presenting guidelines for communities and newcomers on how to reduce or avoid social barriers; and identifying new streams of research.\");\n-\n-        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND name:\\\"Conte, Tayana U.\\\"\");\n-\n-        Assertions.assertEquals(Collections.singletonList(expected), result);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsYearSearch() throws Exception {\n-        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND year:2014\");\n-\n-        // There are 3 papers published by Igor Steinmacher and Marco Gerosa in 2014.\n-        assertEquals(3, result.size());\n-        long publicationsIn2014 = result.stream()\n-                                        .map(bibEntry -> bibEntry.getField(StandardField.YEAR))\n-                                        .filter(Optional::isPresent)\n-                                        .map(Optional::get)\n-                                        .filter(s -> s.equals(\"2014\"))\n-                                        .count();\n-        assertEquals(3, publicationsIn2014);\n-    }\n-\n-    @Test\n-    @Disabled(\"Is not natively supported by the API, can be emulated by multiple single year searches.\")\n-    @Override\n-    public void supportsYearRangeSearch() throws Exception {\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsJournalSearch() throws Exception {\n-\n-        List<BibEntry> result = fetcher.performSearch(\"journalid:392\");\n-        List<String> resultEntriesJournals = result.stream()\n-                                                   .map(bibEntry -> bibEntry.getField(StandardField.JOURNAL))\n-                                                   .filter(Optional::isPresent)\n-                                                   .map(Optional::get)\n-                                                   .collect(Collectors.toList());\n-\n-        // Ensure no entries without a journal field were returned\n-        assertEquals(result.size(), resultEntriesJournals.size());\n-        resultEntriesJournals.forEach(journal -> journal.equals(\"Clinical Research in Cardiology\"));\n-        System.out.println(result);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsPhraseSearch() throws Exception {\n-        // Normal search should match due to Redmiles, Elissa M., phrase search on the other hand should not find it.\n-        BibEntry expected = new BibEntry(StandardEntryType.InCollection)\n-                .withField(StandardField.AUTHOR, \"Booth, Kayla M. and Dosono, Bryan and Redmiles, Elissa M. and Morales, Miraida and Depew, Michael and Farzan, Rosta and Herman, Everett and Trahan, Keith and Tananis, Cindy\")\n-                .withField(StandardField.DATE, \"2018-01-01\")\n-                .withField(StandardField.DOI, \"10.1007/978-3-319-78105-1_75\")\n-                .withField(StandardField.ISBN, \"978-3-319-78104-4\")\n-                .withField(StandardField.MONTH, \"#jan#\")\n-                .withField(StandardField.PUBLISHER, \"Springer\")\n-                .withField(StandardField.BOOKTITLE, \"Transforming Digital Worlds\")\n-                .withField(StandardField.TITLE, \"Diversifying the Next Generation of\u00a0Information Scientists: Six Years of\u00a0Implementation and Outcomes for\u00a0a\u00a0Year-Long REU Program\")\n-                .withField(StandardField.YEAR, \"2018\")\n-                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/978-3-319-78105-1_75:PDF\")\n-                .withField(StandardField.ABSTRACT, \"The iSchool Inclusion Institute (i3) is a Research Experience for Undergraduates (REU) program in the US designed to address underrepresentation in the information sciences. i3 is a year-long, cohort-based program that prepares undergraduate students for graduate school in information science and is rooted in a research and leadership development curriculum. Using data from six years of i3 cohorts, we present in this paper a qualitative and quantitative evaluation of the program in terms of student learning, research production, and graduate school enrollment. We find that students who participate in i3 report significant learning gains in information-science- and graduate-school-related areas and that 52% of i3 participants enroll in graduate school, over 2 $$\\\\times $$ \u00d7 the national average. Based on these and additional results, we distill recommendations for future implementations of similar programs to address underrepresentation in information science.\");\n-\n-        List<BibEntry> resultPhrase = fetcher.performSearch(\"name:\\\"Redmiles David\\\"\");\n-        List<BibEntry> result = fetcher.performSearch(\"name:Redmiles David\");\n-\n-        // Phrase search should be a subset of the normal search result.\n-        Assertions.assertTrue(result.containsAll(resultPhrase));\n-        result.removeAll(resultPhrase);\n-        Assertions.assertEquals(Collections.singletonList(expected), result);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsBooleanANDSearch() throws Exception {\n-\n-        List<BibEntry> resultJustByAuthor = fetcher.performSearch(\"name:\\\"Redmiles, David\\\"\");\n-        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Redmiles, David\\\" AND journal:Computer Supported Cooperative Work\");\n-\n-        Assertions.assertTrue(resultJustByAuthor.containsAll(result));\n-        List<BibEntry> allEntriesFromCSCW = result.stream()\n-                                                  .filter(bibEntry -> bibEntry.getField(StandardField.JOURNAL).orElse(\"\").equals(\"Computer Supported Cooperative Work (CSCW)\"))\n-                                                  .collect(Collectors.toList());\n-        allEntriesFromCSCW.stream()\n-                          .map(bibEntry -> bibEntry.getField(StandardField.AUTHOR))\n-                          .filter(Optional::isPresent)\n-                          .map(Optional::get).forEach(authorField -> assertTrue(authorField.contains(\"Redmiles\")));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NTI5MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454495290", "bodyText": "I think an assertion is missing here, moreover it seems Assert.equals(Collection.singleton(\"Clinical...\"), result) is what were looking for.", "author": "tobiasdiez", "createdAt": "2020-07-14T16:45:07Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java", "diffHunk": "@@ -78,4 +82,110 @@ void testSpringerJSONToBibtex() {\n     void searchByEmptyQueryFindsNothing() throws Exception {\n         assertEquals(Collections.emptyList(), fetcher.performSearch(\"\"));\n     }\n+\n+    @Test\n+    @Override\n+    public void supportsAuthorSearch() throws Exception {\n+        BibEntry expected = new BibEntry(StandardEntryType.Article)\n+                .withField(StandardField.AUTHOR, \"Steinmacher, Igor and Gerosa, Marco and Conte, Tayana U. and Redmiles, David F.\")\n+                .withField(StandardField.DATE, \"2019-04-15\")\n+                .withField(StandardField.DOI, \"10.1007/s10606-018-9335-z\")\n+                .withField(StandardField.ISSN, \"0925-9724\")\n+                .withField(StandardField.JOURNAL, \"Computer Supported Cooperative Work (CSCW)\")\n+                .withField(StandardField.MONTH, \"#apr#\")\n+                .withField(StandardField.PAGES, \"247--290\")\n+                .withField(StandardField.NUMBER, \"1-2\")\n+                .withField(StandardField.VOLUME, \"28\")\n+                .withField(StandardField.PUBLISHER, \"Springer\")\n+                .withField(StandardField.TITLE, \"Overcoming Social Barriers When Contributing to Open Source Software Projects\")\n+                .withField(StandardField.YEAR, \"2019\")\n+                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/s10606-018-9335-z:PDF\")\n+                .withField(StandardField.ABSTRACT, \"An influx of newcomers is critical to the survival, long-term success, and continuity of many Open Source Software (OSS) community-based projects. However, newcomers face many barriers when making their first contribution, leading in many cases to dropouts. Due to the collaborative nature of community-based OSS projects, newcomers may be susceptible to social barriers, such as communication breakdowns and reception issues. In this article, we report a two-phase study aimed at better understanding social barriers faced by newcomers. In the first phase, we qualitatively analyzed the literature and data collected from practitioners to identify barriers that hinder newcomers\u2019 first contribution. We designed a model composed of 58 barriers, including 13 social barriers. In the second phase, based on the barriers model, we developed FLOSScoach, a portal to support newcomers making their first contribution. We evaluated the portal in a diary-based study and found that the portal guided the newcomers and reduced the need for communication. Our results provide insights for communities that want to support newcomers and lay a foundation for building better onboarding tools. The contributions of this paper include identifying and gathering empirical evidence of social barriers faced by newcomers; understanding how social barriers can be reduced or avoided by using a portal that organizes proper information for newcomers (FLOSScoach); presenting guidelines for communities and newcomers on how to reduce or avoid social barriers; and identifying new streams of research.\");\n+\n+        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND name:\\\"Conte, Tayana U.\\\"\");\n+\n+        Assertions.assertEquals(Collections.singletonList(expected), result);\n+    }\n+\n+    @Test\n+    @Override\n+    public void supportsYearSearch() throws Exception {\n+        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND year:2014\");\n+\n+        // There are 3 papers published by Igor Steinmacher and Marco Gerosa in 2014.\n+        assertEquals(3, result.size());\n+        long publicationsIn2014 = result.stream()\n+                                        .map(bibEntry -> bibEntry.getField(StandardField.YEAR))\n+                                        .filter(Optional::isPresent)\n+                                        .map(Optional::get)\n+                                        .filter(s -> s.equals(\"2014\"))\n+                                        .count();\n+        assertEquals(3, publicationsIn2014);\n+    }\n+\n+    @Test\n+    @Disabled(\"Is not natively supported by the API, can be emulated by multiple single year searches.\")\n+    @Override\n+    public void supportsYearRangeSearch() throws Exception {\n+    }\n+\n+    @Test\n+    @Override\n+    public void supportsJournalSearch() throws Exception {\n+\n+        List<BibEntry> result = fetcher.performSearch(\"journalid:392\");\n+        List<String> resultEntriesJournals = result.stream()\n+                                                   .map(bibEntry -> bibEntry.getField(StandardField.JOURNAL))\n+                                                   .filter(Optional::isPresent)\n+                                                   .map(Optional::get)\n+                                                   .collect(Collectors.toList());\n+\n+        // Ensure no entries without a journal field were returned\n+        assertEquals(result.size(), resultEntriesJournals.size());\n+        resultEntriesJournals.forEach(journal -> journal.equals(\"Clinical Research in Cardiology\"));", "originalCommit": "7c1327581da2d9ba359b7919c4d8df86d9be1133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyODc3Ng==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r454928776", "bodyText": "Thanks, I added the missing assert and modified the test.", "author": "DominikVoigt", "createdAt": "2020-07-15T09:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ5NTI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "c7795e9124d55908b8f074c475d62229972a4edc", "chunk": "diff --git a/src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java b/src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java\ndeleted file mode 100644\nindex 5a5bd5c4d..000000000\n--- a/src/test/java/org/jabref/logic/importer/fetcher/SpringerFetcherTest.java\n+++ /dev/null\n\n@@ -1,191 +0,0 @@\n-package org.jabref.logic.importer.fetcher;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import org.jabref.model.entry.BibEntry;\n-import org.jabref.model.entry.field.StandardField;\n-import org.jabref.model.entry.types.StandardEntryType;\n-import org.jabref.support.DisabledOnCIServer;\n-import org.jabref.testutils.category.FetcherTest;\n-\n-import kong.unirest.json.JSONObject;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-@FetcherTest\n-class SpringerFetcherTest implements SearchBasedFetcherCapabilityTest {\n-\n-    SpringerFetcher fetcher;\n-\n-    @BeforeEach\n-    void setUp() {\n-        fetcher = new SpringerFetcher();\n-    }\n-\n-    @DisabledOnCIServer(\"Disable on CI Server to not hit the API call limit\")\n-    @Test\n-    void searchByQueryFindsEntry() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Steinmacher, Igor and Gerosa, Marco and Conte, Tayana U. and Redmiles, David F.\")\n-                .withField(StandardField.DATE, \"2019-04-15\")\n-                .withField(StandardField.DOI, \"10.1007/s10606-018-9335-z\")\n-                .withField(StandardField.ISSN, \"0925-9724\")\n-                .withField(StandardField.JOURNAL, \"Computer Supported Cooperative Work (CSCW)\")\n-                .withField(StandardField.MONTH, \"#apr#\")\n-                .withField(StandardField.PAGES, \"247--290\")\n-                .withField(StandardField.NUMBER, \"1-2\")\n-                .withField(StandardField.VOLUME, \"28\")\n-                .withField(StandardField.PUBLISHER, \"Springer\")\n-                .withField(StandardField.TITLE, \"Overcoming Social Barriers When Contributing to Open Source Software Projects\")\n-                .withField(StandardField.YEAR, \"2019\")\n-                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/s10606-018-9335-z:PDF\")\n-                .withField(StandardField.ABSTRACT, \"An influx of newcomers is critical to the survival, long-term success, and continuity of many Open Source Software (OSS) community-based projects. However, newcomers face many barriers when making their first contribution, leading in many cases to dropouts. Due to the collaborative nature of community-based OSS projects, newcomers may be susceptible to social barriers, such as communication breakdowns and reception issues. In this article, we report a two-phase study aimed at better understanding social barriers faced by newcomers. In the first phase, we qualitatively analyzed the literature and data collected from practitioners to identify barriers that hinder newcomers\u2019 first contribution. We designed a model composed of 58 barriers, including 13 social barriers. In the second phase, based on the barriers model, we developed FLOSScoach, a portal to support newcomers making their first contribution. We evaluated the portal in a diary-based study and found that the portal guided the newcomers and reduced the need for communication. Our results provide insights for communities that want to support newcomers and lay a foundation for building better onboarding tools. The contributions of this paper include identifying and gathering empirical evidence of social barriers faced by newcomers; understanding how social barriers can be reduced or avoided by using a portal that organizes proper information for newcomers (FLOSScoach); presenting guidelines for communities and newcomers on how to reduce or avoid social barriers; and identifying new streams of research.\");\n-\n-        List<BibEntry> fetchedEntries = fetcher.performSearch(\"JabRef Social Barriers Steinmacher\");\n-        assertEquals(Collections.singletonList(expected), fetchedEntries);\n-    }\n-\n-    @DisabledOnCIServer(\"Disable on CI Server to not hit the API call limit\")\n-    @Test\n-    void testSpringerJSONToBibtex() {\n-        String jsonString = \"{\\r\\n\" + \"            \\\"identifier\\\":\\\"doi:10.1007/BF01201962\\\",\\r\\n\"\n-                + \"            \\\"title\\\":\\\"Book reviews\\\",\\r\\n\"\n-                + \"            \\\"publicationName\\\":\\\"World Journal of Microbiology & Biotechnology\\\",\\r\\n\"\n-                + \"            \\\"issn\\\":\\\"1573-0972\\\",\\r\\n\" + \"            \\\"isbn\\\":\\\"\\\",\\r\\n\"\n-                + \"            \\\"doi\\\":\\\"10.1007/BF01201962\\\",\\r\\n\" + \"            \\\"publisher\\\":\\\"Springer\\\",\\r\\n\"\n-                + \"            \\\"publicationDate\\\":\\\"1992-09-01\\\",\\r\\n\" + \"            \\\"volume\\\":\\\"8\\\",\\r\\n\"\n-                + \"            \\\"number\\\":\\\"5\\\",\\r\\n\" + \"            \\\"startingPage\\\":\\\"550\\\",\\r\\n\"\n-                + \"            \\\"url\\\":\\\"http://dx.doi.org/10.1007/BF01201962\\\",\\\"copyright\\\":\\\"\u00a91992 Rapid Communications of Oxford Ltd.\\\"\\r\\n\"\n-                + \"        }\";\n-\n-        JSONObject jsonObject = new JSONObject(jsonString);\n-        BibEntry bibEntry = SpringerFetcher.parseSpringerJSONtoBibtex(jsonObject);\n-        assertEquals(Optional.of(\"1992\"), bibEntry.getField(StandardField.YEAR));\n-        assertEquals(Optional.of(\"5\"), bibEntry.getField(StandardField.NUMBER));\n-        assertEquals(Optional.of(\"#sep#\"), bibEntry.getField(StandardField.MONTH));\n-        assertEquals(Optional.of(\"10.1007/BF01201962\"), bibEntry.getField(StandardField.DOI));\n-        assertEquals(Optional.of(\"8\"), bibEntry.getField(StandardField.VOLUME));\n-        assertEquals(Optional.of(\"Springer\"), bibEntry.getField(StandardField.PUBLISHER));\n-        assertEquals(Optional.of(\"1992-09-01\"), bibEntry.getField(StandardField.DATE));\n-    }\n-\n-    @DisabledOnCIServer(\"Disable on CI Server to not hit the API call limit\")\n-    @Test\n-    void searchByEmptyQueryFindsNothing() throws Exception {\n-        assertEquals(Collections.emptyList(), fetcher.performSearch(\"\"));\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsAuthorSearch() throws Exception {\n-        BibEntry expected = new BibEntry(StandardEntryType.Article)\n-                .withField(StandardField.AUTHOR, \"Steinmacher, Igor and Gerosa, Marco and Conte, Tayana U. and Redmiles, David F.\")\n-                .withField(StandardField.DATE, \"2019-04-15\")\n-                .withField(StandardField.DOI, \"10.1007/s10606-018-9335-z\")\n-                .withField(StandardField.ISSN, \"0925-9724\")\n-                .withField(StandardField.JOURNAL, \"Computer Supported Cooperative Work (CSCW)\")\n-                .withField(StandardField.MONTH, \"#apr#\")\n-                .withField(StandardField.PAGES, \"247--290\")\n-                .withField(StandardField.NUMBER, \"1-2\")\n-                .withField(StandardField.VOLUME, \"28\")\n-                .withField(StandardField.PUBLISHER, \"Springer\")\n-                .withField(StandardField.TITLE, \"Overcoming Social Barriers When Contributing to Open Source Software Projects\")\n-                .withField(StandardField.YEAR, \"2019\")\n-                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/s10606-018-9335-z:PDF\")\n-                .withField(StandardField.ABSTRACT, \"An influx of newcomers is critical to the survival, long-term success, and continuity of many Open Source Software (OSS) community-based projects. However, newcomers face many barriers when making their first contribution, leading in many cases to dropouts. Due to the collaborative nature of community-based OSS projects, newcomers may be susceptible to social barriers, such as communication breakdowns and reception issues. In this article, we report a two-phase study aimed at better understanding social barriers faced by newcomers. In the first phase, we qualitatively analyzed the literature and data collected from practitioners to identify barriers that hinder newcomers\u2019 first contribution. We designed a model composed of 58 barriers, including 13 social barriers. In the second phase, based on the barriers model, we developed FLOSScoach, a portal to support newcomers making their first contribution. We evaluated the portal in a diary-based study and found that the portal guided the newcomers and reduced the need for communication. Our results provide insights for communities that want to support newcomers and lay a foundation for building better onboarding tools. The contributions of this paper include identifying and gathering empirical evidence of social barriers faced by newcomers; understanding how social barriers can be reduced or avoided by using a portal that organizes proper information for newcomers (FLOSScoach); presenting guidelines for communities and newcomers on how to reduce or avoid social barriers; and identifying new streams of research.\");\n-\n-        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND name:\\\"Conte, Tayana U.\\\"\");\n-\n-        Assertions.assertEquals(Collections.singletonList(expected), result);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsYearSearch() throws Exception {\n-        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Steinmacher, Igor\\\" AND name:\\\"Gerosa, Marco\\\" AND year:2014\");\n-\n-        // There are 3 papers published by Igor Steinmacher and Marco Gerosa in 2014.\n-        assertEquals(3, result.size());\n-        long publicationsIn2014 = result.stream()\n-                                        .map(bibEntry -> bibEntry.getField(StandardField.YEAR))\n-                                        .filter(Optional::isPresent)\n-                                        .map(Optional::get)\n-                                        .filter(s -> s.equals(\"2014\"))\n-                                        .count();\n-        assertEquals(3, publicationsIn2014);\n-    }\n-\n-    @Test\n-    @Disabled(\"Is not natively supported by the API, can be emulated by multiple single year searches.\")\n-    @Override\n-    public void supportsYearRangeSearch() throws Exception {\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsJournalSearch() throws Exception {\n-\n-        List<BibEntry> result = fetcher.performSearch(\"journalid:392\");\n-        List<String> resultEntriesJournals = result.stream()\n-                                                   .map(bibEntry -> bibEntry.getField(StandardField.JOURNAL))\n-                                                   .filter(Optional::isPresent)\n-                                                   .map(Optional::get)\n-                                                   .collect(Collectors.toList());\n-\n-        // Ensure no entries without a journal field were returned\n-        assertEquals(result.size(), resultEntriesJournals.size());\n-        resultEntriesJournals.forEach(journal -> journal.equals(\"Clinical Research in Cardiology\"));\n-        System.out.println(result);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsPhraseSearch() throws Exception {\n-        // Normal search should match due to Redmiles, Elissa M., phrase search on the other hand should not find it.\n-        BibEntry expected = new BibEntry(StandardEntryType.InCollection)\n-                .withField(StandardField.AUTHOR, \"Booth, Kayla M. and Dosono, Bryan and Redmiles, Elissa M. and Morales, Miraida and Depew, Michael and Farzan, Rosta and Herman, Everett and Trahan, Keith and Tananis, Cindy\")\n-                .withField(StandardField.DATE, \"2018-01-01\")\n-                .withField(StandardField.DOI, \"10.1007/978-3-319-78105-1_75\")\n-                .withField(StandardField.ISBN, \"978-3-319-78104-4\")\n-                .withField(StandardField.MONTH, \"#jan#\")\n-                .withField(StandardField.PUBLISHER, \"Springer\")\n-                .withField(StandardField.BOOKTITLE, \"Transforming Digital Worlds\")\n-                .withField(StandardField.TITLE, \"Diversifying the Next Generation of\u00a0Information Scientists: Six Years of\u00a0Implementation and Outcomes for\u00a0a\u00a0Year-Long REU Program\")\n-                .withField(StandardField.YEAR, \"2018\")\n-                .withField(StandardField.FILE, \"online:http\\\\://link.springer.com/openurl/pdf?id=doi\\\\:10.1007/978-3-319-78105-1_75:PDF\")\n-                .withField(StandardField.ABSTRACT, \"The iSchool Inclusion Institute (i3) is a Research Experience for Undergraduates (REU) program in the US designed to address underrepresentation in the information sciences. i3 is a year-long, cohort-based program that prepares undergraduate students for graduate school in information science and is rooted in a research and leadership development curriculum. Using data from six years of i3 cohorts, we present in this paper a qualitative and quantitative evaluation of the program in terms of student learning, research production, and graduate school enrollment. We find that students who participate in i3 report significant learning gains in information-science- and graduate-school-related areas and that 52% of i3 participants enroll in graduate school, over 2 $$\\\\times $$ \u00d7 the national average. Based on these and additional results, we distill recommendations for future implementations of similar programs to address underrepresentation in information science.\");\n-\n-        List<BibEntry> resultPhrase = fetcher.performSearch(\"name:\\\"Redmiles David\\\"\");\n-        List<BibEntry> result = fetcher.performSearch(\"name:Redmiles David\");\n-\n-        // Phrase search should be a subset of the normal search result.\n-        Assertions.assertTrue(result.containsAll(resultPhrase));\n-        result.removeAll(resultPhrase);\n-        Assertions.assertEquals(Collections.singletonList(expected), result);\n-    }\n-\n-    @Test\n-    @Override\n-    public void supportsBooleanANDSearch() throws Exception {\n-\n-        List<BibEntry> resultJustByAuthor = fetcher.performSearch(\"name:\\\"Redmiles, David\\\"\");\n-        List<BibEntry> result = fetcher.performSearch(\"name:\\\"Redmiles, David\\\" AND journal:Computer Supported Cooperative Work\");\n-\n-        Assertions.assertTrue(resultJustByAuthor.containsAll(result));\n-        List<BibEntry> allEntriesFromCSCW = result.stream()\n-                                                  .filter(bibEntry -> bibEntry.getField(StandardField.JOURNAL).orElse(\"\").equals(\"Computer Supported Cooperative Work (CSCW)\"))\n-                                                  .collect(Collectors.toList());\n-        allEntriesFromCSCW.stream()\n-                          .map(bibEntry -> bibEntry.getField(StandardField.AUTHOR))\n-                          .filter(Optional::isPresent)\n-                          .map(Optional::get).forEach(authorField -> assertTrue(authorField.contains(\"Redmiles\")));\n-    }\n-}\n"}}, {"oid": "c7795e9124d55908b8f074c475d62229972a4edc", "url": "https://github.com/JabRef/jabref/commit/c7795e9124d55908b8f074c475d62229972a4edc", "message": "Squashed 'src/main/resources/csl-styles/' changes from a995c63a0a..bf698acec7\n\nbf698acec7 Create common-market-law-review.csl (#4910)\nc962ecaea9 Create harvard-prifysgol-caerdydd.csl (#4922)\n0c24e7f7f6 Update gewerblicher-rechtsschutz-und-urheberrecht.csl (#4923)\nd2ec1a736c Create Tijdschrift-voor-Geneeskunde.csl (#4907)\n5df7250369 Update harvard-institut-fur-praxisforschung-de.csl (#4918)\n093fd91618 Update universite-de-montreal-apa.csl (#4916)\na3e41d49f7 Update thieme-german.csl (#4919)\n648765ac11 add DOI to aerosol-science-and-technology.csl (#4909)\nbc1ebeece9 Reindent/reorder\na8dc18a80d Fix documentation link for epidemiology & infection\naab403aff7 Fix AGLC Newspaper date\n4c018d5ef3 Add period between editor and translator (SBL styles) (#4906)\n42f7491f64 Create geographische-zeitschrift.csl (#4898)\na4002a6b0f Create german-kunstwissenschaft.csl (#4896)\nb01910b380 Disambiguation of names (#4895)\n\ngit-subtree-dir: src/main/resources/csl-styles\ngit-subtree-split: bf698acec747594a57e3c1423c351c69bc5ad6e1", "committedDate": "2020-07-15T02:11:10Z", "type": "commit"}, {"oid": "a89db0821afe2d9595c9a0f1fd088646124a8bb5", "url": "https://github.com/JabRef/jabref/commit/a89db0821afe2d9595c9a0f1fd088646124a8bb5", "message": "Merge commit 'c7795e9124d55908b8f074c475d62229972a4edc'", "committedDate": "2020-07-15T02:11:10Z", "type": "commit"}, {"oid": "5ec7ef62109a04b928be8d8a805c889d41e49a9d", "url": "https://github.com/JabRef/jabref/commit/5ec7ef62109a04b928be8d8a805c889d41e49a9d", "message": "Merge branch 'feat/add-capability-tests-for-fetchers' of https://github.com/DominikVoigt/jabref into feat/add-capability-tests-for-fetchers", "committedDate": "2020-07-15T09:32:24Z", "type": "commit"}, {"oid": "ea4b67fddcd423d5ec9010bc00c0dddf615c67bb", "url": "https://github.com/JabRef/jabref/commit/ea4b67fddcd423d5ec9010bc00c0dddf615c67bb", "message": "Remove empty lines in tests\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T09:34:46Z", "type": "commit"}, {"oid": "0950cb6f318c66f43f34f24a45e524ebc0a24d35", "url": "https://github.com/JabRef/jabref/commit/0950cb6f318c66f43f34f24a45e524ebc0a24d35", "message": "Correct SpringerFetcherTest\n- Add missing assert\n- Modify test\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T09:46:19Z", "type": "commit"}, {"oid": "6bffc68bc4733c7dd7821907a34c0f8ac86b52c2", "url": "https://github.com/JabRef/jabref/commit/6bffc68bc4733c7dd7821907a34c0f8ac86b52c2", "message": "Rename AdvancedFetcher and AdvancedSearchConfig.java accordingly to change request\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T10:03:26Z", "type": "commit"}, {"oid": "f5f1b5b65fe41990d61a0fe69a0fa15177028afb", "url": "https://github.com/JabRef/jabref/commit/f5f1b5b65fe41990d61a0fe69a0fa15177028afb", "message": "Add documentation to the default field\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T10:58:30Z", "type": "commit"}, {"oid": "7e81ccad597dd184ec471c4fdfd5e5c7a2bf8e3c", "url": "https://github.com/JabRef/jabref/commit/7e81ccad597dd184ec471c4fdfd5e5c7a2bf8e3c", "message": "Modify AdvancedSearchBasedParserFetcher interface to be in line with AdvancedSearchBasedParserFetcher interface.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T11:14:37Z", "type": "commit"}, {"oid": "db19e60100f253a9a5654254d9be0d12a98e1c82", "url": "https://github.com/JabRef/jabref/commit/db19e60100f253a9a5654254d9be0d12a98e1c82", "message": "Adapt test of getAdvancedURL\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T11:22:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwMDg1NA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r455000854", "bodyText": "Can you please have a look how the other getUrl*** methods handle the exception handling. I think they are allowed to simply throw them and the performSearch method then converts it to a FetcherException.", "author": "tobiasdiez", "createdAt": "2020-07-15T12:06:26Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/IEEE.java", "diffHunk": "@@ -236,4 +229,24 @@ public String getName() {\n     public Optional<HelpFile> getHelpPage() {\n         return Optional.of(HelpFile.FETCHER_IEEEXPLORE);\n     }\n+\n+    @Override\n+    public URL getComplexQueryURL(ComplexSearchQuery complexSearchQuery) {\n+        try {\n+            URIBuilder uriBuilder = new URIBuilder(\"https://ieeexploreapi.ieee.org/api/v1/search/articles\");\n+            uriBuilder.addParameter(\"apikey\", API_KEY);\n+            complexSearchQuery.getDefaultField().ifPresent(defaultField -> uriBuilder.addParameter(\"querytext\", defaultField));\n+            complexSearchQuery.getAuthor().ifPresent(author -> uriBuilder.addParameter(\"author\", author));\n+            complexSearchQuery.getTitle().ifPresent(articleTitle -> uriBuilder.addParameter(\"article_title\", articleTitle));\n+            complexSearchQuery.getJournal().ifPresent(journalTitle -> uriBuilder.addParameter(\"publication_title\", journalTitle));\n+            complexSearchQuery.getFromYear().map(String::valueOf).ifPresent(year -> uriBuilder.addParameter(\"start_year\", year));\n+            complexSearchQuery.getToYear().map(String::valueOf).ifPresent(year -> uriBuilder.addParameter(\"end_year\", year));\n+\n+            URLDownload.bypassSSLVerification();\n+            return uriBuilder.build().toURL();\n+        } catch (URISyntaxException | MalformedURLException ex) {\n+            LOGGER.error(\"Error creating URL.\", ex);\n+            throw new IllegalStateException(\"Error during creation of URL.\", ex);", "originalCommit": "db19e60100f253a9a5654254d9be0d12a98e1c82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTA1MzkwOQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r455053909", "bodyText": "Oh, the comment was missing here. The assumption was that per definition, this exception will never raised. Neverheless +1 for consistency \ud83d\ude05", "author": "koppor", "createdAt": "2020-07-15T13:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwMDg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1MDgyOQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r455150829", "bodyText": "I changed this to be consistent with the other getURL methods.", "author": "DominikVoigt", "createdAt": "2020-07-15T15:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAwMDg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "4065fa5879b180ddf4ed7e6afd642dc04ff4aaeb", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/fetcher/IEEE.java b/src/main/java/org/jabref/logic/importer/fetcher/IEEE.java\nindex b2937053d..c50d8d090 100644\n--- a/src/main/java/org/jabref/logic/importer/fetcher/IEEE.java\n+++ b/src/main/java/org/jabref/logic/importer/fetcher/IEEE.java\n\n@@ -231,22 +231,17 @@ public class IEEE implements FulltextFetcher, SearchBasedParserFetcher, Advanced\n     }\n \n     @Override\n-    public URL getComplexQueryURL(ComplexSearchQuery complexSearchQuery) {\n-        try {\n-            URIBuilder uriBuilder = new URIBuilder(\"https://ieeexploreapi.ieee.org/api/v1/search/articles\");\n-            uriBuilder.addParameter(\"apikey\", API_KEY);\n-            complexSearchQuery.getDefaultField().ifPresent(defaultField -> uriBuilder.addParameter(\"querytext\", defaultField));\n-            complexSearchQuery.getAuthor().ifPresent(author -> uriBuilder.addParameter(\"author\", author));\n-            complexSearchQuery.getTitle().ifPresent(articleTitle -> uriBuilder.addParameter(\"article_title\", articleTitle));\n-            complexSearchQuery.getJournal().ifPresent(journalTitle -> uriBuilder.addParameter(\"publication_title\", journalTitle));\n-            complexSearchQuery.getFromYear().map(String::valueOf).ifPresent(year -> uriBuilder.addParameter(\"start_year\", year));\n-            complexSearchQuery.getToYear().map(String::valueOf).ifPresent(year -> uriBuilder.addParameter(\"end_year\", year));\n-\n-            URLDownload.bypassSSLVerification();\n+    public URL getComplexQueryURL(ComplexSearchQuery complexSearchQuery) throws URISyntaxException, MalformedURLException {\n+        URIBuilder uriBuilder = new URIBuilder(\"https://ieeexploreapi.ieee.org/api/v1/search/articles\");\n+        uriBuilder.addParameter(\"apikey\", API_KEY);\n+        complexSearchQuery.getDefaultField().ifPresent(defaultField -> uriBuilder.addParameter(\"querytext\", defaultField));\n+        complexSearchQuery.getAuthor().ifPresent(author -> uriBuilder.addParameter(\"author\", author));\n+        complexSearchQuery.getTitle().ifPresent(articleTitle -> uriBuilder.addParameter(\"article_title\", articleTitle));\n+        complexSearchQuery.getJournal().ifPresent(journalTitle -> uriBuilder.addParameter(\"publication_title\", journalTitle));\n+        complexSearchQuery.getFromYear().map(String::valueOf).ifPresent(year -> uriBuilder.addParameter(\"start_year\", year));\n+        complexSearchQuery.getToYear().map(String::valueOf).ifPresent(year -> uriBuilder.addParameter(\"end_year\", year));\n+\n+        URLDownload.bypassSSLVerification();\n             return uriBuilder.build().toURL();\n-        } catch (URISyntaxException | MalformedURLException ex) {\n-            LOGGER.error(\"Error creating URL.\", ex);\n-            throw new IllegalStateException(\"Error during creation of URL.\", ex);\n-        }\n     }\n }\n"}}, {"oid": "4065fa5879b180ddf4ed7e6afd642dc04ff4aaeb", "url": "https://github.com/JabRef/jabref/commit/4065fa5879b180ddf4ed7e6afd642dc04ff4aaeb", "message": "Integrate change requests.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-15T15:40:34Z", "type": "commit"}, {"oid": "7b9e85f57106817fcb545b5b4f203bb287a0683e", "url": "https://github.com/JabRef/jabref/commit/7b9e85f57106817fcb545b5b4f203bb287a0683e", "message": "Integrate change requests.\n- Add IEEE Xplore fetcher test\n- Move performComplexSearch into the SearchBasedFetcher Interface\n- Modify TestInterface to define how the objects under test behave\n- Use performComplexSearch in the TestInterface\n- Modify ComplexSearchQuery to allow for multiple author and multiple title phrase searches\n- Change SpringerFetcher from using JournalTitle field instead of Journal field, to be in line with IEEE and ArXiv Fetcher\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-17T08:31:04Z", "type": "commit"}, {"oid": "d2a79fdbc61d1a8f7e0467d062ca8d8da056ee88", "url": "https://github.com/JabRef/jabref/commit/d2a79fdbc61d1a8f7e0467d062ca8d8da056ee88", "message": "Merge remote-tracking branch 'upstream/master' into feat/add-capability-tests-for-fetchers", "committedDate": "2020-07-19T15:28:53Z", "type": "commit"}, {"oid": "9673b6c8ee20c7deea5e85cee813d5c51f1c3b21", "url": "https://github.com/JabRef/jabref/commit/9673b6c8ee20c7deea5e85cee813d5c51f1c3b21", "message": "Start Working on format conversion\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-19T21:37:55Z", "type": "commit"}, {"oid": "e4b1ad176ffd4df85db139bef120c3a460ab7a32", "url": "https://github.com/JabRef/jabref/commit/e4b1ad176ffd4df85db139bef120c3a460ab7a32", "message": "Continue integrate format conversion\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-20T14:09:29Z", "type": "commit"}, {"oid": "de623121bd9607e3aa0b16429858065b814af789", "url": "https://github.com/JabRef/jabref/commit/de623121bd9607e3aa0b16429858065b814af789", "message": "Continue integrate format conversion.\nAdd related ADR.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-20T15:09:17Z", "type": "commit"}, {"oid": "bb089f4012d7ea0765c31fa2d0e02ec2d2b6b6b9", "url": "https://github.com/JabRef/jabref/commit/bb089f4012d7ea0765c31fa2d0e02ec2d2b6b6b9", "message": "Merge remote-tracking branch 'upstream/master' into feat/add-capability-tests-for-fetchers", "committedDate": "2020-07-20T15:09:27Z", "type": "commit"}, {"oid": "988a275356e7155ef2fc2cc355753670cc8739b2", "url": "https://github.com/JabRef/jabref/commit/988a275356e7155ef2fc2cc355753670cc8739b2", "message": "Get it to build. Start correcting tests.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-21T16:44:06Z", "type": "commit"}, {"oid": "a2a26e2f3111619386a4dc8aa8fd3c43d07770e9", "url": "https://github.com/JabRef/jabref/commit/a2a26e2f3111619386a4dc8aa8fd3c43d07770e9", "message": "Work on correcting tests.\nRemove URL from Doifetcher test, as it gets cleaned up by DOICleanUp as the URL contains a DOI.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-21T17:18:05Z", "type": "commit"}, {"oid": "6f482a4afed0c95afcb9950cfc554db081aaf975", "url": "https://github.com/JabRef/jabref/commit/6f482a4afed0c95afcb9950cfc554db081aaf975", "message": "Finalize format conversion changes.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-24T09:17:57Z", "type": "commit"}, {"oid": "a7461976a46b04fa0648201f20eae95d8c747f73", "url": "https://github.com/JabRef/jabref/commit/a7461976a46b04fa0648201f20eae95d8c747f73", "message": "Merge remote-tracking branch 'upstream/master' into feat/add-capability-tests-for-fetchers", "committedDate": "2020-07-24T09:19:55Z", "type": "commit"}, {"oid": "f675e132a9eb7e3c1cef3f08aaddff673722fae6", "url": "https://github.com/JabRef/jabref/commit/f675e132a9eb7e3c1cef3f08aaddff673722fae6", "message": "Add ADR.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-24T09:53:40Z", "type": "commit"}, {"oid": "90540110ef592535570882d37503425b6901b96f", "url": "https://github.com/JabRef/jabref/commit/90540110ef592535570882d37503425b6901b96f", "message": "Remove comment.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-24T09:58:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2MjMxMw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r459962313", "bodyText": "If these changes are approved this localized text has to be adapted", "author": "DominikVoigt", "createdAt": "2020-07-24T10:01:08Z", "path": "src/main/java/org/jabref/cli/ArgumentProcessor.java", "diffHunk": "@@ -520,15 +520,17 @@ private void regenerateCitationKeys(List<ParserResult> loaded) {\n      * @return A parser result containing the entries fetched or null if an error occurred.\n      */\n     private Optional<ParserResult> fetch(String fetchCommand) {\n-        if ((fetchCommand == null) || !fetchCommand.contains(\":\")) {\n-            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>'\"));\n+        if ((fetchCommand == null) || !fetchCommand.contains(\":\") ||\n+                !(fetchCommand.toLowerCase().endsWith(\":bibtex\") || fetchCommand.toLowerCase().endsWith(\":biblatex\"))) {\n+            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>:<bib entry format>'\"));", "originalCommit": "f675e132a9eb7e3c1cef3f08aaddff673722fae6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODc1MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463998750", "bodyText": "Due to the decision in ADR-0012, this hole change is obsolete? --> git checkout upstream/master -- src/main/java/org/jabref/cli/ArgumentProcessor.java (to revert the changes in this file)\n(If not, there should be a default mode, if possible, the mode of the bibdatabase should be used)", "author": "koppor", "createdAt": "2020-08-01T20:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2MjMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "f08184e5677368e65c6036577b64d0f8be364aea", "chunk": "diff --git a/src/main/java/org/jabref/cli/ArgumentProcessor.java b/src/main/java/org/jabref/cli/ArgumentProcessor.java\nindex 74f238247..a5d723cfc 100644\n--- a/src/main/java/org/jabref/cli/ArgumentProcessor.java\n+++ b/src/main/java/org/jabref/cli/ArgumentProcessor.java\n\n@@ -520,9 +520,8 @@ public class ArgumentProcessor {\n      * @return A parser result containing the entries fetched or null if an error occurred.\n      */\n     private Optional<ParserResult> fetch(String fetchCommand) {\n-        if ((fetchCommand == null) || !fetchCommand.contains(\":\") ||\n-                !(fetchCommand.toLowerCase().endsWith(\":bibtex\") || fetchCommand.toLowerCase().endsWith(\":biblatex\"))) {\n-            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>:<bib entry format>'\"));\n+        if ((fetchCommand == null) || !fetchCommand.contains(\":\")) {\n+            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>'\"));\n             System.out.println(Localization.lang(\"The following fetchers are available:\"));\n             return Optional.empty();\n         }\n"}}, {"oid": "c8ead6bb2b192ee47ef763cd33569345b46d3662", "url": "https://github.com/JabRef/jabref/commit/c8ead6bb2b192ee47ef763cd33569345b46d3662", "message": "Revert \"Squashed 'src/main/resources/csl-styles/' changes from a995c63a0a..bf698acec7\"\n\nThis reverts commit c7795e9124d55908b8f074c475d62229972a4edc.\nThis hopefully fixes the issue with the csl files.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>\n\n# Conflicts:\n#\tsrc/main/resources/csl-styles/common-market-law-review.csl\n#\tsrc/main/resources/csl-styles/dependent/prifysgol-caerdydd-harvard.csl\n#\tsrc/main/resources/csl-styles/geographische-zeitschrift.csl\n#\tsrc/main/resources/csl-styles/kunstakademie-munster.csl\n#\tsrc/main/resources/csl-styles/tijdschrift-voor-geneeskunde.csl", "committedDate": "2020-07-24T10:42:18Z", "type": "commit"}, {"oid": "1eddd44a7fdf575768f08d303780f3be090cc48b", "url": "https://github.com/JabRef/jabref/commit/1eddd44a7fdf575768f08d303780f3be090cc48b", "message": "Revert \"Revert \"Squashed 'src/main/resources/csl-styles/' changes from a995c63a0a..bf698acec7\"\"\n\nThis reverts commit c8ead6bb2b192ee47ef763cd33569345b46d3662.", "committedDate": "2020-07-24T10:44:52Z", "type": "commit"}, {"oid": "92c05bee57fa26907dcf48f08bcf795c58f8c848", "url": "https://github.com/JabRef/jabref/commit/92c05bee57fa26907dcf48f08bcf795c58f8c848", "message": "Update ADRs\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-26T09:03:36Z", "type": "commit"}, {"oid": "84a9b536380aa70fadbacf1c7ad8d438edc5ed71", "url": "https://github.com/JabRef/jabref/commit/84a9b536380aa70fadbacf1c7ad8d438edc5ed71", "message": "Update ADR. Remove import.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-27T16:11:52Z", "type": "commit"}, {"oid": "8fa03d5e56a45ecb01d9af56ac6dd16da9bc51bc", "url": "https://github.com/JabRef/jabref/commit/8fa03d5e56a45ecb01d9af56ac6dd16da9bc51bc", "message": "Remove unused import.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-27T16:16:13Z", "type": "commit"}, {"oid": "b86f34e22cfa8b6608ef5807c8b5ef0e1bff3f8d", "url": "https://github.com/JabRef/jabref/commit/b86f34e22cfa8b6608ef5807c8b5ef0e1bff3f8d", "message": "Merge remote-tracking branch 'upstream/master' into feat/add-capability-tests-for-fetchers", "committedDate": "2020-07-27T16:16:31Z", "type": "commit"}, {"oid": "c694bc1499534efb02ab1e878f727b47a1a672e6", "url": "https://github.com/JabRef/jabref/commit/c694bc1499534efb02ab1e878f727b47a1a672e6", "message": "Remove whitespaces and redundant paragraph from ADR.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-27T17:15:08Z", "type": "commit"}, {"oid": "e1b0bf87cb07808fd9cf994c8bbea84891599903", "url": "https://github.com/JabRef/jabref/commit/e1b0bf87cb07808fd9cf994c8bbea84891599903", "message": "Move format conversion from Fetchers into ImportCleanup.\nRemove any format conversion where the fetcher format conversion added it.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-28T18:47:18Z", "type": "commit"}, {"oid": "d424f885b1feec1180fa9e709a5d60a1c5e45150", "url": "https://github.com/JabRef/jabref/commit/d424f885b1feec1180fa9e709a5d60a1c5e45150", "message": "Revert incorrect change.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-28T19:07:03Z", "type": "commit"}, {"oid": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "url": "https://github.com/JabRef/jabref/commit/d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "message": "Remove debugging print statement.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-07-29T11:23:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODc3OA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463998778", "bodyText": "This variable is obsolete, isn't it?", "author": "koppor", "createdAt": "2020-08-01T20:45:51Z", "path": "src/main/java/org/jabref/cli/ArgumentProcessor.java", "diffHunk": "@@ -520,15 +520,17 @@ private void regenerateCitationKeys(List<ParserResult> loaded) {\n      * @return A parser result containing the entries fetched or null if an error occurred.\n      */\n     private Optional<ParserResult> fetch(String fetchCommand) {\n-        if ((fetchCommand == null) || !fetchCommand.contains(\":\")) {\n-            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>'\"));\n+        if ((fetchCommand == null) || !fetchCommand.contains(\":\") ||\n+                !(fetchCommand.toLowerCase().endsWith(\":bibtex\") || fetchCommand.toLowerCase().endsWith(\":biblatex\"))) {\n+            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>:<bib entry format>'\"));\n             System.out.println(Localization.lang(\"The following fetchers are available:\"));\n             return Optional.empty();\n         }\n \n         String[] split = fetchCommand.split(\":\");\n         String engine = split[0];\n         String query = split[1];\n+        String bibFormat = split[2].toLowerCase();", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f08184e5677368e65c6036577b64d0f8be364aea", "chunk": "diff --git a/src/main/java/org/jabref/cli/ArgumentProcessor.java b/src/main/java/org/jabref/cli/ArgumentProcessor.java\nindex 3e5923403..a5d723cfc 100644\n--- a/src/main/java/org/jabref/cli/ArgumentProcessor.java\n+++ b/src/main/java/org/jabref/cli/ArgumentProcessor.java\n\n@@ -520,9 +520,8 @@ public class ArgumentProcessor {\n      * @return A parser result containing the entries fetched or null if an error occurred.\n      */\n     private Optional<ParserResult> fetch(String fetchCommand) {\n-        if ((fetchCommand == null) || !fetchCommand.contains(\":\") ||\n-                !(fetchCommand.toLowerCase().endsWith(\":bibtex\") || fetchCommand.toLowerCase().endsWith(\":biblatex\"))) {\n-            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>:<bib entry format>'\"));\n+        if ((fetchCommand == null) || !fetchCommand.contains(\":\")) {\n+            System.out.println(Localization.lang(\"Expected syntax for --fetch='<name of fetcher>:<query>'\"));\n             System.out.println(Localization.lang(\"The following fetchers are available:\"));\n             return Optional.empty();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODc4NQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463998785", "bodyText": "Just keep it in one line", "author": "koppor", "createdAt": "2020-08-01T20:45:58Z", "path": "src/main/java/org/jabref/cli/ArgumentProcessor.java", "diffHunk": "@@ -545,7 +547,8 @@ private void regenerateCitationKeys(List<ParserResult> loaded) {\n             System.out.println(Localization.lang(\"Running query '%0' with fetcher '%1'.\", query, engine));\n             System.out.print(Localization.lang(\"Please wait...\"));\n             try {\n-                List<BibEntry> matches = selectedFetcher.get().performSearch(query);\n+                List<BibEntry> matches = selectedFetcher.get().performSearch(query", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f08184e5677368e65c6036577b64d0f8be364aea", "chunk": "diff --git a/src/main/java/org/jabref/cli/ArgumentProcessor.java b/src/main/java/org/jabref/cli/ArgumentProcessor.java\nindex 3e5923403..a5d723cfc 100644\n--- a/src/main/java/org/jabref/cli/ArgumentProcessor.java\n+++ b/src/main/java/org/jabref/cli/ArgumentProcessor.java\n\n@@ -547,8 +545,7 @@ public class ArgumentProcessor {\n             System.out.println(Localization.lang(\"Running query '%0' with fetcher '%1'.\", query, engine));\n             System.out.print(Localization.lang(\"Please wait...\"));\n             try {\n-                List<BibEntry> matches = selectedFetcher.get().performSearch(query\n-                );\n+                List<BibEntry> matches = selectedFetcher.get().performSearch(query);\n                 if (matches.isEmpty()) {\n                     System.out.println(\"\\r\" + Localization.lang(\"No results found.\"));\n                     return Optional.empty();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODkxOQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463998919", "bodyText": "I think, the location in the code can be kept --> git checkoupt upstream/master -- src/main/java/org/jabref/logic/importer/EntryBasedParserFetcher.java", "author": "koppor", "createdAt": "2020-08-01T20:47:52Z", "path": "src/main/java/org/jabref/logic/importer/EntryBasedParserFetcher.java", "diffHunk": "@@ -69,4 +52,21 @@ default void doPostCleanup(BibEntry entry) {\n             throw new FetcherException(\"An internal parser error occurred\", e);\n         }\n     }\n+\n+    /**", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f08184e5677368e65c6036577b64d0f8be364aea", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/EntryBasedParserFetcher.java b/src/main/java/org/jabref/logic/importer/EntryBasedParserFetcher.java\nindex 2e5b61a74..5297d5ad1 100644\n--- a/src/main/java/org/jabref/logic/importer/EntryBasedParserFetcher.java\n+++ b/src/main/java/org/jabref/logic/importer/EntryBasedParserFetcher.java\n\n@@ -52,21 +70,4 @@ public interface EntryBasedParserFetcher extends EntryBasedFetcher {\n             throw new FetcherException(\"An internal parser error occurred\", e);\n         }\n     }\n-\n-    /**\n-     * Performs a cleanup of the fetched entry.\n-     *\n-     * Only systematic errors of the fetcher should be corrected here\n-     * (i.e. if information is consistently contained in the wrong field or the wrong format)\n-     * but not cosmetic issues which may depend on the user's taste (for example, LateX code vs HTML in the abstract).\n-     *\n-     * Try to reuse existing {@link Formatter} for the cleanup. For example,\n-     * {@code new FieldFormatterCleanup(StandardField.TITLE, new RemoveBracesFormatter()).cleanup(entry);}\n-     *\n-     * By default, no cleanup is done.\n-     * @param entry the entry to be cleaned-up\n-     */\n-    default void doPostCleanup(BibEntry entry) {\n-        // Do nothing by default\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5ODk1MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463998950", "bodyText": "Pleaes move to the original location (maybe reset to the original format and add the newline at line 76 afterwards)", "author": "koppor", "createdAt": "2020-08-01T20:48:32Z", "path": "src/main/java/org/jabref/logic/importer/IdBasedParserFetcher.java", "diffHunk": "@@ -87,4 +69,21 @@ default void doPostCleanup(BibEntry entry) {\n             throw new FetcherException(\"An internal parser error occurred\", e);\n         }\n     }\n+\n+    /**", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f08184e5677368e65c6036577b64d0f8be364aea", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/IdBasedParserFetcher.java b/src/main/java/org/jabref/logic/importer/IdBasedParserFetcher.java\nindex 72444f257..6bbdf3795 100644\n--- a/src/main/java/org/jabref/logic/importer/IdBasedParserFetcher.java\n+++ b/src/main/java/org/jabref/logic/importer/IdBasedParserFetcher.java\n\n@@ -69,21 +87,4 @@ public interface IdBasedParserFetcher extends IdBasedFetcher {\n             throw new FetcherException(\"An internal parser error occurred\", e);\n         }\n     }\n-\n-    /**\n-     * Performs a cleanup of the fetched entry.\n-     *\n-     * Only systematic errors of the fetcher should be corrected here\n-     * (i.e. if information is consistently contained in the wrong field or the wrong format)\n-     * but not cosmetic issues which may depend on the user's taste (for example, LateX code vs HTML in the abstract).\n-     *\n-     * Try to reuse existing {@link Formatter} for the cleanup. For example,\n-     * {@code new FieldFormatterCleanup(StandardField.TITLE, new RemoveBracesFormatter()).cleanup(entry);}\n-     *\n-     * By default, no cleanup is done.\n-     * @param entry the entry to be cleaned-up\n-     */\n-    default void doPostCleanup(BibEntry entry) {\n-        // Do nothing by default\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTA5OA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463999098", "bodyText": "Please use Logger.debug() or remove this line", "author": "koppor", "createdAt": "2020-08-01T20:50:16Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/CiteSeer.java", "diffHunk": "@@ -59,7 +59,7 @@ public Parser getParser() {\n         // So we extract the data string from the <span class=\"Z3988\" title=\"<data>\"></span> tags and pass the content to the COinS parser\n         return inputStream -> {\n             String response = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(OS.NEWLINE));\n-\n+            System.out.println(response);", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/fetcher/CiteSeer.java b/src/main/java/org/jabref/logic/importer/fetcher/CiteSeer.java\nindex b1b7439d0..77c386a75 100644\n--- a/src/main/java/org/jabref/logic/importer/fetcher/CiteSeer.java\n+++ b/src/main/java/org/jabref/logic/importer/fetcher/CiteSeer.java\n\n@@ -59,7 +59,6 @@ public class CiteSeer implements SearchBasedParserFetcher {\n         // So we extract the data string from the <span class=\"Z3988\" title=\"<data>\"></span> tags and pass the content to the COinS parser\n         return inputStream -> {\n             String response = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(OS.NEWLINE));\n-            System.out.println(response);\n             List<BibEntry> entries = new ArrayList<>();\n             CoinsParser parser = new CoinsParser();\n             Pattern pattern = Pattern.compile(\"<span class=\\\"Z3988\\\" title=\\\"(.*)\\\"></span>\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTMyMA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463999320", "bodyText": "Can't the cleanup be done right after .limit? If it's not easy, maybe add .forEach after the .collect and initialize the converter before the result variable?", "author": "koppor", "createdAt": "2020-08-01T20:53:19Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java", "diffHunk": "@@ -35,16 +36,19 @@ public CompositeSearchBasedFetcher(Set<SearchBasedFetcher> searchBasedFetchers,\n \n     @Override\n     public List<BibEntry> performSearch(String query) {\n-        return fetchers.stream().flatMap(searchBasedFetcher -> {\n+        List<BibEntry> result = fetchers.parallelStream().flatMap(searchBasedFetcher -> {\n             try {\n                 return searchBasedFetcher.performSearch(query).stream();\n             } catch (FetcherException e) {\n                 LOGGER.warn(String.format(\"%s API request failed\", searchBasedFetcher.getName()), e);\n                 return Stream.empty();\n             }\n-        }).parallel()\n-          .limit(maximumNumberOfReturnedResults)\n-          .collect(Collectors.toList());\n+        }).limit(maximumNumberOfReturnedResults)\n+                                        .collect(Collectors.toList());", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNzE0Mw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464007143", "bodyText": "Shouldn't this cleanup actually be removed / replaced by the import cleanup process?", "author": "tobiasdiez", "createdAt": "2020-08-01T22:38:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java b/src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java\nindex cdf6aa4d2..bdc77a5a2 100644\n--- a/src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java\n+++ b/src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java\n\n@@ -36,7 +37,9 @@ public class CompositeSearchBasedFetcher implements SearchBasedFetcher {\n \n     @Override\n     public List<BibEntry> performSearch(String query) {\n-        List<BibEntry> result = fetchers.parallelStream().flatMap(searchBasedFetcher -> {\n+        ImportCleanup cleanup = new ImportCleanup(BibDatabaseMode.BIBTEX);\n+        // All entries have to be converted into one format, this is necessary for the format conversion\n+        return fetchers.parallelStream().flatMap(searchBasedFetcher -> {\n             try {\n                 return searchBasedFetcher.performSearch(query).stream();\n             } catch (FetcherException e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTM5Mw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463999393", "bodyText": "This really has to be public?", "author": "koppor", "createdAt": "2020-08-01T20:54:12Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/DoiFetcher.java", "diffHunk": "@@ -89,7 +88,7 @@ public String getName() {\n         }\n     }\n \n-    private void doPostCleanup(BibEntry entry) {\n+    public void doPostCleanup(BibEntry entry) {", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/fetcher/DoiFetcher.java b/src/main/java/org/jabref/logic/importer/fetcher/DoiFetcher.java\nindex 5a59cc9d4..9d1fe530b 100644\n--- a/src/main/java/org/jabref/logic/importer/fetcher/DoiFetcher.java\n+++ b/src/main/java/org/jabref/logic/importer/fetcher/DoiFetcher.java\n\n@@ -88,7 +88,7 @@ public class DoiFetcher implements IdBasedFetcher, EntryBasedFetcher {\n         }\n     }\n \n-    public void doPostCleanup(BibEntry entry) {\n+    void doPostCleanup(BibEntry entry) {\n         new FieldFormatterCleanup(StandardField.PAGES, new NormalizePagesFormatter()).cleanup(entry);\n         new FieldFormatterCleanup(StandardField.URL, new ClearFormatter()).cleanup(entry);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTYyOA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r463999628", "bodyText": "This needs to be discused -> maybe in a separate PR?\nThe LinkedFile points to a file locally stored. Not to a URL. -- Maybe, just use the URL field of the BibEntry. Or use the URLDownloader to download and store the file. (Needs some investigation how JabRef downloads the file; since JabRef does some rename and folder-sort-magic)", "author": "koppor", "createdAt": "2020-08-01T20:56:50Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/IEEE.java", "diffHunk": "@@ -115,7 +106,11 @@ private static BibEntry parseJsonRespone(JSONObject jsonEntry, Character keyword\n         entry.setField(StandardField.ISBN, jsonEntry.optString(\"isbn\"));\n         entry.setField(StandardField.ISSN, jsonEntry.optString(\"issn\"));\n         entry.setField(StandardField.ISSUE, jsonEntry.optString(\"issue\"));\n-        entry.addFile(new LinkedFile(\"\", Path.of(jsonEntry.optString(\"pdf_url\")), \"PDF\"));\n+        try {\n+            entry.addFile(new LinkedFile(new URL(jsonEntry.optString(\"pdf_url\")), \"PDF\"));", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwMzEzMA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464003130", "bodyText": "Linked files can also contain an online link.\nHowever in this case I would set the URL field with the pdf url.", "author": "Siedlerchr", "createdAt": "2020-08-01T21:43:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNzMwMQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464007301", "bodyText": "I think this is correct: the url for the download of the fulltetx should be added as a linked file.", "author": "tobiasdiez", "createdAt": "2020-08-01T22:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExNzU2Mw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464117563", "bodyText": "Did not know this concept. Seemed to be introduced at 5e1adf8. Thus, OK for me.", "author": "koppor", "createdAt": "2020-08-02T20:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk5OTYyOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNTg4MQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464005881", "bodyText": "targetBibEntryFormat is not used", "author": "tobiasdiez", "createdAt": "2020-08-01T22:21:45Z", "path": "src/main/java/org/jabref/gui/ClipBoardManager.java", "diffHunk": "@@ -201,7 +201,7 @@ public void setContent(List<BibEntry> entries) throws IOException {\n         }\n     }\n \n-    private List<BibEntry> fetchByDOI(DOI doi) {\n+    private List<BibEntry> fetchByDOI(DOI doi, BibDatabaseMode targetBibEntryFormat) {", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c87c1d284f5072343a8aad2e1fd7a7b05129c67", "chunk": "diff --git a/src/main/java/org/jabref/gui/ClipBoardManager.java b/src/main/java/org/jabref/gui/ClipBoardManager.java\nindex b31b5dd8f..ba6803534 100644\n--- a/src/main/java/org/jabref/gui/ClipBoardManager.java\n+++ b/src/main/java/org/jabref/gui/ClipBoardManager.java\n\n@@ -201,7 +201,7 @@ public class ClipBoardManager {\n         }\n     }\n \n-    private List<BibEntry> fetchByDOI(DOI doi, BibDatabaseMode targetBibEntryFormat) {\n+    private List<BibEntry> fetchByDOI(DOI doi) {\n         LOGGER.info(\"Found DOI in clipboard\");\n         try {\n             Optional<BibEntry> entry = new DoiFetcher(Globals.prefs.getImportFormatPreferences()).performSearchById(doi.getDOI());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNTg5MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464005890", "bodyText": "also not used I guess", "author": "tobiasdiez", "createdAt": "2020-08-01T22:21:58Z", "path": "src/main/java/org/jabref/gui/bibtexextractor/BibtexExtractorViewModel.java", "diffHunk": "@@ -41,6 +43,7 @@ public BibtexExtractorViewModel(BibDatabaseContext bibdatabaseContext,\n         this.dialogService = dialogService;\n         currentCitationfetcher = new GrobidCitationFetcher(jabRefPreferences.getImportFormatPreferences());\n         this.taskExecutor = taskExecutor;\n+        this.bibEntryFormat = bibdatabaseContext.getMode();", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "190414f4eb1f29c17f8b6e0b9f66fc915dc64d2e", "chunk": "diff --git a/src/main/java/org/jabref/gui/bibtexextractor/BibtexExtractorViewModel.java b/src/main/java/org/jabref/gui/bibtexextractor/BibtexExtractorViewModel.java\nindex 97f5ce7d9..1bf6ea2cd 100644\n--- a/src/main/java/org/jabref/gui/bibtexextractor/BibtexExtractorViewModel.java\n+++ b/src/main/java/org/jabref/gui/bibtexextractor/BibtexExtractorViewModel.java\n\n@@ -43,7 +41,6 @@ public class BibtexExtractorViewModel {\n         this.dialogService = dialogService;\n         currentCitationfetcher = new GrobidCitationFetcher(jabRefPreferences.getImportFormatPreferences());\n         this.taskExecutor = taskExecutor;\n-        this.bibEntryFormat = bibdatabaseContext.getMode();\n         this.importHandler = new ImportHandler(\n                 dialogService,\n                 bibdatabaseContext,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNTk5Nw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464005997", "bodyText": "I would move the targetBibEntryFormat into a constructor argument", "author": "tobiasdiez", "createdAt": "2020-08-01T22:23:35Z", "path": "src/main/java/org/jabref/logic/importer/ImportCleanup.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.jabref.logic.importer;\n+\n+import java.util.Collection;\n+\n+import org.jabref.logic.cleanup.ConvertToBiblatexCleanup;\n+import org.jabref.logic.cleanup.ConvertToBibtexCleanup;\n+import org.jabref.model.database.BibDatabaseMode;\n+import org.jabref.model.entry.BibEntry;\n+\n+public class ImportCleanup {\n+\n+    /**\n+     * Performs a format conversion of the given entry into the targeted format.\n+     */\n+    public void doPostCleanup(BibEntry entry, BibDatabaseMode targetBibEntryFormat) {", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f08184e5677368e65c6036577b64d0f8be364aea", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/ImportCleanup.java b/src/main/java/org/jabref/logic/importer/ImportCleanup.java\nindex 859198df1..428c2d6e0 100644\n--- a/src/main/java/org/jabref/logic/importer/ImportCleanup.java\n+++ b/src/main/java/org/jabref/logic/importer/ImportCleanup.java\n\n@@ -9,10 +9,16 @@ import org.jabref.model.entry.BibEntry;\n \n public class ImportCleanup {\n \n+    private final BibDatabaseMode targetBibEntryFormat;\n+\n+    public ImportCleanup(BibDatabaseMode targetBibEntryFormat) {\n+        this.targetBibEntryFormat = targetBibEntryFormat;\n+    }\n+\n     /**\n      * Performs a format conversion of the given entry into the targeted format.\n      */\n-    public void doPostCleanup(BibEntry entry, BibDatabaseMode targetBibEntryFormat) {\n+    public void doPostCleanup(BibEntry entry) {\n         if (targetBibEntryFormat == BibDatabaseMode.BIBTEX) {\n             new ConvertToBibtexCleanup().cleanup(entry);\n         } else if (targetBibEntryFormat == BibDatabaseMode.BIBLATEX) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNjAyOQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464006029", "bodyText": "the addition \"in the requested format\" is obsolete now, right?", "author": "tobiasdiez", "createdAt": "2020-08-01T22:24:14Z", "path": "src/main/java/org/jabref/logic/importer/SearchBasedFetcher.java", "diffHunk": "@@ -14,7 +15,18 @@\n      * Looks for hits which are matched by the given free-text query.\n      *\n      * @param query search string\n-     * @return a list of {@link BibEntry}, which are matched by the query (may be empty)\n+     * @return a list of {@link BibEntry}, which are matched by the query (may be empty) in the requested format", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/SearchBasedFetcher.java b/src/main/java/org/jabref/logic/importer/SearchBasedFetcher.java\nindex c3e5d2f58..d5d83f64f 100644\n--- a/src/main/java/org/jabref/logic/importer/SearchBasedFetcher.java\n+++ b/src/main/java/org/jabref/logic/importer/SearchBasedFetcher.java\n\n@@ -15,7 +15,7 @@ public interface SearchBasedFetcher extends WebFetcher {\n      * Looks for hits which are matched by the given free-text query.\n      *\n      * @param query search string\n-     * @return a list of {@link BibEntry}, which are matched by the query (may be empty) in the requested format\n+     * @return a list of {@link BibEntry}, which are matched by the query (may be empty)\n      */\n     List<BibEntry> performSearch(String query) throws FetcherException;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNjA2MA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464006060", "bodyText": "the old documentation of query should be kept", "author": "tobiasdiez", "createdAt": "2020-08-01T22:24:48Z", "path": "src/main/java/org/jabref/logic/importer/SearchBasedParserFetcher.java", "diffHunk": "@@ -22,7 +23,6 @@\n \n     /**\n      * Constructs a URL based on the query.\n-     * @param query the search query\n      */", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "chunk": "diff --git a/src/main/java/org/jabref/logic/importer/SearchBasedParserFetcher.java b/src/main/java/org/jabref/logic/importer/SearchBasedParserFetcher.java\nindex c706af9d6..24b0e2c84 100644\n--- a/src/main/java/org/jabref/logic/importer/SearchBasedParserFetcher.java\n+++ b/src/main/java/org/jabref/logic/importer/SearchBasedParserFetcher.java\n\n@@ -23,6 +23,8 @@ public interface SearchBasedParserFetcher extends SearchBasedFetcher {\n \n     /**\n      * Constructs a URL based on the query.\n+     *\n+     * @param query the search query\n      */\n     URL getURLForQuery(String query) throws URISyntaxException, MalformedURLException, FetcherException;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNjk3Ng==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464006976", "bodyText": "Is it really a problem if the user searches for an empty string, e.g. author = \"\"?", "author": "tobiasdiez", "createdAt": "2020-08-01T22:36:07Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/ComplexSearchQuery.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.jabref.model.strings.StringUtil;\n+\n+public class ComplexSearchQuery {\n+    // Field for non-fielded search\n+    private final String defaultField;\n+    private final List<String> authors;\n+    private final List<String> titlePhrases;\n+    private final Integer fromYear;\n+    private final Integer toYear;\n+    private final Integer singleYear;\n+    private final String journal;\n+\n+    private ComplexSearchQuery(String defaultField, List<String> authors, List<String> titlePhrases, Integer fromYear, Integer toYear, Integer singleYear, String journal) {\n+        this.defaultField = defaultField;\n+        this.authors = authors;\n+        this.titlePhrases = titlePhrases;\n+        this.fromYear = fromYear;\n+        // Some APIs do not support, or not fully support, year based search. In these cases, the non applicable parameters are ignored.\n+        this.toYear = toYear;\n+        this.journal = journal;\n+        this.singleYear = singleYear;\n+    }\n+\n+    public Optional<String> getDefaultField() {\n+        return Optional.ofNullable(defaultField);\n+    }\n+\n+    public Optional<List<String>> getAuthors() {\n+        return Optional.ofNullable(authors);\n+    }\n+\n+    public Optional<List<String>> getTitlePhrases() {\n+        return Optional.ofNullable(titlePhrases);\n+    }\n+\n+    public Optional<Integer> getFromYear() {\n+        return Optional.ofNullable(fromYear);\n+    }\n+\n+    public Optional<Integer> getToYear() {\n+        return Optional.ofNullable(toYear);\n+    }\n+\n+    public Optional<Integer> getSingleYear() {\n+        return Optional.ofNullable(singleYear);\n+    }\n+\n+    public Optional<String> getJournal() {\n+        return Optional.ofNullable(journal);\n+    }\n+\n+    public static ComplexSearchQueryBuilder builder() {\n+        return new ComplexSearchQueryBuilder();\n+    }\n+\n+    public static class ComplexSearchQueryBuilder {\n+        private String defaultField;\n+        private List<String> authors;\n+        private List<String> titlePhrases;\n+        private String journal;\n+        private Integer fromYear;\n+        private Integer toYear;\n+        private Integer singleYear;\n+\n+        public ComplexSearchQueryBuilder() {\n+        }\n+\n+        public ComplexSearchQueryBuilder defaultField(String defaultField) {\n+            if (Objects.requireNonNull(defaultField).isBlank()) {\n+                throw new IllegalArgumentException(\"Parameter must not be blank\");\n+            }\n+            this.defaultField = defaultField;\n+            return this;\n+        }\n+\n+        /**\n+         * Adds author and wraps it in quotes\n+         */\n+        public ComplexSearchQueryBuilder author(String author) {\n+            if (Objects.requireNonNull(author).isBlank()) {\n+                throw new IllegalArgumentException(\"Parameter must not be blank\");", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA3MjcxNw==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464072717", "bodyText": "Hey :)\nIMHO allowing empty strings for any query parameter does not really make much sense semantically.\nI do not see the semantics such an empty string should have:\n\nIf the user does not want to specify an author, he should just leave the field null\nOtherwise, he tries to searches for documents without authors?\n\nDid I overlook a use case where giving an empty string for a query parameter is useful?", "author": "DominikVoigt", "createdAt": "2020-08-02T12:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNjk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4Mjg0NQ==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464082845", "bodyText": "Sounds good! I just wanted to double check.\n(We should keep this in the back of our heads when the user interface is implemented. There you would like to show a helping message instead of an error dialog).", "author": "tobiasdiez", "createdAt": "2020-08-02T14:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNjk3Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAwNzUwNA==", "url": "https://github.com/JabRef/jabref/pull/6687#discussion_r464007504", "bodyText": "Why did you disabled these tests?", "author": "tobiasdiez", "createdAt": "2020-08-01T22:43:38Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -26,6 +28,7 @@\n import static org.mockito.Mockito.when;\n \n @FetcherTest\n+@Disabled", "originalCommit": "d6eb086acec5c426a2bde6a68bf50f10c5f26b63", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "chunk": "diff --git a/src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java b/src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java\nindex b082cfd40..b25f9cafd 100644\n--- a/src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java\n+++ b/src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java\n\n@@ -28,7 +27,6 @@ import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n @FetcherTest\n-@Disabled\n public class CompositeSearchBasedFetcherTest {\n \n     private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n"}}, {"oid": "f08184e5677368e65c6036577b64d0f8be364aea", "url": "https://github.com/JabRef/jabref/commit/f08184e5677368e65c6036577b64d0f8be364aea", "message": "Integrate requested changes.\n\n- Move doPostCleanup back\n- Move format in ImportCleanup into constructor.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T11:44:15Z", "type": "commit"}, {"oid": "8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "url": "https://github.com/JabRef/jabref/commit/8f3fe0f07647c290b0306812e5a3a9e67b88ea1d", "message": "Integrate requested changes.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T11:59:47Z", "type": "commit"}, {"oid": "056cc933ecb60ffb6936436d9e001b4a422349d1", "url": "https://github.com/JabRef/jabref/commit/056cc933ecb60ffb6936436d9e001b4a422349d1", "message": "Change test to use ImportCleanup.\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T12:07:00Z", "type": "commit"}, {"oid": "e0fc10aebe7431bb6683b20f642a677b31389b89", "url": "https://github.com/JabRef/jabref/commit/e0fc10aebe7431bb6683b20f642a677b31389b89", "message": "Merge remote-tracking branch 'upstream/master' into feat/add-capability-tests-for-fetchers", "committedDate": "2020-08-02T12:07:34Z", "type": "commit"}, {"oid": "1c87c1d284f5072343a8aad2e1fd7a7b05129c67", "url": "https://github.com/JabRef/jabref/commit/1c87c1d284f5072343a8aad2e1fd7a7b05129c67", "message": "Remove unused bibentry format\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T12:11:07Z", "type": "commit"}, {"oid": "190414f4eb1f29c17f8b6e0b9f66fc915dc64d2e", "url": "https://github.com/JabRef/jabref/commit/190414f4eb1f29c17f8b6e0b9f66fc915dc64d2e", "message": "Integrate requested changes\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T12:21:26Z", "type": "commit"}, {"oid": "a37d29efb645a25bd50ca807c7516d9c6ac4de82", "url": "https://github.com/JabRef/jabref/commit/a37d29efb645a25bd50ca807c7516d9c6ac4de82", "message": "Inline variable\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T12:24:07Z", "type": "commit"}, {"oid": "4b6b54b880c11e2b177a5bf61111162456fb6b34", "url": "https://github.com/JabRef/jabref/commit/4b6b54b880c11e2b177a5bf61111162456fb6b34", "message": "Modify ADR\n - Change title\n - Fix some typos and punctuation\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T12:29:16Z", "type": "commit"}, {"oid": "b5d93690fcccb53c552f1289168e18ddc5c9f28f", "url": "https://github.com/JabRef/jabref/commit/b5d93690fcccb53c552f1289168e18ddc5c9f28f", "message": "Fix compile error\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T19:43:13Z", "type": "commit"}, {"oid": "cf2ff45ca61eaad60899c4836b3537596865c849", "url": "https://github.com/JabRef/jabref/commit/cf2ff45ca61eaad60899c4836b3537596865c849", "message": "Change ADR title\nFix indentation issue in CompositeSearchBasedFetcher\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T20:10:55Z", "type": "commit"}, {"oid": "37293c60deee4802fa6c1a6e045ccdf0673195ee", "url": "https://github.com/JabRef/jabref/commit/37293c60deee4802fa6c1a6e045ccdf0673195ee", "message": "Inline some variables\nRemove outdated JavaDoc\n\nSigned-off-by: Dominik Voigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-08-02T20:19:39Z", "type": "commit"}]}