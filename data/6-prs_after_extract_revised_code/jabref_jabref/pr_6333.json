{"pr_number": 6333, "pr_title": "Check duplicate DOI", "pr_createdAt": "2020-04-21T21:49:11Z", "pr_url": "https://github.com/JabRef/jabref/pull/6333", "timeline": [{"oid": "2e07d9b690df9395a52fca80f22ecd56dbbecc84", "url": "https://github.com/JabRef/jabref/commit/2e07d9b690df9395a52fca80f22ecd56dbbecc84", "message": "ioebnfgoeoignboieg", "committedDate": "2020-04-21T19:27:42Z", "type": "commit"}, {"oid": "c3724a8cbb92cf64370d7ba7c7266a7ae4eb5fe6", "url": "https://github.com/JabRef/jabref/commit/c3724a8cbb92cf64370d7ba7c7266a7ae4eb5fe6", "message": "asdf", "committedDate": "2020-04-21T20:11:13Z", "type": "commit"}, {"oid": "1a7aa441132755f6c1dc2506c71a5d860c54dff3", "url": "https://github.com/JabRef/jabref/commit/1a7aa441132755f6c1dc2506c71a5d860c54dff3", "message": "WIP: Add equals to DOI", "committedDate": "2020-04-21T20:42:30Z", "type": "commit"}, {"oid": "a1b0fbc8193977420e8401b750e3667e5b7de74c", "url": "https://github.com/JabRef/jabref/commit/a1b0fbc8193977420e8401b750e3667e5b7de74c", "message": "rbrbbrbr", "committedDate": "2020-04-21T21:28:00Z", "type": "commit"}, {"oid": "9b46f8597fa16a1d03f9cd73d11b196844a336a3", "url": "https://github.com/JabRef/jabref/commit/9b46f8597fa16a1d03f9cd73d11b196844a336a3", "message": "Flatmap", "committedDate": "2020-04-21T21:47:17Z", "type": "commit"}, {"oid": "ae89990cbc20b1caf105477e5ef500ec3fd44820", "url": "https://github.com/JabRef/jabref/commit/ae89990cbc20b1caf105477e5ef500ec3fd44820", "message": "Fix checkstyle", "committedDate": "2020-04-21T21:55:30Z", "type": "commit"}, {"oid": "006c24187326b2cf1ccf8d85e3122fd643a94095", "url": "https://github.com/JabRef/jabref/commit/006c24187326b2cf1ccf8d85e3122fd643a94095", "message": "Remove obsolete .", "committedDate": "2020-04-21T22:03:11Z", "type": "commit"}, {"oid": "b3e703bff6f3ba0960ad590e12839494e37f8896", "url": "https://github.com/JabRef/jabref/commit/b3e703bff6f3ba0960ad590e12839494e37f8896", "message": "Add CHANGELOG.md entry", "committedDate": "2020-04-21T22:12:15Z", "type": "commit"}, {"oid": "2c00e7de4615edf6e59f7d3ed925070d9676befc", "url": "https://github.com/JabRef/jabref/commit/2c00e7de4615edf6e59f7d3ed925070d9676befc", "message": "Fix tests by using \"old school\" for loop with appropriate Optional check", "committedDate": "2020-04-21T22:19:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412701403", "bodyText": "Why not directly initialize that HashMap in the field declaration?", "author": "Siedlerchr", "createdAt": "2020-04-22T06:21:29Z", "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();", "originalCommit": "2c00e7de4615edf6e59f7d3ed925070d9676befc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjMwNQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412712305", "bodyText": "MAybe you did not see that the later code uses the BibtexDatabase from the constructor. We decided to put the code into check - and not into the constructor - to have a lean constructor and not have high CPU usage when initializing the checker, but at the first time an entry is checked.", "author": "koppor", "createdAt": "2020-04-22T06:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNzQxMg==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412717412", "bodyText": "This seems like premature optimization for me.", "author": "Siedlerchr", "createdAt": "2020-04-22T06:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkzNjI1MQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412936251", "bodyText": "Why are you caching the errors anyway? Also in case you are worrying about performance, why do you choose to implement a solution that has O(n^2) (with n = entries). Why not implement a O(n) solution (e.g. https://stackoverflow.com/a/31341963/873661) which you call in checkDatabase below?", "author": "tobiasdiez", "createdAt": "2020-04-22T12:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIyOTEwNA==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413229104", "bodyText": "See in line 30 that the method is called once per entry. Is is by design of the Checker interface that there is method for checking each entry. There is no method for checking a complete database. There is also no interface for a complete database.\nAt the first call, the result map is filled. At all subsequent calls do not fill the map and reuse it.\nWe are O(n+m) where n is the size of the database and m is the number of entries with DOIs.", "author": "koppor", "createdAt": "2020-04-22T18:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NDU0OQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413494549", "bodyText": "To make the code more reable, I moved the call to the error check to the constructor. See fd7621d", "author": "koppor", "createdAt": "2020-04-23T04:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMTQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "fd7621db9cc87c2d2a82e8dfab3d8ee055a17a68", "chunk": "diff --git a/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java b/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\nindex 16c14fb1f..892288b4b 100644\n--- a/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\n+++ b/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\n\n@@ -24,28 +24,33 @@ public class DoiDuplicationChecker implements Checker {\n \n     public DoiDuplicationChecker(BibDatabase database) {\n         this.database = Objects.requireNonNull(database);\n+        // There is no interface for the check of the complete database.\n+        // A duplication check needs the knowledge of the **other** entries.\n+        // The method \"check\" is called for each **entry**, thus walk through all entries only once\n+        fillErrorMap();\n     }\n \n     @Override\n     public List<IntegrityMessage> check(BibEntry entry) {\n-        if (errors == null) {\n-            errors = new HashMap<>();\n-\n-            ObservableList<BibEntry> bibEntries = database.getEntries();\n-            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n-            for (BibEntry bibEntry : bibEntries) {\n-                bibEntry.getDOI().ifPresent(doi ->\n-                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));\n-            }\n-\n-            duplicateMap.inverse().keySet().stream()\n-                        .filter(list -> list.size() > 1)\n-                        .flatMap(list -> list.stream())\n-                        .forEach(item -> {\n-                            IntegrityMessage errorMessage = new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI);\n-                            errors.put(item, List.of(errorMessage));\n-                        });\n-        }\n         return errors.getOrDefault(entry, Collections.emptyList());\n     }\n+\n+    private void fillErrorMap() {\n+        errors = new HashMap<>();\n+\n+        ObservableList<BibEntry> bibEntries = database.getEntries();\n+        BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+        for (BibEntry bibEntry : bibEntries) {\n+            bibEntry.getDOI().ifPresent(doi ->\n+                    duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));\n+        }\n+\n+        duplicateMap.inverse().keySet().stream()\n+                    .filter(list -> list.size() > 1)\n+                    .flatMap(list -> list.stream())\n+                    .forEach(item -> {\n+                        IntegrityMessage errorMessage = new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI);\n+                        errors.put(item, List.of(errorMessage));\n+                    });\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412712675", "bodyText": "It is doi, not entry. However, doi cannot be used as the variable name is already bound.", "author": "koppor", "createdAt": "2020-04-22T06:44:37Z", "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements Checker {\n+    private final BibDatabase database;\n+    private Map<BibEntry, List<IntegrityMessage>> errors;\n+\n+    public DoiDuplicationChecker(BibDatabase database) {\n+        this.database = Objects.requireNonNull(database);\n+    }\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibEntry entry) {\n+        if (errors == null) {\n+            errors = new HashMap<>();\n+\n+            ObservableList<BibEntry> bibEntries = database.getEntries();\n+            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+            for (BibEntry bibEntry : bibEntries) {\n+                bibEntry.getDOI().ifPresent(doi ->\n+                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));", "originalCommit": "2c00e7de4615edf6e59f7d3ed925070d9676befc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNTg1Mg==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412715852", "bodyText": "@koppor Please have a close look. The second argument of duplicateMap.computeIfAbsent refers to the value and this clearly is of type  List.   So then maybe name it entries", "author": "Siedlerchr", "createdAt": "2020-04-22T06:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc2NjI3Nw==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412766277", "bodyText": "@Siedlerchr Please explain the JavaDoc to me. The Map is FROM doi TO list. https://www.geeksforgeeks.org/hashmap-computeifabsent-method-in-java-with-examples/ explains the computeIfAbsent.\nTo me, it reads, that the key is passed to Function<? super K, ? extends V> remappingFunction. The key is clearly (!) a DOI not a list. -- Am I wrong?", "author": "koppor", "createdAt": "2020-04-22T08:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NDYyMQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413494621", "bodyText": "To make the code more reable, I called the variable absentDoi. See 6f9b148", "author": "koppor", "createdAt": "2020-04-23T04:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMjY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fd7621db9cc87c2d2a82e8dfab3d8ee055a17a68", "chunk": "diff --git a/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java b/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\nindex 16c14fb1f..892288b4b 100644\n--- a/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\n+++ b/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\n\n@@ -24,28 +24,33 @@ public class DoiDuplicationChecker implements Checker {\n \n     public DoiDuplicationChecker(BibDatabase database) {\n         this.database = Objects.requireNonNull(database);\n+        // There is no interface for the check of the complete database.\n+        // A duplication check needs the knowledge of the **other** entries.\n+        // The method \"check\" is called for each **entry**, thus walk through all entries only once\n+        fillErrorMap();\n     }\n \n     @Override\n     public List<IntegrityMessage> check(BibEntry entry) {\n-        if (errors == null) {\n-            errors = new HashMap<>();\n-\n-            ObservableList<BibEntry> bibEntries = database.getEntries();\n-            BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n-            for (BibEntry bibEntry : bibEntries) {\n-                bibEntry.getDOI().ifPresent(doi ->\n-                        duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));\n-            }\n-\n-            duplicateMap.inverse().keySet().stream()\n-                        .filter(list -> list.size() > 1)\n-                        .flatMap(list -> list.stream())\n-                        .forEach(item -> {\n-                            IntegrityMessage errorMessage = new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI);\n-                            errors.put(item, List.of(errorMessage));\n-                        });\n-        }\n         return errors.getOrDefault(entry, Collections.emptyList());\n     }\n+\n+    private void fillErrorMap() {\n+        errors = new HashMap<>();\n+\n+        ObservableList<BibEntry> bibEntries = database.getEntries();\n+        BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+        for (BibEntry bibEntry : bibEntries) {\n+            bibEntry.getDOI().ifPresent(doi ->\n+                    duplicateMap.computeIfAbsent(doi, x -> new ArrayList<>()).add(bibEntry));\n+        }\n+\n+        duplicateMap.inverse().keySet().stream()\n+                    .filter(list -> list.size() > 1)\n+                    .flatMap(list -> list.stream())\n+                    .forEach(item -> {\n+                        IntegrityMessage errorMessage = new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI);\n+                        errors.put(item, List.of(errorMessage));\n+                    });\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyOTMzOA==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r412929338", "bodyText": "To be honest, I don't see any advantage of this refactoring. Just makes the code more complex and harder to maintain in my opinion.\nIf you really feel like the original code needs a refactoring, then you create a list of all checkers that need to be run a) always, b) bibtex c)biblatex (still I would create these lists only in the checkdatabase method). This would get ride of the repeated check methods below. But to be honest, I don't think this yields a more readable code either.", "author": "tobiasdiez", "createdAt": "2020-04-22T12:16:14Z", "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "diffHunk": "@@ -32,9 +45,36 @@ public IntegrityCheck(BibDatabaseContext bibDatabaseContext,\n         this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n         this.enforceLegalKey = enforceLegalKey;\n         this.allowIntegerEdition = allowIntegerEdition;\n+        initCheckers(bibDatabaseContext, bibtexKeyPatternPreferences, journalAbbreviationRepository);\n     }\n \n-    public List<IntegrityMessage> checkDatabase() {\n+    private void initCheckers(BibDatabaseContext bibDatabaseContext, BibtexKeyPatternPreferences bibtexKeyPatternPreferences, JournalAbbreviationRepository journalAbbreviationRepository) {", "originalCommit": "2c00e7de4615edf6e59f7d3ed925070d9676befc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM0MDkzNQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413340935", "bodyText": "We initialize the checkers once per database check - not once per entry check. In case of a 20k database, approx 100k less java objects in memory per quality check.\nWe ensured that each checker is stateless - thus, it can be reused for acroess entries.\nI agree with your proposal though.", "author": "koppor", "createdAt": "2020-04-22T21:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyOTMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NTIwNg==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413495206", "bodyText": "With your proposal, the code is much more reable. \ud83c\udf89 03dd2a0", "author": "koppor", "createdAt": "2020-04-23T04:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkyOTMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "03dd2a0b59a63c17460a74cd12aa205edc628aad", "chunk": "diff --git a/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java b/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java\nindex 7d7c5784e..ed040d095 100644\n--- a/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java\n+++ b/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java\n\n@@ -39,39 +23,35 @@ public class IntegrityCheck {\n                           JournalAbbreviationRepository journalAbbreviationRepository,\n                           boolean enforceLegalKey,\n                           boolean allowIntegerEdition) {\n-        this.bibDatabaseContext = Objects.requireNonNull(bibDatabaseContext);\n-        this.filePreferences = Objects.requireNonNull(filePreferences);\n-        this.bibtexKeyPatternPreferences = Objects.requireNonNull(bibtexKeyPatternPreferences);\n-        this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n-        this.enforceLegalKey = enforceLegalKey;\n-        this.allowIntegerEdition = allowIntegerEdition;\n-        initCheckers(bibDatabaseContext, bibtexKeyPatternPreferences, journalAbbreviationRepository);\n-    }\n-\n-    private void initCheckers(BibDatabaseContext bibDatabaseContext, BibtexKeyPatternPreferences bibtexKeyPatternPreferences, JournalAbbreviationRepository journalAbbreviationRepository) {\n-        asciiCharacterChecker = new ASCIICharacterChecker();\n-        noBibtexFieldChecker = new NoBibtexFieldChecker();\n-        bibTeXEntryTypeChecker = new BibTeXEntryTypeChecker();\n-        bibtexKeyChecker = new BibtexKeyChecker();\n-        typeChecker = new TypeChecker();\n-        bibStringChecker = new BibStringChecker();\n-        htmlCharacterChecker = new HTMLCharacterChecker();\n-        entryLinkChecker = new EntryLinkChecker(bibDatabaseContext.getDatabase());\n-        bibtexkeyDeviationChecker = new BibtexkeyDeviationChecker(bibDatabaseContext, bibtexKeyPatternPreferences);\n-        bibtexKeyDuplicationChecker = new BibtexKeyDuplicationChecker(bibDatabaseContext.getDatabase());\n-        doiDuplicationChecker = new DoiDuplicationChecker(bibDatabaseContext.getDatabase());\n-\n-        if (bibDatabaseContext.isBiblatexMode()) {\n-            journalInAbbreviationListChecker = new JournalInAbbreviationListChecker(StandardField.JOURNALTITLE, journalAbbreviationRepository);\n-        } else {\n-            journalInAbbreviationListChecker = new JournalInAbbreviationListChecker(StandardField.JOURNAL, journalAbbreviationRepository);\n-        }\n+        this.bibDatabaseContext = bibDatabaseContext;\n \n         fieldCheckers = new FieldCheckers(bibDatabaseContext,\n                 filePreferences,\n                 journalAbbreviationRepository,\n                 enforceLegalKey,\n                 allowIntegerEdition);\n+\n+        entryCheckers = Arrays.asList(\n+                new BibtexKeyChecker(),\n+                new TypeChecker(),\n+                new BibStringChecker(),\n+                new HTMLCharacterChecker(),\n+                new EntryLinkChecker(bibDatabaseContext.getDatabase()),\n+                new BibtexkeyDeviationChecker(bibDatabaseContext, bibtexKeyPatternPreferences),\n+                new BibtexKeyDuplicationChecker(bibDatabaseContext.getDatabase()),\n+                new DoiDuplicationChecker(bibDatabaseContext.getDatabase())\n+        );\n+\n+        if (!bibDatabaseContext.isBiblatexMode()) {\n+            entryCheckers.add(new JournalInAbbreviationListChecker(StandardField.JOURNALTITLE, journalAbbreviationRepository));\n+        } else {\n+            entryCheckers.addAll(List.of(\n+                    new JournalInAbbreviationListChecker(StandardField.JOURNAL, journalAbbreviationRepository),\n+                    new ASCIICharacterChecker(),\n+                    new NoBibtexFieldChecker(),\n+                    new BibTeXEntryTypeChecker())\n+            );\n+        }\n     }\n \n     List<IntegrityMessage> checkDatabase() {\n"}}, {"oid": "fd7621db9cc87c2d2a82e8dfab3d8ee055a17a68", "url": "https://github.com/JabRef/jabref/commit/fd7621db9cc87c2d2a82e8dfab3d8ee055a17a68", "message": "Rearrange code (to make it more readable)", "committedDate": "2020-04-23T03:52:59Z", "type": "commit"}, {"oid": "03dd2a0b59a63c17460a74cd12aa205edc628aad", "url": "https://github.com/JabRef/jabref/commit/03dd2a0b59a63c17460a74cd12aa205edc628aad", "message": "Create List of checkers at the contructor", "committedDate": "2020-04-23T04:09:14Z", "type": "commit"}, {"oid": "6f9b14812976b8b70abacada1c670dd318a307f3", "url": "https://github.com/JabRef/jabref/commit/6f9b14812976b8b70abacada1c670dd318a307f3", "message": "Fix variable name", "committedDate": "2020-04-23T04:10:04Z", "type": "commit"}, {"oid": "2de185810040146b1d79a9074020f3d54471340c", "url": "https://github.com/JabRef/jabref/commit/2de185810040146b1d79a9074020f3d54471340c", "message": "add new interface DatabaseChecker\n\nCo-authored-by: Oliver Kopp <kopp.dev@gmail.com>", "committedDate": "2020-04-23T10:03:28Z", "type": "commit"}, {"oid": "4c9e687a0f2181704ba08f0eff9edbabe17a6971", "url": "https://github.com/JabRef/jabref/commit/4c9e687a0f2181704ba08f0eff9edbabe17a6971", "message": "Add FunctionalInterface annotation to DatabaseChecker\n\nCo-authored-by: Oliver Kopp <kopp.dev@gmail.com>", "committedDate": "2020-04-23T10:07:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNDU0Nw==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413704547", "bodyText": "Rename to EntryChecker?", "author": "tobiasdiez", "createdAt": "2020-04-23T10:35:21Z", "path": "src/main/java/org/jabref/logic/integrity/Checker.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.List;\n+\n+import org.jabref.model.entry.BibEntry;\n+\n+@FunctionalInterface\n+public interface Checker {", "originalCommit": "4c9e687a0f2181704ba08f0eff9edbabe17a6971", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a5046c32592a979659d1ece339f1fb6b727ee8c", "chunk": "diff --git a/src/main/java/org/jabref/logic/integrity/Checker.java b/src/main/java/org/jabref/logic/integrity/EntryChecker.java\nsimilarity index 84%\nrename from src/main/java/org/jabref/logic/integrity/Checker.java\nrename to src/main/java/org/jabref/logic/integrity/EntryChecker.java\nindex 9fb702480..bcbe0e797 100644\n--- a/src/main/java/org/jabref/logic/integrity/Checker.java\n+++ b/src/main/java/org/jabref/logic/integrity/EntryChecker.java\n\n@@ -5,6 +5,6 @@ import java.util.List;\n import org.jabref.model.entry.BibEntry;\n \n @FunctionalInterface\n-public interface Checker {\n+public interface EntryChecker {\n     List<IntegrityMessage> check(BibEntry entry);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNTY2MQ==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413705661", "bodyText": "I think \"The same DOI is used...\" is better", "author": "tobiasdiez", "createdAt": "2020-04-23T10:37:04Z", "path": "src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.jabref.logic.integrity;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javafx.collections.ObservableList;\n+\n+import org.jabref.logic.l10n.Localization;\n+import org.jabref.model.database.BibDatabase;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.model.entry.field.StandardField;\n+import org.jabref.model.entry.identifier.DOI;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+\n+public class DoiDuplicationChecker implements DatabaseChecker {\n+\n+    @Override\n+    public List<IntegrityMessage> check(BibDatabase database) {\n+        ObservableList<BibEntry> bibEntries = database.getEntries();\n+        BiMap<DOI, List<BibEntry>> duplicateMap = HashBiMap.create(bibEntries.size());\n+        for (BibEntry bibEntry : bibEntries) {\n+            bibEntry.getDOI().ifPresent(doi ->\n+                    duplicateMap.computeIfAbsent(doi, absentDoi -> new ArrayList<>()).add(bibEntry));\n+        }\n+\n+        return duplicateMap.inverse().keySet().stream()\n+                           .filter(list -> list.size() > 1)\n+                           .flatMap(list -> list.stream())\n+                           .map(item -> new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI))", "originalCommit": "4c9e687a0f2181704ba08f0eff9edbabe17a6971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxODQ4NA==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r414018484", "bodyText": "Just \"Same DOI...\" will do.", "author": "stefan-kolb", "createdAt": "2020-04-23T18:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNTY2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a5046c32592a979659d1ece339f1fb6b727ee8c", "chunk": "diff --git a/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java b/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\nindex 954d3322a..41dfcdfba 100644\n--- a/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\n+++ b/src/main/java/org/jabref/logic/integrity/DoiDuplicationChecker.java\n\n@@ -29,7 +29,7 @@ public class DoiDuplicationChecker implements DatabaseChecker {\n         return duplicateMap.inverse().keySet().stream()\n                            .filter(list -> list.size() > 1)\n                            .flatMap(list -> list.stream())\n-                           .map(item -> new IntegrityMessage(Localization.lang(\"Unique DOI used in multiple entries\"), item, StandardField.DOI))\n+                           .map(item -> new IntegrityMessage(Localization.lang(\"Same DOI used in multiple entries\"), item, StandardField.DOI))\n                            .collect(Collectors.toList());\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcwNzUxMw==", "url": "https://github.com/JabRef/jabref/pull/6333#discussion_r413707513", "bodyText": "Name it simply check?", "author": "tobiasdiez", "createdAt": "2020-04-23T10:39:56Z", "path": "src/main/java/org/jabref/logic/integrity/IntegrityCheck.java", "diffHunk": "@@ -14,75 +15,77 @@\n public class IntegrityCheck {\n \n     private final BibDatabaseContext bibDatabaseContext;\n-    private final FilePreferences filePreferences;\n-    private final BibtexKeyPatternPreferences bibtexKeyPatternPreferences;\n-    private final JournalAbbreviationRepository journalAbbreviationRepository;\n-    private final boolean enforceLegalKey;\n-    private final boolean allowIntegerEdition;\n+    private final FieldCheckers fieldCheckers;\n+    private final List<Checker> entryCheckers;\n \n     public IntegrityCheck(BibDatabaseContext bibDatabaseContext,\n                           FilePreferences filePreferences,\n                           BibtexKeyPatternPreferences bibtexKeyPatternPreferences,\n                           JournalAbbreviationRepository journalAbbreviationRepository,\n                           boolean enforceLegalKey,\n                           boolean allowIntegerEdition) {\n-        this.bibDatabaseContext = Objects.requireNonNull(bibDatabaseContext);\n-        this.filePreferences = Objects.requireNonNull(filePreferences);\n-        this.bibtexKeyPatternPreferences = Objects.requireNonNull(bibtexKeyPatternPreferences);\n-        this.journalAbbreviationRepository = Objects.requireNonNull(journalAbbreviationRepository);\n-        this.enforceLegalKey = enforceLegalKey;\n-        this.allowIntegerEdition = allowIntegerEdition;\n+        this.bibDatabaseContext = bibDatabaseContext;\n+\n+        fieldCheckers = new FieldCheckers(bibDatabaseContext,\n+                filePreferences,\n+                journalAbbreviationRepository,\n+                enforceLegalKey,\n+                allowIntegerEdition);\n+\n+        entryCheckers = new ArrayList<>(List.of(\n+                new BibtexKeyChecker(),\n+                new TypeChecker(),\n+                new BibStringChecker(),\n+                new HTMLCharacterChecker(),\n+                new EntryLinkChecker(bibDatabaseContext.getDatabase()),\n+                new BibtexkeyDeviationChecker(bibDatabaseContext, bibtexKeyPatternPreferences),\n+                new BibtexKeyDuplicationChecker(bibDatabaseContext.getDatabase())\n+        ));\n+\n+        if (!bibDatabaseContext.isBiblatexMode()) {\n+            entryCheckers.add(new JournalInAbbreviationListChecker(StandardField.JOURNALTITLE, journalAbbreviationRepository));\n+        } else {\n+            entryCheckers.addAll(List.of(\n+                    new JournalInAbbreviationListChecker(StandardField.JOURNAL, journalAbbreviationRepository),\n+                    new ASCIICharacterChecker(),\n+                    new NoBibtexFieldChecker(),\n+                    new BibTeXEntryTypeChecker())\n+            );\n+        }\n     }\n \n-    public List<IntegrityMessage> checkDatabase() {\n+    List<IntegrityMessage> executeAllCheckers() {", "originalCommit": "4c9e687a0f2181704ba08f0eff9edbabe17a6971", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7c72d52bccddf0fdfcb243c45f95775e35a0774a", "chunk": "diff --git a/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java b/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java\nindex 6fe47fc06..6d239865f 100644\n--- a/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java\n+++ b/src/main/java/org/jabref/logic/integrity/IntegrityCheck.java\n\n@@ -22,14 +21,12 @@ public class IntegrityCheck {\n                           FilePreferences filePreferences,\n                           BibtexKeyPatternPreferences bibtexKeyPatternPreferences,\n                           JournalAbbreviationRepository journalAbbreviationRepository,\n-                          boolean enforceLegalKey,\n                           boolean allowIntegerEdition) {\n         this.bibDatabaseContext = bibDatabaseContext;\n \n         fieldCheckers = new FieldCheckers(bibDatabaseContext,\n                 filePreferences,\n                 journalAbbreviationRepository,\n-                enforceLegalKey,\n                 allowIntegerEdition);\n \n         entryCheckers = new ArrayList<>(List.of(\n"}}, {"oid": "97b9cbed797fb1fea62f8f8f3c75ae4ed6dd6ffb", "url": "https://github.com/JabRef/jabref/commit/97b9cbed797fb1fea62f8f8f3c75ae4ed6dd6ffb", "message": "Move comments", "committedDate": "2020-04-23T20:09:31Z", "type": "commit"}, {"oid": "eaebdf53011881f70e4b81601f3140cf3f3c84de", "url": "https://github.com/JabRef/jabref/commit/eaebdf53011881f70e4b81601f3140cf3f3c84de", "message": "remove unused import", "committedDate": "2020-05-15T08:22:46Z", "type": "commit"}, {"oid": "7c72d52bccddf0fdfcb243c45f95775e35a0774a", "url": "https://github.com/JabRef/jabref/commit/7c72d52bccddf0fdfcb243c45f95775e35a0774a", "message": "Merge remote-tracking branch 'upstream/master' into check-duplicate-doi\n\n# Conflicts:\n#\tsrc/main/java/org/jabref/logic/integrity/IntegrityCheck.java\n#\tsrc/test/java/org/jabref/logic/integrity/IntegrityCheckTest.java", "committedDate": "2020-05-15T08:43:57Z", "type": "commit"}, {"oid": "c8296c3a08b76320147a3bfd5ea6b3c08a173f67", "url": "https://github.com/JabRef/jabref/commit/c8296c3a08b76320147a3bfd5ea6b3c08a173f67", "message": "Merge branch 'check-duplicate-doi' of https://github.com/JabRef/jabref into check-duplicate-doi", "committedDate": "2020-05-15T08:45:26Z", "type": "commit"}, {"oid": "6597dc65a790517d9ae4308b707cd16fd9100b19", "url": "https://github.com/JabRef/jabref/commit/6597dc65a790517d9ae4308b707cd16fd9100b19", "message": "fix filename of DoiValidityCheckerTest", "committedDate": "2020-05-15T09:01:49Z", "type": "commit"}, {"oid": "de629d20f902c570dcd7402a93f66ce3eea644b9", "url": "https://github.com/JabRef/jabref/commit/de629d20f902c570dcd7402a93f66ce3eea644b9", "message": "fix condition", "committedDate": "2020-05-15T09:08:00Z", "type": "commit"}, {"oid": "5a5046c32592a979659d1ece339f1fb6b727ee8c", "url": "https://github.com/JabRef/jabref/commit/5a5046c32592a979659d1ece339f1fb6b727ee8c", "message": "address comments", "committedDate": "2020-05-15T09:22:02Z", "type": "commit"}]}