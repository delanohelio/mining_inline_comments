{"pr_number": 1827, "pr_title": "initial implementation of reflective decoder", "pr_createdAt": "2020-07-28T14:58:36Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1827", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTIxMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461755213", "bodyText": "Will fields overwrite the methods that were just read above?", "author": "vkryachko", "createdAt": "2020-07-28T17:36:07Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,214 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);", "originalCommit": "82b6254984e08a0ff226c67330480f728b88e280", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5ODMzMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461798333", "bodyText": "no, it won't. Fields will only be written when their associated setter methods were not found.", "author": "James201311", "createdAt": "2020-07-28T18:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex dd2710d2..08b97369 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n\n@@ -48,7 +48,7 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n \n     private final Map<String, FieldRef<?>> refs = new HashMap<>();\n     private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n \n     private ReflectiveObjectDecoderImpl() {}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTYyMQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461755621", "bodyText": "We don't want to include all annotations in the descriptor, only ones that are themselves annotated with @ExtraProperty.", "author": "vkryachko", "createdAt": "2020-07-28T17:36:51Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,214 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);\n+      decodeFields(ctx);\n+      return getTypeCreator(ctx.getTypeToken());\n+    }\n+\n+    private void readMethods(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        Method[] methods = currentClass.getDeclaredMethods();\n+        for (Method method : methods) {\n+          if (!shouldIncludeSetter(method)) {\n+            continue;\n+          }\n+\n+          String fieldName = fieldName(method);\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(\n+                fieldName,\n+                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));", "originalCommit": "82b6254984e08a0ff226c67330480f728b88e280", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc5OTU3NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461799574", "bodyText": "Great, then @Encodable.Field should be annoated with @ExtraProperty as well, since it is the extra property of the field even if it's an internal annotation.", "author": "James201311", "createdAt": "2020-07-28T18:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NTYyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex dd2710d2..08b97369 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n\n@@ -48,7 +48,7 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n \n     private final Map<String, FieldRef<?>> refs = new HashMap<>();\n     private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n \n     private ReflectiveObjectDecoderImpl() {}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1NjAwNA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461756004", "bodyText": "same here", "author": "vkryachko", "createdAt": "2020-07-28T17:37:32Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,214 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);\n+      decodeFields(ctx);\n+      return getTypeCreator(ctx.getTypeToken());\n+    }\n+\n+    private void readMethods(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        Method[] methods = currentClass.getDeclaredMethods();\n+        for (Method method : methods) {\n+          if (!shouldIncludeSetter(method)) {\n+            continue;\n+          }\n+\n+          String fieldName = fieldName(method);\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(\n+                fieldName,\n+                buildFieldDescriptor(decodingKey(method), method.getDeclaredAnnotations()));\n+          }\n+          if (fieldSetters.get(fieldName) == null) {\n+            fieldSetters.put(fieldName, ReflectiveFieldSetter.of(method));\n+          }\n+        }\n+        currentClass = currentClass.getSuperclass();\n+      }\n+    }\n+\n+    private void readFields(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        for (Field field : currentClass.getDeclaredFields()) {\n+          if (!shouldIncludeField(field)) {\n+            continue;\n+          }\n+          String fieldName = field.getName();\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(\n+                fieldName,\n+                buildFieldDescriptor(decodingKey(field), field.getDeclaredAnnotations()));", "originalCommit": "82b6254984e08a0ff226c67330480f728b88e280", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex dd2710d2..08b97369 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n\n@@ -48,7 +48,7 @@ class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n \n     private final Map<String, FieldRef<?>> refs = new HashMap<>();\n     private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n-    private final Map<String, ReflectiveFieldSetter> fieldSetters = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n \n     private ReflectiveObjectDecoderImpl() {}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzAyOQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461807029", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @ExtraProperty\n          \n      \n    \n    \n  \n\nI don't think we want Field itseld to have this annotation.", "author": "vkryachko", "createdAt": "2020-07-28T19:05:23Z", "path": "encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java", "diffHunk": "@@ -48,6 +48,7 @@\n   /** Field configuration. */\n   @Target(ElementType.METHOD)\n   @Retention(RetentionPolicy.RUNTIME)\n+  @ExtraProperty", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java b/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\nindex 7e79e44c..f12dd25e 100644\n--- a/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\n+++ b/encoders/firebase-encoders-json/src/main/java/com/google/firebase/encoders/annotations/Encodable.java\n\n@@ -48,7 +48,6 @@ public @interface Encodable {\n   /** Field configuration. */\n   @Target(ElementType.METHOD)\n   @Retention(RetentionPolicy.RUNTIME)\n-  @ExtraProperty\n   @interface Field {\n     /** Specifies a custom field name for a given property of a type. */\n     String name() default \"\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzgxOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461807818", "bodyText": "We want to make sure the field name is consistent with whatever the reflective encoder does, can you make sure they are indeed consistent and if not, reconsile them?", "author": "vkryachko", "createdAt": "2020-07-28T19:06:50Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+class ReflectiveDecoderHelper {\n+  private ReflectiveDecoderHelper() {}\n+\n+  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n+    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n+    for (Annotation annotation : annotations) {\n+      if (annotation.annotationType().isAnnotationPresent(ExtraProperty.class)) {\n+        builder.withProperty(annotation);\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static boolean isInLine(FieldDescriptor fieldDescriptor) {\n+    Encodable.Field annotation = fieldDescriptor.getProperty(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n+  }\n+\n+  static String fieldName(Method method) {", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNzg1NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461817854", "bodyText": "yes, they are consistent, but i will change the implementation to align with encoder as well.", "author": "James201311", "createdAt": "2020-07-28T19:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzgxOA=="}], "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\nindex 8ebf6a73..6be263c0 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n\n@@ -17,7 +17,6 @@ package com.google.firebase.encoders.reflective;\n import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwODQ0Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461808443", "bodyText": "please make this an interface", "author": "vkryachko", "createdAt": "2020-07-28T19:08:03Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n+abstract class ReflectiveFieldSetter {", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\nindex ca06889a..51a04e14 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n\n@@ -16,86 +16,47 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n+import com.google.firebase.encoders.annotations.Encodable;\n import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n \n-abstract class ReflectiveFieldSetter {\n-\n-  abstract void set(@NonNull Object obj, @Nullable Object val);\n-\n-  abstract Class<?> getFieldRawType();\n-\n-  abstract Type getFieldGenericType();\n-\n-  private ReflectiveFieldSetter() {}\n+class ReflectiveFieldSetter implements ReflectiveSetter {\n+  private Field field;\n \n   @NonNull\n   static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new FieldSetter(field);\n+    return new ReflectiveFieldSetter(field);\n   }\n \n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Method setter) {\n-    return new MethodSetter(setter);\n+  private ReflectiveFieldSetter(Field field) {\n+    this.field = field;\n   }\n \n-  static class FieldSetter extends ReflectiveFieldSetter {\n-    private Field field;\n-\n-    FieldSetter(Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object value) {\n-      field.setAccessible(true);\n-      try {\n-        field.set(obj, value);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return field.getType();\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return field.getGenericType();\n+  @Override\n+  public void set(@NonNull Object obj, @Nullable Object value) {\n+    field.setAccessible(true);\n+    try {\n+      field.set(obj, value);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n     }\n   }\n \n-  static class MethodSetter extends ReflectiveFieldSetter {\n-    private Method method;\n-\n-    MethodSetter(Method method) {\n-      this.method = method;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object val) {\n-      method.setAccessible(true);\n-      try {\n-        method.invoke(obj, val);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      } catch (InvocationTargetException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n+  @NonNull\n+  @Override\n+  public Class<?> getFieldRawType() {\n+    return field.getType();\n+  }\n \n-    @Override\n-    Class<?> getFieldRawType() {\n-      return method.getParameterTypes()[0];\n-    }\n+  @Nullable\n+  @Override\n+  public Type getFieldGenericType() {\n+    return field.getGenericType();\n+  }\n \n-    @Override\n-    Type getFieldGenericType() {\n-      return method.getGenericParameterTypes()[0];\n-    }\n+  @Override\n+  public boolean isDecodedInline() {\n+    Encodable.Field annotation = field.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwODczMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r461808730", "bodyText": "extract Field and MethodSetters into top level classes pls.", "author": "vkryachko", "createdAt": "2020-07-28T19:08:36Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+\n+abstract class ReflectiveFieldSetter {\n+\n+  abstract void set(@NonNull Object obj, @Nullable Object val);\n+\n+  abstract Class<?> getFieldRawType();\n+\n+  abstract Type getFieldGenericType();\n+\n+  private ReflectiveFieldSetter() {}\n+\n+  @NonNull\n+  static ReflectiveFieldSetter of(@NonNull Field field) {\n+    return new FieldSetter(field);\n+  }\n+\n+  @NonNull\n+  static ReflectiveFieldSetter of(@NonNull Method setter) {\n+    return new MethodSetter(setter);\n+  }\n+\n+  static class FieldSetter extends ReflectiveFieldSetter {", "originalCommit": "67110ce157c19078fed6197b5347f27352b9c270", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e8959edf460da975591882c26cf3f251060884d8", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\nindex ca06889a..51a04e14 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveFieldSetter.java\n\n@@ -16,86 +16,47 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n+import com.google.firebase.encoders.annotations.Encodable;\n import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n \n-abstract class ReflectiveFieldSetter {\n-\n-  abstract void set(@NonNull Object obj, @Nullable Object val);\n-\n-  abstract Class<?> getFieldRawType();\n-\n-  abstract Type getFieldGenericType();\n-\n-  private ReflectiveFieldSetter() {}\n+class ReflectiveFieldSetter implements ReflectiveSetter {\n+  private Field field;\n \n   @NonNull\n   static ReflectiveFieldSetter of(@NonNull Field field) {\n-    return new FieldSetter(field);\n+    return new ReflectiveFieldSetter(field);\n   }\n \n-  @NonNull\n-  static ReflectiveFieldSetter of(@NonNull Method setter) {\n-    return new MethodSetter(setter);\n+  private ReflectiveFieldSetter(Field field) {\n+    this.field = field;\n   }\n \n-  static class FieldSetter extends ReflectiveFieldSetter {\n-    private Field field;\n-\n-    FieldSetter(Field field) {\n-      this.field = field;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object value) {\n-      field.setAccessible(true);\n-      try {\n-        field.set(obj, value);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n-\n-    @Override\n-    Class<?> getFieldRawType() {\n-      return field.getType();\n-    }\n-\n-    @Override\n-    Type getFieldGenericType() {\n-      return field.getGenericType();\n+  @Override\n+  public void set(@NonNull Object obj, @Nullable Object value) {\n+    field.setAccessible(true);\n+    try {\n+      field.set(obj, value);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n     }\n   }\n \n-  static class MethodSetter extends ReflectiveFieldSetter {\n-    private Method method;\n-\n-    MethodSetter(Method method) {\n-      this.method = method;\n-    }\n-\n-    @Override\n-    void set(@NonNull Object obj, @Nullable Object val) {\n-      method.setAccessible(true);\n-      try {\n-        method.invoke(obj, val);\n-      } catch (IllegalAccessException e) {\n-        throw new RuntimeException(e);\n-      } catch (InvocationTargetException e) {\n-        throw new RuntimeException(e);\n-      }\n-    }\n+  @NonNull\n+  @Override\n+  public Class<?> getFieldRawType() {\n+    return field.getType();\n+  }\n \n-    @Override\n-    Class<?> getFieldRawType() {\n-      return method.getParameterTypes()[0];\n-    }\n+  @Nullable\n+  @Override\n+  public Type getFieldGenericType() {\n+    return field.getGenericType();\n+  }\n \n-    @Override\n-    Type getFieldGenericType() {\n-      return method.getGenericParameterTypes()[0];\n-    }\n+  @Override\n+  public boolean isDecodedInline() {\n+    Encodable.Field annotation = field.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n   }\n }\n"}}, {"oid": "e8959edf460da975591882c26cf3f251060884d8", "url": "https://github.com/firebase/firebase-android-sdk/commit/e8959edf460da975591882c26cf3f251060884d8", "message": "address comments", "committedDate": "2020-07-28T20:13:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMxNzIxNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462317216", "bodyText": "imo we should throw an EncodingException if the type is not allowed by the annotation", "author": "vkryachko", "createdAt": "2020-07-29T13:55:09Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java", "diffHunk": "@@ -17,19 +17,47 @@\n import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n class ReflectiveDecoderHelper {\n   private ReflectiveDecoderHelper() {}\n \n-  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n+  static FieldDescriptor buildFieldDescriptor(Method method) {\n+    String decodingKey = decodingKey(method);\n+    Annotation[] annotations = method.getDeclaredAnnotations();\n     FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n     for (Annotation annotation : annotations) {\n-      builder.withProperty(annotation);\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 063d2582..00000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n\n@@ -1,126 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(Method method) {\n-    String decodingKey = decodingKey(method);\n-    Annotation[] annotations = method.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static FieldDescriptor buildFieldDescriptor(Field field) {\n-    String decodingKey = decodingKey(field);\n-    Annotation[] annotations = field.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(field.getType())) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyMDQ1OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462320459", "bodyText": "these methods look very similar, could they be merged into one? afaict, the only thing that is specific to method vs field is the return type, the rest can be generalized to java.lang.reflect.AccessibleObject, i.e. the method signature would be buildFieldDescriptor(AccessibleObject element, Class<?> type), wdyt?", "author": "vkryachko", "createdAt": "2020-07-29T13:59:27Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java", "diffHunk": "@@ -17,19 +17,47 @@\n import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n import java.lang.annotation.Annotation;\n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n class ReflectiveDecoderHelper {\n   private ReflectiveDecoderHelper() {}\n \n-  static FieldDescriptor buildFieldDescriptor(String decodingKey, Annotation[] annotations) {\n+  static FieldDescriptor buildFieldDescriptor(Method method) {\n+    String decodingKey = decodingKey(method);\n+    Annotation[] annotations = method.getDeclaredAnnotations();\n     FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n     for (Annotation annotation : annotations) {\n-      builder.withProperty(annotation);\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n+          builder.withProperty(annotation);\n+        }\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  static FieldDescriptor buildFieldDescriptor(Field field) {", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\ndeleted file mode 100644\nindex 063d2582..00000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderHelper.java\n+++ /dev/null\n\n@@ -1,126 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderHelper {\n-  private ReflectiveDecoderHelper() {}\n-\n-  static FieldDescriptor buildFieldDescriptor(Method method) {\n-    String decodingKey = decodingKey(method);\n-    Annotation[] annotations = method.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(method.getParameterTypes()[0])) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static FieldDescriptor buildFieldDescriptor(Field field) {\n-    String decodingKey = decodingKey(field);\n-    Annotation[] annotations = field.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(field.getType())) {\n-          builder.withProperty(annotation);\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-\n-  static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  static boolean shouldIncludeSetter(Method method) {\n-    if (!method.getName().startsWith(\"set\")) {\n-      return false;\n-    }\n-    if (method.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(method.getModifiers())) {\n-      return false;\n-    }\n-    if (!method.getReturnType().equals(Void.TYPE)) {\n-      return false;\n-    }\n-    if (method.getParameterTypes().length != 1) {\n-      return false;\n-    }\n-    return !method.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-\n-  static boolean shouldIncludeField(Field field) {\n-    if (field.getDeclaringClass().equals(Object.class)) {\n-      return false;\n-    }\n-    if (!Modifier.isPublic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isStatic(field.getModifiers())) {\n-      return false;\n-    }\n-    if (Modifier.isTransient(field.getModifiers())) {\n-      return false;\n-    }\n-    return !field.isAnnotationPresent(Encodable.Ignore.class);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyODMxMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462328313", "bodyText": "This looks like a lot of bookkeeping spread across 3 maps, is it ever the case that only a subset of these maps contains a certain key? if not consider merging into one map", "author": "vkryachko", "createdAt": "2020-07-29T14:10:05Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,210 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQyMDk1NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462420954", "bodyText": "Great call, I will wrap them into a ReflectiveDecoderFieldContext, which will also make the ReflectiveSetter be a single purpose setter.", "author": "James201311", "createdAt": "2020-07-29T16:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyODMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex e433b001..7539c440 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n\n@@ -14,8 +14,6 @@\n \n package com.google.firebase.encoders.reflective;\n \n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n import androidx.annotation.NonNull;\n import com.google.firebase.decoders.CreationContext;\n import com.google.firebase.decoders.FieldRef;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzMjM4Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462332382", "bodyText": "don't we want to throw a meaningful exception in the case we could not find the TypeVariable in the class definition? By \"meaningful\" I mean, not the generic on that TypeToken.of will throw, but rather something along the lines of \"class foo<T,U,V> does not have type variable W\".", "author": "vkryachko", "createdAt": "2020-07-29T14:15:02Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,210 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.CreationContext;\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.decoders.ObjectDecoder;\n+import com.google.firebase.decoders.ObjectDecoderContext;\n+import com.google.firebase.decoders.TypeCreator;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+class ReflectiveObjectDecoderProvider implements ObjectDecoderProvider {\n+\n+  static ReflectiveObjectDecoderProvider INSTANCE = new ReflectiveObjectDecoderProvider();\n+\n+  private ReflectiveObjectDecoderProvider() {}\n+\n+  @NonNull\n+  @Override\n+  public <T> ObjectDecoder<T> get(@NonNull Class<T> clazz) {\n+    return new ReflectiveObjectDecoderImpl<>();\n+  }\n+\n+  private static class ReflectiveObjectDecoderImpl<T> implements ObjectDecoder<T> {\n+\n+    private final Map<String, FieldRef<?>> refs = new HashMap<>();\n+    private final Map<String, FieldDescriptor> descriptors = new HashMap<>();\n+    private final Map<String, ReflectiveSetter> reflectiveSetters = new HashMap<>();\n+\n+    private ReflectiveObjectDecoderImpl() {}\n+\n+    @NonNull\n+    @Override\n+    public TypeCreator<T> decode(@NonNull ObjectDecoderContext<T> ctx) {\n+      Class<T> clazz = ctx.getTypeToken().getRawType();\n+      readMethods(clazz);\n+      readFields(clazz);\n+      decodeFields(ctx);\n+      return getTypeCreator(ctx.getTypeToken());\n+    }\n+\n+    private void readMethods(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        Method[] methods = currentClass.getDeclaredMethods();\n+        for (Method method : methods) {\n+          if (!shouldIncludeSetter(method)) {\n+            continue;\n+          }\n+\n+          String fieldName = fieldName(method);\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(fieldName, buildFieldDescriptor(method));\n+          }\n+          if (reflectiveSetters.get(fieldName) == null) {\n+            reflectiveSetters.put(fieldName, ReflectiveMethodSetter.of(method));\n+          }\n+        }\n+        currentClass = currentClass.getSuperclass();\n+      }\n+    }\n+\n+    private void readFields(Class<T> clazz) {\n+      Class<? super T> currentClass = clazz;\n+      while (currentClass != Object.class && currentClass != null) {\n+        for (Field field : currentClass.getDeclaredFields()) {\n+          if (!shouldIncludeField(field)) {\n+            continue;\n+          }\n+          String fieldName = field.getName();\n+          if (descriptors.get(fieldName) == null) {\n+            descriptors.put(fieldName, buildFieldDescriptor(field));\n+          }\n+          if (reflectiveSetters.get(fieldName) == null) {\n+            reflectiveSetters.put(fieldName, ReflectiveFieldSetter.of(field));\n+          }\n+        }\n+        currentClass = currentClass.getSuperclass();\n+      }\n+    }\n+\n+    private void decodeFields(ObjectDecoderContext<T> ctx) {\n+      for (Map.Entry<String, ReflectiveSetter> entry : reflectiveSetters.entrySet()) {\n+        String fieldName = entry.getKey();\n+        Class<?> fieldType = entry.getValue().getFieldRawType();\n+        FieldDescriptor fieldDescriptor = descriptors.get(fieldName);\n+        if (fieldDescriptor == null) {\n+          throw new RuntimeException(fieldName + \" did not have a FieldDescriptor.\");\n+        }\n+        FieldRef<?> ref;\n+        if (fieldType.equals(int.class)) {\n+          ref = ctx.decodeInteger(fieldDescriptor);\n+        } else if (fieldType.equals(long.class)) {\n+          ref = ctx.decodeLong(fieldDescriptor);\n+        } else if (fieldType.equals(short.class)) {\n+          ref = ctx.decodeShort(fieldDescriptor);\n+        } else if (fieldType.equals(double.class)) {\n+          ref = ctx.decodeDouble(fieldDescriptor);\n+        } else if (fieldType.equals(float.class)) {\n+          ref = ctx.decodeFloat(fieldDescriptor);\n+        } else if (fieldType.equals(boolean.class)) {\n+          ref = ctx.decodeBoolean(fieldDescriptor);\n+        } else {\n+          TypeToken<?> fieldTypeToken =\n+              getFieldTypeToken(entry.getValue().getFieldGenericType(), ctx);\n+          if (entry.getValue().isDecodedInline()) {\n+            if (fieldTypeToken instanceof TypeToken.ClassToken) {\n+              @SuppressWarnings(\"unchecked\")\n+              TypeToken.ClassToken<Object> classToken =\n+                  (TypeToken.ClassToken<Object>) fieldTypeToken;\n+              ref = ctx.decodeInline(classToken, ReflectiveObjectDecoder.DEFAULT);\n+            } else {\n+              throw new IllegalArgumentException(\n+                  \"Array types cannot be decoded inline, type:\" + fieldTypeToken + \" found.\");\n+            }\n+          } else {\n+            ref = ctx.decode(fieldDescriptor, fieldTypeToken);\n+          }\n+        }\n+        refs.put(fieldName, ref);\n+      }\n+    }\n+\n+    private TypeToken<?> getFieldTypeToken(Type type, ObjectDecoderContext<?> ctx) {\n+      if (type instanceof TypeVariable) {\n+        TypeVariable[] typeVariables = ctx.getTypeToken().getRawType().getTypeParameters();\n+        for (int i = 0; i < typeVariables.length; i++) {\n+          if (typeVariables[i].equals(type)) {\n+            return ctx.getTypeArgument(i);", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\nindex e433b001..7539c440 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveObjectDecoderProvider.java\n\n@@ -14,8 +14,6 @@\n \n package com.google.firebase.encoders.reflective;\n \n-import static com.google.firebase.encoders.reflective.ReflectiveDecoderHelper.*;\n-\n import androidx.annotation.NonNull;\n import com.google.firebase.decoders.CreationContext;\n import com.google.firebase.decoders.FieldRef;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzMzMxNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462333317", "bodyText": "This is not a very good exception, let's tell the developer what is wrong in each case and how they could fix it.", "author": "vkryachko", "createdAt": "2020-07-29T14:16:11Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.TypeToken;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class ReflectiveInitializer {\n+\n+  @NonNull\n+  static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    try {\n+      Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      return constructor.newInstance();\n+    } catch (NoSuchMethodException e) {\n+      // TODO: try JVM sun.misc.Unsafe to allocate an instance\n+      throw new RuntimeException(e);", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex f8deb48d..52f0215a 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n\n@@ -16,6 +16,7 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMzNTc3Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462335777", "bodyText": "food fo thought(no immediate action required): it seems that it could be useful to just store the inline flag inside the field descriptor. This will help by:\n\nnot needing a method here\nand furthermore would allow us to remove the decodeInline() method altogether making the api surface smaller and the implementation below simpler.\n\nwdyt?", "author": "vkryachko", "createdAt": "2020-07-29T14:19:30Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java", "diffHunk": "@@ -0,0 +1,31 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import java.lang.reflect.Type;\n+\n+interface ReflectiveSetter {\n+  void set(@NonNull Object obj, @Nullable Object val);\n+\n+  @NonNull\n+  Class<?> getFieldRawType();\n+\n+  @Nullable\n+  Type getFieldGenericType();\n+\n+  boolean isDecodedInline();", "originalCommit": "dcd8241547c18de67efc49a603d36b8e1b01db3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\nindex f7ea2521..20690916 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveSetter.java\n\n@@ -16,16 +16,7 @@ package com.google.firebase.encoders.reflective;\n \n import androidx.annotation.NonNull;\n import androidx.annotation.Nullable;\n-import java.lang.reflect.Type;\n \n-interface ReflectiveSetter {\n-  void set(@NonNull Object obj, @Nullable Object val);\n-\n-  @NonNull\n-  Class<?> getFieldRawType();\n-\n-  @Nullable\n-  Type getFieldGenericType();\n-\n-  boolean isDecodedInline();\n+interface ReflectiveSetter<T> {\n+  void set(@NonNull Object obj, @Nullable T val);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4Mjc2MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462482761", "bodyText": "is it something you intend to actually do, if not consider removing this todo", "author": "vkryachko", "createdAt": "2020-07-29T17:55:37Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class ReflectiveInitializer {\n+\n+  @NonNull\n+  static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    try {\n+      Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      return constructor.newInstance();\n+    } catch (NoSuchMethodException e) {\n+      // TODO: try JVM sun.misc.Unsafe to allocate an instance", "originalCommit": "f39d5f7f508683773b394180d3f787eb83295972", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b888..52f0215a 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n\n@@ -26,6 +26,7 @@ final class ReflectiveInitializer {\n   static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n     try {\n       Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      constructor.setAccessible(true);\n       return constructor.newInstance();\n     } catch (NoSuchMethodException e) {\n       // TODO: try JVM sun.misc.Unsafe to allocate an instance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ4MzExOA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462483118", "bodyText": "Looks like you missed all these cases, like constructor is not public, etc.", "author": "vkryachko", "createdAt": "2020-07-29T17:56:09Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.TypeToken;\n+import com.google.firebase.encoders.EncodingException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+final class ReflectiveInitializer {\n+\n+  @NonNull\n+  static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    try {\n+      Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      return constructor.newInstance();\n+    } catch (NoSuchMethodException e) {\n+      // TODO: try JVM sun.misc.Unsafe to allocate an instance\n+      throw new EncodingException(\n+          \"Class \"\n+              + classToken\n+              + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n+              + \"sure these constructors are not stripped.\");\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(e);\n+    } catch (InstantiationException e) {\n+      throw new RuntimeException(e);\n+    } catch (InvocationTargetException e) {\n+      throw new RuntimeException(e);\n+    }", "originalCommit": "f39d5f7f508683773b394180d3f787eb83295972", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex 7ca2b888..52f0215a 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n\n@@ -26,6 +26,7 @@ final class ReflectiveInitializer {\n   static <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n     try {\n       Constructor<T> constructor = classToken.getRawType().getDeclaredConstructor();\n+      constructor.setAccessible(true);\n       return constructor.newInstance();\n     } catch (NoSuchMethodException e) {\n       // TODO: try JVM sun.misc.Unsafe to allocate an instance\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNDU5OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462534598", "bodyText": "nit: it's common to name these things with Impl, not Imp\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {\n          \n          \n            \n            class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {", "author": "vkryachko", "createdAt": "2020-07-29T19:26:11Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java", "diffHunk": "@@ -0,0 +1,181 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {", "originalCommit": "8ccca1ddd84589c39adda98065c856024e25b6b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\nsimilarity index 92%\nrename from encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java\nrename to encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\nindex f542041c..6688e495 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImp.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\n\n@@ -29,7 +29,7 @@ import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Set;\n \n-class ReflectiveDecoderFieldContextImp<T> implements ReflectiveDecoderFieldContext<T> {\n+class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n   private FieldDescriptor fieldDescriptor;\n   private ReflectiveSetter<T> setter;\n   private FieldRef<T> fieldRef;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462535975", "bodyText": "We have to preserve the cause chain to make the error more useful, I would suggest something like this in all cases below:\n} catch (IllegalAccessException | InstantiationException | InvocationTargetException e) {\n  throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n}\nnote the second parameter to the exception constructor.", "author": "vkryachko", "createdAt": "2020-07-29T19:28:44Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java", "diffHunk": "@@ -35,11 +36,11 @@\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n               + \"sure these constructors are not stripped.\");\n     } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n+      throw new EncodingException(e.toString());", "originalCommit": "8ccca1ddd84589c39adda98065c856024e25b6b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNzk3Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462537976", "bodyText": "pls also add the e argument to the catch block above.", "author": "vkryachko", "createdAt": "2020-07-29T19:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU1NjU4Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462556583", "bodyText": "Multi-catch requires API level 19.", "author": "James201311", "createdAt": "2020-07-29T20:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU3Mzg0OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r462573848", "bodyText": "No really, if you set language level to java 8, the desugarer will kick in and desugar to java 6.\ni.e.  see https://github.com/firebase/firebase-android-sdk/blob/master/firebase-common/firebase-common.gradle#L49", "author": "vkryachko", "createdAt": "2020-07-29T20:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzNTk3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "97a17d59375265e7aa131b984c5190b1a047e671", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\nindex d5573aba..52f0215a 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveInitializer.java\n\n@@ -34,13 +34,14 @@ final class ReflectiveInitializer {\n           \"Class \"\n               + classToken\n               + \" does not define a no-argument constructor. If you are using ProGuard, make \"\n-              + \"sure these constructors are not stripped.\");\n+              + \"sure these constructors are not stripped.\"\n+              + e);\n     } catch (IllegalAccessException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InstantiationException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     } catch (InvocationTargetException e) {\n-      throw new EncodingException(e.toString());\n+      throw new EncodingException(\"Could not instantiate type \" + classToken, e);\n     }\n   }\n \n"}}, {"oid": "97a17d59375265e7aa131b984c5190b1a047e671", "url": "https://github.com/firebase/firebase-android-sdk/commit/97a17d59375265e7aa131b984c5190b1a047e671", "message": "initial implementation of reflective decoder", "committedDate": "2020-07-31T19:44:56Z", "type": "forcePushed"}, {"oid": "450e41594933ffc889446112fb2e57f08c6409f2", "url": "https://github.com/firebase/firebase-android-sdk/commit/450e41594933ffc889446112fb2e57f08c6409f2", "message": "initial implementation of reflective decoder", "committedDate": "2020-07-31T20:00:35Z", "type": "commit"}, {"oid": "450e41594933ffc889446112fb2e57f08c6409f2", "url": "https://github.com/firebase/firebase-android-sdk/commit/450e41594933ffc889446112fb2e57f08c6409f2", "message": "initial implementation of reflective decoder", "committedDate": "2020-07-31T20:00:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA4NTQzNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465085435", "bodyText": "Consider just making constructors public and remove these methods", "author": "vkryachko", "createdAt": "2020-08-04T14:18:52Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java", "diffHunk": "@@ -0,0 +1,181 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n+  private FieldDescriptor fieldDescriptor;\n+  private ReflectiveSetter<T> setter;\n+  private FieldRef<T> fieldRef;\n+  private Type genericType;\n+  private Class<T> rawType;\n+  private boolean inline;\n+\n+  public static ReflectiveDecoderFieldContextImpl<?> of(Method method) {\n+    return new ReflectiveDecoderFieldContextImpl(method);\n+  }\n+\n+  public static ReflectiveDecoderFieldContextImpl<?> of(Field field) {\n+    return new ReflectiveDecoderFieldContextImpl(field);\n+  }", "originalCommit": "450e41594933ffc889446112fb2e57f08c6409f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\ndeleted file mode 100644\nindex 6688e495..00000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContextImpl.java\n+++ /dev/null\n\n@@ -1,181 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import com.google.firebase.decoders.FieldRef;\n-import com.google.firebase.encoders.EncodingException;\n-import com.google.firebase.encoders.FieldDescriptor;\n-import com.google.firebase.encoders.annotations.Encodable;\n-import com.google.firebase.encoders.annotations.ExtraProperty;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.AccessibleObject;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Type;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-class ReflectiveDecoderFieldContextImpl<T> implements ReflectiveDecoderFieldContext<T> {\n-  private FieldDescriptor fieldDescriptor;\n-  private ReflectiveSetter<T> setter;\n-  private FieldRef<T> fieldRef;\n-  private Type genericType;\n-  private Class<T> rawType;\n-  private boolean inline;\n-\n-  public static ReflectiveDecoderFieldContextImpl<?> of(Method method) {\n-    return new ReflectiveDecoderFieldContextImpl(method);\n-  }\n-\n-  public static ReflectiveDecoderFieldContextImpl<?> of(Field field) {\n-    return new ReflectiveDecoderFieldContextImpl(field);\n-  }\n-\n-  private ReflectiveDecoderFieldContextImpl(Method method) {\n-    this.fieldDescriptor = buildFieldDescriptor(method);\n-    this.genericType = method.getGenericParameterTypes()[0];\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n-    this.rawType = rawType;\n-    this.inline = inline(method);\n-    method.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            method.invoke(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          } catch (InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  private ReflectiveDecoderFieldContextImpl(Field field) {\n-    this.fieldDescriptor = buildFieldDescriptor(field);\n-    this.genericType = field.getGenericType();\n-    @SuppressWarnings(\"unchecked\")\n-    Class<T> rawType = (Class<T>) field.getType();\n-    this.rawType = rawType;\n-    this.inline = inline(field);\n-    field.setAccessible(true);\n-    this.setter =\n-        (obj, val) -> {\n-          try {\n-            field.set(obj, val);\n-          } catch (IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-          }\n-        };\n-  }\n-\n-  @Override\n-  public Class<T> getFieldRawType() {\n-    return rawType;\n-  }\n-\n-  @Override\n-  public Type getFieldGenericType() {\n-    return genericType;\n-  }\n-\n-  @Override\n-  public FieldDescriptor getFieldDescriptor() {\n-    return fieldDescriptor;\n-  }\n-\n-  @Override\n-  public ReflectiveSetter<T> getReflectiveSetter() {\n-    return setter;\n-  }\n-\n-  @Override\n-  public FieldRef<T> getFieldRef() {\n-    return fieldRef;\n-  }\n-\n-  @Override\n-  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n-    FieldRef<T> old = this.fieldRef;\n-    this.fieldRef = fieldRef;\n-    return old;\n-  }\n-\n-  @Override\n-  public boolean isInline() {\n-    return inline;\n-  }\n-\n-  private static boolean inline(AccessibleObject accessibleObject) {\n-    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-    return annotation != null && annotation.inline();\n-  }\n-\n-  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n-    Class<?> type;\n-    if (accessibleObject instanceof Field) {\n-      type = ((Field) accessibleObject).getType();\n-    } else if (accessibleObject instanceof Method) {\n-      type = ((Method) accessibleObject).getParameterTypes()[0];\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    String decodingKey = decodingKey(accessibleObject);\n-    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n-    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n-    for (Annotation annotation : annotations) {\n-      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n-      if (extraProperty != null) {\n-        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n-        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n-          builder.withProperty(annotation);\n-        } else {\n-          throw new EncodingException(\n-              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n-        }\n-      }\n-    }\n-    return builder.build();\n-  }\n-\n-  private static String decodingKey(AccessibleObject accessibleObject) {\n-    String key;\n-    if (accessibleObject instanceof Field) {\n-      key = ((Field) accessibleObject).getName();\n-    } else if (accessibleObject instanceof Method) {\n-      key = fieldName((Method) accessibleObject);\n-    } else {\n-      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n-    }\n-    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n-      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n-      if (annotation != null && annotation.name().length() > 0) {\n-        key = annotation.name();\n-      }\n-    }\n-    return key;\n-  }\n-\n-  private static String fieldName(Method method) {\n-    String methodName = method.getName();\n-    final String prefix = \"set\";\n-    if (!methodName.startsWith(prefix)) {\n-      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n-    }\n-    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NjAwNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465766006", "bodyText": "Looks like you're not using it for anything, consider removing altogether", "author": "vkryachko", "createdAt": "2020-08-05T14:24:54Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java", "diffHunk": "@@ -0,0 +1,23 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import androidx.annotation.NonNull;\n+import com.google.firebase.decoders.ObjectDecoder;\n+\n+interface ObjectDecoderProvider {", "originalCommit": "450e41594933ffc889446112fb2e57f08c6409f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5OTI1OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465799258", "bodyText": "I was trying to align with the behaviour of ReflectiveEncoder, but it turns out it's redundant. I will remove them.", "author": "James201311", "createdAt": "2020-08-05T15:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2NjAwNg=="}], "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java\ndeleted file mode 100644\nindex 32071853..00000000\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ObjectDecoderProvider.java\n+++ /dev/null\n\n@@ -1,23 +0,0 @@\n-// Copyright 2020 Google LLC\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//      http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-\n-package com.google.firebase.encoders.reflective;\n-\n-import androidx.annotation.NonNull;\n-import com.google.firebase.decoders.ObjectDecoder;\n-\n-interface ObjectDecoderProvider {\n-  @NonNull\n-  <T> ObjectDecoder<T> get(@NonNull Class<T> type);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2Njc5Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r465766792", "bodyText": "Same here, consider removing the interface and renaming the Impl class to this name.", "author": "vkryachko", "createdAt": "2020-08-05T14:25:57Z", "path": "encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java", "diffHunk": "@@ -0,0 +1,36 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.encoders.reflective;\n+\n+import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.FieldDescriptor;\n+import java.lang.reflect.Type;\n+\n+interface ReflectiveDecoderFieldContext<T> {", "originalCommit": "450e41594933ffc889446112fb2e57f08c6409f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4812230cbbf626d779bd2ae5169f38761926c224", "chunk": "diff --git a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\nindex 918291a9..4de1f3a0 100644\n--- a/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\n+++ b/encoders/firebase-encoders-reflective/src/main/java/com/google/firebase/encoders/reflective/ReflectiveDecoderFieldContext.java\n\n@@ -15,22 +15,152 @@\n package com.google.firebase.encoders.reflective;\n \n import com.google.firebase.decoders.FieldRef;\n+import com.google.firebase.encoders.EncodingException;\n import com.google.firebase.encoders.FieldDescriptor;\n+import com.google.firebase.encoders.annotations.Encodable;\n+import com.google.firebase.encoders.annotations.ExtraProperty;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n \n-interface ReflectiveDecoderFieldContext<T> {\n+class ReflectiveDecoderFieldContext<T> {\n+  private FieldDescriptor fieldDescriptor;\n+  private ReflectiveSetter<T> setter;\n+  private FieldRef<T> fieldRef;\n+  private Type genericType;\n+  private Class<T> rawType;\n+  private boolean inline;\n \n-  Class<T> getFieldRawType();\n+  ReflectiveDecoderFieldContext(Method method) {\n+    this.fieldDescriptor = buildFieldDescriptor(method);\n+    this.genericType = method.getGenericParameterTypes()[0];\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> rawType = (Class<T>) method.getParameterTypes()[0];\n+    this.rawType = rawType;\n+    this.inline = inline(method);\n+    method.setAccessible(true);\n+    this.setter =\n+        (obj, val) -> {\n+          try {\n+            method.invoke(obj, val);\n+          } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+          } catch (InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+  }\n \n-  Type getFieldGenericType();\n+  ReflectiveDecoderFieldContext(Field field) {\n+    this.fieldDescriptor = buildFieldDescriptor(field);\n+    this.genericType = field.getGenericType();\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> rawType = (Class<T>) field.getType();\n+    this.rawType = rawType;\n+    this.inline = inline(field);\n+    field.setAccessible(true);\n+    this.setter =\n+        (obj, val) -> {\n+          try {\n+            field.set(obj, val);\n+          } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+  }\n \n-  FieldDescriptor getFieldDescriptor();\n+  public Class<T> getFieldRawType() {\n+    return rawType;\n+  }\n \n-  ReflectiveSetter<T> getReflectiveSetter();\n+  public Type getFieldGenericType() {\n+    return genericType;\n+  }\n \n-  FieldRef<T> getFieldRef();\n+  public FieldDescriptor getFieldDescriptor() {\n+    return fieldDescriptor;\n+  }\n \n-  FieldRef<T> putFieldRef(FieldRef<T> fieldRef);\n+  public ReflectiveSetter<T> getReflectiveSetter() {\n+    return setter;\n+  }\n \n-  boolean isInline();\n+  public FieldRef<T> getFieldRef() {\n+    return fieldRef;\n+  }\n+\n+  public FieldRef<T> putFieldRef(FieldRef<T> fieldRef) {\n+    FieldRef<T> old = this.fieldRef;\n+    this.fieldRef = fieldRef;\n+    return old;\n+  }\n+\n+  public boolean isInline() {\n+    return inline;\n+  }\n+\n+  private static boolean inline(AccessibleObject accessibleObject) {\n+    Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n+    return annotation != null && annotation.inline();\n+  }\n+\n+  private static FieldDescriptor buildFieldDescriptor(AccessibleObject accessibleObject) {\n+    Class<?> type;\n+    if (accessibleObject instanceof Field) {\n+      type = ((Field) accessibleObject).getType();\n+    } else if (accessibleObject instanceof Method) {\n+      type = ((Method) accessibleObject).getParameterTypes()[0];\n+    } else {\n+      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n+    }\n+    String decodingKey = decodingKey(accessibleObject);\n+    Annotation[] annotations = accessibleObject.getDeclaredAnnotations();\n+    FieldDescriptor.Builder builder = FieldDescriptor.builder(decodingKey);\n+    for (Annotation annotation : annotations) {\n+      ExtraProperty extraProperty = annotation.annotationType().getAnnotation(ExtraProperty.class);\n+      if (extraProperty != null) {\n+        Set<Class<?>> allowedTypes = new HashSet<>(Arrays.asList(extraProperty.allowedTypes()));\n+        if (allowedTypes.size() == 0 || allowedTypes.contains(type)) {\n+          builder.withProperty(annotation);\n+        } else {\n+          throw new EncodingException(\n+              \"Type(\" + type + \")is not allowed by the annotation(\" + annotation + \").\");\n+        }\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  private static String decodingKey(AccessibleObject accessibleObject) {\n+    String key;\n+    if (accessibleObject instanceof Field) {\n+      key = ((Field) accessibleObject).getName();\n+    } else if (accessibleObject instanceof Method) {\n+      key = fieldName((Method) accessibleObject);\n+    } else {\n+      throw new EncodingException(\"Constructor shouldn't be used to get its decoding key\");\n+    }\n+    if (accessibleObject.isAnnotationPresent(Encodable.Field.class)) {\n+      Encodable.Field annotation = accessibleObject.getAnnotation(Encodable.Field.class);\n+      if (annotation != null && annotation.name().length() > 0) {\n+        key = annotation.name();\n+      }\n+    }\n+    return key;\n+  }\n+\n+  private static String fieldName(Method method) {\n+    String methodName = method.getName();\n+    final String prefix = \"set\";\n+    if (!methodName.startsWith(prefix)) {\n+      throw new IllegalArgumentException(\"Unknown Bean prefix for method: \" + methodName);\n+    }\n+    return Character.toLowerCase(methodName.charAt(3)) + methodName.substring(4);\n+  }\n }\n"}}, {"oid": "4812230cbbf626d779bd2ae5169f38761926c224", "url": "https://github.com/firebase/firebase-android-sdk/commit/4812230cbbf626d779bd2ae5169f38761926c224", "message": "address commnets", "committedDate": "2020-08-05T15:08:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4ODg5Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1827#discussion_r466088896", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");\n          \n          \n            \n                    throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not registered.\");", "author": "vkryachko", "createdAt": "2020-08-06T01:15:15Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java", "diffHunk": "@@ -20,15 +20,21 @@\n import com.google.firebase.decoders.DecoderConfig;\n import com.google.firebase.decoders.ObjectDecoder;\n import com.google.firebase.decoders.ValueDecoder;\n+import com.google.firebase.encoders.EncodingException;\n import java.lang.annotation.Annotation;\n import java.util.HashMap;\n import java.util.Map;\n \n public final class JsonDataDecoderBuilder implements DecoderConfig<JsonDataDecoderBuilder> {\n+  private static final ObjectDecoder<Object> DEFAULT_FALLBACK_DECODER =\n+      (ctx) -> {\n+        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");", "originalCommit": "4812230cbbf626d779bd2ae5169f38761926c224", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0926ff5722de44fa3f164ba77eeb71044642f988", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\nindex 62462fb6..2f9cbed2 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n\n@@ -28,7 +28,7 @@ import java.util.Map;\n public final class JsonDataDecoderBuilder implements DecoderConfig<JsonDataDecoderBuilder> {\n   private static final ObjectDecoder<Object> DEFAULT_FALLBACK_DECODER =\n       (ctx) -> {\n-        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not register.\");\n+        throw new EncodingException(ctx.getTypeToken().getRawType() + \" is not registered.\");\n       };\n   private final HashMap<Class<?>, ObjectDecoder<?>> objectDecoders = new HashMap<>();\n   private final HashMap<Class<?>, ValueDecoder<?>> valueDecoders = new HashMap<>();\n"}}, {"oid": "0926ff5722de44fa3f164ba77eeb71044642f988", "url": "https://github.com/firebase/firebase-android-sdk/commit/0926ff5722de44fa3f164ba77eeb71044642f988", "message": "Update encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilder.java\n\nCo-authored-by: Vladimir Kryachko <vkryachko@google.com>", "committedDate": "2020-08-06T14:17:15Z", "type": "commit"}]}