{"pr_number": 1717, "pr_title": "Support Collections decoding", "pr_createdAt": "2020-06-25T15:41:55Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1717", "timeline": [{"oid": "bf319e79666d956e96787bc81ebd5e5eea223428", "url": "https://github.com/firebase/firebase-android-sdk/commit/bf319e79666d956e96787bc81ebd5e5eea223428", "message": "support map decoding", "committedDate": "2020-06-25T15:40:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzY4OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r445657689", "bodyText": "Are there better ways to deal with Exceptions?\nor avoid using reflect?", "author": "James201311", "createdAt": "2020-06-25T15:46:30Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +148,83 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return List.class.isAssignableFrom(clazz)\n+        || Map.class.isAssignableFrom(clazz)\n+        || Set.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else if (List.class.isAssignableFrom(clazz)) {\n+      // TODO: support List\n+    } else if (Set.class.isAssignableFrom(clazz)) {\n+      // TODO: support List\n+    }\n+    return null;\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = null;\n+    try {\n+      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }", "originalCommit": "bf319e79666d956e96787bc81ebd5e5eea223428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNTM1MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447025350", "bodyText": "We don't want to use reflection, I would say let's start with supporting HashMap and LinkedHashMap and add support for any others later if we have to.\nIn general users should be encouraged to have fields of interface type Map not concrete implementations, so I think supporting Map, HashMap and LinkedHashMap should be good enough.", "author": "vkryachko", "createdAt": "2020-06-29T14:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex 74a91690..45fa49cf 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -150,9 +150,7 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n \n   private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    return List.class.isAssignableFrom(clazz)\n-        || Map.class.isAssignableFrom(clazz)\n-        || Set.class.isAssignableFrom(clazz);\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n   }\n \n   private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n"}}, {"oid": "9e970b341c89ba6096e2c9bb39e8114e59ba7fc1", "url": "https://github.com/firebase/firebase-android-sdk/commit/9e970b341c89ba6096e2c9bb39e8114e59ba7fc1", "message": "Merge branch 'firebase_encoders' into yizhaoh.map_decode", "committedDate": "2020-06-25T18:53:33Z", "type": "commit"}, {"oid": "158c95f240e5ca933cfbbc0be986f75b370a5995", "url": "https://github.com/firebase/firebase-android-sdk/commit/158c95f240e5ca933cfbbc0be986f75b370a5995", "message": "put map decoding into a seperate test file", "committedDate": "2020-06-25T19:05:15Z", "type": "commit"}, {"oid": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "url": "https://github.com/firebase/firebase-android-sdk/commit/e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "message": "decode collection", "committedDate": "2020-06-26T13:40:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzA0Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r446193046", "bodyText": "same as above", "author": "James201311", "createdAt": "2020-06-26T13:44:46Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +148,101 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = null;\n+    try {\n+      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }\n+\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = null;\n+    try {\n+      collection = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }", "originalCommit": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTMwNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r446441305", "bodyText": "?", "author": "rlazo", "createdAt": "2020-06-26T22:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzA0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a83522134cc3908e71c6564dbfa0e572f942da33", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex 45fa49cf..b86a5f33 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -173,17 +185,7 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n     if (!isSingleValue(keyTypeToken))\n       throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n \n-    T map = null;\n-    try {\n-      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n-    } catch (Exception e) {\n-      throw new IllegalArgumentException(\n-          classToken.getRawType()\n-              + \" cannot be initialized.\\n\"\n-              + \"Do not pass abstract class and an interface.\\n\"\n-              + e);\n-    }\n-\n+    T map = newInstance(classToken);\n     reader.beginObject();\n     while (reader.hasNext()) {\n       String keyLiteral = reader.nextName();\n"}}, {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33", "url": "https://github.com/firebase/firebase-android-sdk/commit/a83522134cc3908e71c6564dbfa0e572f942da33", "message": "remove reflect, implement newInstance method to create supported type", "committedDate": "2020-06-29T18:08:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NDY5Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447844697", "bodyText": "Consider throwing EncodingException instead as this is the exception we advertise can be thrown.", "author": "vkryachko", "createdAt": "2020-06-30T17:07:33Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {\n+      return (T) new ArrayDeque<>();\n+    } else if (clazz.equals(PriorityQueue.class)) {\n+      return (T) new PriorityQueue<>();\n+    } else if (clazz.equals(HashSet.class) || clazz.equals(Set.class)) {\n+      return (T) new HashSet<>();\n+    } else if (clazz.equals(LinkedHashSet.class)) {\n+      return (T) new LinkedHashSet<>();\n+    } else if (clazz.equals(TreeSet.class) || clazz.equals(SortedSet.class)) {\n+      return (T) new TreeSet<>();\n+    }\n+    throw new IllegalArgumentException(classToken + \" not supported.\");", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex b86a5f33..74c89b7a 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -160,22 +166,14 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n     return null;\n   }\n \n-  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+  private <T> boolean isMap(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+    return Map.class.isAssignableFrom(clazz);\n   }\n \n-  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+  private <T> boolean isCollection(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    if (Map.class.isAssignableFrom(clazz)) {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n-      return t;\n-    } else {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n-      return t;\n-    }\n+    return Collection.class.isAssignableFrom(clazz);\n   }\n \n   private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447846233", "bodyText": "Not sure how useful these are in the context of DTOs so we may want to remove them not to encourage folks to model queues with their json payloads, but I don't feel strongly.\nSame for priority queue below.", "author": "vkryachko", "createdAt": "2020-06-30T17:09:59Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4MDAyMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447880022", "bodyText": "Not sure if I understand correctly, the reason discouraging people from using queues is that the order of the decoded Json is not preserved?\nBut we should also support that if a client of Firestore doesn't want to have a dedicated network model(DTOs), but he wants to store the ordered results(get from orderby('x')) into a queue without mapping them.", "author": "James201311", "createdAt": "2020-06-30T18:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDQ5NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624495", "bodyText": "makes sense", "author": "vkryachko", "createdAt": "2020-07-03T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw=="}], "type": "inlineReview", "revised_code": {"commit": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex b86a5f33..74c89b7a 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -160,22 +166,14 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n     return null;\n   }\n \n-  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+  private <T> boolean isMap(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+    return Map.class.isAssignableFrom(clazz);\n   }\n \n-  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+  private <T> boolean isCollection(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    if (Map.class.isAssignableFrom(clazz)) {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n-      return t;\n-    } else {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n-      return t;\n-    }\n+    return Collection.class.isAssignableFrom(clazz);\n   }\n \n   private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMzc4MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449623781", "bodyText": "Looks like these 2 methods do more than one thing, consider splitting their functionality in to map and collection specific stuff, context: https://en.wikipedia.org/wiki/Single-responsibility_principle", "author": "vkryachko", "createdAt": "2020-07-03T15:00:08Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -67,6 +80,8 @@\n       return decodePrimitive(classToken);\n     } else if (isSingleValue(classToken)) {\n       return decodeSingleValue(classToken);\n+    } else if (isPreDefinedObject(classToken)) {\n+      return decodePreDefinedObject(classToken);", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex b86a5f33..74c89b7a 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -80,8 +80,14 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n       return decodePrimitive(classToken);\n     } else if (isSingleValue(classToken)) {\n       return decodeSingleValue(classToken);\n-    } else if (isPreDefinedObject(classToken)) {\n-      return decodePreDefinedObject(classToken);\n+    } else if (isMap(classToken)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T map = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return map;\n+    } else if (isCollection(classToken)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T collection = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return collection;\n     } else {\n       return decodeObject(classToken);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDE1OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624159", "bodyText": "Same here, I would suggest you have 2 methods newMap, newCollection", "author": "vkryachko", "createdAt": "2020-07-03T15:00:58Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex b86a5f33..74c89b7a 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -160,22 +166,14 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n     return null;\n   }\n \n-  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+  private <T> boolean isMap(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+    return Map.class.isAssignableFrom(clazz);\n   }\n \n-  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+  private <T> boolean isCollection(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    if (Map.class.isAssignableFrom(clazz)) {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n-      return t;\n-    } else {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n-      return t;\n-    }\n+    return Collection.class.isAssignableFrom(clazz);\n   }\n \n   private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDY4Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624687", "bodyText": "EncodingException", "author": "vkryachko", "createdAt": "2020-07-03T15:02:16Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {\n+      return (T) new ArrayDeque<>();\n+    } else if (clazz.equals(PriorityQueue.class)) {\n+      return (T) new PriorityQueue<>();\n+    } else if (clazz.equals(HashSet.class) || clazz.equals(Set.class)) {\n+      return (T) new HashSet<>();\n+    } else if (clazz.equals(LinkedHashSet.class)) {\n+      return (T) new LinkedHashSet<>();\n+    } else if (clazz.equals(TreeSet.class) || clazz.equals(SortedSet.class)) {\n+      return (T) new TreeSet<>();\n+    }\n+    throw new IllegalArgumentException(classToken + \" not supported.\");\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <K> K getActualKey(String keyLiteral, Class<K> clazz) {\n+    if (clazz.equals(Integer.class)) {\n+      return (K) (Integer) Integer.parseInt(keyLiteral);\n+    } else if (clazz.equals(Double.class)) {\n+      return (K) (Double) Double.parseDouble(keyLiteral);\n+    } else if (clazz.equals(Float.class)) {\n+      return (K) (Float) Float.parseFloat(keyLiteral);\n+    } else if (clazz.equals(Short.class)) {\n+      return (K) (Short) Short.parseShort(keyLiteral);\n+    } else if (clazz.equals(Long.class)) {\n+      return (K) (Long) Long.parseLong(keyLiteral);\n+    } else if (clazz.equals(Character.class)) {\n+      return (K) (Character) keyLiteral.charAt(0);\n+    } else if (clazz.equals(Byte.class)) {\n+      return (K) (Byte) Byte.parseByte(keyLiteral);\n+    } else if (clazz.equals(String.class)) {\n+      return (K) keyLiteral;\n+    } else {\n+      throw new IllegalArgumentException(\"Excepted Single Value Type. \" + clazz + \" was found.\");", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "chunk": "diff --git a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\nindex b86a5f33..74c89b7a 100644\n--- a/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n+++ b/encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java\n\n@@ -160,22 +166,14 @@ public class JsonDataDecoderBuilderContext implements DataDecoder {\n     return null;\n   }\n \n-  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+  private <T> boolean isMap(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+    return Map.class.isAssignableFrom(clazz);\n   }\n \n-  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+  private <T> boolean isCollection(TypeToken.ClassToken<T> classToken) {\n     Class<T> clazz = classToken.getRawType();\n-    if (Map.class.isAssignableFrom(clazz)) {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n-      return t;\n-    } else {\n-      @SuppressWarnings(\"unchecked\")\n-      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n-      return t;\n-    }\n+    return Collection.class.isAssignableFrom(clazz);\n   }\n \n   private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n"}}, {"oid": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "url": "https://github.com/firebase/firebase-android-sdk/commit/951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "message": "address comment", "committedDate": "2020-07-06T14:15:03Z", "type": "commit"}, {"oid": "91d72db9b35a68e12a9b54c71ce38b53d26edc7e", "url": "https://github.com/firebase/firebase-android-sdk/commit/91d72db9b35a68e12a9b54c71ce38b53d26edc7e", "message": "address comments", "committedDate": "2020-07-23T14:47:13Z", "type": "commit"}]}