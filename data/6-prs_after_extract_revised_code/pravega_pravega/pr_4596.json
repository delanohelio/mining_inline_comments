{"pr_number": 4596, "pr_title": "Issue 4590: (SegmentStore) Fixed Read Index concurrent Tier 2 read bug (Part 2)", "pr_createdAt": "2020-03-06T23:55:38Z", "pr_url": "https://github.com/pravega/pravega/pull/4596", "timeline": [{"oid": "8e6ebc8d8997c3c6d673c2ed54a43d77a93582fb", "url": "https://github.com/pravega/pravega/commit/8e6ebc8d8997c3c6d673c2ed54a43d77a93582fb", "message": "Fixed a storage read concurrency bug.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-06T23:48:50Z", "type": "commit"}, {"oid": "a6d37630d0b3e744a2386f2a96494edb87a14ebf", "url": "https://github.com/pravega/pravega/commit/a6d37630d0b3e744a2386f2a96494edb87a14ebf", "message": "Reverted unintentional change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-07T03:16:45Z", "type": "commit"}, {"oid": "b4fd14a6e54143ae76e2edaf80f021d59df62fb7", "url": "https://github.com/pravega/pravega/commit/b4fd14a6e54143ae76e2edaf80f021d59df62fb7", "message": "Reverted unintentional change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-07T03:18:51Z", "type": "commit"}, {"oid": "725a98cf63ac8a36bebff33bc9ec6d8c46a4a464", "url": "https://github.com/pravega/pravega/commit/725a98cf63ac8a36bebff33bc9ec6d8c46a4a464", "message": "Code coverage\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-09T16:50:33Z", "type": "commit"}, {"oid": "79d39db7c0dc8c28c1380c51a5f8363c3aca4b45", "url": "https://github.com/pravega/pravega/commit/79d39db7c0dc8c28c1380c51a5f8363c3aca4b45", "message": "Code coverage\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-09T16:58:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTI4Ng==", "url": "https://github.com/pravega/pravega/pull/4596#discussion_r389919286", "bodyText": "Is this line reachable? (in practice)", "author": "tkaitchuck", "createdAt": "2020-03-09T19:42:49Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/reading/StreamSegmentReadIndex.java", "diffHunk": "@@ -577,41 +586,67 @@ private CacheIndexEntry addSingleEntryToCacheAndIndex(BufferView data, long offs\n             throw ex;\n         }\n \n-        if (rejectedEntry != null) {\n-            deleteData(rejectedEntry);\n-            if (rejectedEntry != newEntry) {\n-                log.warn(\"{}: {} overrode existing entry (Offset = {}, OldLength = {}, NewLength = {}).\",\n-                        this.traceObjectId, operationName, newEntry.getStreamSegmentOffset(), rejectedEntry.getLength(), newEntry.getLength());\n-            }\n-        }\n         return newEntry;\n     }\n \n     /**\n-     * Attempts to add the given {@link ReadIndexEntry} to the index. No cache operations are performed.\n+     * Inserts data in the index.\n      *\n-     * @param entry The {@link ReadIndexEntry} to add.\n-     * @return A rejected {@link ReadIndexEntry}. If the given entry has overridden another that already existed in the\n-     * index, the overridden one will be returned. If the given entry could not be added to the index due to another,\n-     * more up-to-date one existing already, the given entry will be returned as rejected (and no modifications will\n-     * be made to the index). A null value will be returned if there was no conflict.\n+     * @param data          A {@link BufferView} representing the data to insert.\n+     * @param segmentOffset The segment offset that maps to the first byte in the given {@link BufferView}.\n+     * @return A {@link CacheIndexEntry} representing the index entry added. If the given {@link BufferView} spanned\n+     * multiple entries (due to index fragmentation), only the last {@link CacheIndexEntry} is added.\n      */\n+    private CacheIndexEntry insertEntriesToCacheAndIndex(BufferView data, long segmentOffset) {\n+        CacheIndexEntry lastInsertedEntry = null;\n+        synchronized (this.lock) {\n+            while (data != null && data.getLength() > 0) {\n+                // Figure out if the first byte in the buffer is already cached.\n+                ReadIndexEntry existingEntry = this.indexEntries.getFloor(segmentOffset);\n+                long overlapLength;\n+                if (existingEntry != null && existingEntry.getLastStreamSegmentOffset() >= segmentOffset) {\n+                    // First offset exists already. We need to skip over to the end of this entry.\n+                    overlapLength = existingEntry.getStreamSegmentOffset() + existingEntry.getLength() - segmentOffset;\n+                    segmentOffset += overlapLength;\n+                } else {\n+                    // First offset does not exist. Let's find out how much we can insert.\n+                    existingEntry = this.indexEntries.getCeiling(segmentOffset);\n+                    overlapLength = existingEntry == null ? data.getLength() : existingEntry.getStreamSegmentOffset() - segmentOffset;\n+                    assert overlapLength > 0 : \"indexEntries.getFloor(offset) == null != indexEntries.getCeiling(offset)\";\n+\n+                    // Slice the data that we need to insert. We may be able to insert the whole buffer at once.\n+                    BufferView dataToInsert = overlapLength >= data.getLength() ? data : data.slice(0, (int) overlapLength);\n+                    CacheIndexEntry newEntry;\n+                    int dataAddress = this.cacheStorage.insert(dataToInsert);\n+                    try {\n+                        newEntry = new CacheIndexEntry(segmentOffset, dataToInsert.getLength(), dataAddress);\n+                        ReadIndexEntry overriddenEntry = addToIndex(newEntry);\n+                        assert overriddenEntry == null : \"Insert overrode existing entry; \" + segmentOffset + \":\" + dataToInsert.getLength();\n+                        lastInsertedEntry = newEntry;\n+                    } catch (Throwable ex) {\n+                        // Clean up the data we inserted if we were unable to add it to the index.\n+                        this.cacheStorage.delete(dataAddress);", "originalCommit": "79d39db7c0dc8c28c1380c51a5f8363c3aca4b45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNzcxMg==", "url": "https://github.com/pravega/pravega/pull/4596#discussion_r389927712", "bodyText": "No. Not really. If we end up here then some exception got thrown from addToIndex and we must make sure we delete the data from the cache otherwise it will stay there forever. The only exception thrown from there is an ObjectClosedException, which indicates the whole index is about to close (or has just been) so we must clean up anyway.", "author": "andreipaduroiu", "createdAt": "2020-03-09T19:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "69b3e49b5e1b7be367958b2c006d5ea1f55c6e6b", "chunk": "diff --git a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/reading/StreamSegmentReadIndex.java b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/reading/StreamSegmentReadIndex.java\nindex 760e30d48..84bd04d9f 100644\n--- a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/reading/StreamSegmentReadIndex.java\n+++ b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/reading/StreamSegmentReadIndex.java\n\n@@ -617,18 +617,18 @@ class StreamSegmentReadIndex implements CacheManager.Client, AutoCloseable {\n                     // Slice the data that we need to insert. We may be able to insert the whole buffer at once.\n                     BufferView dataToInsert = overlapLength >= data.getLength() ? data : data.slice(0, (int) overlapLength);\n                     CacheIndexEntry newEntry;\n-                    int dataAddress = this.cacheStorage.insert(dataToInsert);\n+                    int dataAddress = CacheStorage.NO_ADDRESS; // Null address pointer.\n                     try {\n+                        dataAddress = this.cacheStorage.insert(dataToInsert);\n                         newEntry = new CacheIndexEntry(segmentOffset, dataToInsert.getLength(), dataAddress);\n                         ReadIndexEntry overriddenEntry = addToIndex(newEntry);\n                         assert overriddenEntry == null : \"Insert overrode existing entry; \" + segmentOffset + \":\" + dataToInsert.getLength();\n                         lastInsertedEntry = newEntry;\n                     } catch (Throwable ex) {\n-                        // Clean up the data we inserted if we were unable to add it to the index.\n+                        // Clean up the data we might have inserted if we were unable to add it to the index.\n                         this.cacheStorage.delete(dataAddress);\n                         throw ex;\n                     }\n-\n                 }\n \n                 // Slice the remainder of the buffer, or set it to null if we processed everything.\n"}}, {"oid": "69b3e49b5e1b7be367958b2c006d5ea1f55c6e6b", "url": "https://github.com/pravega/pravega/commit/69b3e49b5e1b7be367958b2c006d5ea1f55c6e6b", "message": "Logging uncaught errors from insert callbacks.\nAdded a unit test to verify cache insert failure handling.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-09T20:52:53Z", "type": "commit"}]}