{"pr_number": 5355, "pr_title": "Issue 5345: (SegmentStore) Rewiring StorageWriter into DurableLog", "pr_createdAt": "2020-11-18T16:48:51Z", "pr_url": "https://github.com/pravega/pravega/pull/5355", "timeline": [{"oid": "bb9e7949ae9590611d04c7f9d6008b77ccf442a5", "url": "https://github.com/pravega/pravega/commit/bb9e7949ae9590611d04c7f9d6008b77ccf442a5", "message": "Retired SequencedItemList.\nAbstractDrainingQueue.take overload with timeout.\nChanged OperationLog.read to return a Collection of unread items.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-18T01:33:16Z", "type": "commit"}, {"oid": "664416436d87731a30f1f503bf2b02597c2affaf", "url": "https://github.com/pravega/pravega/commit/664416436d87731a30f1f503bf2b02597c2affaf", "message": "Unit tests for AbstractDrainingQueue and InMemoryLog.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-18T02:01:06Z", "type": "commit"}, {"oid": "31cfe440d15d0b510974c8588a50cef91415fae2", "url": "https://github.com/pravega/pravega/commit/31cfe440d15d0b510974c8588a50cef91415fae2", "message": "Updated DurableLogTests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-18T16:23:47Z", "type": "commit"}, {"oid": "1890c79b584112f62b0193b3b0ff4b7352b4099e", "url": "https://github.com/pravega/pravega/commit/1890c79b584112f62b0193b3b0ff4b7352b4099e", "message": "Merge remote-tracking branch 'origin/master' into issue-5345-storage-writer-data-source", "committedDate": "2020-11-18T16:47:10Z", "type": "commit"}, {"oid": "1a44d1227227358a90aa7c0a58d6c18e33496e51", "url": "https://github.com/pravega/pravega/commit/1a44d1227227358a90aa7c0a58d6c18e33496e51", "message": "Using SimpleDeque instead of ArrayDeque in BlockingDrainingQueue and PriorityBlockingDrainingQueue\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-18T22:31:55Z", "type": "commit"}, {"oid": "fc9e798f66ef6ae2a2bf44b1a367efb0b49960ff", "url": "https://github.com/pravega/pravega/commit/fc9e798f66ef6ae2a2bf44b1a367efb0b49960ff", "message": "Merge remote-tracking branch 'origin/master' into issue-5345-storage-writer-data-source\n\n# Conflicts:\n#\tsegmentstore/server/src/main/java/io/pravega/segmentstore/server/SegmentStoreMetrics.java", "committedDate": "2020-11-19T15:24:33Z", "type": "commit"}, {"oid": "a6a04b1b39e9eb32712b280512f67143de2b221a", "url": "https://github.com/pravega/pravega/commit/a6a04b1b39e9eb32712b280512f67143de2b221a", "message": "Merge conflicts and unit test fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-19T15:32:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzI4OA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527077288", "bodyText": "Why 16 has been chosen as the initialization value?", "author": "RaulGracia", "createdAt": "2020-11-19T17:42:06Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI2OTE5Mw==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527269193", "bodyText": "This class is very similar to Java's ArrayDeque. That class also chooses 16 as a default init value.\nFor our purposes (BlockingDrainingQueue) this initial value makes little difference. We only create the queue once and then hang on to it. So it will eventually grow to a \"steady-state\" length and then reuse the same element array.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3NzI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMjc5OA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527222798", "bodyText": "This code is assuming that this: https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#setRemoveOnCancelPolicy-boolean-\nis set to true on the thread pool. confirm is the case and maybe document this.", "author": "tkaitchuck", "createdAt": "2020-11-19T21:45:39Z", "path": "common/src/main/java/io/pravega/common/util/AbstractDrainingQueue.java", "diffHunk": "@@ -147,6 +152,41 @@ public void add(T item) {\n         }\n     }\n \n+    /**\n+     * Returns the next items from the queue. If the queue is empty, it blocks the call until at least one item is added,\n+     * or until the given timeout expires.\n+     *\n+     * @param maxCount        The maximum number of items to return. This argument will be ignored if the queue is currently\n+     *                        empty, but in that case the result will always be completed with exactly one element.\n+     * @param timeout         Timeout.\n+     * @param timeoutExecutor An Executor to use for timing out.\n+     * @return A CompletableFuture that, when completed, will contain the requested result. If the queue is not currently\n+     * empty, this Future will already be completed, otherwise it will be completed the next time the add() method is called.\n+     * If the queue is closed and this Future is not yet completed, it will be cancelled. If the timeout expires prior\n+     * to adding a new element, this future will be completed with a {@link TimeoutException}.\n+     * @throws ObjectClosedException If the Queue is closed.\n+     * @throws IllegalStateException If another call to take() is in progress.\n+     */\n+    public CompletableFuture<Queue<T>> take(int maxCount, Duration timeout, ScheduledExecutorService timeoutExecutor) {\n+        CompletableFuture<Queue<T>> result = take(maxCount);\n+        if (!result.isDone()) {\n+            ScheduledFuture<?> sf = timeoutExecutor.schedule(() -> {\n+                synchronized (this.lock) {\n+                    if (this.pendingTake == result) {\n+                        this.pendingTake = null;\n+                    }\n+                }\n+\n+                // Timeout the future after we have unregistered it. A zealous callback may invoke us immediately and be\n+                // surprised that their call is rejected since we can only have one take() outstanding at any given time.\n+                result.completeExceptionally(new TimeoutException());\n+            }, timeout.toMillis(), TimeUnit.MILLISECONDS);\n+            result.whenComplete((r, ex) -> sf.cancel(true));", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI2OTcyNw==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527269727", "bodyText": "Yes, I am aware of that. All of our executors have that flag set (see ExecutorServiceHelpers.java) precisely for this reason.\nFYI, this code is borrowed from Futures.futureWithTimeout. I didn't want to reuse that method since I wanted the leanest possible implementation which was tied into the take() future above.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMjc5OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzMTExNw==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527231117", "bodyText": "The correctness of this function and several others are predicated on the fact that there is always at least one empty position in the array. This appears to be enforced but it probably worth explicitly stating in a comment somewhere.", "author": "tkaitchuck", "createdAt": "2020-11-19T22:01:11Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3MjA3OA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527272078", "bodyText": "I updated the class Javadoc with implementation details.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzMTExNw=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTU0NQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527235545", "bodyText": "Based on the above definition of addLast I don't believe this.tail == this.head && newItems[this.head] != null can ever be true.", "author": "tkaitchuck", "createdAt": "2020-11-19T22:09:38Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3NDQwOA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527274408", "bodyText": "Yes you are correct. I looked too much at the ArrayDeque.java class", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTU0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzAyMQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527237021", "bodyText": "Can't a fill do this? (Or it could be avoided per my above comment)", "author": "tkaitchuck", "createdAt": "2020-11-19T22:12:38Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3NDkwNQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527274905", "bodyText": "Arrays.fill. does exactly the same thing. But since I used it everywhere else in this class, I might as well do it here too.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzAyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzODU3NQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527238575", "bodyText": "Looking at the implementation of this method, it would be more efficient to just allocate a new array, then copy the part after head and then copy the part up until tail if it was wrapped.", "author": "tkaitchuck", "createdAt": "2020-11-19T22:14:49Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3NzYyOQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527277629", "bodyText": "Good idea.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzODU3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTg5Ng==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527241896", "bodyText": "Per the documentation here:\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Queue.html\nElement is a variation on peek not on poll.", "author": "tkaitchuck", "createdAt": "2020-11-19T22:19:00Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {\n+                newItems[idx] = null;\n+                idx++;\n+            }\n+        }\n+\n+        this.items = newItems;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Size = %s, Capacity = %s, Head = %s, Tail = %s\", size(), this.items.length, this.head, this.tail);\n+    }\n+\n+    //endregion\n+\n+    //region WrapQueue\n+\n+    @RequiredArgsConstructor\n+    @NotThreadSafe\n+    private static class WrapQueue<T> extends AbstractCollection<T> implements Queue<T> {\n+        private final Object[] items;\n+        private int nextIndex = 0;\n+\n+        //region Queue Implementation\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public T poll() {\n+            if (this.nextIndex >= this.items.length) {\n+                return null;\n+            }\n+\n+            return (T) this.items[this.nextIndex++];\n+        }\n+\n+        @Override\n+        public T element() {", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3ODU0MA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527278540", "bodyText": "Fixed", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjUxMQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527242511", "bodyText": "Here remove is unimplemented but the function element above is doing what remove is supposed to be doing.", "author": "tkaitchuck", "createdAt": "2020-11-19T22:20:14Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {\n+                newItems[idx] = null;\n+                idx++;\n+            }\n+        }\n+\n+        this.items = newItems;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Size = %s, Capacity = %s, Head = %s, Tail = %s\", size(), this.items.length, this.head, this.tail);\n+    }\n+\n+    //endregion\n+\n+    //region WrapQueue\n+\n+    @RequiredArgsConstructor\n+    @NotThreadSafe\n+    private static class WrapQueue<T> extends AbstractCollection<T> implements Queue<T> {\n+        private final Object[] items;\n+        private int nextIndex = 0;\n+\n+        //region Queue Implementation\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public T poll() {\n+            if (this.nextIndex >= this.items.length) {\n+                return null;\n+            }\n+\n+            return (T) this.items[this.nextIndex++];\n+        }\n+\n+        @Override\n+        public T element() {\n+            T result = poll();\n+            if (result == null) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            return result;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public T peek() {\n+            return this.nextIndex >= this.items.length ? null : (T) this.items[nextIndex];\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Iterator<T> iterator() {\n+            return Arrays.stream(this.items).skip(this.nextIndex).map(o -> (T) o).iterator();\n+        }\n+\n+        @Override\n+        public int size() {\n+            return this.items.length - this.nextIndex;\n+        }\n+\n+        //endregion\n+\n+        //region Unsupported Methods\n+\n+        @Override\n+        public boolean offer(T t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public T remove() {", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3OTUxNg==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527279516", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjUxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjkzMw==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527242933", "bodyText": "Javadoc", "author": "tkaitchuck", "createdAt": "2020-11-19T22:21:04Z", "path": "common/src/main/java/io/pravega/common/util/SimpleDeque.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Simplified {@link java.util.Deque} implementation that provides an efficient method to remove multiple items at once\n+ * from the head.\n+ *\n+ * Note that this class does not implement {@link java.util.Deque} and as such not all methods in that interface are\n+ * present here. The only reason it exists is because there is no way in {@link java.util.ArrayDeque} to efficiently\n+ * remove multiple items at once (see {@link #pollFirst(int)}.\n+ *\n+ * @param <T> Type of item in the {@link SimpleDeque}.\n+ */\n+@NotThreadSafe\n+public class SimpleDeque<T> {\n+    //region Members\n+\n+    private static final int MAX_CAPACITY = Integer.MAX_VALUE - Long.BYTES;\n+    private static final int MAX_HALF = MAX_CAPACITY / 2;\n+    private Object[] items;\n+    private int head;\n+    private int tail;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     */\n+    public SimpleDeque() {\n+        this(16);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link SimpleDeque} class.\n+     *\n+     * @param initialCapacity The initial capacity.\n+     */\n+    public SimpleDeque(int initialCapacity) {\n+        Preconditions.checkArgument(initialCapacity >= 0, \"initialCapacity must be a non-negative number.\");\n+        this.items = new Object[initialCapacity + 1];\n+    }\n+\n+    //endregion\n+\n+    //region Operations\n+\n+    /**\n+     * Adds a new item at the tail of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#addLast}.\n+     *\n+     * @param item The item to add. Must be non-null (since we use null internally as a sentinel)\n+     */\n+    public void addLast(@NonNull T item) {\n+        this.items[this.tail] = item;\n+        this.tail = increment(this.tail);\n+        if (this.head == this.tail) {\n+            // Head == Tail means we are now full. Need to expand.\n+            expand();\n+        }\n+    }\n+\n+    /**\n+     * Removes one item from the head of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#pollFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null of empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T pollFirst() {\n+        T e = (T) this.items[this.head];\n+        if (e != null) {\n+            this.items[this.head] = null;\n+            this.head = increment(this.head);\n+        }\n+\n+        return e;\n+    }\n+\n+    /**\n+     * Removes one or more items from the head of the {@link SimpleDeque}.\n+     *\n+     * This method is equivalent to:\n+     * <pre><code>\n+     *     SimpleDeque source;\n+     *     Queue target;\n+     *     int count = maxCount;\n+     *     while(count > 0 && !source.isEmpty()) {\n+     *         target.add(source.removeFirst());\n+     *         count--;\n+     *     }\n+     * </code></pre>\n+     *\n+     * This method is optimized for a bulk copy and is preferred to using the code exemplified above.\n+     *\n+     * @param maxCount The maximum number of items to remove. If this number is larger than {@link #size()}, then\n+     *                 {@link #size()} items will be removed.\n+     * @return A {@link Queue} containing the removed items, in the same order as they were in the {@link SimpleDeque}.\n+     */\n+    public Queue<T> pollFirst(int maxCount) {\n+        int count = Math.min(maxCount, size());\n+        final Object[] result = new Object[count];\n+        if (count == 0) {\n+            return new WrapQueue<>(result);\n+        }\n+\n+        int copyLength = Math.min(this.items.length - this.head, count);\n+        System.arraycopy(this.items, this.head, result, 0, copyLength);\n+        Arrays.fill(this.items, this.head, this.head + copyLength, null);\n+        this.head = this.head + copyLength;\n+        if (this.head == this.items.length) {\n+            this.head = 0;\n+        }\n+\n+        count -= copyLength;\n+        if (count > 0) {\n+            System.arraycopy(this.items, 0, result, copyLength, count);\n+            Arrays.fill(this.items, 0, count, null);\n+            this.head += count; // count is less than size(), so this can't wrap around no matter what.\n+        }\n+\n+        return new WrapQueue<>(result);\n+    }\n+\n+    /**\n+     * Returns (but does not remove) the item at the head of the {@link SimpleDeque}.\n+     * This method does not alter the internal state of the {@link SimpleDeque}.\n+     * See {@link java.util.Deque#peekFirst()}.\n+     *\n+     * @return The item at the head of the {@link SimpleDeque}, or null if empty.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T peekFirst() {\n+        return (T) this.items[this.head];\n+    }\n+\n+    /**\n+     * Gets a value indicating the number of items in the {@link SimpleDeque}.\n+     *\n+     * @return The size of the {@link SimpleDeque}.\n+     */\n+    public int size() {\n+        final int size = this.tail - this.head;\n+        return size < 0 ? size + this.items.length : size;\n+    }\n+\n+    /**\n+     * Gets a value indicating whether the {@link SimpleDeque} is empty or not.\n+     * Consider using this instead of {@code {@link #size()} == 0} since this method does not need to compute anything.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.head == this.tail;\n+    }\n+\n+    /**\n+     * Clears the entire {@link SimpleDeque}.\n+     */\n+    public void clear() {\n+        Arrays.fill(this.items, null);\n+        this.head = 0;\n+        this.tail = 0;\n+    }\n+\n+    private int increment(int index) {\n+        index++;\n+        return index == this.items.length ? 0 : index;\n+    }\n+\n+    private void expand() {\n+        int newCapacity = this.items.length;\n+        if (this.items.length >= MAX_CAPACITY) {\n+            // Can't allocate an array bigger than this.\n+            throw new OutOfMemoryError(\"Unable to grow SimpleDequeue.\");\n+        }\n+\n+        if (newCapacity >= MAX_HALF) {\n+            // We double capacity, so if we're already above half of max, then just set it to max.\n+            newCapacity = MAX_CAPACITY;\n+        } else {\n+            // Double capacity.\n+            newCapacity = newCapacity * 2;\n+        }\n+\n+        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n+        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n+        if (flipped) {\n+            final int diff = newCapacity - this.items.length;\n+            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n+            int idx = this.head;\n+            this.head += diff;\n+            while (idx < this.head) {\n+                newItems[idx] = null;\n+                idx++;\n+            }\n+        }\n+\n+        this.items = newItems;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Size = %s, Capacity = %s, Head = %s, Tail = %s\", size(), this.items.length, this.head, this.tail);\n+    }\n+\n+    //endregion\n+\n+    //region WrapQueue\n+\n+    @RequiredArgsConstructor\n+    @NotThreadSafe\n+    private static class WrapQueue<T> extends AbstractCollection<T> implements Queue<T> {", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI3OTkyNA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527279924", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjkzMw=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/SimpleDeque.java b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\nindex fb2a8488b0..e060f7d3c8 100644\n--- a/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n+++ b/common/src/main/java/io/pravega/common/util/SimpleDeque.java\n\n@@ -203,20 +203,23 @@ public class SimpleDeque<T> {\n             newCapacity = newCapacity * 2;\n         }\n \n-        final Object[] newItems = Arrays.copyOf(this.items, newCapacity);\n-        boolean flipped = this.tail < this.head || (this.tail == this.head && newItems[this.head] != null);\n-        if (flipped) {\n-            final int diff = newCapacity - this.items.length;\n-            System.arraycopy(newItems, this.head, newItems, this.head + diff, this.items.length - this.head);\n-            int idx = this.head;\n-            this.head += diff;\n-            while (idx < this.head) {\n-                newItems[idx] = null;\n-                idx++;\n-            }\n+        final Object[] newItems = new Object[newCapacity];\n+        if (this.head < this.tail) {\n+            // The items do not wrap around the end. We can do everything with a single copy.\n+            final int size = this.tail - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, size);\n+            this.tail = size;\n+        } else {\n+            // The items wrap around the end. First copy from the head to the end, then from the beginning to the tail.\n+            final int copyLength = this.items.length - this.head;\n+            System.arraycopy(this.items, this.head, newItems, 0, copyLength);\n+            System.arraycopy(this.items, 0, newItems, copyLength, this.tail);\n+            this.tail = copyLength + this.tail;\n         }\n \n+        this.head = 0;\n         this.items = newItems;\n+        assert this.head != this.tail;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MzkwNQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527243905", "bodyText": "Shouldn't poll remove the item from q, in which case it won't matter if you modify it?", "author": "tkaitchuck", "createdAt": "2020-11-19T22:22:58Z", "path": "common/src/test/java/io/pravega/common/util/PriorityBlockingDrainingQueueTests.java", "diffHunk": "@@ -155,7 +155,7 @@ public void testMultiplePriorities() {\n         Assert.assertEquals(\"Unexpected size.\", expectedItems.size(), q.size());\n         Assert.assertSame(\"Unexpected peek.\", expectedItems.first(), q.peek());\n \n-        val finalPoll = q.poll(100);\n+        val finalPoll = new ArrayDeque<>(q.poll(100)); // Make a copy since we need to modify it.", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MTIxOQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527281219", "bodyText": "poll(100) returns one of those SimpleDeque.WrapQueue instances, to which we cannot add anything. Previously, it returned an ArrayDeque to which we could add new items, so the test code was lazily reusing that one.\nSince the WrapQueue is closed to additions, I have to make a copy of it. Copying is done using its iterator, so all its elements are contained in the same order. There is no need to test the functionality of WrapQueue - that is already done in the SimpleDequeTests class.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MzkwNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NzAxMw==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527247013", "bodyText": "These two operations are not thread safe but this class extends BlockingDrainingQueue which calls itself threadsafe.\nThere are multiple race conditions:\n\nThere could be two threads the first perform the check and then both call addInternal even though the second one is before the first violating the invariant above.\nThere could be two threads which insert in one order but set lastSequenceNumber in the other order resulting in the wrong sequence number.", "author": "tkaitchuck", "createdAt": "2020-11-19T22:29:19Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.segmentstore.server.logs;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.util.BlockingDrainingQueue;\n+import io.pravega.segmentstore.server.logs.operations.Operation;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+\n+/**\n+ * {@link BlockingDrainingQueue} implementation for {@link Operation}s. Prevents adding {@link Operation}s out of order.\n+ */\n+public class InMemoryLog extends BlockingDrainingQueue<Operation> {\n+    /**\n+     * The last sequence number added. This field is only accessed in {@link #addInternal}, which is guaranteed to be\n+     * executed while holding the base class' lock, hence no need for extra synchronization here.\n+     */\n+    @Getter(AccessLevel.PACKAGE)\n+    @VisibleForTesting\n+    private long lastSequenceNumber = Operation.NO_SEQUENCE_NUMBER;\n+\n+    /**\n+     * See {@link BlockingDrainingQueue#addInternal}.\n+     *\n+     * @param item The item to include.\n+     * @throws OutOfOrderOperationException If item's Sequence Number is out of order.\n+     */\n+    @Override\n+    protected void addInternal(Operation item) {\n+        if (this.lastSequenceNumber >= item.getSequenceNumber()) {\n+            throw new OutOfOrderOperationException(String.format(\"Operation '%s' is out of order. Expected sequence number of at least %s.\",\n+                    item, this.lastSequenceNumber));\n+        }\n+        super.addInternal(item);\n+        this.lastSequenceNumber = item.getSequenceNumber();", "originalCommit": "a6a04b1b39e9eb32712b280512f67143de2b221a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MTU2OA==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527281568", "bodyText": "Look at the javadoc for lastSequenceNumber. This method can only be invoked from its superclass which holds a lock while doing so. As such, no further synchronization is needed.", "author": "andreipaduroiu", "createdAt": "2020-11-19T23:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NzAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkxNDI1NQ==", "url": "https://github.com/pravega/pravega/pull/5355#discussion_r527914255", "bodyText": "Ah, ok. Please add the @guardedby annotation on both this and the BlockingDrainingQueue.addInternal", "author": "tkaitchuck", "createdAt": "2020-11-20T19:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NzAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "0e7152f5b8f92c495fae50076473fa327efc1941", "chunk": "diff --git a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java\nindex 6a353b95b3..8bfdba13f9 100644\n--- a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java\n+++ b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/logs/InMemoryLog.java\n\n@@ -29,6 +29,7 @@ public class InMemoryLog extends BlockingDrainingQueue<Operation> {\n \n     /**\n      * See {@link BlockingDrainingQueue#addInternal}.\n+     * NOTE: this method is invoked while holding the super class' lock; as such, no further synchronization is needed here.\n      *\n      * @param item The item to include.\n      * @throws OutOfOrderOperationException If item's Sequence Number is out of order.\n"}}, {"oid": "0e7152f5b8f92c495fae50076473fa327efc1941", "url": "https://github.com/pravega/pravega/commit/0e7152f5b8f92c495fae50076473fa327efc1941", "message": "Code review feedback. Bug fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-19T23:56:50Z", "type": "commit"}, {"oid": "7a87a96e9055eda8d5bfd1f069751834e9df5ef1", "url": "https://github.com/pravega/pravega/commit/7a87a96e9055eda8d5bfd1f069751834e9df5ef1", "message": "Merge branch 'master' into issue-5345-storage-writer-data-source", "committedDate": "2020-11-20T04:54:11Z", "type": "commit"}, {"oid": "03a72d6824491d38f143db1b501688a86353394a", "url": "https://github.com/pravega/pravega/commit/03a72d6824491d38f143db1b501688a86353394a", "message": "Merge branch 'master' into issue-5345-storage-writer-data-source", "committedDate": "2020-11-20T14:59:10Z", "type": "commit"}, {"oid": "d257ee4fb844ad24a8e26897c169f2741ad3eca1", "url": "https://github.com/pravega/pravega/commit/d257ee4fb844ad24a8e26897c169f2741ad3eca1", "message": "Added GuardedBy annotation.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-11-20T22:45:13Z", "type": "commit"}, {"oid": "12324fa5c270ca525ad9a268de7462ae37b283e5", "url": "https://github.com/pravega/pravega/commit/12324fa5c270ca525ad9a268de7462ae37b283e5", "message": "Merge remote-tracking branch 'ap/issue-5345-storage-writer-data-source' into issue-5345-storage-writer-data-source", "committedDate": "2020-11-20T22:45:21Z", "type": "commit"}]}