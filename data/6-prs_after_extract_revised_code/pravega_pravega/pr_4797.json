{"pr_number": 4797, "pr_title": "Issue 4796: (KeyValue Tables) CreateAPI for Key Value Tables", "pr_createdAt": "2020-05-18T20:12:11Z", "pr_url": "https://github.com/pravega/pravega/pull/4797", "timeline": [{"oid": "5fb403389f5bdfdead19046e64716b3a86f925b4", "url": "https://github.com/pravega/pravega/commit/5fb403389f5bdfdead19046e64716b3a86f925b4", "message": "glue code for KVTables\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-18T19:58:36Z", "type": "commit"}, {"oid": "537376a3d983c5c57802902cd566d5ff142197d3", "url": "https://github.com/pravega/pravega/commit/537376a3d983c5c57802902cd566d5ff142197d3", "message": "Added createAPI call to protobuf\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-19T10:10:18Z", "type": "commit"}, {"oid": "e8aa83f2f3417db3920d5490b84976307e6b0320", "url": "https://github.com/pravega/pravega/commit/e8aa83f2f3417db3920d5490b84976307e6b0320", "message": "fixed glue code\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-19T12:29:13Z", "type": "commit"}, {"oid": "3e6e300a778dc68d4f56a9fd443a0eb96651098b", "url": "https://github.com/pravega/pravega/commit/3e6e300a778dc68d4f56a9fd443a0eb96651098b", "message": "createAPI metadata code\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-20T13:10:56Z", "type": "commit"}, {"oid": "70321c172e7bcd19d6049287cddc93f852aa0f84", "url": "https://github.com/pravega/pravega/commit/70321c172e7bcd19d6049287cddc93f852aa0f84", "message": "more changes for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-21T17:47:08Z", "type": "commit"}, {"oid": "f42dcbf4c08c24a624cad76ca8fba3a33690a781", "url": "https://github.com/pravega/pravega/commit/f42dcbf4c08c24a624cad76ca8fba3a33690a781", "message": "changes for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-22T11:38:02Z", "type": "commit"}, {"oid": "f07f3c03ddc0dd6332fa6cb85e757afc486c13a1", "url": "https://github.com/pravega/pravega/commit/f07f3c03ddc0dd6332fa6cb85e757afc486c13a1", "message": "code review comments impl1\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-27T08:39:17Z", "type": "commit"}, {"oid": "d1748d1e377ada68e3cdfaeb884fed0b385839d5", "url": "https://github.com/pravega/pravega/commit/d1748d1e377ada68e3cdfaeb884fed0b385839d5", "message": "CreateAPI changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-28T11:08:23Z", "type": "commit"}, {"oid": "801783001ad71841266cba48eb2a63dd0e386d6a", "url": "https://github.com/pravega/pravega/commit/801783001ad71841266cba48eb2a63dd0e386d6a", "message": "Added builder to KeyVaueTableConfiguration\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-28T11:25:59Z", "type": "commit"}, {"oid": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "url": "https://github.com/pravega/pravega/commit/a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "message": "fixed checkstyle errors\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-28T13:18:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODEwMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228101", "bodyText": "nit: revert", "author": "shiveshr", "createdAt": "2020-05-29T02:50:18Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -280,4 +280,6 @@\n      */\n     @Override\n     void close();\n+", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3ODUxNg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432378516", "bodyText": "done.", "author": "pbelgundi", "createdAt": "2020-05-29T09:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODEwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 6ead0f86e..c535cd983 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -280,6 +280,4 @@ public interface KeyValueTable<KeyT, ValueT> extends AutoCloseable {\n      */\n     @Override\n     void close();\n-\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODIzNg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228236", "bodyText": "nit: TableConfig", "author": "shiveshr", "createdAt": "2020-05-29T02:50:55Z", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -115,6 +117,20 @@ public static final StreamConfiguration encode(final StreamConfig config) {\n                 .build();\n     }\n \n+    /**\n+     * Helper to convert StreamConfig into Stream Configuration Impl.", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4ODU3MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432388570", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-05-29T10:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/client/src/main/java/io/pravega/client/control/impl/ModelHelper.java b/client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java\nsimilarity index 98%\nrename from client/src/main/java/io/pravega/client/control/impl/ModelHelper.java\nrename to client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java\nindex ba0532980..7629045f1 100644\n--- a/client/src/main/java/io/pravega/client/control/impl/ModelHelper.java\n+++ b/client/src/main/java/io/pravega/client/stream/impl/ModelHelper.java\n\n@@ -118,10 +118,10 @@ public final class ModelHelper {\n     }\n \n     /**\n-     * Helper to convert StreamConfig into Stream Configuration Impl.\n+     * Helper to convert KeyValueTableConfig object into Stream Configuration Impl.\n      *\n      * @param config The StreamConfig\n-     * @return New instance of StreamConfiguration Impl.\n+     * @return New instance of KeyValueTableConfiguration Impl.\n      */\n     public static final KeyValueTableConfiguration encode(final KeyValueTableConfig config) {\n         Preconditions.checkNotNull(config, \"config\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228885", "bodyText": "maybe we can name it better as this is going to pravega common in futures.", "author": "shiveshr", "createdAt": "2020-05-29T02:53:39Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +47,25 @@\n  */\n public final class Futures {\n \n+    public static <T> CompletableFuture<T> withCompletion(CompletableFuture<T> future, final Executor executor) {", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzNDE2Nw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432434167", "bodyText": "Any suggestions?", "author": "pbelgundi", "createdAt": "2020-05-29T11:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NjMyOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432446328", "bodyText": "CompleteOn ?\nand if you are putting it in common.futures , then add proper javadoc as this is a public library.", "author": "shiveshr", "createdAt": "2020-05-29T12:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA2ODAwNA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433068004", "bodyText": "Ok. Will do this.", "author": "pbelgundi", "createdAt": "2020-06-01T06:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTk3Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181973", "bodyText": "Done.", "author": "pbelgundi", "createdAt": "2020-06-01T11:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODg4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b130080057d6810f694b84bb94baa38300022513", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex 842fc1c58..9198a1377 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -47,12 +47,17 @@ import lombok.val;\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future   The future to execute.\n+     * @param executor The executor for executing the future.\n+     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     */\n     public static <T> CompletableFuture<T> withCompletion(CompletableFuture<T> future, final Executor executor) {\n \n-        // Following makes sure that the result future given out to caller is actually completed on\n-        // caller's executor. So any chaining, if done without specifying an executor, will either happen on\n-        // caller's executor or fork join pool but never on someone else's executor.\n-\n         CompletableFuture<T> result = new CompletableFuture<>();\n \n         future.whenCompleteAsync((r, e) -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODk4OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432228988", "bodyText": "please revert this reordering.", "author": "shiveshr", "createdAt": "2020-05-29T02:54:12Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -21,15 +21,17 @@\n import io.pravega.controller.metrics.StreamMetrics;\n import io.pravega.controller.metrics.TransactionMetrics;\n import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.store.OperationContext;\n+import io.pravega.controller.store.stream.StreamMetadataStore;\n import io.pravega.controller.store.stream.BucketStore;\n-import io.pravega.controller.store.stream.OperationContext;\n-import io.pravega.controller.store.stream.ScaleMetadata;\n import io.pravega.controller.store.stream.State;", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2NjM5Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432466392", "bodyText": "fixed.", "author": "pbelgundi", "createdAt": "2020-05-29T13:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyODk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\nindex b6dfb0456..bb44d4f3f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n\n@@ -21,7 +21,7 @@ import io.pravega.common.util.RetriesExhaustedException;\n import io.pravega.controller.metrics.StreamMetrics;\n import io.pravega.controller.metrics.TransactionMetrics;\n import io.pravega.controller.retryable.RetryableException;\n-import io.pravega.controller.store.OperationContext;\n+import io.pravega.controller.store.stream.OperationContext;\n import io.pravega.controller.store.stream.StreamMetadataStore;\n import io.pravega.controller.store.stream.BucketStore;\n import io.pravega.controller.store.stream.State;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTEzMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432229131", "bodyText": "nit: table", "author": "shiveshr", "createdAt": "2020-05-29T02:54:49Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -95,6 +100,29 @@\n         }, executor);\n     }\n \n+    public CompletableFuture<CreateKeyValueTableStatus> createKeyValueTable(String scope, String kvtName,\n+                                                                            final KeyValueTableConfiguration kvtConfig,\n+                                                                            final long createTimestamp) {\n+        Preconditions.checkNotNull(kvtConfig, \"kvTableConfig\");\n+        Preconditions.checkArgument(createTimestamp >= 0);\n+        Timer timer = new Timer();\n+        try {\n+            NameUtils.validateUserKeyValueTableName(kvtName);\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            log.warn(\"Create KeyValueTable failed due to invalid name {}\", kvtName);\n+            return CompletableFuture.completedFuture(\n+                    CreateKeyValueTableStatus.newBuilder().setStatus(CreateKeyValueTableStatus.Status.INVALID_TABLE_NAME).build());\n+        }\n+        // check if stream with same name exists...", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4ODc0NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432388744", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-05-29T10:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTEzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\nindex b6dfb0456..bb44d4f3f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n\n@@ -113,8 +113,6 @@ public class ControllerService {\n             return CompletableFuture.completedFuture(\n                     CreateKeyValueTableStatus.newBuilder().setStatus(CreateKeyValueTableStatus.Status.INVALID_TABLE_NAME).build());\n         }\n-        // check if stream with same name exists...\n-        // alternatively for KVTables have segment names suffixed with _table\n         return kvtMetadataTasks.createKeyValueTable(scope, kvtName, kvtConfig, createTimestamp)\n                 .thenApplyAsync(status -> {\n                     reportCreateKVTableMetrics(scope, kvtName, kvtConfig.getPartitionCount(), status, timer.getElapsed());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTU1Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432229552", "bodyText": "CreateKVTableStatus", "author": "shiveshr", "createdAt": "2020-05-29T02:56:40Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -484,6 +512,16 @@ private Throwable getRealException(Throwable ex) {\n \n     // Metrics reporting region\n \n+\n+    private void reportCreateKVTableMetrics(String scope, String kvtName, int initialSegments, CreateKeyValueTableStatus.Status status,\n+                                           Duration latency) {\n+        if (status.equals(CreateStreamStatus.Status.SUCCESS)) {", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\nindex b6dfb0456..bb44d4f3f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n\n@@ -511,13 +509,11 @@ public class ControllerService {\n     }\n \n     // Metrics reporting region\n-\n-\n     private void reportCreateKVTableMetrics(String scope, String kvtName, int initialSegments, CreateKeyValueTableStatus.Status status,\n                                            Duration latency) {\n-        if (status.equals(CreateStreamStatus.Status.SUCCESS)) {\n+        if (status.equals(CreateKeyValueTableStatus.Status.SUCCESS)) {\n             StreamMetrics.getInstance().createStream(scope, kvtName, initialSegments, latency);\n-        } else if (status.equals(CreateStreamStatus.Status.FAILURE)) {\n+        } else if (status.equals(CreateKeyValueTableStatus.Status.FAILURE)) {\n             StreamMetrics.getInstance().createStreamFailed(scope, kvtName);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTYwNA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432229604", "bodyText": "same as above", "author": "shiveshr", "createdAt": "2020-05-29T02:57:00Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -484,6 +512,16 @@ private Throwable getRealException(Throwable ex) {\n \n     // Metrics reporting region\n \n+\n+    private void reportCreateKVTableMetrics(String scope, String kvtName, int initialSegments, CreateKeyValueTableStatus.Status status,\n+                                           Duration latency) {\n+        if (status.equals(CreateStreamStatus.Status.SUCCESS)) {\n+            StreamMetrics.getInstance().createStream(scope, kvtName, initialSegments, latency);\n+        } else if (status.equals(CreateStreamStatus.Status.FAILURE)) {", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzNDMxOQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432434319", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-05-29T11:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyOTYwNA=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\nindex b6dfb0456..bb44d4f3f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n\n@@ -511,13 +509,11 @@ public class ControllerService {\n     }\n \n     // Metrics reporting region\n-\n-\n     private void reportCreateKVTableMetrics(String scope, String kvtName, int initialSegments, CreateKeyValueTableStatus.Status status,\n                                            Duration latency) {\n-        if (status.equals(CreateStreamStatus.Status.SUCCESS)) {\n+        if (status.equals(CreateKeyValueTableStatus.Status.SUCCESS)) {\n             StreamMetrics.getInstance().createStream(scope, kvtName, initialSegments, latency);\n-        } else if (status.equals(CreateStreamStatus.Status.FAILURE)) {\n+        } else if (status.equals(CreateKeyValueTableStatus.Status.FAILURE)) {\n             StreamMetrics.getInstance().createStreamFailed(scope, kvtName);\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzMDAzMw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432230033", "bodyText": "please revert the reordering of imports (here and everywhere else)", "author": "shiveshr", "createdAt": "2020-05-29T02:58:54Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -31,19 +31,24 @@\n import io.pravega.controller.eventProcessor.impl.EventProcessorGroupConfigImpl;\n import io.pravega.controller.eventProcessor.impl.EventProcessorSystemImpl;\n import io.pravega.controller.fault.FailoverSweeper;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.StreamRequestHandler;", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwOTU3Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432409572", "bodyText": "Ok", "author": "pbelgundi", "createdAt": "2020-05-29T10:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzMDAzMw=="}], "type": "inlineReview", "revised_code": {"commit": "2deac3ded5585ac1bc8c0cfeb2815495df689a31", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java\nindex 4187e0b64..7b1a7f8eb 100755\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java\n\n@@ -45,7 +45,7 @@ import io.pravega.controller.server.eventProcessor.requesthandlers.kvtable.Creat\n \n import io.pravega.controller.store.checkpoint.CheckpointStore;\n import io.pravega.controller.store.checkpoint.CheckpointStoreException;\n-import io.pravega.controller.store.kvtable.TableMetadataStore;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.controller.store.stream.BucketStore;\n import io.pravega.controller.store.stream.StreamMetadataStore;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDYzMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432244631", "bodyText": "please revert this.", "author": "shiveshr", "createdAt": "2020-05-29T04:06:41Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java", "diffHunk": "@@ -50,6 +50,7 @@\n     private final BucketStore bucketStore;\n     private final ScheduledExecutorService executor;\n     private final BlockingQueue<CommitEvent> processedEvents;\n+    private final StreamMetadataStore streamStore = (StreamMetadataStore) getMetadataStore();", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java\nindex d3f77bdb1..d946f498f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java\n\n@@ -50,7 +50,6 @@ public class CommitRequestHandler extends AbstractRequestProcessor<CommitEvent>\n     private final BucketStore bucketStore;\n     private final ScheduledExecutorService executor;\n     private final BlockingQueue<CommitEvent> processedEvents;\n-    private final StreamMetadataStore streamStore = (StreamMetadataStore) getMetadataStore();\n \n     public CommitRequestHandler(final StreamMetadataStore streamMetadataStore,\n                                 final StreamMetadataTasks streamMetadataTasks,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTAxMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432245011", "bodyText": "we dont need to add a getter. the protected variable is availble to derived classes.\nso revert these changes. And also revert all derived classes where you use the getter.", "author": "shiveshr", "createdAt": "2020-05-29T04:08:36Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java", "diffHunk": "@@ -54,15 +55,16 @@\n  * was set against its name.\n  */\n @Slf4j\n-public abstract class AbstractRequestProcessor<T extends ControllerEvent> extends SerializedRequestHandler<T> implements RequestProcessor {\n+public abstract class AbstractRequestProcessor<T extends ControllerEvent> extends SerializedRequestHandler<T> implements StreamRequestProcessor {\n     protected static final Predicate<Throwable> OPERATION_NOT_ALLOWED_PREDICATE = e -> Exceptions.unwrap(e) instanceof StoreException.OperationNotAllowedException;\n \n-    protected final StreamMetadataStore streamMetadataStore;\n+    @Getter\n+    protected final StreamMetadataStore metadataStore;", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3ODY1MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432378651", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-05-29T09:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTAxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java\nindex b26a0851c..3de20188e 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java\n\n@@ -58,13 +57,12 @@ import static io.pravega.controller.eventProcessor.impl.EventProcessorHelper.wit\n public abstract class AbstractRequestProcessor<T extends ControllerEvent> extends SerializedRequestHandler<T> implements StreamRequestProcessor {\n     protected static final Predicate<Throwable> OPERATION_NOT_ALLOWED_PREDICATE = e -> Exceptions.unwrap(e) instanceof StoreException.OperationNotAllowedException;\n \n-    @Getter\n-    protected final StreamMetadataStore metadataStore;\n+    protected final StreamMetadataStore streamMetadataStore;\n \n     public AbstractRequestProcessor(StreamMetadataStore streamMetadataStore, ScheduledExecutorService executor) {\n         super(executor);\n         Preconditions.checkNotNull(streamMetadataStore);\n-        this.metadataStore = streamMetadataStore;\n+        this.streamMetadataStore = streamMetadataStore;\n     }\n \n     public String getProcessorName() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTU2Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432245566", "bodyText": "nit: please revert", "author": "shiveshr", "createdAt": "2020-05-29T04:10:56Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java", "diffHunk": "@@ -42,7 +42,7 @@\n \n     public DeleteStreamTask(final StreamMetadataTasks streamMetadataTasks,\n                             final StreamMetadataStore streamMetadataStore,\n-                            final BucketStore bucketStore, \n+                            final BucketStore bucketStore,", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d0b990123be86e6310006988de1936893460350e", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java\nindex bba03f509..54598320c 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/DeleteStreamTask.java\n\n@@ -42,7 +42,7 @@ public class DeleteStreamTask implements StreamTask<DeleteStreamEvent> {\n \n     public DeleteStreamTask(final StreamMetadataTasks streamMetadataTasks,\n                             final StreamMetadataStore streamMetadataStore,\n-                            final BucketStore bucketStore,\n+                            final BucketStore bucketStore, \n                             final ScheduledExecutorService executor) {\n         Preconditions.checkNotNull(streamMetadataStore);\n         Preconditions.checkNotNull(streamMetadataTasks);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0ODM2Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432248366", "bodyText": "Let us evaluate whether it makes sense to create this higher level abstraction right now.\nwe can create this abstraction when we think tables will also require a waiting request processor mechanism for fairness.\nthe whole waiting request processor business is a bit of a patchwork done for streams because we wanted fairness in execution of work for commit and other workflows.. primarily because commit can be overwhelmingly more frequent than other workflows which can end up waiting unnecessarily..\nmaybe we dont need such construct for tables ever.. at least not now..\nso creating this abstraction is unnecessary at this point and making these methods available and implemented in table store unnecessarily.", "author": "shiveshr", "createdAt": "2020-05-29T04:23:32Z", "path": "controller/src/main/java/io/pravega/controller/store/ArtifactStore.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store;\n+\n+import io.pravega.common.concurrent.Futures;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+public interface ArtifactStore {", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3OTAxMA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432379010", "bodyText": "Removed this.", "author": "pbelgundi", "createdAt": "2020-05-29T09:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0ODM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/ArtifactStore.java b/controller/src/main/java/io/pravega/controller/store/ArtifactStore.java\ndeleted file mode 100644\nindex d35dabaf1..000000000\n--- a/controller/src/main/java/io/pravega/controller/store/ArtifactStore.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-/**\n- * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- */\n-package io.pravega.controller.store;\n-\n-import io.pravega.common.concurrent.Futures;\n-\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ScheduledExecutorService;\n-\n-public interface ArtifactStore {\n-\n-    Artifact getArtifact(String scope, String stream, OperationContext context);\n-\n-    /**\n-     * Method to create an operation context. A context ensures that multiple calls to store for the same data are avoided\n-     * within the same operation. All api signatures are changed to accept context. If context is supplied, the data will be\n-     * looked up within the context and, upon a cache miss, will be fetched from the external store and cached within the context.\n-     * Once an operation completes, the context is discarded.\n-     *\n-     * @param scope Stream scope.\n-     * @param name  Stream name.\n-     * @return Return a streamContext\n-     */\n-    OperationContext createContext(final String scope, final String name);\n-\n-    /**\n-     * This method fetches existing waiting request processor's name if any. It returns null if no processor is waiting.\n-     *\n-     * @param scope scope name\n-     * @param name stream/kvt name\n-     * @param context operation context\n-     * @param executor executor\n-     * @return CompletableFuture which has the name of the processor that had requested for a wait, or null if there was no\n-     * such request.\n-     */\n-    default CompletableFuture<String> getWaitingRequestProcessor(String scope, String name, OperationContext context, ScheduledExecutorService executor) {\n-        return Futures.withCompletion(getArtifact(scope, name, context).getWaitingRequestProcessor(), executor);\n-    }\n-\n-    /**\n-     * This method attempts to create a new Waiting Request node and set the processor's name in the node.\n-     * If a node already exists, this attempt is ignored.\n-     *\n-     * @param scope scope\n-     * @param stream stream\n-     * @param processorName name of the request processor that is waiting to get an opportunity for processing.\n-     * @param context operation context\n-     * @param executor executor\n-     * @return CompletableFuture which indicates that a node was either created successfully or records the failure.\n-     */\n-    default CompletableFuture<Void> createWaitingRequestIfAbsent(String scope, String stream, String processorName,\n-                                                                OperationContext context, ScheduledExecutorService executor) {\n-        return Futures.withCompletion(getArtifact(scope, stream, context).createWaitingRequestIfAbsent(processorName), executor);\n-    }\n-\n-    /**\n-     * Delete existing waiting request processor if the name of the existing matches suppied processor name.\n-     *\n-     * @param scope scope\n-     * @param stream stream\n-     * @param processorName processor name which is to be deleted if it matches the name in waiting record in the store.\n-     * @param context operation context\n-     * @param executor executor\n-     * @return CompletableFuture which indicates completion of processing.\n-     */\n-    default CompletableFuture<Void> deleteWaitingRequestConditionally(String scope, String stream, String processorName,\n-                                                                     OperationContext context, ScheduledExecutorService executor) {\n-        return Futures.withCompletion(getArtifact(scope, stream, context).deleteWaitingRequestConditionally(processorName), executor);\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0ODc1NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432248754", "bodyText": "table's operation context and stream's operation context need not be derived from same base interface. table's requests (operations) are independent of streams. so we dont need a common interface for them.", "author": "shiveshr", "createdAt": "2020-05-29T04:25:29Z", "path": "controller/src/main/java/io/pravega/controller/store/OperationContext.java", "diffHunk": "@@ -7,14 +7,13 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.controller.store.stream;\n+package io.pravega.controller.store;\n \n /**\n  * Interface for defining an operation context.\n  * A context caches metadata fetches so within a context if for the same entity, multiple\n  * read operations against the store are requested, the values are served from the context's cache.\n  */\n-public interface OperationContext {\n-\n-    Stream getStream();\n+public interface OperationContext<T> {", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3OTE3MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432379170", "bodyText": "removed the coupling.", "author": "pbelgundi", "createdAt": "2020-05-29T09:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0ODc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/OperationContext.java b/controller/src/main/java/io/pravega/controller/store/stream/OperationContext.java\nsimilarity index 84%\nrename from controller/src/main/java/io/pravega/controller/store/OperationContext.java\nrename to controller/src/main/java/io/pravega/controller/store/stream/OperationContext.java\nindex ad34e8369..ba0909b93 100644\n--- a/controller/src/main/java/io/pravega/controller/store/OperationContext.java\n+++ b/controller/src/main/java/io/pravega/controller/store/stream/OperationContext.java\n\n@@ -7,13 +7,14 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.controller.store;\n+package io.pravega.controller.store.stream;\n \n /**\n  * Interface for defining an operation context.\n  * A context caches metadata fetches so within a context if for the same entity, multiple\n  * read operations against the store are requested, the values are served from the context's cache.\n  */\n-public interface OperationContext<T> {\n-    public T getObject();\n-}\n+public interface OperationContext {\n+\n+    Stream getStream();\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTA5NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432249095", "bodyText": "we can take out the scope's object cache into its own class.. and use that same cache here and in stream metadata store.", "author": "shiveshr", "createdAt": "2020-05-29T04:27:10Z", "path": "controller/src/main/java/io/pravega/controller/store/kvtable/AbstractTableMetadataStore.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.Scope;\n+import io.pravega.controller.store.OperationContext;\n+import io.pravega.controller.store.VersionedMetadata;\n+import io.pravega.controller.store.Artifact;\n+import io.pravega.controller.store.index.HostIndex;\n+import io.pravega.controller.store.stream.StoreException;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.ControllerEventSerializer;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.ParametersAreNonnullByDefault;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+\n+public abstract class AbstractTableMetadataStore implements TableMetadataStore {\n+    private final LoadingCache<String, Scope> scopeCache;\n+    private final LoadingCache<Pair<String, String>, KeyValueTable> cache;\n+    private final HostIndex hostTaskIndex;\n+    private final ControllerEventSerializer controllerEventSerializer;\n+\n+    protected AbstractTableMetadataStore(HostIndex hostTaskIndex) {\n+        cache = CacheBuilder.newBuilder()\n+                .maximumSize(10000)\n+                .refreshAfterWrite(10, TimeUnit.MINUTES)\n+                .expireAfterWrite(10, TimeUnit.MINUTES)\n+                .build(\n+                        new CacheLoader<Pair<String, String>, KeyValueTable>() {\n+                            @Override\n+                            @ParametersAreNonnullByDefault\n+                            public KeyValueTable load(Pair<String, String> input) {\n+                                try {\n+                                    return newKeyValueTable(input.getKey(), input.getValue());\n+                                } catch (Exception e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }\n+                        });\n+\n+        scopeCache = CacheBuilder.newBuilder()", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4OTI2Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432389262", "bodyText": "Ok. Will implement this after the basic flow is all done and working.", "author": "pbelgundi", "createdAt": "2020-05-29T10:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/kvtable/AbstractTableMetadataStore.java b/controller/src/main/java/io/pravega/controller/store/kvtable/AbstractTableMetadataStore.java\nindex 9385829e5..85ad2ccc4 100644\n--- a/controller/src/main/java/io/pravega/controller/store/kvtable/AbstractTableMetadataStore.java\n+++ b/controller/src/main/java/io/pravega/controller/store/kvtable/AbstractTableMetadataStore.java\n\n@@ -15,9 +15,7 @@ import com.google.common.cache.LoadingCache;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n import io.pravega.common.concurrent.Futures;\n import io.pravega.controller.store.Scope;\n-import io.pravega.controller.store.OperationContext;\n import io.pravega.controller.store.VersionedMetadata;\n-import io.pravega.controller.store.Artifact;\n import io.pravega.controller.store.index.HostIndex;\n import io.pravega.controller.store.stream.StoreException;\n import io.pravega.shared.controller.event.ControllerEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTYxNg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432249616", "bodyText": "nit: table", "author": "shiveshr", "createdAt": "2020-05-29T04:29:43Z", "path": "controller/src/main/java/io/pravega/controller/store/kvtable/KVTableState.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Arrays;\n+import java.util.Set;\n+\n+/**\n+ * This is used to represent the state of the Stream.", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4OTM2MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432389360", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-05-29T10:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableState.java b/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableState.java\nindex 89f7bbbb2..acf76fac4 100644\n--- a/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableState.java\n+++ b/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableState.java\n\n@@ -15,7 +15,7 @@ import java.util.Arrays;\n import java.util.Set;\n \n /**\n- * This is used to represent the state of the Stream.\n+ * This is used to represent the state of the KeyValueTable.\n  */\n public enum KVTableState {\n     UNKNOWN,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MDIzMA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432250230", "bodyText": "Please call this class AbstractTable.\nI have an issue for renaming PersistentStreamBase to AbstractStream as well.\nI dont know why i created that weird name earlier. But please using a different name here. We have followed the pattern of calling the base abstract class AbstractXXX", "author": "shiveshr", "createdAt": "2020-05-29T04:32:43Z", "path": "controller/src/main/java/io/pravega/controller/store/kvtable/PersistentKVTableBase.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.store.Version;\n+import io.pravega.controller.store.VersionedMetadata;\n+import io.pravega.controller.store.kvtable.records.KVTEpochRecord;\n+import io.pravega.controller.store.kvtable.records.KVTSegmentRecord;\n+import io.pravega.controller.store.kvtable.records.KVTConfigurationRecord;\n+import io.pravega.controller.store.kvtable.records.KVTStateRecord;\n+import io.pravega.controller.store.stream.StoreException;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.stream.IntStream;\n+\n+\n+@Slf4j\n+public abstract class PersistentKVTableBase implements KeyValueTable {", "originalCommit": "a00dc353e8df16e8cd99664c7efe4d2bb8a98676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzNDU4OQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432434589", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-05-29T11:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MDIzMA=="}], "type": "inlineReview", "revised_code": {"commit": "eb444aa509869e20fd4618089aba4bb91c629f94", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/kvtable/PersistentKVTableBase.java b/controller/src/main/java/io/pravega/controller/store/kvtable/PersistentKVTableBase.java\nindex 095f799b2..bfffe46dd 100644\n--- a/controller/src/main/java/io/pravega/controller/store/kvtable/PersistentKVTableBase.java\n+++ b/controller/src/main/java/io/pravega/controller/store/kvtable/PersistentKVTableBase.java\n\n@@ -46,11 +46,6 @@ public abstract class PersistentKVTableBase implements KeyValueTable {\n         return this.name;\n     }\n \n-    @Override\n-    public String getScopeName() {\n-        return this.scope;\n-    }\n-\n     @Override\n     public CompletableFuture<Void> updateState(final KVTableState state) {\n         return getStateData(true)\n"}}, {"oid": "eb444aa509869e20fd4618089aba4bb91c629f94", "url": "https://github.com/pravega/pravega/commit/eb444aa509869e20fd4618089aba4bb91c629f94", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T10:10:42Z", "type": "commit"}, {"oid": "2deac3ded5585ac1bc8c0cfeb2815495df689a31", "url": "https://github.com/pravega/pravega/commit/2deac3ded5585ac1bc8c0cfeb2815495df689a31", "message": "code review\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T10:34:21Z", "type": "commit"}, {"oid": "75459e7aafec4891a59f7c5dcef143f7e49f3816", "url": "https://github.com/pravega/pravega/commit/75459e7aafec4891a59f7c5dcef143f7e49f3816", "message": "review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T10:46:04Z", "type": "commit"}, {"oid": "c66ed4e354ba0a46b1ce5495705151d8465395fd", "url": "https://github.com/pravega/pravega/commit/c66ed4e354ba0a46b1ce5495705151d8465395fd", "message": "reverting unnecessary changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T10:55:37Z", "type": "commit"}, {"oid": "d0b990123be86e6310006988de1936893460350e", "url": "https://github.com/pravega/pravega/commit/d0b990123be86e6310006988de1936893460350e", "message": "removed spaces\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T11:14:05Z", "type": "commit"}, {"oid": "630dd1ba67f95c84543fd767ca302dc746088787", "url": "https://github.com/pravega/pravega/commit/630dd1ba67f95c84543fd767ca302dc746088787", "message": "reverse unnecessary changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T11:40:23Z", "type": "commit"}, {"oid": "8d6cd32e9f1ce52973a8b510a08383e08183f746", "url": "https://github.com/pravega/pravega/commit/8d6cd32e9f1ce52973a8b510a08383e08183f746", "message": "removing unnecessary changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T11:54:43Z", "type": "commit"}, {"oid": "6e5b12efea5a0991df33a69e070176f3b271f534", "url": "https://github.com/pravega/pravega/commit/6e5b12efea5a0991df33a69e070176f3b271f534", "message": "review comments impl\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-05-29T12:55:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NTExNQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432445115", "bodyText": "nit: stream config", "author": "shiveshr", "createdAt": "2020-05-29T12:19:52Z", "path": "client/src/main/java/io/pravega/client/control/impl/ModelHelper.java", "diffHunk": "@@ -115,6 +117,20 @@ public static final StreamConfiguration encode(final StreamConfig config) {\n                 .build();\n     }\n \n+    /**\n+     * Helper to convert KeyValueTableConfig object into Stream Configuration Impl.", "originalCommit": "8d6cd32e9f1ce52973a8b510a08383e08183f746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2OTA5NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433169094", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-01T10:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NTExNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b130080057d6810f694b84bb94baa38300022513", "chunk": "diff --git a/client/src/main/java/io/pravega/client/control/impl/ModelHelper.java b/client/src/main/java/io/pravega/client/control/impl/ModelHelper.java\nindex eba0bd262..58882e267 100644\n--- a/client/src/main/java/io/pravega/client/control/impl/ModelHelper.java\n+++ b/client/src/main/java/io/pravega/client/control/impl/ModelHelper.java\n\n@@ -118,9 +118,9 @@ public final class ModelHelper {\n     }\n \n     /**\n-     * Helper to convert KeyValueTableConfig object into Stream Configuration Impl.\n+     * Helper to convert KeyValueTableConfig object into KeyValueTableConfiguration Impl.\n      *\n-     * @param config The StreamConfig\n+     * @param config The KeyValueTable Config\n      * @return New instance of KeyValueTableConfiguration Impl.\n      */\n     public static final KeyValueTableConfiguration encode(final KeyValueTableConfig config) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMjc2Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432612766", "bodyText": "nit: revert the import collection", "author": "shiveshr", "createdAt": "2020-05-29T16:54:27Z", "path": "controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java", "diffHunk": "@@ -14,27 +14,7 @@\n import java.time.Duration;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import static io.pravega.shared.MetricsNames.CREATE_STREAM;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.CREATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.DELETE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.OPEN_TRANSACTIONS;\n-import static io.pravega.shared.MetricsNames.RETENTION_FREQUENCY;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.SEAL_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_COUNT;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_MERGES;\n-import static io.pravega.shared.MetricsNames.SEGMENTS_SPLITS;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_FAILED;\n-import static io.pravega.shared.MetricsNames.UPDATE_STREAM_LATENCY;\n-import static io.pravega.shared.MetricsNames.globalMetricName;\n+import static io.pravega.shared.MetricsNames.*;", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2OTk5OQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433169999", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-01T10:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMjc2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b130080057d6810f694b84bb94baa38300022513", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java b/controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java\nindex c8c6dfb9c..ef58e5110 100644\n--- a/controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java\n+++ b/controller/src/main/java/io/pravega/controller/metrics/StreamMetrics.java\n\n@@ -14,7 +14,31 @@ import io.pravega.shared.metrics.OpStatsLogger;\n import java.time.Duration;\n import java.util.concurrent.atomic.AtomicReference;\n \n-import static io.pravega.shared.MetricsNames.*;\n+import static io.pravega.shared.MetricsNames.CREATE_STREAM;\n+import static io.pravega.shared.MetricsNames.CREATE_STREAM_FAILED;\n+import static io.pravega.shared.MetricsNames.CREATE_STREAM_LATENCY;\n+import static io.pravega.shared.MetricsNames.DELETE_STREAM;\n+import static io.pravega.shared.MetricsNames.DELETE_STREAM_FAILED;\n+import static io.pravega.shared.MetricsNames.DELETE_STREAM_LATENCY;\n+import static io.pravega.shared.MetricsNames.OPEN_TRANSACTIONS;\n+import static io.pravega.shared.MetricsNames.RETENTION_FREQUENCY;\n+import static io.pravega.shared.MetricsNames.SEAL_STREAM;\n+import static io.pravega.shared.MetricsNames.SEAL_STREAM_FAILED;\n+import static io.pravega.shared.MetricsNames.SEAL_STREAM_LATENCY;\n+import static io.pravega.shared.MetricsNames.SEGMENTS_COUNT;\n+import static io.pravega.shared.MetricsNames.SEGMENTS_MERGES;\n+import static io.pravega.shared.MetricsNames.SEGMENTS_SPLITS;\n+import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM;\n+import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_FAILED;\n+import static io.pravega.shared.MetricsNames.TRUNCATE_STREAM_LATENCY;\n+import static io.pravega.shared.MetricsNames.UPDATE_STREAM;\n+import static io.pravega.shared.MetricsNames.UPDATE_STREAM_FAILED;\n+import static io.pravega.shared.MetricsNames.UPDATE_STREAM_LATENCY;\n+import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_LATENCY;\n+import static io.pravega.shared.MetricsNames.CREATE_KVTABLE;\n+import static io.pravega.shared.MetricsNames.KVTABLE_SEGMENTS_COUNT;\n+import static io.pravega.shared.MetricsNames.CREATE_KVTABLE_FAILED;\n+import static io.pravega.shared.MetricsNames.globalMetricName;\n import static io.pravega.shared.MetricsTags.streamTags;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNTIxOQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432615219", "bodyText": "config.tablestreamname", "author": "shiveshr", "createdAt": "2020-05-29T16:57:24Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java", "diffHunk": "@@ -262,11 +273,13 @@ public boolean isReady() {\n                         executor));\n     }\n \n-    public CompletableFuture<Void> bootstrap(final StreamTransactionMetadataTasks streamTransactionMetadataTasks, StreamMetadataTasks streamMetadataTasks) {\n+    public CompletableFuture<Void> bootstrap(final StreamTransactionMetadataTasks streamTransactionMetadataTasks,\n+                                             StreamMetadataTasks streamMetadataTasks, TableMetadataTasks tableMetadataTasks) {\n         log.info(\"Bootstrapping controller event processors\");\n         return createStreams().thenAcceptAsync(x -> {\n             streamMetadataTasks.initializeStreamWriters(clientFactory, config.getRequestStreamName());\n             streamTransactionMetadataTasks.initializeStreamWriters(clientFactory, config);\n+            tableMetadataTasks.initializeStreamWriters(clientFactory, config.getRequestStreamName());", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTcwNg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181706", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-01T11:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNTIxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java\nindex 43bea0d5f..9136c9b4d 100755\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/ControllerEventProcessors.java\n\n@@ -279,7 +279,7 @@ public class ControllerEventProcessors extends AbstractIdleService implements Fa\n         return createStreams().thenAcceptAsync(x -> {\n             streamMetadataTasks.initializeStreamWriters(clientFactory, config.getRequestStreamName());\n             streamTransactionMetadataTasks.initializeStreamWriters(clientFactory, config);\n-            tableMetadataTasks.initializeStreamWriters(clientFactory, config.getRequestStreamName());\n+            tableMetadataTasks.initializeStreamWriters(clientFactory, config.getKvtStreamName());\n         }, executor);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzUxMg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432617512", "bodyText": "nit: revert this", "author": "shiveshr", "createdAt": "2020-05-29T16:59:59Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java", "diffHunk": "@@ -127,7 +127,7 @@ public String getProcessorName() {\n         CompletableFuture<String> waitingProcFuture = suppressException(streamMetadataStore.getWaitingRequestProcessor(scope, stream, context, executor), null,\n                 \"Exception while trying to fetch waiting request. Logged and ignored.\");\n         CompletableFuture<Boolean> hasTaskStarted = task.hasTaskStarted(event);\n-        \n+", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTY0NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181644", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-01T11:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java\nindex 3de20188e..fe0c1c684 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java\n\n@@ -127,7 +127,6 @@ public abstract class AbstractRequestProcessor<T extends ControllerEvent> extend\n         CompletableFuture<String> waitingProcFuture = suppressException(streamMetadataStore.getWaitingRequestProcessor(scope, stream, context, executor), null,\n                 \"Exception while trying to fetch waiting request. Logged and ignored.\");\n         CompletableFuture<Boolean> hasTaskStarted = task.hasTaskStarted(event);\n-\n         CompletableFuture.allOf(waitingProcFuture, hasTaskStarted)\n                 .thenAccept(v -> {\n                     boolean hasStarted = hasTaskStarted.join();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzY1MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432617650", "bodyText": "and this", "author": "shiveshr", "createdAt": "2020-05-29T17:00:15Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/AbstractRequestProcessor.java", "diffHunk": "@@ -184,4 +184,4 @@ public String getProcessorName() {\n                     }\n                 });\n     }\n-}\n+}", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxODM0NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432618344", "bodyText": "this comment is not required here. this doesnt provide the common completion method for fairness.", "author": "shiveshr", "createdAt": "2020-05-29T17:01:32Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/AbstractTableRequestProcessor.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.controller.eventProcessor.impl.SerializedRequestHandler;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.RequestUnsupportedException;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import io.pravega.shared.controller.event.kvtable.TableRequestProcessor;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * Abstract common class for all request processing done over SerializedRequestHandler.\n+ * This implements TableRequestProcessor interface and implements failing request processing for all ControllerEvent types with\n+ * RequestUnsupported.\n+ * Its derived classes should implement specific processing that they wish to handle.\n+ *\n+ * This class provides a common completion method which implements mechanisms that allow multiple event processors", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/AbstractTableRequestProcessor.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/AbstractTableRequestProcessor.java\nindex 7d8cdd6e7..6ba278a1f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/AbstractTableRequestProcessor.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/AbstractTableRequestProcessor.java\n\n@@ -25,21 +25,9 @@ import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ScheduledExecutorService;\n \n /**\n- * Abstract common class for all request processing done over SerializedRequestHandler.\n- * This implements TableRequestProcessor interface and implements failing request processing for all ControllerEvent types with\n- * RequestUnsupported.\n+ * Abstract common class for all KeyValueTable related request processing done over SerializedRequestHandler.\n+ * This implements TableRequestProcessor interface.\n  * Its derived classes should implement specific processing that they wish to handle.\n- *\n- * This class provides a common completion method which implements mechanisms that allow multiple event processors\n- * working on same stream to get fairness in their scheduling and avoid starvation.\n- * To do this, before starting any processing, it fetches waiting request processor record from the store and if there\n- * is a record in the store and it doesnt match current processing request, then it simply postpones the current processing.\n- * Otherwise it attempts to process the event. If the event fails in its processing because of contention with another\n- * process on a different processor, then it sets itself as the waiting request processor in the stream metadata. This will\n- * ensure that when other event processors complete their processing, they will not pick newer work until this processor\n- * processes at least one event.\n- * At the end of processing, each processor attempts to clean up waiting request processor record from the store if it\n- * was set against its name.\n  */\n @Slf4j\n public abstract class AbstractTableRequestProcessor<T extends ControllerEvent> extends SerializedRequestHandler<T> implements TableRequestProcessor {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxOTgzNA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432619834", "bodyText": "nit: don't\nAlso, please elaborate more about why the check for table id mismatch is necessary", "author": "shiveshr", "createdAt": "2020-05-29T17:04:41Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDA3OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433174078", "bodyText": "Ok.", "author": "pbelgundi", "createdAt": "2020-06-01T11:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxOTgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTU2NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181564", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-01T11:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxOTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 2ceb441a3..4c25bfc5f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -14,10 +14,8 @@ import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n-import io.pravega.controller.store.stream.CreateStreamResponse;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n import io.pravega.controller.store.stream.State;\n-import io.pravega.controller.stream.api.grpc.v1.Controller;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDk5OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432620998", "bodyText": "change the CreateStreamResponse to CreateKVTResponse", "author": "shiveshr", "createdAt": "2020-05-29T17:06:33Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)\n+                        .thenComposeAsync(response -> {\n+                            // only if its a new kvtable or an already existing non-active kvtable then we will create\n+                            // segments and change the state of the kvtable to active.\n+                            if (response.getStatus().equals(CreateKVTableResponse.CreateStatus.NEW) ||\n+                                    response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTUwMw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181503", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-01T11:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 2ceb441a3..4c25bfc5f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -14,10 +14,8 @@ import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n-import io.pravega.controller.store.stream.CreateStreamResponse;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n import io.pravega.controller.store.stream.State;\n-import io.pravega.controller.stream.api.grpc.v1.Controller;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzI5OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432623298", "bodyText": "There is one decision to take here -- do you wish to always complete the create table OR fail it after some retries if it cannot be created due to intermittent retryable exceptions?\nIf its former, then wrap this method in a retry block that retries indefinitely on retryable predicate being e -> Exceptions.unwrap(e) instance of RetryableException", "author": "shiveshr", "createdAt": "2020-05-29T17:09:44Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDM3Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432624372", "bodyText": "If its latter, do note that the event could be replayed during controller failover. So if you dont retry forever, then you need to record the failure state.", "author": "shiveshr", "createdAt": "2020-05-29T17:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTIzMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181231", "bodyText": "Ok. Will do this.", "author": "pbelgundi", "createdAt": "2020-06-01T11:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMjk2MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433702961", "bodyText": "Implemented withRetries() inside createTableTask.execute() and in TableMetadataTasks.createKeyValueTable(). Please check and provide feedback, if I'm doing it right.", "author": "pbelgundi", "createdAt": "2020-06-02T08:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzI5OA=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 2ceb441a3..4c25bfc5f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -14,10 +14,8 @@ import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n-import io.pravega.controller.store.stream.CreateStreamResponse;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n import io.pravega.controller.store.stream.State;\n-import io.pravega.controller.stream.api.grpc.v1.Controller;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNTMyOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432625328", "bodyText": "add a common top level retry.", "author": "shiveshr", "createdAt": "2020-05-29T17:13:55Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)\n+                        .thenComposeAsync(response -> {\n+                            // only if its a new kvtable or an already existing non-active kvtable then we will create\n+                            // segments and change the state of the kvtable to active.\n+                            if (response.getStatus().equals(CreateKVTableResponse.CreateStatus.NEW) ||\n+                                    response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {\n+                                final int startingSegmentNumber = response.getStartingSegmentNumber();\n+                                final int minNumSegments = response.getConfiguration().getPartitionCount();\n+                                List<Long> newSegments = IntStream.range(startingSegmentNumber, startingSegmentNumber + minNumSegments)\n+                                        .boxed()\n+                                        .map(x -> NameUtils.computeSegmentId(x, 0))\n+                                        .collect(Collectors.toList());\n+                                return kvtMetadataTasks.notifyNewSegments(scope, kvt, newSegments, requestId)\n+                                        .thenCompose(y -> {\n+                                            final KVTOperationContext context = kvtMetadataStore.createContext(scope, kvt);\n+                                            //TODO: add withRetries", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMzI4Nw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433703287", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-02T08:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNTMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 2ceb441a3..4c25bfc5f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -14,10 +14,8 @@ import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n-import io.pravega.controller.store.stream.CreateStreamResponse;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n import io.pravega.controller.store.stream.State;\n-import io.pravega.controller.stream.api.grpc.v1.Controller;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTg1Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432631853", "bodyText": "please open an issue for creating in memory store later", "author": "shiveshr", "createdAt": "2020-05-29T17:26:26Z", "path": "controller/src/main/java/io/pravega/controller/store/kvtable/KVTableStoreFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.store.kvtable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.client.StoreClient;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.curator.framework.CuratorFramework;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+public class KVTableStoreFactory {\n+\n+    public static KVTableMetadataStore createStore(final StoreClient storeClient, final SegmentHelper segmentHelper,\n+                                                   final GrpcAuthHelper authHelper, final ScheduledExecutorService executor) {\n+        switch (storeClient.getType()) {\n+            case PravegaTable:\n+                return new PravegaTablesKVTMetadataStore(segmentHelper, (CuratorFramework) storeClient.getClient(), executor, authHelper);\n+            default:\n+                throw new NotImplementedException(storeClient.getType().toString());\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    public static KVTableMetadataStore createPravegaTablesStore(final SegmentHelper segmentHelper, final GrpcAuthHelper authHelper,\n+                                                                final CuratorFramework client, final ScheduledExecutorService executor) {\n+        return new PravegaTablesKVTMetadataStore(segmentHelper, client, executor, authHelper);\n+    }\n+    \n+    @VisibleForTesting\n+    public static KVTableMetadataStore createZKStore(final CuratorFramework client, final ScheduledExecutorService executor) {\n+        throw new UnsupportedOperationException(\"ZKStore not supported for KeyValueTables\");\n+    }\n+    \n+    @VisibleForTesting\n+    public static KVTableMetadataStore createInMemoryStore(final Executor executor) {", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDc2Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433174762", "bodyText": "I would need to do it right now itself for the UTs. Will add in subsequent commits.", "author": "pbelgundi", "createdAt": "2020-06-01T11:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NzM0MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434297341", "bodyText": "Done.", "author": "pbelgundi", "createdAt": "2020-06-03T04:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTg1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableStoreFactory.java b/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableStoreFactory.java\nindex 06c79b595..b976631fc 100644\n--- a/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableStoreFactory.java\n+++ b/controller/src/main/java/io/pravega/controller/store/kvtable/KVTableStoreFactory.java\n\n@@ -26,6 +26,10 @@ public class KVTableStoreFactory {\n         switch (storeClient.getType()) {\n             case PravegaTable:\n                 return new PravegaTablesKVTMetadataStore(segmentHelper, (CuratorFramework) storeClient.getClient(), executor, authHelper);\n+            case InMemory:\n+                return new InMemoryKVTMetadataStore(executor);\n+            case Zookeeper:\n+                return new ZookeeperKVTMetadataStore((CuratorFramework) storeClient.getClient(), executor);\n             default:\n                 throw new NotImplementedException(storeClient.getType().toString());\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432911642", "bodyText": "you cannot get DataExistsException from isCreated method.\nThe task will complete. You are checking when the task completes using isCreated method.. Once complete, you should check if the table config and table creation time are as expected by the current request.. if they do, its a tableExists exception.", "author": "shiveshr", "createdAt": "2020-05-31T05:35:02Z", "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(State.UNKNOWN) || state.equals(State.CREATING)) {\n+                        // 1. post event for CreateKVTable.\n+                        return  Futures.withCompletion(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(), createTimestamp, requestId, uuid);\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName))\n+                                                                            .thenApply(y -> CreateKeyValueTableStatus.Status.SUCCESS));\n+                                                        }),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NjE0NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433176144", "bodyText": "I could get a DataExistsException when createEntryForKVTable() is invoked and the intent of this check is to check guard against that.", "author": "pbelgundi", "createdAt": "2020-06-01T11:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODE5Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358196", "bodyText": "what are you doing if you get DataExists exception?\nsecondly, the two phases are separate -- 1. submitting the request, 2. tracking the request..\nso do the handling of errors from two phases separately so that you know and are able to define handling specific to the phase.", "author": "shiveshr", "createdAt": "2020-06-07T12:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1NTA2OQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436455069", "bodyText": "DataExistsException here indicates that an entry for a KVTable with this name exists in the scopesTables. So we're returning TABLE_EXISTS exception in this case to the User and event for table creation is not sent out.", "author": "pbelgundi", "createdAt": "2020-06-08T04:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0OTg2Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437149863", "bodyText": "consider the case where two concurrent createTables come.. one gets data exists exception..\nit still needs to check if the table creation is complete or not.. so it should check the state.. and if state is non-active, then it should wait until the table is created before letting the  know..", "author": "shiveshr", "createdAt": "2020-06-09T05:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM5NDcyOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437394728", "bodyText": "Done as discussed. pls check....", "author": "pbelgundi", "createdAt": "2020-06-09T13:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\nindex 0b69410c9..e37b32e8e 100644\n--- a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n+++ b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n\n@@ -110,7 +110,7 @@ public class TableMetadataTasks implements AutoCloseable {\n                 .thenCompose(state -> {\n                     if (state.equals(State.UNKNOWN) || state.equals(State.CREATING)) {\n                         // 1. post event for CreateKVTable.\n-                        return  Futures.withCompletion(kvtMetadataStore.checkScopeExists(scope)\n+                        return  Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n                                 .thenCompose(exists -> {\n                                     if (exists) {\n                                         return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTc3MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r432911770", "bodyText": "this response is not being sent by the task.. the task completes asynchronously..\nThe submitter of the task doesnt get the response from the task.. it checks for task completion condition (desired goal state).", "author": "shiveshr", "createdAt": "2020-05-31T05:37:09Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.stream.CreateStreamResponse;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.stream.api.grpc.v1.Controller;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                // we don;t execute the request if Table IDs do not match\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)\n+                        .thenComposeAsync(response -> {\n+                            // only if its a new kvtable or an already existing non-active kvtable then we will create\n+                            // segments and change the state of the kvtable to active.\n+                            if (response.getStatus().equals(CreateKVTableResponse.CreateStatus.NEW) ||\n+                                    response.getStatus().equals(CreateStreamResponse.CreateStatus.EXISTS_CREATING)) {\n+                                final int startingSegmentNumber = response.getStartingSegmentNumber();\n+                                final int minNumSegments = response.getConfiguration().getPartitionCount();\n+                                List<Long> newSegments = IntStream.range(startingSegmentNumber, startingSegmentNumber + minNumSegments)\n+                                        .boxed()\n+                                        .map(x -> NameUtils.computeSegmentId(x, 0))\n+                                        .collect(Collectors.toList());\n+                                return kvtMetadataTasks.notifyNewSegments(scope, kvt, newSegments, requestId)\n+                                        .thenCompose(y -> {\n+                                            final KVTOperationContext context = kvtMetadataStore.createContext(scope, kvt);\n+                                            //TODO: add withRetries\n+                                            kvtMetadataStore.getVersionedState(scope, kvt, context, executor)\n+                                                    .thenCompose(state -> {\n+                                                        if (state.getObject().equals(State.CREATING)) {\n+                                                            kvtMetadataStore.updateVersionedState(scope, kvt, KVTableState.ACTIVE,\n+                                                                    state, context, executor);\n+                                                        }\n+                                                        return CompletableFuture.completedFuture(null);\n+                                                    });\n+                                            return CompletableFuture.completedFuture(null);\n+                                        });\n+                            }\n+                            return CompletableFuture.completedFuture(null);\n+                        });\n+                return CompletableFuture.completedFuture(null);\n+             }\n+        });\n+    }\n+\n+    private Controller.CreateKeyValueTableStatus.Status translate(CreateKVTableResponse.CreateStatus status) {", "originalCommit": "6e5b12efea5a0991df33a69e070176f3b271f534", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NjkwOQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433176909", "bodyText": "Ok. Will remove unused translate method.", "author": "pbelgundi", "createdAt": "2020-06-01T11:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTM0OQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r433181349", "bodyText": "done.", "author": "pbelgundi", "createdAt": "2020-06-01T11:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkxMTc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 2ceb441a3..4c25bfc5f 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -14,10 +14,8 @@ import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n-import io.pravega.controller.store.stream.CreateStreamResponse;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n import io.pravega.controller.store.stream.State;\n-import io.pravega.controller.stream.api.grpc.v1.Controller;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"oid": "b130080057d6810f694b84bb94baa38300022513", "url": "https://github.com/pravega/pravega/commit/b130080057d6810f694b84bb94baa38300022513", "message": "added getCurrentSegments API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-01T10:12:12Z", "type": "commit"}, {"oid": "cc289d0f90fc464a588894b8dfc74e3b1645041a", "url": "https://github.com/pravega/pravega/commit/cc289d0f90fc464a588894b8dfc74e3b1645041a", "message": "code review changes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-01T11:26:57Z", "type": "commit"}, {"oid": "2f55f9550e557959d6fcfbef8620df60e757c45f", "url": "https://github.com/pravega/pravega/commit/2f55f9550e557959d6fcfbef8620df60e757c45f", "message": "addressed code review comments for retries\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-02T08:14:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MTY4MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434341680", "bodyText": "nit: pls remove this", "author": "shiveshr", "createdAt": "2020-06-03T06:44:28Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -330,6 +367,8 @@ private SegmentRange convert(final String scope,\n         return listOfSegment;\n     }\n \n+\n+", "originalCommit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MjQwMw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434562403", "bodyText": "fixed.", "author": "pbelgundi", "createdAt": "2020-06-03T13:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MTY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\nindex 71480793d..6d32b58df 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n\n@@ -367,8 +367,6 @@ public class ControllerService {\n         return listOfSegment;\n     }\n \n-\n-\n     public CompletableFuture<TxnStatus> commitTransaction(final String scope, final String stream, final UUID txId,\n                                                           final String writerId, final long timestamp) {\n         Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MTg1Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434341853", "bodyText": "nit: revert", "author": "shiveshr", "createdAt": "2020-06-03T06:44:51Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java", "diffHunk": "@@ -126,22 +132,24 @@ public ControllerServiceStarter(ControllerServiceConfig serviceConfig, StoreClie\n \n     @VisibleForTesting\n     ControllerServiceStarter(ControllerServiceConfig serviceConfig, StoreClient storeClient, SegmentHelper segmentHelper) {\n-        this(serviceConfig, storeClient, segmentHelper, null, null);\n+        this(serviceConfig, storeClient, segmentHelper, null, null, null);\n     }\n \n     @VisibleForTesting\n     ControllerServiceStarter(ControllerServiceConfig serviceConfig, StoreClient storeClient, SegmentHelper segmentHelper,\n-                             ConnectionFactory connectionFactory, StreamMetadataStore streamStore) {\n+                             ConnectionFactory connectionFactory, StreamMetadataStore streamStore, KVTableMetadataStore kvtStore) {\n         this.serviceConfig = serviceConfig;\n         this.storeClient = storeClient;\n         this.objectId = \"ControllerServiceStarter\";\n         this.controllerReadyLatch = new CountDownLatch(1);\n         this.segmentHelperRef = Optional.ofNullable(segmentHelper);\n         this.connectionFactoryRef = Optional.ofNullable(connectionFactory);\n         this.streamMetadataStoreRef = Optional.ofNullable(streamStore);\n+        this.kvtMetaStoreRef = Optional.ofNullable(kvtStore);\n         this.storeClientFailureFuture = new CompletableFuture<>();\n     }\n \n+", "originalCommit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMDUyMA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435030520", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-04T06:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MTg1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java b/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java\nindex 133a6f5ae..6eda3cdcb 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerServiceStarter.java\n\n@@ -149,7 +149,6 @@ public class ControllerServiceStarter extends AbstractIdleService {\n         this.storeClientFailureFuture = new CompletableFuture<>();\n     }\n \n-\n     @Override\n     protected void startUp() {\n         long traceId = LoggerHelpers.traceEnterWithContext(log, this.objectId, \"startUp\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0Mjg4Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434342886", "bodyText": "revert", "author": "shiveshr", "createdAt": "2020-06-03T06:47:17Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java", "diffHunk": "@@ -91,6 +91,7 @@ public CommitRequestHandler(final StreamMetadataStore streamMetadataStore,\n     public CompletableFuture<Void> execute(CommitEvent event) {\n         String scope = event.getScope();\n         String stream = event.getStream();\n+", "originalCommit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMjY5Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435032693", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-04T06:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0Mjg4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5bd4492db9f4392dfa8af4ab68f411757ed0ff56", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java\nindex d946f498f..dfb586eb2 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/CommitRequestHandler.java\n\n@@ -91,7 +91,6 @@ public class CommitRequestHandler extends AbstractRequestProcessor<CommitEvent>\n     public CompletableFuture<Void> execute(CommitEvent event) {\n         String scope = event.getScope();\n         String stream = event.getStream();\n-\n         OperationContext context = streamMetadataStore.createContext(scope, stream);\n         log.debug(\"Attempting to commit available transactions on stream {}/{}\", event.getScope(), event.getStream());\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzAwMw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434343003", "bodyText": "revert", "author": "shiveshr", "createdAt": "2020-06-03T06:47:33Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java", "diffHunk": "@@ -162,4 +162,4 @@ public ScaleOperationTask(final StreamMetadataTasks streamMetadataTasks,\n         return streamMetadataStore.getState(event.getScope(), event.getStream(), true, null, executor)\n                                   .thenApply(state -> state.equals(State.SCALING));\n     }\n-}\n+}", "originalCommit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMjU5Nw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435032597", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-04T06:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0MzAwMw=="}], "type": "inlineReview", "revised_code": {"commit": "5bd4492db9f4392dfa8af4ab68f411757ed0ff56", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java\nindex f773886e6..9ae789607 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/ScaleOperationTask.java\n\n@@ -162,4 +162,4 @@ public class ScaleOperationTask implements StreamTask<ScaleOpEvent> {\n         return streamMetadataStore.getState(event.getScope(), event.getStream(), true, null, executor)\n                                   .thenApply(state -> state.equals(State.SCALING));\n     }\n-}\n\\ No newline at end of file\n+}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NDQ0Nw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434344447", "bodyText": "even this is a network call so wrapping this in retries block for retryable errors is required.", "author": "shiveshr", "createdAt": "2020-06-03T06:50:56Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()", "originalCommit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMTgxMw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435031813", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-04T06:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NDQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 5d6ce422b..ff669e913 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -15,7 +15,6 @@ import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n-import io.pravega.controller.store.stream.State;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NTM5MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r434345391", "bodyText": "this code path is not returning anything . Also this withRetries, what is the retry condition here?", "author": "shiveshr", "createdAt": "2020-06-03T06:53:03Z", "path": "controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.server.eventProcessor.requesthandlers.kvtable;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.controller.store.kvtable.CreateKVTableResponse;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.controller.store.kvtable.KVTOperationContext;\n+import io.pravega.controller.store.stream.State;\n+import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n+import io.pravega.shared.NameUtils;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+/**\n+ * Request handler for performing scale operations received from requeststream.\n+ */\n+@Slf4j\n+public class CreateTableTask implements TableTask<CreateTableEvent> {\n+\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final TableMetadataTasks kvtMetadataTasks;\n+    private final ScheduledExecutorService executor;\n+\n+    public CreateTableTask(final KVTableMetadataStore kvtMetaStore,\n+                           final TableMetadataTasks kvtMetaTasks,\n+                           final ScheduledExecutorService executor) {\n+        Preconditions.checkNotNull(kvtMetaStore);\n+        Preconditions.checkNotNull(kvtMetaTasks);\n+        Preconditions.checkNotNull(executor);\n+        this.kvtMetadataStore = kvtMetaStore;\n+        this.kvtMetadataTasks = kvtMetaTasks;\n+        this.executor = executor;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> execute(final CreateTableEvent request) {\n+        String scope = request.getScopeName();\n+        String kvt = request.getKvtName();\n+        int partitionCount = request.getPartitionCount();\n+        long creationTime = request.getTimestamp();\n+        long requestId = request.getRequestId();\n+        String kvTableId = request.getTableId().toString();\n+        KeyValueTableConfiguration config = new KeyValueTableConfiguration(partitionCount);\n+\n+        return kvtMetadataStore.getKVTable(scope, kvt, null).getId()\n+        .thenCompose(id -> {\n+            if (!id.equals(kvTableId)) {\n+                return CompletableFuture.completedFuture(null);\n+            } else {\n+                withRetries(() -> this.kvtMetadataStore.createKeyValueTable(scope, kvt, config, creationTime, null, executor)", "originalCommit": "2f55f9550e557959d6fcfbef8620df60e757c45f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzMTcwNQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435031705", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-04T06:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NTM5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\nindex 5d6ce422b..ff669e913 100644\n--- a/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n+++ b/controller/src/main/java/io/pravega/controller/server/eventProcessor/requesthandlers/kvtable/CreateTableTask.java\n\n@@ -15,7 +15,6 @@ import io.pravega.controller.store.kvtable.KVTableState;\n import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n import io.pravega.controller.store.kvtable.KVTOperationContext;\n-import io.pravega.controller.store.stream.State;\n import io.pravega.controller.task.KeyValueTable.TableMetadataTasks;\n import io.pravega.shared.NameUtils;\n import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n"}}, {"oid": "5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "url": "https://github.com/pravega/pravega/commit/5a85e4194a11ec5a3497eb3012cdcc48fde9dc2d", "message": "fixed failing tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-03T13:18:21Z", "type": "commit"}, {"oid": "301efd36e0072e4322dd2b986586d9a7f16e5615", "url": "https://github.com/pravega/pravega/commit/301efd36e0072e4322dd2b986586d9a7f16e5615", "message": "code review comments for retries\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-03T16:14:28Z", "type": "commit"}, {"oid": "5bd4492db9f4392dfa8af4ab68f411757ed0ff56", "url": "https://github.com/pravega/pravega/commit/5bd4492db9f4392dfa8af4ab68f411757ed0ff56", "message": "fixed retry logic for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-04T06:58:15Z", "type": "commit"}, {"oid": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "url": "https://github.com/pravega/pravega/commit/43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "message": "Fixing integration tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-04T16:31:50Z", "type": "commit"}, {"oid": "4c068dc095fca55edf1591f7acc40a05b012d91a", "url": "https://github.com/pravega/pravega/commit/4c068dc095fca55edf1591f7acc40a05b012d91a", "message": "KeyValueTable Integration test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-05T16:17:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODM4MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435878381", "bodyText": "nit: revert please", "author": "shiveshr", "createdAt": "2020-06-05T12:09:20Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java", "diffHunk": "@@ -11,8 +11,10 @@\n \n import com.google.common.annotations.Beta;\n import java.io.Serializable;\n+", "originalCommit": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3OTA2Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436879063", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-08T17:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3ODM4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java b/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java\nindex 89774049a..004409652 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java\n\n@@ -11,7 +11,6 @@ package io.pravega.client.tables;\n \n import com.google.common.annotations.Beta;\n import java.io.Serializable;\n-\n import lombok.Builder;\n import lombok.Data;\n import lombok.Getter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3OTAxNQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435879015", "bodyText": "nit: revert", "author": "shiveshr", "createdAt": "2020-06-05T12:10:47Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -35,6 +35,7 @@\n import java.util.function.Predicate;\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n+", "originalCommit": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3OTAwNg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436879006", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-08T17:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3OTAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex f34b68423..c241cff3c 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -35,7 +35,6 @@ import java.util.function.Function;\n import java.util.function.Predicate;\n import java.util.function.Supplier;\n import java.util.stream.Collectors;\n-\n import lombok.Data;\n import lombok.SneakyThrows;\n import lombok.val;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MTc2OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r435881768", "bodyText": "nit: we have passed the executor to the store to use it to process the request, we dont need to do thenApplyAsync. we can simply do thenApply here", "author": "shiveshr", "createdAt": "2020-06-05T12:16:18Z", "path": "controller/src/main/java/io/pravega/controller/server/ControllerService.java", "diffHunk": "@@ -95,6 +102,36 @@\n         }, executor);\n     }\n \n+    public CompletableFuture<CreateKeyValueTableStatus> createKeyValueTable(String scope, String kvtName,\n+                                                                            final KeyValueTableConfiguration kvtConfig,\n+                                                                            final long createTimestamp) {\n+        Preconditions.checkNotNull(kvtConfig, \"kvTableConfig\");\n+        Preconditions.checkArgument(createTimestamp >= 0);\n+        Timer timer = new Timer();\n+        try {\n+            NameUtils.validateUserKeyValueTableName(kvtName);\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            log.warn(\"Create KeyValueTable failed due to invalid name {}\", kvtName);\n+            return CompletableFuture.completedFuture(\n+                    CreateKeyValueTableStatus.newBuilder().setStatus(CreateKeyValueTableStatus.Status.INVALID_TABLE_NAME).build());\n+        }\n+        return kvtMetadataTasks.createKeyValueTable(scope, kvtName, kvtConfig, createTimestamp)\n+                .thenApplyAsync(status -> {\n+                    reportCreateKVTableMetrics(scope, kvtName, kvtConfig.getPartitionCount(), status, timer.getElapsed());\n+                    return CreateKeyValueTableStatus.newBuilder().setStatus(status).build();\n+                }, executor);\n+\n+    }\n+\n+    public CompletableFuture<List<SegmentRange>> getCurrentSegmentsKeyValueTable(final String scope, final String kvtName) {\n+        Exceptions.checkNotNullOrEmpty(scope, \"scope\");\n+        Exceptions.checkNotNullOrEmpty(kvtName, \"KeyValueTable\");\n+\n+        // Fetch active segments from segment store.\n+        return kvtMetadataStore.getActiveSegments(scope, kvtName, null, executor)\n+                .thenApplyAsync(activeSegments -> getSegmentRanges(activeSegments, scope, kvtName), executor);", "originalCommit": "43494d0c773ddf0bb2c3bc54e6888c0c30ddd155", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg0ODgwMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436848801", "bodyText": "This is same as code for getCurrentSegments() on Stream. We could refactor this as part of a separate PR.", "author": "pbelgundi", "createdAt": "2020-06-08T16:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MTc2OA=="}], "type": "inlineReview", "revised_code": {"commit": "01cacbda1e057874f69a08847335251ad07a9b1e", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/server/ControllerService.java b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\nindex 6d32b58df..89d97f69e 100644\n--- a/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n+++ b/controller/src/main/java/io/pravega/controller/server/ControllerService.java\n\n@@ -115,12 +115,21 @@ public class ControllerService {\n             return CompletableFuture.completedFuture(\n                     CreateKeyValueTableStatus.newBuilder().setStatus(CreateKeyValueTableStatus.Status.INVALID_TABLE_NAME).build());\n         }\n-        return kvtMetadataTasks.createKeyValueTable(scope, kvtName, kvtConfig, createTimestamp)\n-                .thenApplyAsync(status -> {\n-                    reportCreateKVTableMetrics(scope, kvtName, kvtConfig.getPartitionCount(), status, timer.getElapsed());\n-                    return CreateKeyValueTableStatus.newBuilder().setStatus(status).build();\n-                }, executor);\n-\n+        return streamStore.checkStreamExists(scope, kvtName)\n+                .thenCompose(streamExists -> {\n+                    if (streamExists) {\n+                        // we can't have a stream and a kvtable with the same name inside the same scope.\n+                        return CompletableFuture.completedFuture(\n+                                CreateKeyValueTableStatus.newBuilder()\n+                                .setStatus(CreateKeyValueTableStatus.Status.STREAM_EXISTS).build());\n+                    } else {\n+                        return kvtMetadataTasks.createKeyValueTable(scope, kvtName, kvtConfig, createTimestamp)\n+                                .thenApplyAsync(status -> {\n+                                    reportCreateKVTableMetrics(scope, kvtName, kvtConfig.getPartitionCount(), status, timer.getElapsed());\n+                                    return CreateKeyValueTableStatus.newBuilder().setStatus(status).build();\n+                                }, executor);\n+                    }\n+                });\n     }\n \n     public CompletableFuture<List<SegmentRange>> getCurrentSegmentsKeyValueTable(final String scope, final String kvtName) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODA2Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358066", "bodyText": "the addIndexAndSubmitTask method gives atomic guarantee of posting event and updating a metadata..\nyou are not updating any metadata inside this. you are posting an event though.. so you can simply post the event in that case directly. you dont need addIndexAndSubmitTask method. basically then what it means is even if we create an entry into the KV tables, if we fail to post the event, the create is never processed. this is fine. the caller will get an error resulting from failure to post event anyway (or connection failure if controller crashed).\nAlternatively, if you want to use the atomic guarantee of addIndexAndSubmitTask method you can also do the following:\nUUID = new UUID(); // generate the id here instead of inside the store. and pass it to the store and include it in the event. \naddIndexAndSubmitTask(event, kvtMetadataStore.createEntryForKVTable(scope, kvtName, uuid, executor))\n\nnotice that i passed the ID to the kvmetadata store .. and if an id is already generated and exists in the table, this will fail with write conflict exception..\nyou can decide on the handling for the conflict - basically if another id is written, its event must have been posted too, and it will eventually complete.. so you can simply wait for the create to complete and respond with success or existing depending on what got created.\nMy personal preference will be the latter approach.", "author": "shiveshr", "createdAt": "2020-06-07T12:26:30Z", "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                        return Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(v -> kvtMetadataStore.getKVTable(scope, kvtName, null).getId()\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                                                                        createTimestamp, requestId, UUID.fromString(uuid));\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))", "originalCommit": "4c068dc095fca55edf1591f7acc40a05b012d91a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3MTA4OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436571088", "bodyText": "Sure. Made changes as per latter approach.", "author": "pbelgundi", "createdAt": "2020-06-08T09:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODA2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MDU5NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437150595", "bodyText": "i still see\n                                                            return addIndexAndSubmitTask(event,\n                                                                    () -> CompletableFuture.completedFuture(null))", "author": "shiveshr", "createdAt": "2020-06-09T05:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODA2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9c5ed58cd7f2275e23e558550b014031254b8e28", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\nindex a2cb8e8fa..da9d8ee0e 100644\n--- a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n+++ b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n\n@@ -18,6 +18,7 @@ import io.pravega.common.Exceptions;\n import io.pravega.common.concurrent.Futures;\n import io.pravega.common.tracing.RequestTracker;\n import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n import io.pravega.controller.retryable.RetryableException;\n import io.pravega.controller.server.SegmentHelper;\n import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODI5Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358296", "bodyText": "please pull latest master and use the timeout mechanism used there..", "author": "shiveshr", "createdAt": "2020-06-07T12:29:44Z", "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                        return Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(v -> kvtMetadataStore.getKVTable(scope, kvtName, null).getId()\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                                                                        createTimestamp, requestId, UUID.fromString(uuid));\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                                                                            .thenCompose(y -> kvtMetadataStore.getConfiguration(scope, kvtName, null, executor)\n+                                                                            .thenCompose(cfg -> {\n+                                                                                if (cfg.getPartitionCount() == kvtConfig.getPartitionCount()) {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SUCCESS);\n+                                                                                } else {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                                                                }\n+                                                                            })));\n+                                                        })),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,\n+                                                CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                    } else {\n+                                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                                    }\n+                                }), executor);\n+                    } else {\n+                       return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                    }\n+                }), e -> Exceptions.unwrap(e) instanceof RetryableException, Integer.MAX_VALUE, executor);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition) {\n+        return checkDone(condition, 100L);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition, long delay) {\n+        AtomicBoolean isDone = new AtomicBoolean(false);", "originalCommit": "4c068dc095fca55edf1591f7acc40a05b012d91a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzODQ0OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437138448", "bodyText": "The upstream for this branch, is feature branch feature-key-value-tables on pravega/pravega and that is not updated yet with changes from master. I'd want to put this off till the upstream is updated..... Can add this as part of my next PR for DeleteAPI.", "author": "pbelgundi", "createdAt": "2020-06-09T05:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4NzE2NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437187164", "bodyText": "Sure. Add a todo comment here please.", "author": "shiveshr", "createdAt": "2020-06-09T07:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9c5ed58cd7f2275e23e558550b014031254b8e28", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\nindex a2cb8e8fa..da9d8ee0e 100644\n--- a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n+++ b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n\n@@ -18,6 +18,7 @@ import io.pravega.common.Exceptions;\n import io.pravega.common.concurrent.Futures;\n import io.pravega.common.tracing.RequestTracker;\n import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n import io.pravega.controller.retryable.RetryableException;\n import io.pravega.controller.server.SegmentHelper;\n import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODM5NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436358395", "bodyText": "we should move this index and submit task to a helper class as this is identical to the code in streammetadatatasks.java", "author": "shiveshr", "createdAt": "2020-06-07T12:30:43Z", "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> {\n+                    if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                        return Futures.completeOn(kvtMetadataStore.checkScopeExists(scope)\n+                                .thenCompose(exists -> {\n+                                    if (exists) {\n+                                        return Futures.exceptionallyExpecting(kvtMetadataStore.createEntryForKVTable(scope, kvtName, executor)\n+                                                        .thenCompose(v -> kvtMetadataStore.getKVTable(scope, kvtName, null).getId()\n+                                                        .thenCompose(uuid -> {\n+                                                            CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                                                                        createTimestamp, requestId, UUID.fromString(uuid));\n+                                                            return addIndexAndSubmitTask(event,\n+                                                                    () -> CompletableFuture.completedFuture(null))\n+                                                                    .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                                                                            .thenCompose(y -> kvtMetadataStore.getConfiguration(scope, kvtName, null, executor)\n+                                                                            .thenCompose(cfg -> {\n+                                                                                if (cfg.getPartitionCount() == kvtConfig.getPartitionCount()) {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SUCCESS);\n+                                                                                } else {\n+                                                                                   return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                                                                }\n+                                                                            })));\n+                                                        })),\n+                                                e -> Exceptions.unwrap(e) instanceof StoreException.DataExistsException,\n+                                                CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                                    } else {\n+                                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                                    }\n+                                }), executor);\n+                    } else {\n+                       return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                    }\n+                }), e -> Exceptions.unwrap(e) instanceof RetryableException, Integer.MAX_VALUE, executor);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition) {\n+        return checkDone(condition, 100L);\n+    }\n+\n+    private CompletableFuture<Void> checkDone(Supplier<CompletableFuture<Boolean>> condition, long delay) {\n+        AtomicBoolean isDone = new AtomicBoolean(false);\n+        return Futures.loop(() -> !isDone.get(),\n+                () -> Futures.delayedFuture(condition, delay, executor)\n+                        .thenAccept(isDone::set), executor);\n+    }\n+\n+    private CompletableFuture<Boolean> isCreated(String scope, String kvtName, KeyValueTableConfiguration kvtConfig, Executor executor) {\n+       return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                .thenCompose(state -> CompletableFuture.completedFuture(state.equals(KVTableState.ACTIVE)));\n+    }\n+\n+    @VisibleForTesting\n+    public void setRequestEventWriter(EventStreamWriter<ControllerEvent> requestEventWriter) {\n+        requestEventWriterRef.set(requestEventWriter);\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     * This method takes an event and a future supplier and guarantees that if future supplier has been executed then event will\n+     * be posted in request stream. It does it by following approach:\n+     * 1. it first adds the index for the event to be posted to the current host.\n+     * 2. it then invokes future.\n+     * 3. it then posts event.\n+     * 4. removes the index.\n+     *\n+     * If controller fails after step 2, a replacement controller will failover all indexes and {@link RequestSweeper} will\n+     * post events for any index that is found.\n+     *\n+     * Upon failover, an index can be found if failure occurred in any step before 3. It is safe to post duplicate events\n+     * because event processing is idempotent. It is also safe to post event even if step 2 was not performed because the\n+     * event will be ignored by the processor after a while.\n+     *\n+     * @param event      Event to publish.\n+     * @param futureSupplier  Supplier future to execute before submitting event.\n+     * @return CompletableFuture<T> returned by Supplier or Exception.\n+     */\n+    @VisibleForTesting\n+    <T> CompletableFuture<T> addIndexAndSubmitTask(ControllerEvent event, Supplier<CompletableFuture<T>> futureSupplier) {", "originalCommit": "4c068dc095fca55edf1591f7acc40a05b012d91a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM5NTA0NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437395045", "bodyText": "done.", "author": "pbelgundi", "createdAt": "2020-06-09T13:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9c5ed58cd7f2275e23e558550b014031254b8e28", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\nindex a2cb8e8fa..da9d8ee0e 100644\n--- a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n+++ b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n\n@@ -18,6 +18,7 @@ import io.pravega.common.Exceptions;\n import io.pravega.common.concurrent.Futures;\n import io.pravega.common.tracing.RequestTracker;\n import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n import io.pravega.controller.retryable.RetryableException;\n import io.pravega.controller.server.SegmentHelper;\n import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n"}}, {"oid": "9c5ed58cd7f2275e23e558550b014031254b8e28", "url": "https://github.com/pravega/pravega/commit/9c5ed58cd7f2275e23e558550b014031254b8e28", "message": "changes for code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-08T09:33:57Z", "type": "commit"}, {"oid": "1ac7d3d082cdeaa543a9bbf3185644b93e815ab5", "url": "https://github.com/pravega/pravega/commit/1ac7d3d082cdeaa543a9bbf3185644b93e815ab5", "message": "testfix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-08T12:19:52Z", "type": "commit"}, {"oid": "955ba7a4455dca423e95e998b6c3be84fb38669c", "url": "https://github.com/pravega/pravega/commit/955ba7a4455dca423e95e998b6c3be84fb38669c", "message": "KVTIntegration test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-08T13:55:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MDkzMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436780931", "bodyText": "Why do you need this?", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:07:15Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;\n+\n+        // 1. Start ZK\n+        this.zkTestServer = new TestingServerStarter().start();\n+\n+        // 2. Start Pravega SegmentStore service.\n         this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n-        this.serviceBuilder.initialize();\n-        this.tableStore = this.serviceBuilder.createTableStoreService();\n-        int port = TestUtils.getAvailableListenPort();\n-        this.serverListener = new PravegaConnectionListener(false, port, mock(StreamSegmentStore.class), this.tableStore);\n-        this.serverListener.startListening();\n+        serviceBuilder.initialize();\n+        StreamSegmentStore store = serviceBuilder.createStreamSegmentService();", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NDU5Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436854596", "bodyText": "Integration Tests should not use mocks.", "author": "pbelgundi", "createdAt": "2020-06-08T16:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MDkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex cb081b094..cab9463b4 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -42,6 +42,8 @@ import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import static org.mockito.Mockito.mock;\n+\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MTU1NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436781554", "bodyText": "This is a configuration. Move it to the private static final section at the top of this file and make sure you pass this value to the Segment Store as well. Otherwise if we change this at one point the test will stop working.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:08:13Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NDc0Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436854743", "bodyText": "Ok", "author": "pbelgundi", "createdAt": "2020-06-08T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MTU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NjIwNw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436876207", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-08T17:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MTU1NA=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex cb081b094..cab9463b4 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -42,6 +42,8 @@ import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import static org.mockito.Mockito.mock;\n+\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjAzMg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436782032", "bodyText": "Revert all these lines that made no actual change. Keep the code consistent. Either everything references this. or nothing.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:08:55Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;\n+\n+        // 1. Start ZK\n+        this.zkTestServer = new TestingServerStarter().start();\n+\n+        // 2. Start Pravega SegmentStore service.\n         this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n-        this.serviceBuilder.initialize();", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NjExOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436876118", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-08T17:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjAzMg=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex cb081b094..cab9463b4 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -42,6 +42,8 @@ import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import static org.mockito.Mockito.mock;\n+\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjEzNA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436782134", "bodyText": "Why?", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:09:04Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NjA0OQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436876049", "bodyText": "copy-paste error. changed back to serverListener.", "author": "pbelgundi", "createdAt": "2020-06-08T17:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4MjEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex cb081b094..cab9463b4 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -42,6 +42,8 @@ import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import static org.mockito.Mockito.mock;\n+\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4Mjg2MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436782861", "bodyText": "Why did you use this pattern here and not apply it to everything else? For cleanliness, I suggest you don't bother with this check.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:10:10Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -22,63 +22,98 @@\n import io.pravega.client.tables.impl.KeyValueTableFactoryImpl;\n import io.pravega.client.tables.impl.KeyValueTableTestBase;\n import io.pravega.common.util.ByteArraySegment;\n-import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+\n import io.pravega.segmentstore.contracts.StreamSegmentStore;\n import io.pravega.segmentstore.contracts.tables.TableStore;\n import io.pravega.segmentstore.server.host.handler.PravegaConnectionListener;\n import io.pravega.segmentstore.server.store.ServiceBuilder;\n import io.pravega.segmentstore.server.store.ServiceBuilderConfig;\n-import io.pravega.test.common.AssertExtensions;\n import io.pravega.test.common.TestUtils;\n-import java.time.Duration;\n import java.util.Collections;\n+import java.time.Duration;\n+import io.pravega.test.common.TestingServerStarter;\n+import io.pravega.test.integration.demo.ControllerWrapper;\n+import lombok.extern.slf4j.Slf4j;\n import lombok.val;\n+import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n+ * import io.pravega.segmentstore.contracts.StreamSegmentNotExistsException;\n+ * //import io.pravega.test.common.AssertExtensions;\n  */\n+@Slf4j\n public class KeyValueTableTest extends KeyValueTableTestBase {\n     private static final String ENDPOINT = \"localhost\";\n     private static final String SCOPE = \"Scope\";\n     private static final KeyValueTableConfiguration DEFAULT_CONFIG = KeyValueTableConfiguration.builder().partitionCount(5).build();\n     private static final Duration TIMEOUT = Duration.ofSeconds(30);\n     private ServiceBuilder serviceBuilder;\n     private TableStore tableStore;\n-    private PravegaConnectionListener serverListener;\n+    private PravegaConnectionListener server = null;\n     private ConnectionFactory connectionFactory;\n+    private TestingServer zkTestServer = null;\n+    private ControllerWrapper controllerWrapper = null;\n     private Controller controller;\n     private KeyValueTableFactory keyValueTableFactory;\n \n+\n     @Before\n     public void setup() throws Exception {\n         super.setup();\n+\n+        final int controllerPort = TestUtils.getAvailableListenPort();\n+        final String serviceHost = ENDPOINT;\n+        final int servicePort = TestUtils.getAvailableListenPort();\n+        final int containerCount = 4;\n+\n+        // 1. Start ZK\n+        this.zkTestServer = new TestingServerStarter().start();\n+\n+        // 2. Start Pravega SegmentStore service.\n         this.serviceBuilder = ServiceBuilder.newInMemoryBuilder(ServiceBuilderConfig.getDefaultConfig());\n-        this.serviceBuilder.initialize();\n-        this.tableStore = this.serviceBuilder.createTableStoreService();\n-        int port = TestUtils.getAvailableListenPort();\n-        this.serverListener = new PravegaConnectionListener(false, port, mock(StreamSegmentStore.class), this.tableStore);\n-        this.serverListener.startListening();\n+        serviceBuilder.initialize();\n+        StreamSegmentStore store = serviceBuilder.createStreamSegmentService();\n+        this.tableStore = serviceBuilder.createTableStoreService();\n \n-        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());\n-        this.controller = new MockController(ENDPOINT, port, this.connectionFactory, true);\n+        this.server = new PravegaConnectionListener(false, servicePort, store, tableStore);\n+        this.server.startListening();\n+\n+        // 3. Start Pravega Controller service\n+        this.controllerWrapper = new ControllerWrapper(zkTestServer.getConnectString(), false,\n+                controllerPort, serviceHost, servicePort, containerCount);\n+        this.controllerWrapper.awaitRunning();\n+        this.controller = controllerWrapper.getController();\n+\n+        //4. Create Scope\n         this.controller.createScope(SCOPE);\n+        this.connectionFactory = new ConnectionFactoryImpl(ClientConfig.builder().build());\n         this.keyValueTableFactory = new KeyValueTableFactoryImpl(SCOPE, this.controller, this.connectionFactory);\n     }\n \n+\n     @After\n-    public void tearDown() {\n+    public void tearDown() throws Exception {\n         this.controller.close();\n         this.connectionFactory.close();\n-        this.serverListener.close();\n+\n+        if (this.controllerWrapper != null) {", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NTk5Nw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436875997", "bodyText": "ok removed.", "author": "pbelgundi", "createdAt": "2020-06-08T17:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4Mjg2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex cb081b094..cab9463b4 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -42,6 +42,8 @@ import org.junit.Before;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import static org.mockito.Mockito.mock;\n+\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4Mzk3MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436783971", "bodyText": "Uncomment this. If Delete is not implemented, add a TODO with a GitHub issue reference.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:11:46Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -91,16 +126,17 @@ public void testCreateDeleteKeyValueTable() {\n         Assert.assertTrue(created);\n         val segments = this.controller.getCurrentSegmentsForKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName()).join();\n         Assert.assertEquals(DEFAULT_CONFIG.getPartitionCount(), segments.getSegments().size());\n+\n         for (val s : segments.getSegments()) {\n             // We know there's nothing in these segments. But if the segments hadn't been created, then this will throw\n             // an exception.\n-            this.tableStore.get(s.getScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT).join();\n+            this.tableStore.get(s.getKVTScopedName(), Collections.singletonList(new ByteArraySegment(new byte[1])), TIMEOUT).join();\n         }\n \n         // Verify re-creation does not work.\n         Assert.assertFalse(this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join());\n-\n         // Delete and verify segments have been deleted too.\n+        /*", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "23eebf743d8df56f5c908a9b65a45592bd269011", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex cb081b094..f42504ade 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -121,6 +105,7 @@ public class KeyValueTableTest extends KeyValueTableTestBase {\n      */\n     @Test\n     public void testCreateDeleteKeyValueTable() {\n+        Assert.assertTrue(isScopeCreated);\n         val kvt = newKeyValueTableName();\n         boolean created = this.controller.createKeyValueTable(kvt.getScope(), kvt.getKeyValueTableName(), DEFAULT_CONFIG).join();\n         Assert.assertTrue(created);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NTExOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436785118", "bodyText": "Revert changes to this file. the @Data annotation creates getters and constructors.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:13:28Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java", "diffHunk": "@@ -26,5 +28,11 @@\n      * The number of Partitions for a Key-Value Table. This value cannot be adjusted after the Key-Value Table has been\n      * created.\n      */\n+    @Getter\n     private final int partitionCount;\n+\n+    public KeyValueTableConfiguration(int partitionCount) {", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxMzA2MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r440313060", "bodyText": "done.", "author": "pbelgundi", "createdAt": "2020-06-15T16:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NTExOA=="}], "type": "inlineReview", "revised_code": {"commit": "8533890a91b15e18315354f2dfdadd1e8474e393", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java b/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java\nindex 89774049a..6b2dbd58d 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTableConfiguration.java\n\n@@ -28,11 +26,5 @@ public class KeyValueTableConfiguration implements Serializable {\n      * The number of Partitions for a Key-Value Table. This value cannot be adjusted after the Key-Value Table has been\n      * created.\n      */\n-    @Getter\n     private final int partitionCount;\n-\n-    public KeyValueTableConfiguration(int partitionCount) {\n-        this.partitionCount = partitionCount;\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NTY3MQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436785671", "bodyText": "Rephrase this as:\nReturns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}. This helps transfer the downstream callback executions on another executor.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:14:18Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01cacbda1e057874f69a08847335251ad07a9b1e", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex f34b68423..657563d9b 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -46,14 +45,13 @@ import lombok.val;\n public final class Futures {\n \n     /**\n-     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n-     * So any chaining, if done without specifying an executor, will either happen on\n-     * caller's executor or fork join pool but never on someone else's executor.\n+     * Returns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}.\n+     * This helps transfer the downstream callback executions on another executor.\n      *\n      * @param future The future to execute.\n      * @param <T> The Type of the future's result.\n-     * @param executor The executor for executing the future.\n-     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     * @param executor The executor to transfer callback execution onto.\n+     * @return A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.\n      */\n     public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzE1NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436787155", "bodyText": "The future is not \"to execute\". The future is some object that will be completed after execution. Chances are that the execution of the backing task is already underway.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:16:14Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwNzEzMw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r440307133", "bodyText": "Fixed.", "author": "pbelgundi", "createdAt": "2020-06-15T16:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzE1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "01cacbda1e057874f69a08847335251ad07a9b1e", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex f34b68423..657563d9b 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -46,14 +45,13 @@ import lombok.val;\n public final class Futures {\n \n     /**\n-     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n-     * So any chaining, if done without specifying an executor, will either happen on\n-     * caller's executor or fork join pool but never on someone else's executor.\n+     * Returns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}.\n+     * This helps transfer the downstream callback executions on another executor.\n      *\n      * @param future The future to execute.\n      * @param <T> The Type of the future's result.\n-     * @param executor The executor for executing the future.\n-     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     * @param executor The executor to transfer callback execution onto.\n+     * @return A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.\n      */\n     public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzM4MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436787380", "bodyText": "The executor to transfer callback execution onto.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:16:33Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.\n+     * @param <T> The Type of the future's result.\n+     * @param executor The executor for executing the future.", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01cacbda1e057874f69a08847335251ad07a9b1e", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex f34b68423..657563d9b 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -46,14 +45,13 @@ import lombok.val;\n public final class Futures {\n \n     /**\n-     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n-     * So any chaining, if done without specifying an executor, will either happen on\n-     * caller's executor or fork join pool but never on someone else's executor.\n+     * Returns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}.\n+     * This helps transfer the downstream callback executions on another executor.\n      *\n      * @param future The future to execute.\n      * @param <T> The Type of the future's result.\n-     * @param executor The executor for executing the future.\n-     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     * @param executor The executor to transfer callback execution onto.\n+     * @return A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.\n      */\n     public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4NzkwOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436787908", "bodyText": "A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:17:13Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.\n+     * @param <T> The Type of the future's result.\n+     * @param executor The executor for executing the future.\n+     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "01cacbda1e057874f69a08847335251ad07a9b1e", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex f34b68423..657563d9b 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -46,14 +45,13 @@ import lombok.val;\n public final class Futures {\n \n     /**\n-     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n-     * So any chaining, if done without specifying an executor, will either happen on\n-     * caller's executor or fork join pool but never on someone else's executor.\n+     * Returns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}.\n+     * This helps transfer the downstream callback executions on another executor.\n      *\n      * @param future The future to execute.\n      * @param <T> The Type of the future's result.\n-     * @param executor The executor for executing the future.\n-     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     * @param executor The executor to transfer callback execution onto.\n+     * @return A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.\n      */\n     public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4ODM3NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436788375", "bodyText": "This method does not have any unit tests. Please write some.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:17:53Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -44,6 +45,31 @@\n  */\n public final class Futures {\n \n+    /**\n+     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n+     * So any chaining, if done without specifying an executor, will either happen on\n+     * caller's executor or fork join pool but never on someone else's executor.\n+     *\n+     * @param future The future to execute.\n+     * @param <T> The Type of the future's result.\n+     * @param executor The executor for executing the future.\n+     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     */\n+    public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwMzkzOA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r440303938", "bodyText": "Ok. Added UTs to cover this.", "author": "pbelgundi", "createdAt": "2020-06-15T16:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc4ODM3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "01cacbda1e057874f69a08847335251ad07a9b1e", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex f34b68423..657563d9b 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -46,14 +45,13 @@ import lombok.val;\n public final class Futures {\n \n     /**\n-     * Makes sure that the result future given out to caller is actually completed on caller's executor.\n-     * So any chaining, if done without specifying an executor, will either happen on\n-     * caller's executor or fork join pool but never on someone else's executor.\n+     * Returns a new {@link CompletableFuture} that completes with the same outcome as the given one, but on the given {@link Executor}.\n+     * This helps transfer the downstream callback executions on another executor.\n      *\n      * @param future The future to execute.\n      * @param <T> The Type of the future's result.\n-     * @param executor The executor for executing the future.\n-     * @return <T>CompletableFuture<T> Result of execution, successful or exceptional.\n+     * @param executor The executor to transfer callback execution onto.\n+     * @return A new {@link CompletableFuture} that will complete with the same outcome as the given one, but on the given {@link Executor}.\n      */\n     public static <T> CompletableFuture<T> completeOn(CompletableFuture<T> future, final Executor executor) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MDg4MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436790880", "bodyText": "Why did you make this change?", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:21:33Z", "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorTest.java", "diffHunk": "@@ -89,7 +89,7 @@\n import static org.mockito.Mockito.when;\n \n @Slf4j\n-public class PravegaRequestProcessorTest {\n+public class PravegaStreamRequestProcessorTest {", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\nsimilarity index 99%\nrename from segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorTest.java\nrename to segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\nindex 8e38f4e78..1af2c5b8a 100644\n--- a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorTest.java\n+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorTest.java\n\n@@ -89,7 +89,7 @@ import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.mockito.Mockito.when;\n \n @Slf4j\n-public class PravegaStreamRequestProcessorTest {\n+public class PravegaRequestProcessorTest {\n \n     private static final int MAX_KEY_LENGTH = 100;\n     private static final int MAX_VALUE_LENGTH = 100;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MDk1MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436790950", "bodyText": "Revert", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:21:38Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/containers/TableMetadataStore.java", "diffHunk": "@@ -51,7 +51,6 @@\n     private final TableStore tableStore;\n     private final String metadataSegmentName;\n     private final AtomicBoolean initialized;\n-", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MTA3NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436791075", "bodyText": "Revert", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:21:48Z", "path": "segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorAuthFailedTest.java", "diffHunk": "@@ -23,7 +23,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n \n-public class PravegaRequestProcessorAuthFailedTest {\n+public class PravegaStreamRequestProcessorAuthFailedTest {", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MDI3OQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436860279", "bodyText": "Ok. done", "author": "pbelgundi", "createdAt": "2020-06-08T17:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MTA3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorAuthFailedTest.java b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorAuthFailedTest.java\nsimilarity index 98%\nrename from segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorAuthFailedTest.java\nrename to segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorAuthFailedTest.java\nindex 82bb119f4..accff779f 100644\n--- a/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaStreamRequestProcessorAuthFailedTest.java\n+++ b/segmentstore/server/host/src/test/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessorAuthFailedTest.java\n\n@@ -23,7 +23,7 @@ import static io.pravega.shared.protocol.netty.WireCommands.AuthTokenCheckFailed\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.verify;\n \n-public class PravegaStreamRequestProcessorAuthFailedTest {\n+public class PravegaRequestProcessorAuthFailedTest {\n \n     private PravegaRequestProcessor processor;\n     private ServerConnection connection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjM3NA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436792374", "bodyText": "Please add comments indicating what type of metric this is. See other metric names defined in this class.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:23:35Z", "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -172,6 +172,13 @@\n     public static final String THREAD_POOL_ACTIVE_THREADS = PREFIX + \"segmentstore.thread_pool.active_threads\";  // Histogram\n \n     // Metrics in Controller\n+    // KeyValueTable request counts\n+    public static final String CREATE_KVTABLE = PREFIX + \"controller.kvtable.created\";", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2NDM0NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436864345", "bodyText": "I have added more comments to make the meaning explicit. But names are modeled based on those for STREAM metrics and so it should be self explanatory.", "author": "pbelgundi", "createdAt": "2020-06-08T17:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjM3NA=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java b/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java\nindex 415ef8555..1322c3a89 100644\n--- a/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java\n+++ b/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java\n\n@@ -172,11 +172,13 @@ public final class MetricsNames {\n     public static final String THREAD_POOL_ACTIVE_THREADS = PREFIX + \"segmentstore.thread_pool.active_threads\";  // Histogram\n \n     // Metrics in Controller\n-    // KeyValueTable request counts\n+    // KeyValueTable create request counts\n     public static final String CREATE_KVTABLE = PREFIX + \"controller.kvtable.created\";\n-    // segment counts\n+    // KeyValueTable segment counts\n     public static final String KVTABLE_SEGMENTS_COUNT = PREFIX + \"controller.kvtable.segments.count\";\n+    // KeyValueTable Create Latency\n     public static final String CREATE_KVTABLE_LATENCY = PREFIX + \"controller.kvtable.created_latency_ms\";\n+    // KeyValueTable Create Failure\n     public static final String CREATE_KVTABLE_FAILED = PREFIX + \"controller.kvtable.create_failed\";\n \n     // Stream request counts\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjQ3Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436792476", "bodyText": "Be consistent. created -> create", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:23:44Z", "path": "shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java", "diffHunk": "@@ -172,6 +172,13 @@\n     public static final String THREAD_POOL_ACTIVE_THREADS = PREFIX + \"segmentstore.thread_pool.active_threads\";  // Histogram\n \n     // Metrics in Controller\n+    // KeyValueTable request counts\n+    public static final String CREATE_KVTABLE = PREFIX + \"controller.kvtable.created\";\n+    // segment counts\n+    public static final String KVTABLE_SEGMENTS_COUNT = PREFIX + \"controller.kvtable.segments.count\";\n+    public static final String CREATE_KVTABLE_LATENCY = PREFIX + \"controller.kvtable.created_latency_ms\";", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2NDc5Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436864796", "bodyText": "This is as per corresponding STREAM metric name : public static final String CREATE_STREAM_LATENCY = PREFIX + \"controller.stream.created_latency_ms\";", "author": "pbelgundi", "createdAt": "2020-06-08T17:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MjQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java b/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java\nindex 415ef8555..1322c3a89 100644\n--- a/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java\n+++ b/shared/metrics/src/main/java/io/pravega/shared/MetricsNames.java\n\n@@ -172,11 +172,13 @@ public final class MetricsNames {\n     public static final String THREAD_POOL_ACTIVE_THREADS = PREFIX + \"segmentstore.thread_pool.active_threads\";  // Histogram\n \n     // Metrics in Controller\n-    // KeyValueTable request counts\n+    // KeyValueTable create request counts\n     public static final String CREATE_KVTABLE = PREFIX + \"controller.kvtable.created\";\n-    // segment counts\n+    // KeyValueTable segment counts\n     public static final String KVTABLE_SEGMENTS_COUNT = PREFIX + \"controller.kvtable.segments.count\";\n+    // KeyValueTable Create Latency\n     public static final String CREATE_KVTABLE_LATENCY = PREFIX + \"controller.kvtable.created_latency_ms\";\n+    // KeyValueTable Create Failure\n     public static final String CREATE_KVTABLE_FAILED = PREFIX + \"controller.kvtable.create_failed\";\n \n     // Stream request counts\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MzI0Mw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436793243", "bodyText": "Why do we need to do this? Virtually all Segments for a KV Table will have this suffix and they'll all be in the same directory. So this is useless in my view.", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:24:54Z", "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -285,13 +290,35 @@ public static String getScopedKeyValueTableName(String scope, String streamName)\n         return getScopedStreamNameInternal(scope, streamName).toString();\n     }\n \n+    /**\n+     * Method to generate Fully Qualified  TableSegmentName using scope, stream and segment id.\n+     * Table segments for KVTables have segment names suffixed with _table,\n+     * so we can have a stream and KeyValueTable with the same name.\n+     *\n+     * @param scope scope to be used in the ScopedTableSegment name\n+     * @param kvTableName kvTable name to be used in ScopedTableSegment name.\n+     * @param segmentId segment id to be used in ScopedStreamSegment name.\n+     * @return fully qualified TableSegmentName for a TableSegment that is part of the KeyValueTable.\n+     */\n+    public static String getQualifiedTableSegmentName(String scope, String kvTableName, long segmentId) {\n+        int segmentNumber = getSegmentNumber(segmentId);\n+        int epoch = getEpoch(segmentId);\n+        StringBuffer sb = getScopedStreamNameInternal(scope, kvTableName);\n+        sb.append('/');\n+        sb.append(segmentNumber);\n+        sb.append(EPOCH_DELIMITER);\n+        sb.append(epoch);\n+        sb.append(KVTABLE_SUFFIX);", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2NTgxNw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436865817", "bodyText": "This suffix is to distinguish KVTable Segments from Stream Segments. A KVTable and Stream can have the same name and be inside the same scope and this suffix makes sure we don;t mix up the segment names for the two.", "author": "pbelgundi", "createdAt": "2020-06-08T17:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MzI0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java b/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java\nindex 66c5278a7..2060e822a 100644\n--- a/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java\n+++ b/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java\n\n@@ -318,7 +318,7 @@ public final class NameUtils {\n      * @param scope scope to be used in the ScopedStreamSegment name\n      * @param streamName stream name to be used in ScopedStreamSegment name.\n      * @param segmentId segment id to be used in ScopedStreamSegment name.\n-     * @return fully qualified StreamSegmentName\n+     * @return fully qualified StreamSegmentName.\n      */\n     public static String getQualifiedStreamSegmentName(String scope, String streamName, long segmentId) {\n         int segmentNumber = getSegmentNumber(segmentId);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MzM4Nw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436793387", "bodyText": "revert", "author": "andreipaduroiu", "createdAt": "2020-06-08T15:25:07Z", "path": "shared/protocol/src/main/java/io/pravega/shared/NameUtils.java", "diffHunk": "@@ -285,13 +290,35 @@ public static String getScopedKeyValueTableName(String scope, String streamName)\n         return getScopedStreamNameInternal(scope, streamName).toString();\n     }\n \n+    /**\n+     * Method to generate Fully Qualified  TableSegmentName using scope, stream and segment id.\n+     * Table segments for KVTables have segment names suffixed with _table,\n+     * so we can have a stream and KeyValueTable with the same name.\n+     *\n+     * @param scope scope to be used in the ScopedTableSegment name\n+     * @param kvTableName kvTable name to be used in ScopedTableSegment name.\n+     * @param segmentId segment id to be used in ScopedStreamSegment name.\n+     * @return fully qualified TableSegmentName for a TableSegment that is part of the KeyValueTable.\n+     */\n+    public static String getQualifiedTableSegmentName(String scope, String kvTableName, long segmentId) {\n+        int segmentNumber = getSegmentNumber(segmentId);\n+        int epoch = getEpoch(segmentId);\n+        StringBuffer sb = getScopedStreamNameInternal(scope, kvTableName);\n+        sb.append('/');\n+        sb.append(segmentNumber);\n+        sb.append(EPOCH_DELIMITER);\n+        sb.append(epoch);\n+        sb.append(KVTABLE_SUFFIX);\n+        return sb.toString();\n+    }\n+\n     /**\n      * Method to generate Fully Qualified StreamSegmentName using scope, stream and segment id.\n      *\n      * @param scope scope to be used in the ScopedStreamSegment name\n      * @param streamName stream name to be used in ScopedStreamSegment name.\n      * @param segmentId segment id to be used in ScopedStreamSegment name.\n-     * @return fully qualified StreamSegmentName.\n+     * @return fully qualified StreamSegmentName", "originalCommit": "955ba7a4455dca423e95e998b6c3be84fb38669c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3NTcxNw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r436875717", "bodyText": "done", "author": "pbelgundi", "createdAt": "2020-06-08T17:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjc5MzM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "c965adcacae987b0515ef92f931dffef958afea9", "chunk": "diff --git a/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java b/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java\nindex 66c5278a7..2060e822a 100644\n--- a/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java\n+++ b/shared/protocol/src/main/java/io/pravega/shared/NameUtils.java\n\n@@ -318,7 +318,7 @@ public final class NameUtils {\n      * @param scope scope to be used in the ScopedStreamSegment name\n      * @param streamName stream name to be used in ScopedStreamSegment name.\n      * @param segmentId segment id to be used in ScopedStreamSegment name.\n-     * @return fully qualified StreamSegmentName\n+     * @return fully qualified StreamSegmentName.\n      */\n     public static String getQualifiedStreamSegmentName(String scope, String streamName, long segmentId) {\n         int segmentNumber = getSegmentNumber(segmentId);\n"}}, {"oid": "c965adcacae987b0515ef92f931dffef958afea9", "url": "https://github.com/pravega/pravega/commit/c965adcacae987b0515ef92f931dffef958afea9", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-08T17:30:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE4Njg0NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r437186845", "bodyText": "do a config.equals so that it is future safe.\notherwise when more configuration is added, this may become a stale value and the developer may not know to change it here.", "author": "shiveshr", "createdAt": "2020-06-09T07:16:24Z", "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventStreamWriter;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.eventProcessor.requesthandlers.TaskExceptions;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.Stream.RequestSweeper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.ControllerEvent;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private String requestStreamName;\n+    private final CompletableFuture<Void> writerInitFuture = new CompletableFuture<>();\n+    private final AtomicReference<EventStreamWriter<ControllerEvent>> requestEventWriterRef = new AtomicReference<>();\n+\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+        this.requestStreamName = streamName;\n+        requestEventWriterRef.set(clientFactory.createEventWriter(requestStreamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()));\n+        writerInitFuture.complete(null);\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+               // 1. check if scope with this name exists...\n+               return kvtMetadataStore.checkScopeExists(scope)\n+                   .thenCompose(exists -> {\n+                        if (!exists) {\n+                           return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                        }\n+                        //2. check state of the KVTable, if found\n+                        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                                 e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                                    .thenCompose(state -> {\n+                                       if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                                           //3. get a new UUID for the KVTable we will be creating.\n+                                           byte[] newUUID = kvtMetadataStore.newScope(scope).newId();\n+                                           CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                        createTimestamp, requestId, BitConverter.readUUID(newUUID, 0));\n+                                                //4. Update ScopeTable with entry for this KVT and Publish event for creation\n+                                                return Futures.exceptionallyExpecting(addIndexAndSubmitTask(event, () -> kvtMetadataStore.createEntryForKVTable(scope, kvtName, newUUID, executor))\n+                                                                .thenCompose(x -> checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                                                                        .thenCompose(y -> kvtMetadataStore.getConfiguration(scope, kvtName, null, executor)\n+                                                                                .thenCompose(cfg -> {\n+                                                                                    if (cfg.getPartitionCount() == kvtConfig.getPartitionCount()) {", "originalCommit": "c965adcacae987b0515ef92f931dffef958afea9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b076eb0ba449758a27ce468ff2ae615bf3ee2a51", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\nindex da9d8ee0e..b0aa9d930 100644\n--- a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n+++ b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n\n@@ -9,9 +9,7 @@\n  */\n package io.pravega.controller.task.KeyValueTable;\n \n-import com.google.common.annotations.VisibleForTesting;\n import io.pravega.client.EventStreamClientFactory;\n-import io.pravega.client.stream.EventStreamWriter;\n import io.pravega.client.stream.EventWriterConfig;\n import io.pravega.client.tables.KeyValueTableConfiguration;\n import io.pravega.common.Exceptions;\n"}}, {"oid": "b076eb0ba449758a27ce468ff2ae615bf3ee2a51", "url": "https://github.com/pravega/pravega/commit/b076eb0ba449758a27ce468ff2ae615bf3ee2a51", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-09T12:59:29Z", "type": "commit"}, {"oid": "01cacbda1e057874f69a08847335251ad07a9b1e", "url": "https://github.com/pravega/pravega/commit/01cacbda1e057874f69a08847335251ad07a9b1e", "message": "fixed Integration Tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-10T10:38:06Z", "type": "commit"}, {"oid": "661451adde10f924da9204cd7f964c5dacaea3dd", "url": "https://github.com/pravega/pravega/commit/661451adde10f924da9204cd7f964c5dacaea3dd", "message": "going back to using the _kvt suffix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-10T11:54:11Z", "type": "commit"}, {"oid": "4f8e27a9e0fa50954b56a6d99abd5305090e1f1a", "url": "https://github.com/pravega/pravega/commit/4f8e27a9e0fa50954b56a6d99abd5305090e1f1a", "message": "unit test testBootstrap fixed\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-10T12:34:14Z", "type": "commit"}, {"oid": "a22d7c55c408b373384b4756d8481e4d92915180", "url": "https://github.com/pravega/pravega/commit/a22d7c55c408b373384b4756d8481e4d92915180", "message": "deleting unused Integration test\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-10T13:00:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NDM0OA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438194348", "bodyText": "Typo", "author": "andreipaduroiu", "createdAt": "2020-06-10T15:04:02Z", "path": "controller/src/main/java/io/pravega/controller/store/kvtable/PravegaTablesKVTable.java", "diffHunk": "@@ -202,6 +201,7 @@ private String getMetadataTableName(String id) {\n     @Override\n     CompletableFuture<Void> storeCreationTimeIfAbsent(final long creationTime) {\n         byte[] b = new byte[Long.BYTES];\n+        log.info(\"Sroring Creation time: {}\", creationTime);", "originalCommit": "a22d7c55c408b373384b4756d8481e4d92915180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzI5Ng==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438197296", "bodyText": "Will remove that log it was added for debugging..", "author": "pbelgundi", "createdAt": "2020-06-10T15:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NDM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NjAwMQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438656001", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-11T09:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NDM0OA=="}], "type": "inlineReview", "revised_code": {"commit": "e53eddcf269aa62e4ad2440834ae1b60dce1aac1", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/store/kvtable/PravegaTablesKVTable.java b/controller/src/main/java/io/pravega/controller/store/kvtable/PravegaTablesKVTable.java\nindex 09e3431c1..5df1bf5c1 100644\n--- a/controller/src/main/java/io/pravega/controller/store/kvtable/PravegaTablesKVTable.java\n+++ b/controller/src/main/java/io/pravega/controller/store/kvtable/PravegaTablesKVTable.java\n\n@@ -201,7 +201,6 @@ class PravegaTablesKVTable extends AbstractKVTableBase {\n     @Override\n     CompletableFuture<Void> storeCreationTimeIfAbsent(final long creationTime) {\n         byte[] b = new byte[Long.BYTES];\n-        log.info(\"Sroring Creation time: {}\", creationTime);\n         BitConverter.writeLong(b, 0, creationTime);\n         return getMetadataTable()\n                 .thenCompose(metadataTable -> storeHelper.addNewEntryIfAbsent(metadataTable, CREATION_TIME_KEY, b)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NTA3MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438195070", "bodyText": "I think we can remove this line now that we user real controller.", "author": "andreipaduroiu", "createdAt": "2020-06-10T15:05:01Z", "path": "test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java", "diffHunk": "@@ -42,13 +41,9 @@\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.mock;\n-\n /**\n  * Integration test for {@link KeyValueTable}s using real Segment Store and connection.\n  * The only simulated component is the {@link Controller} which is provided via the {@link MockController}.", "originalCommit": "a22d7c55c408b373384b4756d8481e4d92915180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzQwMA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438197400", "bodyText": "Sure", "author": "pbelgundi", "createdAt": "2020-06-10T15:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NTA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NTgwNw==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438655807", "bodyText": "fixed", "author": "pbelgundi", "createdAt": "2020-06-11T09:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NTA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "0f102dd1ca1e90d77f0bdc57a3842bf744942885", "chunk": "diff --git a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\nindex 2cd13bc48..7097dcb8c 100644\n--- a/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n+++ b/test/integration/src/test/java/io/pravega/test/integration/KeyValueTableTest.java\n\n@@ -38,7 +38,6 @@ import org.apache.curator.test.TestingServer;\n import org.junit.After;\n import org.junit.Assert;\n import org.junit.Before;\n-import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNzQ0MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438227440", "bodyText": "In order for this to work properly (that's why the testIterators integration doesn't work), we need to do the following:\n\nIn SegmentHelper, update createTableSegment to include a boolean sortedTableSegment flag. Pass that value to line 340 when you createWireCommands.CreateTableSegments as the 3rd parameter (currently stubbed as false).\nIn this TableMetadataTasks class, pass true to it.\nIn PravegaTablesStoreHelper, pass false to it.\n\nYou may have to fix any unit tests, but having sorted Table Segments is a requirement for KVTs.", "author": "andreipaduroiu", "createdAt": "2020-06-10T15:48:07Z", "path": "controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.controller.task.KeyValueTable;\n+\n+import io.pravega.client.EventStreamClientFactory;\n+import io.pravega.client.stream.EventWriterConfig;\n+import io.pravega.client.tables.KeyValueTableConfiguration;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.common.tracing.RequestTracker;\n+import io.pravega.common.tracing.TagLogger;\n+import io.pravega.common.util.BitConverter;\n+import io.pravega.controller.retryable.RetryableException;\n+import io.pravega.controller.server.SegmentHelper;\n+import io.pravega.controller.server.eventProcessor.ControllerEventProcessors;\n+import io.pravega.controller.server.rpc.auth.GrpcAuthHelper;\n+import io.pravega.controller.store.kvtable.AbstractKVTableMetadataStore;\n+import io.pravega.controller.store.kvtable.KVTableState;\n+import io.pravega.controller.store.stream.StoreException;\n+\n+import io.pravega.controller.stream.api.grpc.v1.Controller.CreateKeyValueTableStatus;\n+import io.pravega.controller.store.kvtable.KVTableMetadataStore;\n+import io.pravega.controller.task.EventHelper;\n+import io.pravega.controller.util.RetryHelper;\n+import io.pravega.shared.controller.event.kvtable.CreateTableEvent;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.stream.Collectors;\n+\n+import lombok.Synchronized;\n+import org.slf4j.LoggerFactory;\n+\n+import static io.pravega.controller.task.Stream.TaskStepsRetryHelper.withRetries;\n+import static io.pravega.shared.NameUtils.getQualifiedTableSegmentName;\n+\n+\n+/**\n+ * Collection of metadata update tasks on KeyValueTable.\n+ * <p>\n+ * Any update to the task method signature should be avoided, since it can cause problems during upgrade.\n+ * Instead, a new overloaded method may be created with the same task annotation name but a new version.\n+ */\n+public class TableMetadataTasks implements AutoCloseable {\n+    private static final TagLogger log = new TagLogger(LoggerFactory.getLogger(TableMetadataTasks.class));\n+    private final KVTableMetadataStore kvtMetadataStore;\n+    private final SegmentHelper segmentHelper;\n+    private final ScheduledExecutorService executor;\n+    private final ScheduledExecutorService eventExecutor;\n+    private final String hostId;\n+    private final GrpcAuthHelper authHelper;\n+    private final RequestTracker requestTracker;\n+    private EventHelper eventHelper;\n+\n+    public TableMetadataTasks(final KVTableMetadataStore kvtMetadataStore,\n+                              final SegmentHelper segmentHelper, final ScheduledExecutorService executor,\n+                              final ScheduledExecutorService eventExecutor, final String hostId,\n+                              GrpcAuthHelper authHelper, RequestTracker requestTracker) {\n+        this.kvtMetadataStore = kvtMetadataStore;\n+        this.segmentHelper = segmentHelper;\n+        this.executor = executor;\n+        this.eventExecutor = eventExecutor;\n+        this.hostId = hostId;\n+        this.authHelper = authHelper;\n+        this.requestTracker = requestTracker;\n+    }\n+\n+    @Synchronized\n+    public void initializeStreamWriters(final EventStreamClientFactory clientFactory,\n+                                        final String streamName) {\n+\n+        this.eventHelper = new EventHelper(clientFactory.createEventWriter(streamName,\n+                ControllerEventProcessors.CONTROLLER_EVENT_SERIALIZER,\n+                EventWriterConfig.builder().build()), streamName,\n+                                            this.executor, this.eventExecutor, hostId,\n+                ((AbstractKVTableMetadataStore) this.kvtMetadataStore).getHostTaskIndex());\n+    }\n+\n+    /**\n+     *  Create a Key-Value Table.\n+     *\n+     * @param scope      scope name.\n+     * @param kvtName    KVTable name.\n+     * @param kvtConfig  KVTable configuration.\n+     * @param createTimestamp  KVTable creation timestamp.\n+     * @return update status.\n+     */\n+    public CompletableFuture<CreateKeyValueTableStatus.Status> createKeyValueTable(String scope, String kvtName,\n+                                                                                   KeyValueTableConfiguration kvtConfig,\n+                                                                                   final long createTimestamp) {\n+        final long requestId = requestTracker.getRequestIdFor(\"createKVTable\", scope, kvtName);\n+        return RetryHelper.withRetriesAsync(() -> {\n+               // 1. check if scope with this name exists...\n+               return kvtMetadataStore.checkScopeExists(scope)\n+                   .thenCompose(exists -> {\n+                        if (!exists) {\n+                            return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SCOPE_NOT_FOUND);\n+                        }\n+                        //2. check state of the KVTable, if found\n+                        return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                                 e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+                                    .thenCompose(state -> {\n+                                       if (state.equals(KVTableState.UNKNOWN) || state.equals(KVTableState.CREATING)) {\n+                                           //3. get a new UUID for the KVTable we will be creating.\n+                                           byte[] newUUID = kvtMetadataStore.newScope(scope).newId();\n+                                           CreateTableEvent event = new CreateTableEvent(scope, kvtName, kvtConfig.getPartitionCount(),\n+                                                        createTimestamp, requestId, BitConverter.readUUID(newUUID, 0));\n+                                           //4. Update ScopeTable with the entry for this KVT and Publish the event for creation\n+                                           return eventHelper.addIndexAndSubmitTask(event,\n+                                                   () -> kvtMetadataStore.createEntryForKVTable(scope, kvtName, newUUID, executor))\n+                                                   .thenCompose(x -> isCreateProcessed(scope, kvtName, kvtConfig, createTimestamp, executor));\n+                                       }\n+                                       return isCreateProcessed(scope, kvtName, kvtConfig, createTimestamp, executor);\n+                                 });\n+                            });\n+               }, e -> Exceptions.unwrap(e) instanceof RetryableException, Integer.MAX_VALUE, executor);\n+    }\n+\n+    private CompletableFuture<CreateKeyValueTableStatus.Status> isCreateProcessed(String scope, String kvtName,\n+                                                                                  KeyValueTableConfiguration kvtConfig,\n+                                                                                  final long createTimestamp,\n+                                                                                  Executor executor) {\n+        return eventHelper.checkDone(() -> isCreated(scope, kvtName, kvtConfig, executor))\n+                .thenCompose(y -> isSameCreateRequest(scope, kvtName, kvtConfig, createTimestamp, executor))\n+                .thenCompose(same -> {\n+                    if (same) {\n+                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.SUCCESS);\n+                    } else {\n+                        return CompletableFuture.completedFuture(CreateKeyValueTableStatus.Status.TABLE_EXISTS);\n+                    }\n+                });\n+    }\n+\n+    private CompletableFuture<Boolean> isCreated(String scope, String kvtName, KeyValueTableConfiguration kvtConfig, Executor executor) {\n+       return Futures.exceptionallyExpecting(kvtMetadataStore.getState(scope, kvtName, true, null, executor),\n+                e -> Exceptions.unwrap(e) instanceof StoreException.DataNotFoundException, KVTableState.UNKNOWN)\n+               .thenApply(state -> {\n+                    log.debug(\"KVTable State is {}\", state.toString());\n+                    return state.equals(KVTableState.ACTIVE);\n+                });\n+    }\n+\n+    private CompletableFuture<Boolean> isSameCreateRequest(final String requestScopeName, final String requestKVTName,\n+                                                           final KeyValueTableConfiguration requestKVTConfig,\n+                                                           final long requestCreateTimestamp,\n+                                                           Executor executor) {\n+    return kvtMetadataStore.getCreationTime(requestScopeName, requestKVTName, null, executor)\n+    .thenCompose(creationTime -> {\n+        if (creationTime == requestCreateTimestamp) {\n+            return kvtMetadataStore.getConfiguration(requestScopeName, requestKVTName, null, executor)\n+                    .thenCompose(cfg -> {\n+                        if (cfg.getPartitionCount() == requestKVTConfig.getPartitionCount()) {\n+                            return CompletableFuture.completedFuture(Boolean.TRUE);\n+                        } else {\n+                            return CompletableFuture.completedFuture(Boolean.FALSE);\n+                        }\n+                    });\n+            }\n+        return CompletableFuture.completedFuture(Boolean.FALSE);\n+        });\n+    }\n+\n+    private String retrieveDelegationToken() {\n+        return authHelper.retrieveMasterToken();\n+    }\n+    \n+    public CompletableFuture<Void> createNewSegments(String scope, String kvt,\n+                                                     List<Long> segmentIds, long requestId) {\n+        return Futures.toVoid(Futures.allOfWithResults(segmentIds\n+                .stream()\n+                .parallel()\n+                .map(segment -> createNewSegment(scope, kvt, segment, retrieveDelegationToken(), requestId))\n+                .collect(Collectors.toList())));\n+    }\n+\n+    private CompletableFuture<Void> createNewSegment(String scope, String kvt, long segmentId, String controllerToken,\n+                                                     long requestId) {\n+        final String qualifiedTableSegmentName = getQualifiedTableSegmentName(scope, kvt, segmentId);\n+        return Futures.toVoid(withRetries(() -> segmentHelper.createTableSegment(qualifiedTableSegmentName, controllerToken, requestId), executor));", "originalCommit": "a22d7c55c408b373384b4756d8481e4d92915180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NTkyNA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r438655924", "bodyText": "fixed.", "author": "pbelgundi", "createdAt": "2020-06-11T09:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNzQ0MA=="}], "type": "inlineReview", "revised_code": {"commit": "0f102dd1ca1e90d77f0bdc57a3842bf744942885", "chunk": "diff --git a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\nindex 29049627f..ebf4d2855 100644\n--- a/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n+++ b/controller/src/main/java/io/pravega/controller/task/KeyValueTable/TableMetadataTasks.java\n\n@@ -185,7 +185,7 @@ public class TableMetadataTasks implements AutoCloseable {\n     private CompletableFuture<Void> createNewSegment(String scope, String kvt, long segmentId, String controllerToken,\n                                                      long requestId) {\n         final String qualifiedTableSegmentName = getQualifiedTableSegmentName(scope, kvt, segmentId);\n-        return Futures.toVoid(withRetries(() -> segmentHelper.createTableSegment(qualifiedTableSegmentName, controllerToken, requestId), executor));\n+        return Futures.toVoid(withRetries(() -> segmentHelper.createTableSegment(qualifiedTableSegmentName, controllerToken, requestId, true), executor));\n     }\n \n     @Override\n"}}, {"oid": "0f102dd1ca1e90d77f0bdc57a3842bf744942885", "url": "https://github.com/pravega/pravega/commit/0f102dd1ca1e90d77f0bdc57a3842bf744942885", "message": "rebase from upstream branch\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T09:14:55Z", "type": "commit"}, {"oid": "e53eddcf269aa62e4ad2440834ae1b60dce1aac1", "url": "https://github.com/pravega/pravega/commit/e53eddcf269aa62e4ad2440834ae1b60dce1aac1", "message": "code review comments\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T09:21:50Z", "type": "commit"}, {"oid": "303589fb15f2f9061038044b2e2c89e218d295ea", "url": "https://github.com/pravega/pravega/commit/303589fb15f2f9061038044b2e2c89e218d295ea", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T09:39:24Z", "type": "commit"}, {"oid": "1ed8d4b1916ef19cb5914dc07625abf02d50d905", "url": "https://github.com/pravega/pravega/commit/1ed8d4b1916ef19cb5914dc07625abf02d50d905", "message": "client test fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T10:06:52Z", "type": "commit"}, {"oid": "7fe13395fe8be57f57b17fd609ccb45f001c9171", "url": "https://github.com/pravega/pravega/commit/7fe13395fe8be57f57b17fd609ccb45f001c9171", "message": "checkstyle fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T10:52:18Z", "type": "commit"}, {"oid": "3842090c1c5a8c748169a81237b61b66c1100a37", "url": "https://github.com/pravega/pravega/commit/3842090c1c5a8c748169a81237b61b66c1100a37", "message": "New Unit Tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T13:22:20Z", "type": "commit"}, {"oid": "3d2891723add3ba320e76d56377723281964d983", "url": "https://github.com/pravega/pravega/commit/3d2891723add3ba320e76d56377723281964d983", "message": "checkstyle fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-11T16:08:20Z", "type": "commit"}, {"oid": "23eebf743d8df56f5c908a9b65a45592bd269011", "url": "https://github.com/pravega/pravega/commit/23eebf743d8df56f5c908a9b65a45592bd269011", "message": "changed retries to 10 for CreateAPI\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-12T07:12:52Z", "type": "commit"}, {"oid": "54e4cc4ecd2a9c257863326a6aabb34c44180838", "url": "https://github.com/pravega/pravega/commit/54e4cc4ecd2a9c257863326a6aabb34c44180838", "message": "KeyValueTableImplTest fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-12T08:08:16Z", "type": "commit"}, {"oid": "c889e6f3220519566ec62dbb4360a63c4bc61459", "url": "https://github.com/pravega/pravega/commit/c889e6f3220519566ec62dbb4360a63c4bc61459", "message": "Unit tests for KVTables\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-12T11:03:09Z", "type": "commit"}, {"oid": "0eeb041224149d18bfaf9f871f61810afd564fa6", "url": "https://github.com/pravega/pravega/commit/0eeb041224149d18bfaf9f871f61810afd564fa6", "message": "Test fixes\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-15T16:29:08Z", "type": "commit"}, {"oid": "59f3745129f594b524f230bb173c53dcbdace370", "url": "https://github.com/pravega/pravega/commit/59f3745129f594b524f230bb173c53dcbdace370", "message": "comment fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-15T16:40:41Z", "type": "commit"}, {"oid": "8533890a91b15e18315354f2dfdadd1e8474e393", "url": "https://github.com/pravega/pravega/commit/8533890a91b15e18315354f2dfdadd1e8474e393", "message": "code review comments fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-15T16:56:17Z", "type": "commit"}, {"oid": "43b5bdc05a192789c063eff14f08be9f0b27e71d", "url": "https://github.com/pravega/pravega/commit/43b5bdc05a192789c063eff14f08be9f0b27e71d", "message": "added unit tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-16T14:11:52Z", "type": "commit"}, {"oid": "5d9d191ada9c2bd83b261a8176c731348341c448", "url": "https://github.com/pravega/pravega/commit/5d9d191ada9c2bd83b261a8176c731348341c448", "message": "UT coverage\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-16T16:52:23Z", "type": "commit"}, {"oid": "c3a32cb8e14e43a0c9f9dc219a07eebcbb181492", "url": "https://github.com/pravega/pravega/commit/c3a32cb8e14e43a0c9f9dc219a07eebcbb181492", "message": "UT fix\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-16T17:52:49Z", "type": "commit"}, {"oid": "b480afc6b879b45e1e3f49fdf906385df2a7fb1c", "url": "https://github.com/pravega/pravega/commit/b480afc6b879b45e1e3f49fdf906385df2a7fb1c", "message": "more tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-17T02:06:16Z", "type": "commit"}, {"oid": "039b3b26df0578334fa77be57a01613395fd7154", "url": "https://github.com/pravega/pravega/commit/039b3b26df0578334fa77be57a01613395fd7154", "message": "Futures Unit Test\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-17T02:44:33Z", "type": "commit"}, {"oid": "b273d4354fd13b461b6de1f43b66775079920cb5", "url": "https://github.com/pravega/pravega/commit/b273d4354fd13b461b6de1f43b66775079920cb5", "message": "fixed checkstyle errors\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-17T03:12:13Z", "type": "commit"}, {"oid": "8964cb8e0522bc64de32d232556356a2c0115704", "url": "https://github.com/pravega/pravega/commit/8964cb8e0522bc64de32d232556356a2c0115704", "message": "Removed updateKeyValueTable API\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-17T04:34:33Z", "type": "commit"}, {"oid": "2f2984a57cb7876ed306251eacde35cd0a599391", "url": "https://github.com/pravega/pravega/commit/2f2984a57cb7876ed306251eacde35cd0a599391", "message": "More tests\n\nSigned-off-by: pbelgundi <prajakta.belgundi@emc.com>", "committedDate": "2020-06-17T07:47:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3Mzk4Mg==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r441573982", "bodyText": "What's the point of this? Do you not do this in the setup?", "author": "andreipaduroiu", "createdAt": "2020-06-17T14:08:27Z", "path": "client/src/test/java/io/pravega/client/tables/impl/KeyValueTableTestBase.java", "diffHunk": "@@ -44,6 +44,7 @@\n      */\n     @Test\n     public void testSingleKeyConditionalInserts() {\n+        Assert.assertTrue(isScopeCreated);", "originalCommit": "2f2984a57cb7876ed306251eacde35cd0a599391", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3OTU5NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r441579595", "bodyText": "This is to make sure ScopeCreation has succeeded, before attempting Table creation so that we do not get a SCOPE_NOT_FOUND...", "author": "pbelgundi", "createdAt": "2020-06-17T14:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3Mzk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4MTU5MA==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r441581590", "bodyText": "So you'll either get SCOPE_NOT_FOUND or the test will fail due to this assertion. The outcome is the same. That's why I asked what the point is.", "author": "andreipaduroiu", "createdAt": "2020-06-17T14:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3Mzk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU5MTU4NQ==", "url": "https://github.com/pravega/pravega/pull/4797#discussion_r441591585", "bodyText": "Yes... either ways the test would fail if scope is not created...", "author": "pbelgundi", "createdAt": "2020-06-17T14:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU3Mzk4Mg=="}], "type": "inlineReview", "revised_code": null}]}