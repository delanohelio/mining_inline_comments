{"pr_number": 4703, "pr_title": "Issue 4702: (SegmentStore) Fixed a deadlock condition in the Read Index.", "pr_createdAt": "2020-04-16T21:57:32Z", "pr_url": "https://github.com/pravega/pravega/pull/4703", "timeline": [{"oid": "9df3c8405e873f048919237f6463ec6e281fd89f", "url": "https://github.com/pravega/pravega/commit/9df3c8405e873f048919237f6463ec6e281fd89f", "message": "Fixed a deadlock condition in the Read Index.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-16T21:51:49Z", "type": "commit"}, {"oid": "e8374b8704e523be11aa00660a8aa720998133ad", "url": "https://github.com/pravega/pravega/commit/e8374b8704e523be11aa00660a8aa720998133ad", "message": "Fixed a deadlock condition in the Read Index.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-16T21:59:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDk4MA==", "url": "https://github.com/pravega/pravega/pull/4703#discussion_r410510980", "bodyText": "RetryPolicy in common is built to do this.", "author": "tkaitchuck", "createdAt": "2020-04-17T23:16:45Z", "path": "segmentstore/storage/src/main/java/io/pravega/segmentstore/storage/cache/DirectMemoryCache.java", "diffHunk": "@@ -399,15 +403,23 @@ private DirectMemoryBuffer getNextAvailableBuffer() {\n \n             // If we get here, there are no available buffers and we have allocated all the buffers we could. Notify\n             // any upstream listeners to attempt a cleanup (if possible).\n-        } while (++attempts <= MAX_CLEANUP_ATTEMPTS && tryCleanup());\n+            attempts++;\n+            tryCleanup(attempts);\n+        }\n \n         // Unable to reuse any existing buffer or find a new one to allocate and upstream code could not free up data.\n         throw new CacheFullException(String.format(\"%s full: %s.\", DirectMemoryCache.class.getSimpleName(), getState()));\n     }\n \n-    private boolean tryCleanup() {\n+    private void tryCleanup(int attempts) {\n         val c = this.tryCleanup.get();\n-        return c != null && c.get();\n+        if (c != null && !c.get()) {\n+            // Unable to clean up the cache. Wait a bit, then try again.\n+            int sleepMillis = attempts * this.retryDelayBaseMillis.get();", "originalCommit": "e8374b8704e523be11aa00660a8aa720998133ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2Mzk1MA==", "url": "https://github.com/pravega/pravega/pull/4703#discussion_r411463950", "bodyText": "That was my first choice, however Retry only retries on exceptions. Here I retry based on the response from a method.", "author": "andreipaduroiu", "createdAt": "2020-04-20T15:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMDk4MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTUzMQ==", "url": "https://github.com/pravega/pravega/pull/4703#discussion_r410511531", "bodyText": "As usual when changing from course locking to fine locking make double sure there aren't code paths that implicitly assume that another thread isn't going to change something in the mean time. For example here one might make the assumption that currentGeneration would not change in the middle of a method, or that current and oldest generation are different or that older is newer that current etc.", "author": "tkaitchuck", "createdAt": "2020-04-17T23:19:15Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/CacheManager.java", "diffHunk": "@@ -47,17 +49,15 @@\n @ThreadSafe\n public class CacheManager extends AbstractScheduledService implements AutoCloseable {\n     //region Members\n-\n+    private static final int CACHE_FULL_RETRY_BASE_MILLIS = 50;\n     private static final String TRACE_OBJECT_ID = \"CacheManager\";\n     @GuardedBy(\"lock\")\n     private final Collection<Client> clients;\n     private final ScheduledExecutorService executorService;\n-    @GuardedBy(\"lock\")\n-    private int currentGeneration;\n-    @GuardedBy(\"lock\")\n-    private int oldestGeneration;\n-    @GuardedBy(\"lock\")\n-    private CacheState lastCacheState;\n+    private final AtomicInteger currentGeneration;", "originalCommit": "e8374b8704e523be11aa00660a8aa720998133ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NjUyNg==", "url": "https://github.com/pravega/pravega/pull/4703#discussion_r411466526", "bodyText": "Agreed. In this class, the only thing changing the internal state is applyCachePolicyInternal, which is guarded by the lock. I decided to make all these fields AtomicXYZ because I didn't want to acquire some lock just to query them. To be clear, applyCachePolicyInternal modifies these values, but they are queried in other places as well, which should be OK for thread safety purposes.\nThe only exception to this rule is this.clients, which keeps track of all the Cache Manager's Clients, and is a collection that is modified when new segments are activated or evicted from memory, hence out of the control of the Cache Manager. However, no external APIs are invoked while using the clients lock, so no chance for deadlock there.", "author": "andreipaduroiu", "createdAt": "2020-04-20T15:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUxMTUzMQ=="}], "type": "inlineReview", "revised_code": null}]}