{"pr_number": 5283, "pr_title": "Issue 4884: BufferView equals() and compare() optimizations for JDK11", "pr_createdAt": "2020-10-22T23:12:08Z", "pr_url": "https://github.com/pravega/pravega/pull/5283", "timeline": [{"oid": "a26f79f47330887572948e41eaf18fcbf998b730", "url": "https://github.com/pravega/pravega/commit/a26f79f47330887572948e41eaf18fcbf998b730", "message": "Created project \"common_server\" - everything that is common but needs to be compiled with JDK11.\nMoved io.pravega.common.util.btree from \"common\" to \"common_server\". Package name stays the same.\nDeleted ByteArrayComparator.java. Replaced with BufferViewComparator.java, which now sits in \"common_server\".\nUpdated all callsites to use new classes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-22T23:10:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMTY0MA==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511331640", "bodyText": "I believe this method does the same thing without the wrapping:\nhttps://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html#equals(byte%5B%5D,int,int,byte%5B%5D,int,int)", "author": "tkaitchuck", "createdAt": "2020-10-24T07:21:17Z", "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -171,44 +172,28 @@ public void copyTo(OutputStream stream) throws IOException {\n     }\n \n     @Override\n-    @SneakyThrows(IOException.class)\n     public boolean equals(BufferView other) {\n         if (this.length != other.getLength()) {\n             return false;\n         } else if (other instanceof ArrayView) {\n-            return equals((ArrayView) other);\n+            // ByteBuffer-optimized equality check.\n+            return this.asByteBuffer().equals(((ArrayView) other).asByteBuffer());", "originalCommit": "a26f79f47330887572948e41eaf18fcbf998b730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDI5MA==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512054290", "bodyText": "That method is not available in JDK8. This class is part of common so it must compile with JDK8 APIs.\nHowever, instances of this class may be used in JRE11 environments (such as Segment store) where the updated ByteBuffer.equals will be used.", "author": "andreipaduroiu", "createdAt": "2020-10-26T15:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzMTY0MA=="}], "type": "inlineReview", "revised_code": {"commit": "858c9d595be1577b721d7c8b1b2dc9a00081dd10", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/ByteArraySegment.java b/common/src/main/java/io/pravega/common/util/ByteArraySegment.java\nindex 4e25aac7e8..d0b831f2bf 100644\n--- a/common/src/main/java/io/pravega/common/util/ByteArraySegment.java\n+++ b/common/src/main/java/io/pravega/common/util/ByteArraySegment.java\n\n@@ -177,7 +178,9 @@ public class ByteArraySegment extends AbstractBufferView implements ArrayView {\n             return false;\n         } else if (other instanceof ArrayView) {\n             // ByteBuffer-optimized equality check.\n-            return this.asByteBuffer().equals(((ArrayView) other).asByteBuffer());\n+            ArrayView otherArray = (ArrayView) other;\n+            return Arrays.equals(this.array, this.startOffset, this.startOffset + this.length,\n+                    otherArray.array(), otherArray.arrayOffset(), otherArray.arrayOffset() + this.length);\n         }\n \n         // No good optimization available; default to AbstractBufferView.equals().\n"}}, {"oid": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce", "url": "https://github.com/pravega/pravega/commit/c0f33db5ff3ba03b5dd771e7700591925a26d9ce", "message": "Removed BufferView.getContents().\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-24T13:42:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDA2Nw==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511470067", "bodyText": "Why AtomicInteger? What about using some simpler int holder without concurrency support?", "author": "eolivelli", "createdAt": "2020-10-24T14:24:03Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -183,6 +185,31 @@ public CompositeArrayView slice(int offset, int length) {\n         assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n     }\n \n+    @Override\n+    public Iterator<ByteBuffer> iterateBuffers() {\n+        if (this.length == 0) {\n+            return Collections.emptyIterator();\n+        }\n+\n+        AtomicInteger arrayOffset = new AtomicInteger(getArrayOffset(0));", "originalCommit": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjQ5NQ==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512006495", "bodyText": "Because I need to use this in a lambda just below which doesn't like me fiddling around with the variable contents (it needs to be immutable).\nThe reason for a lambda is because this method needs to return an iterator, and the simplest way to make one on-the-fly is by using Arrays.stream()... and then doing some mapping, hence the need for lambda.", "author": "andreipaduroiu", "createdAt": "2020-10-26T14:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDA2Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDYxNQ==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511470615", "bodyText": "Does is make sense to have a simpler handling in case of wrapping only 2 buffers?\nProbably we can save a few cpu cycles and memory allocations, but I am not sure it is worth", "author": "eolivelli", "createdAt": "2020-10-24T14:26:02Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -183,6 +185,31 @@ public CompositeArrayView slice(int offset, int length) {\n         assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n     }\n \n+    @Override\n+    public Iterator<ByteBuffer> iterateBuffers() {\n+        if (this.length == 0) {\n+            return Collections.emptyIterator();\n+        }", "originalCommit": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwODk5Nw==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512008997", "bodyText": "I tried to optimize both this and CompositeBufferView based on when they have only one (or two) buffers. The difference I saw was measured in fractions of nanoseconds so not worth it in my POV.\nFYI, CompositeByteArraySegment is only used in one place (currently). When we generate writes to BookKeeper, we need to write at most 1MB, but we do not know how much in advance to allocate. To give the impression of an array, this class creates a \"sparse array\" made of smaller arrays which are only allocated when first written to.\nMost of the time this will have just 1 element (up to 128KB).", "author": "andreipaduroiu", "createdAt": "2020-10-26T14:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDYxNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDk3MQ==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r511470971", "bodyText": "What about using multirelease jars? It will be more simpler at runtime and less error prone", "author": "eolivelli", "createdAt": "2020-10-24T14:27:51Z", "path": "common_server/src/main/java/io/pravega/common/util/BufferViewComparator.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.Serializable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+\n+/**\n+ * Performs a lexicographic bitwise comparison of {@link BufferView} instances (and of implemented classes).\n+ * <p>\n+ * Lexicographic bitwise comparison for {@link BufferView}s of the same length:\n+ * - Consider two {@link BufferView}s A and B, with each having L bits (L is a multiple of 8).\n+ * - Define A{n} and B{n} as the bit at position n in A and B, respectively. This can be either 0 or 1.\n+ * - A precedes B if there exists bit position i such that for all bit positions j smaller than i,\n+ * then A{j} is equal to B{j}, A{i} is 0 and B{i} is 1.\n+ * - A is equal to B if the values of all bit positions in both {@link BufferView}s match.\n+ * <p>\n+ * Lexicographic bitwise comparison for {@link BufferView}s of different lengths:\n+ * - Consider two {@link BufferView}s A and B, with A having LA bits and B having LB bits (LA, LB are multiples of 8).\n+ * - We do a Lexicographic bitwise comparison of the prefixes of A and B of lengths Min(LA, LB).\n+ * - If the prefixes are equal, then the shorter of A and B precedes the longer of A and B.\n+ * -- If LA &lt; LB, then A is before B; if LA &gt; LB, then A is after B.\n+ * - If the prefixes are not equal, then the result from the prefix comparison is used to order A and B (see above).\n+ * <p>\n+ * Lexicographic bitwise comparison matches the natural order of numbers when serialized as unsigned (i.e., using the\n+ * specialized methods in {@link BitConverter}) since they avoid the complications involved with interpreting individual\n+ * bytes with the first bit set to 1 using 2's complement (128 is before 127 if we used signed bytes).\n+ * <p>\n+ * For example:\n+ * - Consider any two Longs L1 and L2.\n+ * - Let S1 be the result of {@link BitConverter#writeUnsignedLong} when applied to L1, and S2 the result when applied to L2.\n+ * - Then {@link Long#compare} applied to (L1, L2) is equal to {@link #compare} applied to (S1, S2).\n+ * - This equality would not hold should L1 and L2 be serialized using {@link BitConverter#writeLong} or if we used plain\n+ * (signed) byte comparison internally.\n+ */\n+public abstract class BufferViewComparator implements Comparator<byte[]>, Serializable {\n+    /**\n+     * The minimum byte value for this comparison. Since we use unsigned bytes, this is 0-based.\n+     */\n+    public static final byte MIN_VALUE = 0;\n+    /**\n+     * The maximum byte value for this comparison. Since we use unsigned bytes, this is 0-based, hence 255.\n+     * Note that the actual value stored in Java for this is 0xFF, which is actually -1.\n+     */\n+    public static final byte MAX_VALUE = (byte) 255;\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    //region Constructor\n+\n+    /**\n+     * Determines if Intrinsic (JRE9+) array and {@link ByteBuffer} comparison is available.\n+     */\n+    private static final boolean INTRINSIC_SUPPORTED;\n+\n+    static {\n+        // Figure out if we support JRE9+ Intrinsic comparators. We do compile this code with JDK11, however this is to\n+        // have a failover in case we run with a lesser JRE.\n+        boolean intrinsicSupported = true;\n+        try {\n+            ByteBuffer bb = ByteBuffer.wrap(new byte[1]);\n+            bb.mismatch(bb);\n+        } catch (ExceptionInInitializerError | UnsatisfiedLinkError | NoClassDefFoundError e) {", "originalCommit": "c0f33db5ff3ba03b5dd771e7700591925a26d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMDE0Mw==", "url": "https://github.com/pravega/pravega/pull/5283#discussion_r512010143", "bodyText": "Gradle recommends against that, so in my opinion, this is less controversial (and more deterministic - what goes where).", "author": "andreipaduroiu", "createdAt": "2020-10-26T14:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDk3MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "858c9d595be1577b721d7c8b1b2dc9a00081dd10", "url": "https://github.com/pravega/pravega/commit/858c9d595be1577b721d7c8b1b2dc9a00081dd10", "message": "Using Arrays.equals in ByteArraySegment.equals.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-26T14:49:08Z", "type": "commit"}, {"oid": "c427880c5017a2e6bd77c2dcb04cc879ca8410a7", "url": "https://github.com/pravega/pravega/commit/c427880c5017a2e6bd77c2dcb04cc879ca8410a7", "message": "Reverted change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-26T15:31:55Z", "type": "commit"}, {"oid": "7c0e2434db29282a32eb2e464b12e17fd081c0dc", "url": "https://github.com/pravega/pravega/commit/7c0e2434db29282a32eb2e464b12e17fd081c0dc", "message": "Reverted change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-26T17:31:32Z", "type": "commit"}, {"oid": "18cc1af28dc68906467310763b74bb7cdfc9673c", "url": "https://github.com/pravega/pravega/commit/18cc1af28dc68906467310763b74bb7cdfc9673c", "message": "Reverted change.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-10-27T00:48:09Z", "type": "commit"}, {"oid": "2812dc492a9ef2319e553ddbd8b90c51ea1e00fd", "url": "https://github.com/pravega/pravega/commit/2812dc492a9ef2319e553ddbd8b90c51ea1e00fd", "message": "Merge branch 'master' into issue-4884-bufferviews", "committedDate": "2020-10-27T17:20:09Z", "type": "commit"}, {"oid": "56b631370d80e10bc91fc7a425426207dd926563", "url": "https://github.com/pravega/pravega/commit/56b631370d80e10bc91fc7a425426207dd926563", "message": "Merge branch 'master' into issue-4884-bufferviews", "committedDate": "2020-10-28T10:09:14Z", "type": "commit"}]}