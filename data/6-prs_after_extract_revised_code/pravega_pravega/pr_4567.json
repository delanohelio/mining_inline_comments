{"pr_number": 4567, "pr_title": "Issue 4565: (SegmentStore) Improving Data Frames memory allocation", "pr_createdAt": "2020-02-21T00:26:22Z", "pr_url": "https://github.com/pravega/pravega/pull/4567", "timeline": [{"oid": "1a58a48a94db38509aaee9220e68076c44734113", "url": "https://github.com/pravega/pravega/commit/1a58a48a94db38509aaee9220e68076c44734113", "message": "CompositeArrayView, CompositeByteArraySegment.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-02-21T00:07:38Z", "type": "commit"}, {"oid": "77a07529a4194ab9f17be27c6d94bd650ac414eb", "url": "https://github.com/pravega/pravega/commit/77a07529a4194ab9f17be27c6d94bd650ac414eb", "message": "Javadoc for CompositeArrayView.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-02-22T16:22:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MDg4OA==", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r382940888", "bodyText": "Why aren't we using Netty ByteBufs ? There is already lot of support for composition and they support direct memory?", "author": "eolivelli", "createdAt": "2020-02-22T20:55:44Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {", "originalCommit": "77a07529a4194ab9f17be27c6d94bd650ac414eb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "22664531816c7a5805f3fd1ded5040c6f4cdf429", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java b/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java\nindex 57794162fc..2073933db4 100644\n--- a/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java\n+++ b/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java\n\n@@ -20,6 +20,8 @@ import java.io.OutputStream;\n import java.io.SequenceInputStream;\n import java.nio.ByteBuffer;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n import lombok.Getter;\n import lombok.NonNull;\n \n"}}, {"oid": "22664531816c7a5805f3fd1ded5040c6f4cdf429", "url": "https://github.com/pravega/pravega/commit/22664531816c7a5805f3fd1ded5040c6f4cdf429", "message": "Unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-02-23T18:39:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTY0OQ==", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384855649", "bodyText": "byte[] result = new byte[this.length];\ncopyTo(ByteBuffer.wrap(result));\nreturn result;", "author": "tkaitchuck", "createdAt": "2020-02-27T00:51:53Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import io.pravega.common.Exceptions;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * A composite, index-based array-like structure that is made up of one or more individual arrays of equal size. Each\n+ * component array maps to a contiguous offset range and is only allocated when the first index within its range needs\n+ * to be set (if unallocated, any index within its range will have a value of 0).\n+ */\n+public class CompositeByteArraySegment implements CompositeArrayView {\n+    //region Members\n+    /**\n+     * Default component array size. 4KB maps to the kernel's page size.\n+     */\n+    private static final int DEFAULT_ARRAY_SIZE = 4 * 1024;\n+    /**\n+     * The offset at which the {@link CompositeByteArraySegment} begins, counted from the first block. This is helpful\n+     * for slicing a {@link CompositeByteArraySegment}. See {@link #slice}.\n+     */\n+    private final int startOffset;\n+    /**\n+     * Size of each component array.\n+     */\n+    private final int arraySize;\n+    private final Object[] arrays;\n+    @Getter\n+    private final int length;\n+    //endregion\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with a default component array size.\n+     *\n+     * @param length The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *               to use, but doesn't allocate any of them yet.\n+     */\n+    public CompositeByteArraySegment(int length) {\n+        this(length, DEFAULT_ARRAY_SIZE);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class with the given component array size.\n+     *\n+     * @param length    The length of the {@link CompositeByteArraySegment}. This will determine the number of components\n+     *                  to use, but doesn't allocate any of them yet.\n+     * @param arraySize The component array size.\n+     */\n+    public CompositeByteArraySegment(int length, int arraySize) {\n+        Preconditions.checkArgument(length >= 0, \"length must be a non-negative number.\");\n+        Preconditions.checkArgument(arraySize > 0, \"arraySize must be a positive number.\");\n+\n+        this.length = length;\n+        this.arraySize = Math.min(length, arraySize); // No point in allocating more memory if total length is smaller than arraySize.\n+        this.startOffset = 0;\n+        int count = length / arraySize + (length % arraySize == 0 ? 0 : 1);\n+        this.arrays = new Object[count];\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} class that wraps the given array. This instance\n+     * will have a single component array.\n+     *\n+     * @param source The byte array to wrap. Any changes made to this array will be reflected in this\n+     *               {@link CompositeByteArraySegment} instance and vice-versa.\n+     */\n+    @VisibleForTesting\n+    public CompositeByteArraySegment(@NonNull byte[] source) {\n+        this(new Object[]{source}, source.length, 0, source.length);\n+    }\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeByteArraySegment} that uses the given arguments. Useful for slicing.\n+     *\n+     * @param arrays      The array components to use.\n+     * @param arraySize   Size of each individual component.\n+     * @param startOffset Start offset.\n+     * @param length      Length of {@link CompositeByteArraySegment}.\n+     */\n+    private CompositeByteArraySegment(Object[] arrays, int arraySize, int startOffset, int length) {\n+        this.arrays = arrays;\n+        this.arraySize = arraySize;\n+        this.startOffset = startOffset;\n+        this.length = length;\n+    }\n+\n+    //region CompositeArrayView Implementation\n+\n+    @Override\n+    public byte get(int offset) {\n+        byte[] array = getArray(getArrayId(offset), false); // No need to allocate array if not allocated yet.\n+        return array == null ? 0 : array[getArrayOffset(offset)];\n+    }\n+\n+    @Override\n+    public void set(int offset, byte value) {\n+        byte[] array = getArray(getArrayId(offset), true); // Need to allocate array if not allocated yet.\n+        array[getArrayOffset(offset)] = value;\n+    }\n+\n+    @Override\n+    public InputStream getReader() {\n+        // Use the collector to create a list of ByteArrayInputStreams and then return them as combined.\n+        ArrayList<ByteArrayInputStream> streams = new ArrayList<>();\n+        collect((array, offset, length) -> streams.add(new ByteArrayInputStream(array, offset, length)));\n+        return new SequenceInputStream(Iterators.asEnumeration(streams.iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public CompositeArrayView slice(int offset, int length) {\n+        Exceptions.checkArrayRange(offset, length, this.length, \"offset\", \"length\");\n+        if (offset == 0 && length == this.length) {\n+            // Nothing to slice.\n+            return this;\n+        }\n+\n+        return new CompositeByteArraySegment(this.arrays, this.arraySize, this.startOffset + offset, length);\n+    }\n+\n+    @Override\n+    public <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray) throws ExceptionT {\n+        collect(collectArray, this.length);\n+    }\n+\n+    private <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectArray, int length) throws ExceptionT {\n+        if (length == 0) {\n+            // Nothing to collect.\n+            return;\n+        }\n+\n+        // We only need to process a subset of our arrays (since we may be sliced from the original array list).\n+        int startId = getArrayId(0);\n+        int endId = getArrayId(length - 1);\n+\n+        int arrayOffset = getArrayOffset(0); // The first array may need an offset, if this.startOffset > 0.\n+        for (int arrayId = startId; arrayId <= endId; arrayId++) {\n+            int arrayLength = Math.min(length, this.arraySize - arrayOffset);\n+            byte[] array = getArray(arrayId, false); // Don't allocate array if not allocated yet.\n+            if (array == null) {\n+                // Providing a dummy, empty array of the correct size is the easiest way to handle unallocated components\n+                // for all the cases this method is used for.\n+                collectArray.accept(new byte[arrayLength], 0, arrayLength);\n+            } else {\n+                collectArray.accept(array, arrayOffset, arrayLength);\n+            }\n+\n+            length -= arrayLength;\n+            arrayOffset = 0; // After processing the first array (handling this.startOffset), all other array offsets are 0.\n+        }\n+\n+        assert length == 0 : \"Collection finished but \" + length + \" bytes remaining\";\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {", "originalCommit": "22664531816c7a5805f3fd1ded5040c6f4cdf429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTM5Nw==", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384869397", "bodyText": "Done.", "author": "andreipaduroiu", "createdAt": "2020-02-27T01:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NTY0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7ebd3fb51133da338f99086ba017995bfe33c9e7", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java b/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java\nindex 2073933db4..4475b83c3d 100644\n--- a/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java\n+++ b/common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java\n\n@@ -179,24 +179,8 @@ public class CompositeByteArraySegment implements CompositeArrayView {\n \n     @Override\n     public byte[] getCopy() {\n-        // This method is a special instance of collect(), however we can optimize it since we can skip over unallocated\n-        // components without having to create a dummy one.\n-        int startId = getArrayId(0);\n-        int endId = getArrayId(this.length - 1);\n         byte[] result = new byte[this.length];\n-        int resultOffset = 0;\n-        int arrayOffset = getArrayOffset(resultOffset); // The first array may need an offset, if this.startOffset > 0.\n-        for (int i = startId; i <= endId; i++) {\n-            byte[] array = getArray(i, false); // Don't allocate array if not allocated yet.\n-            int copyLength = Math.min(result.length - resultOffset, this.arraySize - arrayOffset);\n-            if (array != null) {\n-                System.arraycopy(array, arrayOffset, result, resultOffset, copyLength);\n-            }\n-\n-            resultOffset += copyLength;\n-            arrayOffset = 0; // After processing the first array (handling this.startOffset), all other array offsets are 0.\n-        }\n-\n+        copyTo(ByteBuffer.wrap(result));\n         return result;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzE3NA==", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384857174", "bodyText": "Is this the best place for this method?", "author": "tkaitchuck", "createdAt": "2020-02-27T00:57:09Z", "path": "segmentstore/storage/impl/src/main/java/io/pravega/segmentstore/storage/impl/bookkeeper/Write.java", "diffHunk": "@@ -60,12 +68,19 @@\n         this.beginAttemptTimer = new AtomicReference<>();\n     }\n \n+    private ByteBuf convertData(CompositeArrayView data) {", "originalCommit": "22664531816c7a5805f3fd1ded5040c6f4cdf429", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTk1Mw==", "url": "https://github.com/pravega/pravega/pull/4567#discussion_r384869953", "bodyText": "This method converts a CompositeByteArraySegment to a Netty ByteBuf. CompositeByteArraySegment is in common which doesn't have a dependency on Netty, so I can't do that there.\nThis is the main reason why I added the collect method in CompositeArrayView, so that I can essentially convert it to anything else without having to add extra dependencies in it.", "author": "andreipaduroiu", "createdAt": "2020-02-27T01:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1NzE3NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "7dea2fc49e7fc15737d80e4b34995cdb7f724c1f", "url": "https://github.com/pravega/pravega/commit/7dea2fc49e7fc15737d80e4b34995cdb7f724c1f", "message": "Merge branch 'master' into issue-4565-data-frame", "committedDate": "2020-02-27T01:40:31Z", "type": "commit"}, {"oid": "7ebd3fb51133da338f99086ba017995bfe33c9e7", "url": "https://github.com/pravega/pravega/commit/7ebd3fb51133da338f99086ba017995bfe33c9e7", "message": "Simplified getCopy().\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-02-27T01:44:53Z", "type": "commit"}, {"oid": "90dfa65e9b365ad9bba148d08599d34ed1430856", "url": "https://github.com/pravega/pravega/commit/90dfa65e9b365ad9bba148d08599d34ed1430856", "message": "Merge remote-tracking branch 'ap/issue-4565-data-frame' into issue-4565-data-frame", "committedDate": "2020-02-27T01:45:25Z", "type": "commit"}, {"oid": "8a86956692007a42e4739f3638acf02ec93bee97", "url": "https://github.com/pravega/pravega/commit/8a86956692007a42e4739f3638acf02ec93bee97", "message": "Merge branch 'master' into issue-4565-data-frame", "committedDate": "2020-02-27T22:04:34Z", "type": "commit"}, {"oid": "b401b9efda45813bd4b427e45f293913c8fbba31", "url": "https://github.com/pravega/pravega/commit/b401b9efda45813bd4b427e45f293913c8fbba31", "message": "Merge branch 'master' into issue-4565-data-frame", "committedDate": "2020-02-28T08:28:13Z", "type": "commit"}]}