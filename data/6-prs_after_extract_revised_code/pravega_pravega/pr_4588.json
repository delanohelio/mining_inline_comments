{"pr_number": 4588, "pr_title": "Issue 4568: Key-Value Table Client Contracts", "pr_createdAt": "2020-03-03T16:23:59Z", "pr_url": "https://github.com/pravega/pravega/pull/4588", "timeline": [{"oid": "ef911343197440d18c3184731e56f78b3b775192", "url": "https://github.com/pravega/pravega/commit/ef911343197440d18c3184731e56f78b3b775192", "message": "Refactored TableSegment, TableEntry, TableKey in preparation for creating KeyValueTable. Moved a few classes around.\n\nRefactored SegmentHelper to make use of TableSegmentKey, TableSegmentEntry and TableSegmentKeyVersion which better map to what a Table Segment can do. Refactored upstream code and adjusted unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-02-24T23:51:07Z", "type": "commit"}, {"oid": "05ff3487b0c7e26b69c22e3ef1969823915141a2", "url": "https://github.com/pravega/pravega/commit/05ff3487b0c7e26b69c22e3ef1969823915141a2", "message": "Javadoc.\nMoved IteratorItem into its own file.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-02-25T00:21:59Z", "type": "commit"}, {"oid": "65f52b7d5bc0cc86d9490957498480d151703be2", "url": "https://github.com/pravega/pravega/commit/65f52b7d5bc0cc86d9490957498480d151703be2", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-02-25T18:03:54Z", "type": "commit"}, {"oid": "201e5f049c5ba118018d0633463cf739ea11e7e4", "url": "https://github.com/pravega/pravega/commit/201e5f049c5ba118018d0633463cf739ea11e7e4", "message": "Made IteratorState a class.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-02-25T18:21:59Z", "type": "commit"}, {"oid": "2e11121b0ee12384c7bae18228bf06d87bacc3b4", "url": "https://github.com/pravega/pravega/commit/2e11121b0ee12384c7bae18228bf06d87bacc3b4", "message": "Updated TableSegment.keyIterator and TableSegment.entryIterator.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-02-25T22:48:52Z", "type": "commit"}, {"oid": "206d4847cf8fd13c7ed69deabe9abf7f047a9589", "url": "https://github.com/pravega/pravega/commit/206d4847cf8fd13c7ed69deabe9abf7f047a9589", "message": "Javadoc fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-02-26T18:14:46Z", "type": "commit"}, {"oid": "e848733fbbb3a14ce48713e73a5cfa520dbaca03", "url": "https://github.com/pravega/pravega/commit/e848733fbbb3a14ce48713e73a5cfa520dbaca03", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4568-key-value-table-contracts", "committedDate": "2020-03-02T18:24:40Z", "type": "commit"}, {"oid": "bec961271dd6680d2f065f11505cd618bc50e14b", "url": "https://github.com/pravega/pravega/commit/bec961271dd6680d2f065f11505cd618bc50e14b", "message": "Refactored TableSegment, TableEntry, TableKey in preparation for creating KeyValueTable. Moved a few classes around.\n\nRefactored SegmentHelper to make use of TableSegmentKey, TableSegmentEntry and TableSegmentKeyVersion which better map to what a Table Segment can do. Refactored upstream code and adjusted unit tests.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-03-03T16:10:18Z", "type": "commit"}, {"oid": "fdc48e967cae0a052e064c0178aacde4a34f7124", "url": "https://github.com/pravega/pravega/commit/fdc48e967cae0a052e064c0178aacde4a34f7124", "message": "Javadoc.\nMoved IteratorItem into its own file.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-03-03T16:10:18Z", "type": "commit"}, {"oid": "57a4ae4f6a76424ffd789947232bb426e7266cec", "url": "https://github.com/pravega/pravega/commit/57a4ae4f6a76424ffd789947232bb426e7266cec", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-03T16:10:18Z", "type": "commit"}, {"oid": "9a9cc3e0dbf4d34ac8d51a2e842b999dc2fc471d", "url": "https://github.com/pravega/pravega/commit/9a9cc3e0dbf4d34ac8d51a2e842b999dc2fc471d", "message": "Made IteratorState a class.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-03T16:10:18Z", "type": "commit"}, {"oid": "2c138dd219c3bed59ad5998638c3cdf28e27471f", "url": "https://github.com/pravega/pravega/commit/2c138dd219c3bed59ad5998638c3cdf28e27471f", "message": "Updated TableSegment.keyIterator and TableSegment.entryIterator.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-03T16:10:18Z", "type": "commit"}, {"oid": "096cdd4843a0cb3dd11893b7c66592c858b1471e", "url": "https://github.com/pravega/pravega/commit/096cdd4843a0cb3dd11893b7c66592c858b1471e", "message": "Javadoc fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-03-03T16:10:18Z", "type": "commit"}, {"oid": "5f81fbb3aa9d099e39986a9c258da838a4e7f630", "url": "https://github.com/pravega/pravega/commit/5f81fbb3aa9d099e39986a9c258da838a4e7f630", "message": "Merge branch 'issue-4568-key-value-table-contracts' of https://github.com/andreipaduroiu/pravega into issue-4568-key-value-table-contracts", "committedDate": "2020-03-04T16:17:34Z", "type": "commit"}, {"oid": "e8a3e9cb0186f3c390a8b500d71be299cceb8c8c", "url": "https://github.com/pravega/pravega/commit/e8a3e9cb0186f3c390a8b500d71be299cceb8c8c", "message": "Unit tests ... for coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-03-04T16:56:28Z", "type": "commit"}, {"oid": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "url": "https://github.com/pravega/pravega/commit/1cadfa9c07c323757ad24197deccd3e6fb27f577", "message": "Increasing coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@dell.com>", "committedDate": "2020-03-04T21:05:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NTUwMQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388495501", "bodyText": "If there is no ordering this should really be a Set or a Collection and not a List.", "author": "tkaitchuck", "createdAt": "2020-03-05T18:57:29Z", "path": "client/src/main/java/io/pravega/client/tables/IteratorItem.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import lombok.Data;\n+\n+/**\n+ * An iteration result item returned by {@link AsyncIterator} when invoking {@link KeyValueTable#entryIterator}\n+ * or {@link KeyValueTable#keyIterator}.\n+ *\n+ * @param <T> Iterator Item type.\n+ */\n+@Data\n+public class IteratorItem<T> {\n+    /**\n+     * Gets an {@link IteratorState} that can be used to reinvoke {@link KeyValueTable#entryIterator} or\n+     * {@link KeyValueTable#keyIterator} if a previous iteration has been interrupted (by losing the pointer to the\n+     * {@link AsyncIterator}), system restart, etc.\n+     */\n+    private final IteratorState state;\n+    /**\n+     * A List of items that are contained in this instance. The items in this list are not necessarily related to each", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MjcxOA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389842718", "bodyText": "I removed this verbiage. Having a List gives the most flexibility in the API in case we want to return KVPs in a specific order in the future.", "author": "andreipaduroiu", "createdAt": "2020-03-09T17:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ5NTUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "df7480352538f93c7ccb10db86216513e019faa5", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/IteratorItem.java b/client/src/main/java/io/pravega/client/tables/IteratorItem.java\nindex 00c3ef6001..ec6721d0ac 100644\n--- a/client/src/main/java/io/pravega/client/tables/IteratorItem.java\n+++ b/client/src/main/java/io/pravega/client/tables/IteratorItem.java\n\n@@ -28,8 +28,7 @@ public class IteratorItem<T> {\n      */\n     private final IteratorState state;\n     /**\n-     * A List of items that are contained in this instance. The items in this list are not necessarily related to each\n-     * other, nor are they guaranteed to be in any particular order.\n+     * A List of items that are contained in this instance.\n      */\n     private final List<T> items;\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDIyMA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388504220", "bodyText": "Is this intended to be a public method? If so we cannot expose ByteBuf as it is from netty. This will need to be ByteBuffer as will the token above.", "author": "tkaitchuck", "createdAt": "2020-03-05T19:12:40Z", "path": "client/src/main/java/io/pravega/client/tables/IteratorState.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import lombok.Data;\n+\n+/**\n+ * Represents the state of a resumable iterator. Such an iterator can be executed asynchronously and continued after an\n+ * interruption. Each iteration will result in a new request to the server (which is stateless). The entire state of\n+ * the iterator is encoded in this object and is non-transferable between different types of iterations. The server will\n+ * use the information within it to decide what to return for the next iteration call.\n+ */\n+@Data\n+public class IteratorState {\n+    /**\n+     * No state. Providing this value will result in an iterator that starts from the beginning (i.e., not resuming an\n+     * existing iteration).\n+     */\n+    public static final IteratorState EMPTY = new IteratorState(Unpooled.EMPTY_BUFFER);\n+\n+    private final ByteBuf token;\n+\n+    /**\n+     * Gets a value indicating whether this {@link IteratorState} instance is empty.\n+     *\n+     * @return True if empty, false otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return this.token.readableBytes() == 0;\n+    }\n+\n+    /**\n+     * Deserializes the IteratorState from its serialized form obtained from calling {@link #getToken()} .\n+     *\n+     * @param serializedState A serialized {@link IteratorState}.\n+     * @return The IteratorState object.\n+     */\n+    public static IteratorState fromBytes(ByteBuf serializedState) {", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3NTQ3Mg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389975472", "bodyText": "I separated this into an interface (IteratorState - in this package) and an implementing class (IteratorStateImpl - in the impl package). The interface only deals with ByteBuffers, but the implementation was already heavily used in the SegmentHelper, so I had to provide both ByteBuffer and ByteBuf methods for that one.\nOnce this whole feature is merged in, we should put some effort into making SegmentHelper use TableSegmentImpl (coming in next PR), which will reduce the need for all of these extra methods.", "author": "andreipaduroiu", "createdAt": "2020-03-09T21:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUwNDIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "df7480352538f93c7ccb10db86216513e019faa5", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/IteratorState.java b/client/src/main/java/io/pravega/client/tables/IteratorState.java\nindex cf16d61719..d12964e94b 100644\n--- a/client/src/main/java/io/pravega/client/tables/IteratorState.java\n+++ b/client/src/main/java/io/pravega/client/tables/IteratorState.java\n\n@@ -9,9 +9,9 @@\n  */\n package io.pravega.client.tables;\n \n-import io.netty.buffer.ByteBuf;\n import io.netty.buffer.Unpooled;\n-import lombok.Data;\n+import io.pravega.client.tables.impl.IteratorStateImpl;\n+import java.nio.ByteBuffer;\n \n /**\n  * Represents the state of a resumable iterator. Such an iterator can be executed asynchronously and continued after an\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjY3Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388516677", "bodyText": "This concept is already complex enough without the additional possibility of some keys not being in a family. I think we can just make it mandatory. If users want them to be random they can just pass the same string twice.", "author": "tkaitchuck", "createdAt": "2020-03-05T19:34:41Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk3NjA0MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389976040", "bodyText": "What I am concerned is that if users absolutely do not care about Key families, they will just do something like put(\"\", key, value), which will essentially group all keys into the same TableSegment, so there's no distribution done.\nI am in favor of keeping both around.", "author": "andreipaduroiu", "createdAt": "2020-03-09T21:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYzODk5Mw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r390638993", "bodyText": "Perhaps we can then hide this inside of the key object itself. Have a Key type that we take which has an optional family field. That keeps this API clean, and there is no risk of misuse.", "author": "tkaitchuck", "createdAt": "2020-03-10T22:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5ODMzMw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392498333", "bodyText": "That will cause trouble with batch updates and removals. Having the family separate from the keys forces the user to think that the update affects a single key family. Being able to mix keys from different key families together will not be supported, and we'll need to throw a runtime exception, which I think is worse than it is now.", "author": "andreipaduroiu", "createdAt": "2020-03-13T21:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNjY3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d3f2e4d22f861bc513255b0a1d26e916c66e905b", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex d0b6583285..00796a77f1 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -27,20 +27,24 @@ import java.util.concurrent.CompletableFuture;\n  * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n  * keys/entries belonging to the same Key Family to be updated/removed atomically.\n  * <ul>\n- * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n  * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n  * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n  * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n  * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n  * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n  * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n- * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n- * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n- * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n- * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n- * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n- * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n- * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n  * </ul>\n  * <p>\n  * Types of Updates:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNzg0OQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388517849", "bodyText": "This is explaining that \"improper\" use is bad, but it does so without first explaining how the system is architected and what a 'proper' use looks like given that architecture.", "author": "tkaitchuck", "createdAt": "2020-03-05T19:36:55Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MDU1Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389980557", "bodyText": "It is explained a few lines above:\n Each {@link TableKey} is hashed to a Table Partition which may be represented by one or more Table Segments\n\n...\n\nKey Families are used to group related Keys together in the same Table Partition, which allows multiple keys/entries belonging to the same Key Family to be updated/removed atomically.", "author": "andreipaduroiu", "createdAt": "2020-03-09T21:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNzg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODMyOA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392518328", "bodyText": "That's not really an instruction. Please rephrase this sentence to tell people what they should do.", "author": "tkaitchuck", "createdAt": "2020-03-13T22:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNzg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4ODIzOA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r393788238", "bodyText": "Ok. I rephrased the entire paragraph.", "author": "andreipaduroiu", "createdAt": "2020-03-17T15:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxNzg0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d3f2e4d22f861bc513255b0a1d26e916c66e905b", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex d0b6583285..00796a77f1 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -27,20 +27,24 @@ import java.util.concurrent.CompletableFuture;\n  * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n  * keys/entries belonging to the same Key Family to be updated/removed atomically.\n  * <ul>\n- * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n  * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n  * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n  * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n  * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n  * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n  * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n- * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n- * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n- * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n- * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n- * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n- * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n- * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n  * </ul>\n  * <p>\n  * Types of Updates:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388522834", "bodyText": "With these conditional and unconditional updates, I think we should blatantly copy the verbage from concurrenthashmap, because they are standardized in the Java Collections.\nput, putAll, putIfAbsent, remove, and replace.\nJava developers will recognise the meaning of these terms.", "author": "tkaitchuck", "createdAt": "2020-03-05T19:45:52Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n+ * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n+ * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n+ * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n+ * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n+ * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n+ * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NTMxNw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389985317", "bodyText": "The HashMap/ConcurrentHashMap methods do not have the rich semantics the ones in the KeyValueTableAre.\nHashMap.put performs an unconditional update of a single key and returns the existing key.\nHashMap.putAll performs an unconditional update of multiple key and doesn't return anything.\nSimilarly with remove.\nThe KeyValueTable methods give you more flexibility than just simple put/putAll/remove. For example, when you update multiple entries at once, you can set a condition on 0, one or more of those entries; all the conditions on the update batch will need to be satisified in order for the entire batch to be accepted. In addition, you can mix conditions (one key may have no condition, one key may condition on it not existing before, and another key may be conditioned on a specific version).\nHashMap does not give you that - as a programmer, you'd have to write your own code to do something similar.\nSo I don't see how we can differentiate this using different API names given all the possibilities it supports.", "author": "andreipaduroiu", "createdAt": "2020-03-09T21:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0MDEyMg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r390640122", "bodyText": "Yes, put is unconditional. replace is the name of the API when the update is conditional on a particular value, and putIfAbsent is the name when the update is conditional on the non-existence of the value. I see no reason for us to name conditional operations put which has the already established a meaning of \"non-conditional update\".", "author": "tkaitchuck", "createdAt": "2020-03-10T22:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwMTI5NA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392501294", "bodyText": "Ok, so how are we going to name the batch operations, which can take multiple keys, each having a condition of a different type (version, not exists, or no condition at all)?\nShall we have put(single entry), replace(single entry), putIfAbsent(single entry), remove(single key) (this one for both conditional and unconditional), and putAll(multiple entries) and removeAll?\nEach of these calls will need to validate their input properly. Currently all APIs take in TableKey or TableEntry which contain various fields, including a version. We'll need to ensure that we don't pass one of these with no version to a conditional API or viceversa.", "author": "andreipaduroiu", "createdAt": "2020-03-13T21:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTEwNg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392525106", "bodyText": "No. I am proposing the following:\nRename KeyVersion to Version and move it off of key and put in on TableEntry. (It has to do with entries no keys after all) and have TableEntry extend Map.Entry.\nThen on this class have:\nCompletableFuture<TableEntry<KeyT, ValueT>> get(String keyFamily, KeyT key);\nCompletableFuture<List<TableEntry<KeyT, ValueT>>> getAll(String keyFamily, List<KeyT> keys);\nCompletableFuture<Version> put(String keyFamily, KeyT key, ValueT value);\nCompletableFuture<List<Version>> putAll(String keyFamily, Iterable<Entry<KeyT, ValueT> items);\nCompletableFuture<Version> putIfAbsent(String keyFamily, KeyT key, ValueT value);\nCompletableFuture<Version> replace(String keyFamily, KeyT key, Version version, ValueT value);\nCompletableFuture<List<Version>> replaceAll(String keyFamily, Iterable<TableEntry<KeyT, ValueT>> items);\nCompletableFuture<TableEntry<KeyT, ValueT>> remove(String keyFamily, KeyT key);\nCompletableFuture<Boolean> remove(String keyFamily, KeyT key, Version version);\nCompletableFuture<Boolean> removeAll(String keyFamily, Iterable<TableEntry<KeyT, ValueT>> items);\nIn all of the above keyFamily may be null.", "author": "tkaitchuck", "createdAt": "2020-03-13T23:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0NTYzNg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398645636", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMjgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "d3f2e4d22f861bc513255b0a1d26e916c66e905b", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex d0b6583285..00796a77f1 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -27,20 +27,24 @@ import java.util.concurrent.CompletableFuture;\n  * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n  * keys/entries belonging to the same Key Family to be updated/removed atomically.\n  * <ul>\n- * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n  * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n  * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n  * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n  * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n  * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n  * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n- * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n- * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n- * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n- * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n- * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n- * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n- * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n  * </ul>\n  * <p>\n  * Types of Updates:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNjU4Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r388526587", "bodyText": "Why is there a getter for this? Generally we don't expose segments", "author": "tkaitchuck", "createdAt": "2020-03-05T19:52:24Z", "path": "client/src/main/java/io/pravega/client/tables/KeyVersion.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.client.tables.impl.TableSegmentKeyVersion;\n+import java.io.Serializable;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Version of a Key in a Table.\n+ */\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+public class KeyVersion implements Serializable {\n+    /**\n+     * {@link KeyVersion} that indicates no specific version is desired. Using this will result in an unconditional\n+     * update or removal being performed. See {@link KeyValueTable} for details on conditional/unconditional updates.\n+     */\n+    public static final KeyVersion NO_VERSION = new KeyVersion(null, TableSegmentKeyVersion.NO_VERSION);\n+    /**\n+     * {@link KeyVersion} that indicates the {@link TableKey} must not exist. Using this will result in an conditional\n+     * update or removal being performed, conditioned on the {@link TableKey} not existing at the time of the operation.\n+     * See {@link KeyValueTable} for details on conditional/unconditional updates.\n+     */\n+    public static final KeyVersion NOT_EXISTS = new KeyVersion(null, TableSegmentKeyVersion.NOT_EXISTS);\n+\n+    /**\n+     * The Segment where this Key resides. May be null if this is a {@link #NOT_EXISTS} or {@link #NO_VERSION}\n+     * {@link KeyVersion}.\n+     */\n+    @Getter", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1MDgyMQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389850821", "bodyText": "Ok. Until I know how these will be exposed externally (probably some opaque serialization), I have decided to remove the getter for this one and make getSegmentVersion package-private. We'll revisit some of these once we have implementations done.", "author": "andreipaduroiu", "createdAt": "2020-03-09T17:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyNjU4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "df7480352538f93c7ccb10db86216513e019faa5", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyVersion.java b/client/src/main/java/io/pravega/client/tables/KeyVersion.java\nindex 4c246713d7..dbf84c9643 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyVersion.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyVersion.java\n\n@@ -12,7 +12,6 @@ package io.pravega.client.tables;\n import io.pravega.client.tables.impl.TableSegmentKeyVersion;\n import java.io.Serializable;\n import lombok.AccessLevel;\n-import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3NjczOQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389476739", "bodyText": "@andreipaduroiu Could you help undertstand how ByteBuf release is being handled here?", "author": "shrids", "createdAt": "2020-03-09T06:09:12Z", "path": "controller/src/main/java/io/pravega/controller/server/SegmentHelper.java", "diffHunk": "@@ -376,27 +366,24 @@ private String getTransactionName(String scope, String stream, long segmentId, U\n     /**\n      * This method sends a WireCommand to update table entries.\n      *\n-     * @param tableName           Qualified table name.\n-     * @param entries             List of {@link TableEntry}s to be updated.\n-     * @param delegationToken     The token to be presented to the segmentstore.\n-     * @param clientRequestId     Request id.\n-     * @return A CompletableFuture that, when completed normally, will contain the current versions of each {@link TableEntry}\n+     * @param tableName       Qualified table name.\n+     * @param entries         List of {@link TableSegmentEntry} instances to be updated.\n+     * @param delegationToken The token to be presented to the Segment Store.\n+     * @param clientRequestId Request id.\n+     * @return A CompletableFuture that, when completed normally, will contain the current versions of each\n+     * {@link TableSegmentEntry}.\n      * If the operation failed, the future will be failed with the causing exception. If the exception can be retried\n      * then the future will be failed with {@link WireCommandFailedException}.\n      */\n-    public CompletableFuture<List<KeyVersion>> updateTableEntries(final String tableName,\n-                                                                  final List<TableEntry<byte[], byte[]>> entries,\n-                                                                  String delegationToken,\n-                                                                  final long clientRequestId) {\n+    public CompletableFuture<List<TableSegmentKeyVersion>> updateTableEntries(final String tableName,\n+                                                                              final List<TableSegmentEntry> entries,\n+                                                                              String delegationToken,\n+                                                                              final long clientRequestId) {\n         final Controller.NodeUri uri = getTableUri(tableName);\n         final WireCommandType type = WireCommandType.UPDATE_TABLE_ENTRIES;\n-        List<ByteBuf> buffersToRelease = new ArrayList<>();\n         List<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>> wireCommandEntries = entries.stream().map(te -> {\n             final WireCommands.TableKey key = convertToWireCommand(te.getKey());\n-            ByteBuf valueBuffer = wrappedBuffer(te.getValue());\n-            buffersToRelease.add(key.getData());\n-            buffersToRelease.add(valueBuffer);\n-            final WireCommands.TableValue value = new WireCommands.TableValue(valueBuffer);", "originalCommit": "1cadfa9c07c323757ad24197deccd3e6fb27f577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0OTk3NA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r389849974", "bodyText": "I moved it up into PravegaTablesStoreHelper. It is the responsibility of whomever generates the ByteBufs to release them. Now that they are no longer generated inside SegmentHelper, PravegaTablesStoreHelper is the one that both creates and releases them.\nI needed to to this since the eventual TableSegmentImpl class deals with ByteBufs that come from the eventual KeyValueTableImpl class, so I had to standardize the usage across both implementations.", "author": "andreipaduroiu", "createdAt": "2020-03-09T17:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ3NjczOQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "df7480352538f93c7ccb10db86216513e019faa5", "url": "https://github.com/pravega/pravega/commit/df7480352538f93c7ccb10db86216513e019faa5", "message": "Fixed some Javadoc verbiage.\nSeparated IteratorState (interface) and IteratorStateImpl (class) to hide some implementation details.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-09T22:03:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxNzYwMg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r392517602", "bodyText": "This should say \"(either all changes will be applied or none will)\".\nI am trying to avoid the implication that \"all\" refers to keys/entries rather than the changes.", "author": "tkaitchuck", "createdAt": "2020-03-13T22:45:38Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).", "originalCommit": "df7480352538f93c7ccb10db86216513e019faa5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d3f2e4d22f861bc513255b0a1d26e916c66e905b", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex d0b6583285..00796a77f1 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -27,20 +27,24 @@ import java.util.concurrent.CompletableFuture;\n  * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n  * keys/entries belonging to the same Key Family to be updated/removed atomically.\n  * <ul>\n- * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all at once or none).\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n  * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n  * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n  * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n  * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n  * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n  * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n- * <li> Improper use of Key Families may result in degraded performance. If a disproportionate number of Keys/Entries\n- * are placed in the same Key Family (compared to the number of Key/Entries in other Key Families), it may not be\n- * possible to uniformly distribute the Key-Value Table Entries across the cluster and more load will be placed on a\n- * single backing Table Segment instead of spreading such load across many Table Segments. An ideally balanced Key-Value\n- * Table will be one where Keys are not part of any Key Families or the number of Keys in each Key Family is approximately\n- * the same. An improperly designed Key-Value Table will have all Keys part of a single Key Family which will cause a\n- * single Table Segment to bear the full storage and processing load of the entire Key-Value Table.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n  * </ul>\n  * <p>\n  * Types of Updates:\n"}}, {"oid": "d3f2e4d22f861bc513255b0a1d26e916c66e905b", "url": "https://github.com/pravega/pravega/commit/d3f2e4d22f861bc513255b0a1d26e916c66e905b", "message": "Javadoc fixes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-17T16:00:03Z", "type": "commit"}, {"oid": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "url": "https://github.com/pravega/pravega/commit/5fa9ebfaafd25626e344949f70230ca690a41ff4", "message": "KeyValueTable API variant #2\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-17T18:06:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NDYxOQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398444619", "bodyText": "This is a bit confusing. I understand that BadKeyVersion is a special case of ConditionalTableUpdate, but I don't understand what other case is included in ConditionalTableUpdate. If there is such a case, why not create an exception for that specific case?\nAlso, the use that I'm seeing of ConditionalTableUpdate in TableSegment is about version mismatch, so why are you not using BadKeyVersion there. From TableSegment:\n <li>{@link ConditionalTableUpdateException} If this is a Conditional Update and the condition was not satisfied.", "author": "fpj", "createdAt": "2020-03-26T09:55:41Z", "path": "client/src/main/java/io/pravega/client/tables/BadKeyVersionException.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+/**\n+ * Exception that is thrown whenever a conditional {@link KeyValueTable} update failed due to the provided key version\n+ * mismatching. This is different from {@link NoSuchKeyException}.\n+ */\n+public class BadKeyVersionException extends ConditionalTableUpdateException {", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0NzM4MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398647380", "bodyText": "NoSuchKeyException is another type of ConditionalTableUpdateException that indicates the Key does not exist when it was expected to exist. In some cases it is useful to the caller to know that the key does not exist instead of just \"BadVersion\". The Controller already uses this differentiation.", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NDYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Mjg3OA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398662878", "bodyText": "Check out here (branch forked from this that implements the Table Segment Client) on how Wire commands are converted to such exceptions:\nhttps://github.com/andreipaduroiu/pravega/blob/issue-4333-tables-segment-client/client/src/main/java/io/pravega/client/tables/impl/TableSegmentImpl.java#L227", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NDYxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NjI0NQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398446245", "bodyText": "I'm not sure what \"non-transferable between different types of iterations\" is referring to. Are you referring to reusing state from different iterator instances?", "author": "fpj", "createdAt": "2020-03-26T09:58:04Z", "path": "client/src/main/java/io/pravega/client/tables/IteratorState.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.netty.buffer.Unpooled;\n+import io.pravega.client.tables.impl.IteratorStateImpl;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Represents the state of a resumable iterator. Such an iterator can be executed asynchronously and continued after an\n+ * interruption. Each iteration will result in a new request to the server (which is stateless). The entire state of\n+ * the iterator is encoded in this object and is non-transferable between different types of iterations. The server will", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0ODM5NQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398648395", "bodyText": "I am saying you may not use the state:\n\nFrom one KVT to another KVT\nFrom a KVT Key Iterator to the same KVT Entry iterator.\n\nIn other words, use the state only on the same method and on the same KVT.", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzU3Ng==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398657576", "bodyText": "Reworded the paragraph to clarify.", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ0NjI0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/IteratorState.java b/client/src/main/java/io/pravega/client/tables/IteratorState.java\nindex d12964e94b..036f363adb 100644\n--- a/client/src/main/java/io/pravega/client/tables/IteratorState.java\n+++ b/client/src/main/java/io/pravega/client/tables/IteratorState.java\n\n@@ -16,8 +16,14 @@ import java.nio.ByteBuffer;\n /**\n  * Represents the state of a resumable iterator. Such an iterator can be executed asynchronously and continued after an\n  * interruption. Each iteration will result in a new request to the server (which is stateless). The entire state of\n- * the iterator is encoded in this object and is non-transferable between different types of iterations. The server will\n- * use the information within it to decide what to return for the next iteration call.\n+ * the iterator is encoded in this object and and is used by the server to decide what to return for the next iteration\n+ * call.\n+ * <p>\n+ * Each {@link IteratorState} instance is coupled to the Key-Value Table that it was created for and is tailored for the\n+ * type of iteration that generates it (i.e., {@link KeyValueTable#keyIterator} vs {@link KeyValueTable#entryIterator}).\n+ * As such, an {@link IteratorState} instance is non-transferable between different types of iterations or between\n+ * different Key-Value Tables. It is OK to pass a {@link IteratorState} generated from a {@link KeyValueTable} instance\n+ * to another {@link KeyValueTable} instance for the same Key-Value Table.\n  */\n public interface IteratorState {\n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ1NTcxOQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398455719", "bodyText": "I suggest to rephrase this to the following:\nInserts a new Entry in the {@link KeyValueTable} only if the given Key is not already present.\n\nThe use of conditionally is redundant and the use of iff does not sound logically correct.", "author": "fpj", "createdAt": "2020-03-26T10:13:07Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link KeyVersion#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link KeyVersion#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NOT_EXISTS} or {@link KeyVersion#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link KeyVersion} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<KeyVersion> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if and only if the given Key is not already present.", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0OTQwNQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398649405", "bodyText": "removed iff", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ1NTcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 635305b6a2..2c91046fd7 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -92,7 +92,7 @@ public interface KeyValueTable<KeyT, ValueT> {\n     CompletableFuture<KeyVersion> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n \n     /**\n-     * Conditionally inserts a new Entry in the {@link KeyValueTable} if and only if the given Key is not already present.\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if the given Key is not already present.\n      *\n      * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n      *                  Key Family.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ1NTk3Mw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398455973", "bodyText": "Same comment about rephrasing.", "author": "fpj", "createdAt": "2020-03-26T10:13:32Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link KeyVersion#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link KeyVersion#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NOT_EXISTS} or {@link KeyVersion#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link KeyVersion#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link KeyVersion} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<KeyVersion> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if and only if the given Key is not already present.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link KeyVersion} associated with the newly\n+     * inserted or updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is already present in the {@link KeyValueTable} for the\n+     * provided Key Family.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<KeyVersion> putIfAbsent(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Unconditionally inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family\n+     * into this {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link Map.Entry} instances to insert or update.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link KeyVersion} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as the number of\n+     * items in entries and the versions will be in the same order as the entries.\n+     */\n+    CompletableFuture<List<KeyVersion>> putAll(@NonNull String keyFamily, @NonNull Iterable<Map.Entry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Conditionally updates an existing Entry in the {@link KeyValueTable} if and only if the given Key exists and its", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0OTcxNw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398649717", "bodyText": "fixed", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ1NTk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 635305b6a2..2c91046fd7 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -92,7 +92,7 @@ public interface KeyValueTable<KeyT, ValueT> {\n     CompletableFuture<KeyVersion> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n \n     /**\n-     * Conditionally inserts a new Entry in the {@link KeyValueTable} if and only if the given Key is not already present.\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if the given Key is not already present.\n      *\n      * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n      *                  Key Family.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398460771", "bodyText": "I find this notion of \"key version\" confusing. I understand you want the comparison to be on separate value compared to making it conditional on the value itself, and I think I understand why you associate the version to the key: you the key is what is constant in a key-value pair. But, the version really refers to the KV pair, and it indicates state changes to a particular KV pair, where the state change is reflected in the change of a value.\nI'm saying all this to ask whether we can disassociate version from key. If we call it just version, then it would be ideal but it is too generic maybe and might conflict with some other definition of version. Another option is to call it KVVersion to associate to a KV pair.\nLet me know what you think.", "author": "fpj", "createdAt": "2020-03-26T10:21:23Z", "path": "client/src/main/java/io/pravega/client/tables/KeyVersion.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.client.tables.impl.TableSegmentKeyVersion;\n+import java.io.Serializable;\n+import lombok.AccessLevel;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Version of a Key in a Table.", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MzQ1OA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398653458", "bodyText": "The KVT is a collection of KV pairs, then each KV pair is essentially immutable. As such it cannot have \"versions\".\nThe KVT can also be viewed as a collection of Keys that have values associated, and every KVT mutation modifies the Value associated with a Key. As such, every such mutation creates a new KVP for that Key, which means the version of the Key needs to change. Hence the association of Versions to Keys (i.e., KeyVersion).", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0MDg0MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398940840", "bodyText": "In the general case of a table, a triple {row, column, version} gives the value of a cell, e.g., as in hbase:\nhttps://hbase.apache.org/book.html#versions\nif we treat KV pairs as a special case of a table with a single column, then {key, version} gives the corresponding value of that version. I think that's why you say that the version is associated to the key, but if we think more generally about tables, then the version is really about the cell and its value.\nI\u00b4d rather not call it KeyVersion because the key is a coordinate to the value, and the version is not about the coordinate. But, I don't fully understand whether that breaks the internal abstractions (e.g., TableSegment), in which case we might not have a choice. Let me know.", "author": "fpj", "createdAt": "2020-03-26T22:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1MTA5Ng==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398951096", "bodyText": "This is not a multi-column table. It's a 2-column table, one column being key and the other value. We cannot use version to execute a lookup (i.e., get version X of key Y). We can only get the latest version of a Key. Versions are only there to enable conditional updates.\nThis API does nothing to change the meaning of versions. Versions are defined like this in Table Segments and the KeyValue Table API is just passing them through and exposing them.\nIf you are looking to make such a semantic change, we'd have to likely redo most of the Table Segment work, which is out of scope for this project.", "author": "andreipaduroiu", "createdAt": "2020-03-26T23:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM2NDU4MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399364580", "bodyText": "If we can call it Version or add a prefix to version that doesn't make it look like we are versioning the key rather than the value, I'm good. Internally, the version can remain implemented as is, so no work out of scope. Does it work?", "author": "fpj", "createdAt": "2020-03-27T15:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM5NzAzMg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399397032", "bodyText": "Ok. I renamed it to Version.", "author": "andreipaduroiu", "createdAt": "2020-03-27T16:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MDc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "253896be5fe963601edbccfb29e13efdb515280a", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyVersion.java b/client/src/main/java/io/pravega/client/tables/Version.java\nsimilarity index 73%\nrename from client/src/main/java/io/pravega/client/tables/KeyVersion.java\nrename to client/src/main/java/io/pravega/client/tables/Version.java\nindex dbf84c9643..cfb7a349f6 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyVersion.java\n+++ b/client/src/main/java/io/pravega/client/tables/Version.java\n\n@@ -18,22 +18,22 @@ import lombok.RequiredArgsConstructor;\n  * Version of a Key in a Table.\n  */\n @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n-public class KeyVersion implements Serializable {\n+public class Version implements Serializable {\n     /**\n-     * {@link KeyVersion} that indicates no specific version is desired. Using this will result in an unconditional\n+     * {@link Version} that indicates no specific version is desired. Using this will result in an unconditional\n      * update or removal being performed. See {@link KeyValueTable} for details on conditional/unconditional updates.\n      */\n-    public static final KeyVersion NO_VERSION = new KeyVersion(null, TableSegmentKeyVersion.NO_VERSION);\n+    public static final Version NO_VERSION = new Version(null, TableSegmentKeyVersion.NO_VERSION);\n     /**\n-     * {@link KeyVersion} that indicates the {@link TableKey} must not exist. Using this will result in an conditional\n+     * {@link Version} that indicates the {@link TableKey} must not exist. Using this will result in an conditional\n      * update or removal being performed, conditioned on the {@link TableKey} not existing at the time of the operation.\n      * See {@link KeyValueTable} for details on conditional/unconditional updates.\n      */\n-    public static final KeyVersion NOT_EXISTS = new KeyVersion(null, TableSegmentKeyVersion.NOT_EXISTS);\n+    public static final Version NOT_EXISTS = new Version(null, TableSegmentKeyVersion.NOT_EXISTS);\n \n     /**\n      * The Segment where this Key resides. May be null if this is a {@link #NOT_EXISTS} or {@link #NO_VERSION}\n-     * {@link KeyVersion}.\n+     * {@link Version}.\n      */\n     private final String segmentName;\n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzI3OA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398463278", "bodyText": "Is this supposed to be public or package protected? Do I understand right that TableSegment isn't a concept we are exposing, that it is an internal implementation detail?", "author": "fpj", "createdAt": "2020-03-26T10:25:23Z", "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentEntry.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Entry in a {@link TableSegment}.\n+ */\n+@Getter\n+@RequiredArgsConstructor(access = AccessLevel.PACKAGE)\n+public class TableSegmentEntry {", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDU3Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398650577", "bodyText": "Because the Controller already uses these classes I have no option but to make them public. Once we get this KVT merged in (with TableSegmentImpl as well), we should make an issue for the Controller to retire their own client in favor of this implementation.", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgwMDgyMw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398800823", "bodyText": "Let's create an issue ahead of time so that we don't forget, please.", "author": "fpj", "createdAt": "2020-03-26T18:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0OTI4MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398949280", "bodyText": "#4647 and assigned to @shrids .", "author": "andreipaduroiu", "createdAt": "2020-03-26T23:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzI3OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzYwNQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398463605", "bodyText": "Same question about the visibility of this class.", "author": "fpj", "createdAt": "2020-03-26T10:26:01Z", "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegmentKey.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+\n+/**\n+ * Key for a {@link TableSegment}.\n+ */\n+@Getter\n+@RequiredArgsConstructor(access = AccessLevel.PACKAGE)\n+public class TableSegmentKey {", "originalCommit": "5fa9ebfaafd25626e344949f70230ca690a41ff4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MTI3Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r398651277", "bodyText": "Same answer.", "author": "andreipaduroiu", "createdAt": "2020-03-26T15:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODQ2MzYwNQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "url": "https://github.com/pravega/pravega/commit/7b95541f6d6bb74395c9e470a651a9592a4f5762", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-26T15:20:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI3NjQ3NQ==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399276475", "bodyText": "nit: missing }", "author": "shrids", "createdAt": "2020-03-27T13:48:19Z", "path": "client/src/main/java/io/pravega/client/tables/impl/TableSegment.java", "diffHunk": "@@ -23,134 +26,123 @@\n  * * Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether that Key\n  * previously existed or not, and regardless of what that Key's version is.\n  * * Conditional Updates will only overwrite an existing value if the specified version matches that Key's version. If\n- * the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with {@link KeyVersion#NOT_EXISTS}\n- * in order for the update to succeed.\n+ * the key does not exist, the {@link TableSegmentKey} or {@link TableSegmentEntry} must have been created with\n+ * {@link TableSegmentKeyVersion#NOT_EXISTS} in order for the update to succeed.\n  * * Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also succeed (albeit\n  * with no effect) if the Key does not exist.\n- * * Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's version.\n- * It will also fail (with no effect) if the Key does not exist and Version is not set to {@link KeyVersion#NOT_EXISTS}.\n+ * * Conditional Removals will remove a Key only if the specified {@link TableSegmentKey#getVersion()} matches that Key's version.\n+ * It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link TableSegmentKeyVersion#NOT_EXISTS}.\n  *\n- * @param <KeyT>   Table Key Type.\n- * @param <ValueT> Table Value Type.\n+ * A note about {@link ByteBuf}s. All the methods defined in this interface make use of {@link ByteBuf} either directly\n+ * or via {@link TableSegmentKey}/{@link TableSegmentEntry}. It is expected that no implementation of the {@link TableSegment}\n+ * interface will either retain ({@link ByteBuf#retain()) or release ({@link ByteBuf#release()}) these buffers during", "originalCommit": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/impl/TableSegment.java b/client/src/main/java/io/pravega/client/tables/impl/TableSegment.java\nindex 731374d0d6..f9ded62854 100644\n--- a/client/src/main/java/io/pravega/client/tables/impl/TableSegment.java\n+++ b/client/src/main/java/io/pravega/client/tables/impl/TableSegment.java\n\n@@ -36,7 +36,7 @@ import java.util.concurrent.CompletableFuture;\n  *\n  * A note about {@link ByteBuf}s. All the methods defined in this interface make use of {@link ByteBuf} either directly\n  * or via {@link TableSegmentKey}/{@link TableSegmentEntry}. It is expected that no implementation of the {@link TableSegment}\n- * interface will either retain ({@link ByteBuf#retain()) or release ({@link ByteBuf#release()}) these buffers during\n+ * interface will either retain ({@link ByteBuf#retain()}) or release ({@link ByteBuf#release()}) these buffers during\n  * execution. The lifecycle of these buffers should be maintained externally by the calling code, using the following\n  * guidelines:\n  * * For methods that accept externally-provided {@link ByteBuf}s, the calling code should call {@link ByteBuf#retain()}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5MDQ1OA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399290458", "bodyText": "+1", "author": "shrids", "createdAt": "2020-03-27T14:08:48Z", "path": "controller/src/main/java/io/pravega/controller/store/stream/PravegaTablesStoreHelper.java", "diffHunk": "@@ -429,69 +445,24 @@ public void invalidateCache(String table, String key) {\n             Function<byte[], T> fromBytes) {\n         log.trace(\"get entries paginated called for : {}\", tableName);\n         return withRetries(() -> segmentHelper.readTableEntries(tableName, limit,\n-                IteratorState.fromBytes(continuationToken), authToken.get(), RequestTag.NON_EXISTENT_ID),\n+                IteratorStateImpl.fromBytes(continuationToken), authToken.get(), RequestTag.NON_EXISTENT_ID),\n                 () -> String.format(\"get entries paginated for table: %s\", tableName))\n                 .thenApplyAsync(result -> {\n-                    List<Map.Entry<String, VersionedMetadata<T>>> items = result.getItems().stream().map(x -> {\n-                        String key = new String(x.getKey().getKey(), Charsets.UTF_8);\n-                        T deserialized = fromBytes.apply(x.getValue());\n-                        VersionedMetadata<T> value = new VersionedMetadata<>(deserialized, new Version.LongVersion(x.getKey().getVersion().getSegmentVersion()));\n-                        return new AbstractMap.SimpleEntry<>(key, value);\n-                    }).collect(Collectors.toList());\n-                    log.trace(\"get keys paginated on table {} returned number of items {}\", tableName, items.size());\n-                    return new AbstractMap.SimpleEntry<>(result.getState().toBytes(), items);\n+                    try {\n+                        List<Map.Entry<String, VersionedMetadata<T>>> items = result.getItems().stream().map(x -> {\n+                            String key = new String(getArray(x.getKey().getKey()), Charsets.UTF_8);\n+                            T deserialized = fromBytes.apply(getArray(x.getValue()));\n+                            VersionedMetadata<T> value = new VersionedMetadata<>(deserialized, new Version.LongVersion(x.getKey().getVersion().getSegmentVersion()));\n+                            return new AbstractMap.SimpleEntry<>(key, value);\n+                        }).collect(Collectors.toList());\n+                        log.trace(\"get keys paginated on table {} returned number of items {}\", tableName, items.size());\n+                        return new AbstractMap.SimpleEntry<>(Unpooled.wrappedBuffer(result.getState().toBytes()), items);\n+                    } finally {\n+                        releaseEntries(result.getItems());\n+                    }\n                 }, executor);\n     }\n \n-    /**\n-     * Method to retrieve a collection of entries bounded by the specified limit size that satisfy the supplied filter.\n-     * This function makes calls into segment store and includes entries that satisfy the supplied\n-     * predicate. It makes repeated paginated calls into segment store until it has either collected deseried number\n-     * of entries or it has exhausted all entries in the store.\n-     * @param table table\n-     * @param fromStringKey function to deserialize key from String.\n-     * @param fromBytesValue function to deserialize value from byte array\n-     * @param filter filer predicate which takes key and value and returns true or false.\n-     * @param limit maximum number of entries to retrieve\n-     * @param <K> Type of Key\n-     * @param <V> Type of Value\n-     * @return CompletableFuture which when completed will have a map of keys and values of size bounded by supplied limit\n-     */\n-    public <K, V> CompletableFuture<Map<K, V>> getEntriesWithFilter(", "originalCommit": "7b95541f6d6bb74395c9e470a651a9592a4f5762", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "253896be5fe963601edbccfb29e13efdb515280a", "url": "https://github.com/pravega/pravega/commit/253896be5fe963601edbccfb29e13efdb515280a", "message": "KeyVersion -> Version.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-27T16:40:26Z", "type": "commit"}, {"oid": "b5f530b75c7f3e0df64cbcfad07fdc1fdbfdbd2f", "url": "https://github.com/pravega/pravega/commit/b5f530b75c7f3e0df64cbcfad07fdc1fdbfdbd2f", "message": "Unit test coverage.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-27T19:58:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMDc3MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399420770", "bodyText": "I think this needs to be updated.", "author": "tkaitchuck", "createdAt": "2020-03-27T17:17:33Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.", "originalCommit": "253896be5fe963601edbccfb29e13efdb515280a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU1MzcwNw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399553707", "bodyText": "I updated this entire section.", "author": "andreipaduroiu", "createdAt": "2020-03-27T21:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMDc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 6b29919b1b..11b71f8547 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -52,15 +52,32 @@ import lombok.NonNull;\n  * Types of Updates:\n  * <ul>\n  * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n- * that Key previously existed or not, and regardless of what that Key's version is.\n- * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n- * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n- * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * that Key previously existed or not, and regardless of what that Key's version is. Such updates can be performed using\n+ * {@link #put(String, KeyT, ValueT)} or {@link #putAll(String, Iterable)}.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified {@link Version} matches the one that\n+ * is currently present on the server. Conditional inserts can be performed using {@link #putIfAbsent(String, KeyT, ValueT)}\n+ * and will only succeed if the given Key does not already exist in the given Key Family. Conditional updates can be\n+ * performed using {@link #replace(String, KeyT, ValueT, Version)}.\n  * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n- * succeed (albeit with no effect) if the Key does not exist.\n- * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n- * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n- * {@link Version#NOT_EXISTS}.\n+ * succeed (albeit with no effect) if the Key does not exist. Such removals can be performed using\n+ * {@link #remove(String, KeyT)}.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link Version} matches the one that is currently\n+ * present on the server. Such removals can be performed using {@link #remove(String, KeyT, Version)}.\n+ * <li> Multi-key updates allow mixing different types of updates in the same update batch. Some entries may be conditioned\n+ * on their Keys not existing at all ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}),\n+ * some may be conditioned on specific versions and some may not have condition attached at all\n+ * ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). All the conditions that\n+ * are present in the update batch must be satisfied in order for the update batch to be accepted - the condition checks\n+ * and updates are performed atomically. Use {@link #replaceAll(String, Iterable)} for such an update.\n+ * <li> Multi-key removals allow mixing different types of removals in the same removal batch. Some removals may be\n+ * conditioned on their affected Keys having a specific version and some may not have a condition attached at all\n+ * ({@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). Although unusual, it is possible to have a removal\n+ * conditioned on a Key not existing ({@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}); such an update\n+ * will have no effect on that Key if it doesn't exist but it will  prevent the rest of the removals from the same batch\n+ * from being applied - this can be used in scenarios where a set of Keys must be removed only if a particular Key is not\n+ * present. All the conditions that are present in the removal batch must be satisfied in order for the removal batch to\n+ * be accepted - the condition checks and updates are performed atomically. Use {@link #removeAll(String, Iterable)} for\n+ * such a removal.\n  * </ul>\n  * <p>\n  * Conditional Update Responses:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMTQ1MA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399421450", "bodyText": "Same here. (What does it mean to condition a removal on the non-existence of the item?)", "author": "tkaitchuck", "createdAt": "2020-03-27T17:18:44Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.", "originalCommit": "253896be5fe963601edbccfb29e13efdb515280a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU1Mzg0NA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399553844", "bodyText": "I Explained it in the reworded section. Yes, it is a valid case, albeit very unusual.", "author": "andreipaduroiu", "createdAt": "2020-03-27T21:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMTQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 6b29919b1b..11b71f8547 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -52,15 +52,32 @@ import lombok.NonNull;\n  * Types of Updates:\n  * <ul>\n  * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n- * that Key previously existed or not, and regardless of what that Key's version is.\n- * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n- * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n- * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * that Key previously existed or not, and regardless of what that Key's version is. Such updates can be performed using\n+ * {@link #put(String, KeyT, ValueT)} or {@link #putAll(String, Iterable)}.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified {@link Version} matches the one that\n+ * is currently present on the server. Conditional inserts can be performed using {@link #putIfAbsent(String, KeyT, ValueT)}\n+ * and will only succeed if the given Key does not already exist in the given Key Family. Conditional updates can be\n+ * performed using {@link #replace(String, KeyT, ValueT, Version)}.\n  * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n- * succeed (albeit with no effect) if the Key does not exist.\n- * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n- * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n- * {@link Version#NOT_EXISTS}.\n+ * succeed (albeit with no effect) if the Key does not exist. Such removals can be performed using\n+ * {@link #remove(String, KeyT)}.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link Version} matches the one that is currently\n+ * present on the server. Such removals can be performed using {@link #remove(String, KeyT, Version)}.\n+ * <li> Multi-key updates allow mixing different types of updates in the same update batch. Some entries may be conditioned\n+ * on their Keys not existing at all ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}),\n+ * some may be conditioned on specific versions and some may not have condition attached at all\n+ * ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). All the conditions that\n+ * are present in the update batch must be satisfied in order for the update batch to be accepted - the condition checks\n+ * and updates are performed atomically. Use {@link #replaceAll(String, Iterable)} for such an update.\n+ * <li> Multi-key removals allow mixing different types of removals in the same removal batch. Some removals may be\n+ * conditioned on their affected Keys having a specific version and some may not have a condition attached at all\n+ * ({@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). Although unusual, it is possible to have a removal\n+ * conditioned on a Key not existing ({@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}); such an update\n+ * will have no effect on that Key if it doesn't exist but it will  prevent the rest of the removals from the same batch\n+ * from being applied - this can be used in scenarios where a set of Keys must be removed only if a particular Key is not\n+ * present. All the conditions that are present in the removal batch must be satisfied in order for the removal batch to\n+ * be accepted - the condition checks and updates are performed atomically. Use {@link #removeAll(String, Iterable)} for\n+ * such a removal.\n  * </ul>\n  * <p>\n  * Conditional Update Responses:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMjA1OA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399422058", "bodyText": "Can we create a Version#WRONG_VERSION to make this more clear?", "author": "tkaitchuck", "createdAt": "2020-03-27T17:19:46Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NOT_EXISTS} or {@link Version#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.", "originalCommit": "253896be5fe963601edbccfb29e13efdb515280a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU0Njk0Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399546947", "bodyText": "This doesn't mean \"Wrong Version\". It means that the user does not care about the server-side version of this update so their update will be unconditional.", "author": "andreipaduroiu", "createdAt": "2020-03-27T21:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMjA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwMDI3Mg==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399600272", "bodyText": "It appears to be used for both. I would like to differentiate the two", "author": "tkaitchuck", "createdAt": "2020-03-28T01:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQyMjA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 6b29919b1b..11b71f8547 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -52,15 +52,32 @@ import lombok.NonNull;\n  * Types of Updates:\n  * <ul>\n  * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n- * that Key previously existed or not, and regardless of what that Key's version is.\n- * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n- * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n- * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * that Key previously existed or not, and regardless of what that Key's version is. Such updates can be performed using\n+ * {@link #put(String, KeyT, ValueT)} or {@link #putAll(String, Iterable)}.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified {@link Version} matches the one that\n+ * is currently present on the server. Conditional inserts can be performed using {@link #putIfAbsent(String, KeyT, ValueT)}\n+ * and will only succeed if the given Key does not already exist in the given Key Family. Conditional updates can be\n+ * performed using {@link #replace(String, KeyT, ValueT, Version)}.\n  * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n- * succeed (albeit with no effect) if the Key does not exist.\n- * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n- * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n- * {@link Version#NOT_EXISTS}.\n+ * succeed (albeit with no effect) if the Key does not exist. Such removals can be performed using\n+ * {@link #remove(String, KeyT)}.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link Version} matches the one that is currently\n+ * present on the server. Such removals can be performed using {@link #remove(String, KeyT, Version)}.\n+ * <li> Multi-key updates allow mixing different types of updates in the same update batch. Some entries may be conditioned\n+ * on their Keys not existing at all ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}),\n+ * some may be conditioned on specific versions and some may not have condition attached at all\n+ * ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). All the conditions that\n+ * are present in the update batch must be satisfied in order for the update batch to be accepted - the condition checks\n+ * and updates are performed atomically. Use {@link #replaceAll(String, Iterable)} for such an update.\n+ * <li> Multi-key removals allow mixing different types of removals in the same removal batch. Some removals may be\n+ * conditioned on their affected Keys having a specific version and some may not have a condition attached at all\n+ * ({@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). Although unusual, it is possible to have a removal\n+ * conditioned on a Key not existing ({@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}); such an update\n+ * will have no effect on that Key if it doesn't exist but it will  prevent the rest of the removals from the same batch\n+ * from being applied - this can be used in scenarios where a set of Keys must be removed only if a particular Key is not\n+ * present. All the conditions that are present in the removal batch must be satisfied in order for the removal batch to\n+ * be accepted - the condition checks and updates are performed atomically. Use {@link #removeAll(String, Iterable)} for\n+ * such a removal.\n  * </ul>\n  * <p>\n  * Conditional Update Responses:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzOTY2Nw==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399539667", "bodyText": "This links to tableKey but the signature does not take one.", "author": "tkaitchuck", "createdAt": "2020-03-27T21:10:53Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NOT_EXISTS} or {@link Version#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<Version> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if the given Key is not already present.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is already present in the {@link KeyValueTable} for the\n+     * provided Key Family.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> putIfAbsent(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Unconditionally inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family\n+     * into this {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link Map.Entry} instances to insert or update.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as the number of\n+     * items in entries and the versions will be in the same order as the entries.\n+     */\n+    CompletableFuture<List<Version>> putAll(@NonNull String keyFamily, @NonNull Iterable<Map.Entry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Conditionally updates an existing Entry in the {@link KeyValueTable} if the given Key exists and its\n+     * version matches the given {@link Version}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to update.\n+     * @param value     The new Value to be associated with the Key.\n+     * @param version   A {@link Version} representing the version that this Key must have in order to replace it.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the\n+     * updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is not present present in the {@link KeyValueTable} for the\n+     * provided Key Family or it is and has a different {@link Version}.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> replace(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value,\n+                                       @NonNull Version version);\n+\n+    /**\n+     * Inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family into this\n+     * {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link TableEntry} instances to insert or update. If for at least one\n+     *                  such entry, {@link TableEntry#getKey()}{@link TableKey#getVersion()} indicates a conditional\n+     *                  update, this will perform an atomic Conditional Update conditioned on the server-side versions\n+     *                  matching the provided ones (for all {@link TableEntry} instances that have one); otherwise an\n+     *                  Unconditional Update will be performed.\n+     *                  See {@link KeyValueTable} doc for more details on Types of Updates.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as entries.size()\n+     * and the versions will be in the same order as the entries. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If this is a Conditional Update and the condition was not satisfied.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<List<Version>> replaceAll(@NonNull String keyFamily, @NonNull Iterable<TableEntry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Unconditionally removes a {@link TableKey} from this Table Segment. If the Key does not exist, no action will be", "originalCommit": "253896be5fe963601edbccfb29e13efdb515280a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 6b29919b1b..11b71f8547 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -52,15 +52,32 @@ import lombok.NonNull;\n  * Types of Updates:\n  * <ul>\n  * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n- * that Key previously existed or not, and regardless of what that Key's version is.\n- * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n- * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n- * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * that Key previously existed or not, and regardless of what that Key's version is. Such updates can be performed using\n+ * {@link #put(String, KeyT, ValueT)} or {@link #putAll(String, Iterable)}.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified {@link Version} matches the one that\n+ * is currently present on the server. Conditional inserts can be performed using {@link #putIfAbsent(String, KeyT, ValueT)}\n+ * and will only succeed if the given Key does not already exist in the given Key Family. Conditional updates can be\n+ * performed using {@link #replace(String, KeyT, ValueT, Version)}.\n  * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n- * succeed (albeit with no effect) if the Key does not exist.\n- * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n- * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n- * {@link Version#NOT_EXISTS}.\n+ * succeed (albeit with no effect) if the Key does not exist. Such removals can be performed using\n+ * {@link #remove(String, KeyT)}.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link Version} matches the one that is currently\n+ * present on the server. Such removals can be performed using {@link #remove(String, KeyT, Version)}.\n+ * <li> Multi-key updates allow mixing different types of updates in the same update batch. Some entries may be conditioned\n+ * on their Keys not existing at all ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}),\n+ * some may be conditioned on specific versions and some may not have condition attached at all\n+ * ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). All the conditions that\n+ * are present in the update batch must be satisfied in order for the update batch to be accepted - the condition checks\n+ * and updates are performed atomically. Use {@link #replaceAll(String, Iterable)} for such an update.\n+ * <li> Multi-key removals allow mixing different types of removals in the same removal batch. Some removals may be\n+ * conditioned on their affected Keys having a specific version and some may not have a condition attached at all\n+ * ({@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). Although unusual, it is possible to have a removal\n+ * conditioned on a Key not existing ({@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}); such an update\n+ * will have no effect on that Key if it doesn't exist but it will  prevent the rest of the removals from the same batch\n+ * from being applied - this can be used in scenarios where a set of Keys must be removed only if a particular Key is not\n+ * present. All the conditions that are present in the removal batch must be satisfied in order for the removal batch to\n+ * be accepted - the condition checks and updates are performed atomically. Use {@link #removeAll(String, Iterable)} for\n+ * such a removal.\n  * </ul>\n  * <p>\n  * Conditional Update Responses:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzOTc0OA==", "url": "https://github.com/pravega/pravega/pull/4588#discussion_r399539748", "bodyText": "Same here", "author": "tkaitchuck", "createdAt": "2020-03-27T21:11:08Z", "path": "client/src/main/java/io/pravega/client/tables/KeyValueTable.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.tables;\n+\n+import io.pravega.common.util.AsyncIterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import javax.annotation.Nullable;\n+import lombok.NonNull;\n+\n+/**\n+ * Defines all operations that are supported on a Key-Value Table.\n+ * <p>\n+ * A Key-Value Table is a distributed Key-Value Store that indexes Entries by Keys. It uses Table Segments (non-distributed\n+ * Key-Value Store backed by a single Pravega Segment) as the fundamental storage primitive and provides a unified view\n+ * of all Table Segments involved. Each {@link TableKey} is hashed to a Table Partition which may be represented by one\n+ * or more Table Segments (depending on the Key-Value Table configuration chosen when it was created). Such partitioning\n+ * enables the Key-Value Table to be distributed across the Pravega cluster but also introduces some constraints for\n+ * certain operations (such as multi-key/entry atomic updates). See below for details.\n+ * <p>\n+ * Key Families are used to group related Keys together in the same Table Partition, which allows multiple\n+ * keys/entries belonging to the same Key Family to be updated/removed atomically.\n+ * <ul>\n+ * <li> Multiple Keys/Entries in the same Key Family can be updated or removed atomically (either all changes will be\n+ * applied or none will).\n+ * <li> Iterating through all Keys/Entries in the same Key Family is possible.\n+ * <li> The same Key may exist in multiple Key Families or even not be associated with any Key Family at all. Such keys\n+ * are treated as distinct keys and will not interfere with each other (i.e., if key K1 exists in Key Families F1 and F2,\n+ * then F1.K1 is different from F2.K1 and both are different from K1 (no Key Family association).\n+ * <li> Keys that do not belong to any Key Family will be uniformly distributed across the Key-Value Table Partitions and\n+ * cannot be used for multi-key/entry atomic updates or removals or be iterated on.\n+ * <li> {@link TableKey}s belonging to the same Key Family are grouped into the same Table Segment; as such, the choice\n+ * of Key Families can have performance implications. An ideally balanced Key-Value Table is one where no {@link TableKey}\n+ * is part of any Key Family or the number of {@link TableKey}s in each Key Family is approximately the same. To enable\n+ * a uniform distribution of {@link TableKey}s over the Key-Value Table, it is highly recommended not to use Key Families\n+ * at all. If this situation cannot be avoided (i.e., multi-entry atomic updates or iterators are required), then it is\n+ * recommended that Key Families themselves be diversified and {@link TableKey}s be equally distributed across them. Such\n+ * approaches will ensure that the Key-Value Table load will be spread across all its Table Segments. An undesirable\n+ * situation is an extreme case where all the {@link TableKey}s in the Key-Value Table are associated with a single\n+ * Key Family; in this case the entire Key-Value Table load will be placed on a single backing Table Segment instead of\n+ * spreading it across many Table Segments, leading to eventual performance degradation.\n+ * </ul>\n+ * <p>\n+ * Types of Updates:\n+ * <ul>\n+ * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n+ * that Key previously existed or not, and regardless of what that Key's version is.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n+ * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n+ * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n+ * succeed (albeit with no effect) if the Key does not exist.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n+ * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n+ * {@link Version#NOT_EXISTS}.\n+ * </ul>\n+ * <p>\n+ * Conditional Update Responses:\n+ * <ul>\n+ * <li> Success: the update or removal has been atomically validated and performed; all updates or removals in the\n+ * request have been accepted.\n+ * <li> Failure: the update or removal has been rejected due to version mismatch; no update or removal has been performed.\n+ * <li> {@link NoSuchKeyException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NOT_EXISTS} or {@link Version#NO_VERSION}) but the {@link TableKey} does not exist in the\n+ * {@link KeyValueTable}.\n+ * <li> {@link BadKeyVersionException}: the update or removal has been conditioned on a specific version (different from\n+ * {@link Version#NO_VERSION} but the {@link TableKey} exists in the {@link KeyValueTable} with a different version.\n+ * </ul>\n+ *\n+ * @param <KeyT>   Table Key Type.\n+ * @param <ValueT> Table Value Type.\n+ */\n+public interface KeyValueTable<KeyT, ValueT> {\n+    /**\n+     * Unconditionally inserts a new or updates an existing Entry in the {@link KeyValueTable}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert or update.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry.\n+     */\n+    CompletableFuture<Version> put(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Conditionally inserts a new Entry in the {@link KeyValueTable} if the given Key is not already present.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to insert.\n+     * @param value     The Value to be associated with the Key.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the newly\n+     * inserted or updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is already present in the {@link KeyValueTable} for the\n+     * provided Key Family.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> putIfAbsent(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value);\n+\n+    /**\n+     * Unconditionally inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family\n+     * into this {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link Map.Entry} instances to insert or update.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as the number of\n+     * items in entries and the versions will be in the same order as the entries.\n+     */\n+    CompletableFuture<List<Version>> putAll(@NonNull String keyFamily, @NonNull Iterable<Map.Entry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Conditionally updates an existing Entry in the {@link KeyValueTable} if the given Key exists and its\n+     * version matches the given {@link Version}.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Entry. If null, this Entry will not be associated with any\n+     *                  Key Family.\n+     * @param key       The Key to update.\n+     * @param value     The new Value to be associated with the Key.\n+     * @param version   A {@link Version} representing the version that this Key must have in order to replace it.\n+     * @return A CompletableFuture that, when completed, will contain the {@link Version} associated with the\n+     * updated entry. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If the Key is not present present in the {@link KeyValueTable} for the\n+     * provided Key Family or it is and has a different {@link Version}.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<Version> replace(@Nullable String keyFamily, @NonNull KeyT key, @NonNull ValueT value,\n+                                       @NonNull Version version);\n+\n+    /**\n+     * Inserts new or updates existing {@link TableEntry} instances that belong to the same Key Family into this\n+     * {@link KeyValueTable}. All changes are performed atomically (either all or none will be accepted).\n+     *\n+     * @param keyFamily The Key Family for the all provided {@link TableEntry} instances.\n+     * @param entries   An {@link Iterable} of {@link TableEntry} instances to insert or update. If for at least one\n+     *                  such entry, {@link TableEntry#getKey()}{@link TableKey#getVersion()} indicates a conditional\n+     *                  update, this will perform an atomic Conditional Update conditioned on the server-side versions\n+     *                  matching the provided ones (for all {@link TableEntry} instances that have one); otherwise an\n+     *                  Unconditional Update will be performed.\n+     *                  See {@link KeyValueTable} doc for more details on Types of Updates.\n+     * @return A CompletableFuture that, when completed, will contain a List of {@link Version} instances which\n+     * represent the versions for the inserted/updated keys. The size of this list will be the same as entries.size()\n+     * and the versions will be in the same order as the entries. Notable exceptions:\n+     * <ul>\n+     * <li>{@link ConditionalTableUpdateException} If this is a Conditional Update and the condition was not satisfied.\n+     * See the {@link KeyValueTable} doc for more details on Conditional Update Responses.\n+     * </ul>\n+     */\n+    CompletableFuture<List<Version>> replaceAll(@NonNull String keyFamily, @NonNull Iterable<TableEntry<KeyT, ValueT>> entries);\n+\n+    /**\n+     * Unconditionally removes a {@link TableKey} from this Table Segment. If the Key does not exist, no action will be\n+     * taken.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the Key to remove.\n+     * @param key       The Key to remove.\n+     * @return A CompletableFuture that, when completed, will indicate the Key has been removed.\n+     */\n+    CompletableFuture<Void> remove(@Nullable String keyFamily, @NonNull KeyT key);\n+\n+    /**\n+     * Conditionally Removes a Key from this Table Segment.\n+     *\n+     * @param keyFamily (Optional) The Key Family for the {@link TableKey} to remove.", "originalCommit": "253896be5fe963601edbccfb29e13efdb515280a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "chunk": "diff --git a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\nindex 6b29919b1b..11b71f8547 100644\n--- a/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n+++ b/client/src/main/java/io/pravega/client/tables/KeyValueTable.java\n\n@@ -52,15 +52,32 @@ import lombok.NonNull;\n  * Types of Updates:\n  * <ul>\n  * <li> Unconditional Updates will insert and/or overwrite any existing values for the given Key, regardless of whether\n- * that Key previously existed or not, and regardless of what that Key's version is.\n- * <li> Conditional Updates will only overwrite an existing value if the specified version matches that Key's version.\n- * If the key does not exist, the {@link TableKey} or {@link TableEntry} must have been created with\n- * {@link Version#NOT_EXISTS} in order for the update to succeed.\n+ * that Key previously existed or not, and regardless of what that Key's version is. Such updates can be performed using\n+ * {@link #put(String, KeyT, ValueT)} or {@link #putAll(String, Iterable)}.\n+ * <li> Conditional Updates will only overwrite an existing value if the specified {@link Version} matches the one that\n+ * is currently present on the server. Conditional inserts can be performed using {@link #putIfAbsent(String, KeyT, ValueT)}\n+ * and will only succeed if the given Key does not already exist in the given Key Family. Conditional updates can be\n+ * performed using {@link #replace(String, KeyT, ValueT, Version)}.\n  * <li> Unconditional Removals will remove a Key regardless of what that Key's version is. The operation will also\n- * succeed (albeit with no effect) if the Key does not exist.\n- * <li> Conditional Removals will remove a Key only if the specified {@link TableKey#getVersion()} matches that Key's\n- * version. It will also fail (with no effect) if the Key does not exist and Version is not set to\n- * {@link Version#NOT_EXISTS}.\n+ * succeed (albeit with no effect) if the Key does not exist. Such removals can be performed using\n+ * {@link #remove(String, KeyT)}.\n+ * <li> Conditional Removals will remove a Key only if the specified {@link Version} matches the one that is currently\n+ * present on the server. Such removals can be performed using {@link #remove(String, KeyT, Version)}.\n+ * <li> Multi-key updates allow mixing different types of updates in the same update batch. Some entries may be conditioned\n+ * on their Keys not existing at all ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}),\n+ * some may be conditioned on specific versions and some may not have condition attached at all\n+ * ({@link TableEntry#getKey()}{@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). All the conditions that\n+ * are present in the update batch must be satisfied in order for the update batch to be accepted - the condition checks\n+ * and updates are performed atomically. Use {@link #replaceAll(String, Iterable)} for such an update.\n+ * <li> Multi-key removals allow mixing different types of removals in the same removal batch. Some removals may be\n+ * conditioned on their affected Keys having a specific version and some may not have a condition attached at all\n+ * ({@link TableKey#getVersion()} equals {@link Version#NO_VERSION}). Although unusual, it is possible to have a removal\n+ * conditioned on a Key not existing ({@link TableKey#getVersion()} equals {@link Version#NOT_EXISTS}); such an update\n+ * will have no effect on that Key if it doesn't exist but it will  prevent the rest of the removals from the same batch\n+ * from being applied - this can be used in scenarios where a set of Keys must be removed only if a particular Key is not\n+ * present. All the conditions that are present in the removal batch must be satisfied in order for the removal batch to\n+ * be accepted - the condition checks and updates are performed atomically. Use {@link #removeAll(String, Iterable)} for\n+ * such a removal.\n  * </ul>\n  * <p>\n  * Conditional Update Responses:\n"}}, {"oid": "a549c9bcba0ef0442b62c167e1acea979deba5d2", "url": "https://github.com/pravega/pravega/commit/a549c9bcba0ef0442b62c167e1acea979deba5d2", "message": "Javadoc\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-27T21:49:36Z", "type": "commit"}, {"oid": "7037d1c3fe0fde33f0cb7e5a87026185c2c351a6", "url": "https://github.com/pravega/pravega/commit/7037d1c3fe0fde33f0cb7e5a87026185c2c351a6", "message": "Javadoc.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-03-27T22:37:10Z", "type": "commit"}]}