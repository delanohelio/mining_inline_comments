{"pr_number": 4698, "pr_title": "Issue 4694: (SegmentStore) Use BufferViews instead of InputStreams on read path", "pr_createdAt": "2020-04-16T00:16:35Z", "pr_url": "https://github.com/pravega/pravega/pull/4698", "timeline": [{"oid": "4bdb48fe623a609e079ea29cd3fa680140aa8a40", "url": "https://github.com/pravega/pravega/commit/4bdb48fe623a609e079ea29cd3fa680140aa8a40", "message": "Replaced InputStream with BufferView on ReadResultEntry, which provides greater flexibility and better performance in copying data out of the wrapped buffer.\nRetired ReadResultEntryContents.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-15T22:11:35Z", "type": "commit"}, {"oid": "f8ea466f8927bf207b89ca1ea08529709855d6d1", "url": "https://github.com/pravega/pravega/commit/f8ea466f8927bf207b89ca1ea08529709855d6d1", "message": "Fixed bugs.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-16T00:13:40Z", "type": "commit"}, {"oid": "d0a8444520d62129c1e3e6543aa9804571ef08c7", "url": "https://github.com/pravega/pravega/commit/d0a8444520d62129c1e3e6543aa9804571ef08c7", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-16T07:45:24Z", "type": "commit"}, {"oid": "e6844f267ce32b7f472d132b1ec41fe0a65e810d", "url": "https://github.com/pravega/pravega/commit/e6844f267ce32b7f472d132b1ec41fe0a65e810d", "message": "SegmentRead uses ByteBuf instead of ByteBuffer.\nAdded BufferView.getContents.\nPravegaRequestProcessor copies data directly to the wire for segment reads.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T00:54:17Z", "type": "commit"}, {"oid": "f005dc705f8eb8b1cc1f27949ca7f1985b94a504", "url": "https://github.com/pravega/pravega/commit/f005dc705f8eb8b1cc1f27949ca7f1985b94a504", "message": "Merge remote-tracking branch 'ap/issue-4694-bufferviews-on-reads' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-17T00:54:25Z", "type": "commit"}, {"oid": "be571996f5e1f399485267f4ef759329f32e43a1", "url": "https://github.com/pravega/pravega/commit/be571996f5e1f399485267f4ef759329f32e43a1", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-17T00:55:43Z", "type": "commit"}, {"oid": "2e52b331a0604f599101957d50e7bd07d8145503", "url": "https://github.com/pravega/pravega/commit/2e52b331a0604f599101957d50e7bd07d8145503", "message": "Fixed serialization.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T03:11:31Z", "type": "commit"}, {"oid": "c24747107387e6cbaeaf630ea83ac2929c901471", "url": "https://github.com/pravega/pravega/commit/c24747107387e6cbaeaf630ea83ac2929c901471", "message": "Added EnhancedByteBufInputStream.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T18:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MzUxMw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410383513", "bodyText": "Per the javadocs nioBuffer() may make a copy. I would like to avoid making two copies here.", "author": "tkaitchuck", "createdAt": "2020-04-17T17:59:55Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -150,20 +150,21 @@ private void handleRequest() throws SegmentTruncatedException {\n             throw e;\n         }\n         verifyIsAtCorrectOffset(segmentRead);\n-        if (segmentRead.getData().hasRemaining()) {\n-            buffer.fill(segmentRead.getData());\n+        if (segmentRead.getData().readableBytes() > 0) {\n+            int copied = buffer.fill(segmentRead.getData().nioBuffer());", "originalCommit": "2e52b331a0604f599101957d50e7bd07d8145503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDEzNg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410450136", "bodyText": "Added a method to CircularBuffer to handle this.", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MzUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "chunk": "diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java\nindex 29bf2deb1e..1ae12d74dc 100644\n--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java\n+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java\n\n@@ -151,13 +151,14 @@ class SegmentInputStreamImpl implements SegmentInputStream {\n         }\n         verifyIsAtCorrectOffset(segmentRead);\n         if (segmentRead.getData().readableBytes() > 0) {\n-            int copied = buffer.fill(segmentRead.getData().nioBuffer());\n+            int copied = buffer.fill(segmentRead.getData().nioBuffers());\n             segmentRead.getData().skipBytes(copied);\n         }\n         if (segmentRead.isEndOfSegment()) {\n             receivedEndOfSegment = true;\n         }\n         if (segmentRead.getData().readableBytes() == 0) {\n+            segmentRead.release();\n             outstandingRequest = null;\n             issueRequestIfNeeded();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTU2Ng==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410385566", "bodyText": "Given that the array() method already exists on this interface, I think the return type can just be a single ByteBuffer. If there were multiple components array() wouldn't be implementable in which case it would make sense to just use a different interface.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:03:54Z", "path": "common/src/main/java/io/pravega/common/util/ArrayView.java", "diffHunk": "@@ -48,4 +52,9 @@\n      * @throws ArrayIndexOutOfBoundsException If targetOffset or length are invalid.\n      */\n     void copyTo(byte[] target, int targetOffset, int length);\n+\n+    @Override\n+    default List<ByteBuffer> getContents() {\n+        return Collections.singletonList(ByteBuffer.wrap(array(), arrayOffset(), getLength()));", "originalCommit": "2e52b331a0604f599101957d50e7bd07d8145503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTUyNA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410431524", "bodyText": "This method is inherited from BufferView which may wrap multiple buffers. I can't change the return type.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NTU2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410388208", "bodyText": "This may have unintended consequences if there is a subclass of bufferView which has internal state such as a modifiable position.\nI think instead there should be be a 'getView' method on bufferView the default version of which returns this. But which can be overridden by some impls to perform a slice.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:08:55Z", "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -104,4 +105,28 @@ default void retain() {\n     default void release() {\n         // Default implementation intentionally left blank. Any derived class may implement if needed.\n     }\n+\n+    /**\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     *\n+     * @return A List of {@link ByteBuffer}.\n+     */\n+    List<ByteBuffer> getContents();\n+\n+    /**\n+     * Wraps the given {@link BufferView} into a single instance.\n+     *\n+     * @param components The components to wrap.\n+     * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n+     * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n+     */\n+    static BufferView wrap(List<BufferView> components) {\n+        if (components.size() == 0) {\n+            return new ByteArraySegment(new byte[0]);\n+        } else if (components.size() == 1) {\n+            return components.get(0);", "originalCommit": "2e52b331a0604f599101957d50e7bd07d8145503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTk3Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410449977", "bodyText": "Can I just name it BufferView.slice() which will invoke BufferView.slice(0, BufferView.getLength())?", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3Mzk0Mw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410473943", "bodyText": "sure", "author": "tkaitchuck", "createdAt": "2020-04-17T21:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyNzA1OA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r411727058", "bodyText": "done", "author": "andreipaduroiu", "createdAt": "2020-04-20T22:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4ODIwOA=="}], "type": "inlineReview", "revised_code": {"commit": "65704b6f9a548c32a248dc9c8a61f5acdc40e001", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/BufferView.java b/common/src/main/java/io/pravega/common/util/BufferView.java\nindex 35ef67312f..968241c5e2 100644\n--- a/common/src/main/java/io/pravega/common/util/BufferView.java\n+++ b/common/src/main/java/io/pravega/common/util/BufferView.java\n\n@@ -124,7 +134,7 @@ public interface BufferView {\n         if (components.size() == 0) {\n             return new ByteArraySegment(new byte[0]);\n         } else if (components.size() == 1) {\n-            return components.get(0);\n+            return components.get(0).slice();\n         } else {\n             return new CompositeBufferView(components);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5MDc0MA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410390740", "bodyText": "I really don't like these methods. Because they aren't used in most code paths they won't be well tested and the code handling these classes may assume it's working with an impl that doesn't use them, and will break with one that does.\nIf it is at all possible to remove them, I suggest we do so.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:13:54Z", "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Iterators;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.SequenceInputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Provides a unified view of multiple wrapped {@link BufferView} instances.\n+ */\n+class CompositeBufferView implements BufferView {\n+    //region Members\n+\n+    private final List<BufferView> components;\n+    @Getter\n+    private final int length;\n+\n+    //endregion\n+\n+    //region Constructor\n+\n+    /**\n+     * Creates a new instance of the {@link CompositeBufferView} class. It is recommended to use {@link BufferView#wrap}\n+     * instead.\n+     *\n+     * @param components The components to wrap.\n+     */\n+    CompositeBufferView(@NonNull List<BufferView> components) {\n+        this.components = new ArrayList<>();\n+        int length = 0;\n+        for (BufferView c : components) {\n+            if (c instanceof CompositeBufferView) {\n+                this.components.addAll(((CompositeBufferView) c).components);\n+            } else {\n+                this.components.add(c);\n+            }\n+            length += c.getLength();\n+        }\n+        this.length = length;\n+    }\n+\n+    //endregion\n+\n+    //region BufferView implementation\n+\n+    @Override\n+    public InputStream getReader() {\n+        this.components.stream().map(BufferView::getReader).iterator();\n+        return new SequenceInputStream(Iterators.asEnumeration(this.components.stream().map(BufferView::getReader).iterator()));\n+    }\n+\n+    @Override\n+    public InputStream getReader(int offset, int length) {\n+        return slice(offset, length).getReader();\n+    }\n+\n+    @Override\n+    public BufferView slice(int offset, int length) {\n+        Preconditions.checkArgument(offset >= 0 && offset < length && length <= this.length,\n+                \"offset and length must be non-negative and less than %s.\", this.length);\n+        if (offset == 0 && length == this.length) {\n+            return this;\n+        }\n+        ArrayList<BufferView> components = new ArrayList<>(this.components.size());\n+        int index = 0;\n+        int currentOffset = 0;\n+        while (length > 0) {\n+            BufferView c = this.components.get(index);\n+            int lastComponentOffset = currentOffset + c.getLength();\n+            if (offset < lastComponentOffset) {\n+                int sliceStart = Math.max(0, offset - currentOffset);\n+                int sliceLength = Math.min(length, c.getLength() - sliceStart);\n+                components.add(c.slice(sliceStart, sliceLength));\n+                length -= sliceLength;\n+            }\n+\n+            index++;\n+            currentOffset += c.getLength();\n+        }\n+\n+        return BufferView.wrap(components);\n+    }\n+\n+    @Override\n+    public byte[] getCopy() {\n+        byte[] result = new byte[getLength()];\n+        int offset = 0;\n+        for (BufferView c : this.components) {\n+            int copiedBytes = c.copyTo(ByteBuffer.wrap(result, offset, c.getLength()));\n+            assert copiedBytes == c.getLength();\n+            offset += copiedBytes;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public void copyTo(OutputStream target) throws IOException {\n+        for (BufferView c : this.components) {\n+            c.copyTo(target);\n+        }\n+    }\n+\n+    @Override\n+    public int copyTo(ByteBuffer target) {\n+        int bytesCopied = 0;\n+        for (BufferView c : this.components) {\n+            bytesCopied += c.copyTo(target);\n+        }\n+\n+        return bytesCopied;\n+    }\n+\n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>(this.components.size());\n+        for (BufferView c : this.components) {\n+            result.addAll(c.getContents());\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public void retain() {", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjYyNQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410432625", "bodyText": "There is an implementation of BufferView that wraps ByteBufs. I need these methods for that specific case. The default implementation in BufferView does nothing, so they are only overridden if they have to.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5MDc0MA=="}], "type": "inlineReview", "revised_code": {"commit": "65704b6f9a548c32a248dc9c8a61f5acdc40e001", "chunk": "diff --git a/common/src/main/java/io/pravega/common/util/CompositeBufferView.java b/common/src/main/java/io/pravega/common/util/CompositeBufferView.java\nindex 28ad291c3d..144e8ae95a 100644\n--- a/common/src/main/java/io/pravega/common/util/CompositeBufferView.java\n+++ b/common/src/main/java/io/pravega/common/util/CompositeBufferView.java\n\n@@ -46,9 +46,11 @@ class CompositeBufferView implements BufferView {\n         int length = 0;\n         for (BufferView c : components) {\n             if (c instanceof CompositeBufferView) {\n-                this.components.addAll(((CompositeBufferView) c).components);\n+                for (BufferView b : ((CompositeBufferView) c).components) {\n+                    this.components.add(b.slice());\n+                }\n             } else {\n-                this.components.add(c);\n+                this.components.add(c.slice());\n             }\n             length += c.getLength();\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDA4Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410394087", "bodyText": "Why is arrays an Object[] rather than a byte[][]?", "author": "tkaitchuck", "createdAt": "2020-04-17T18:20:22Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNDY0Mg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410434642", "bodyText": "because byte[][] arrays = new byte[x][y] will create y arrays of x elements. This defeats the purpose of this class, which is a view of a sparse array (only allocates sub-arrays as they are needed).", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NDA4Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjI2OQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410396269", "bodyText": "It is not obvious from the method signature/javadoc that it is going to allocate.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:24:31Z", "path": "common/src/main/java/io/pravega/common/util/CompositeByteArraySegment.java", "diffHunk": "@@ -217,6 +218,21 @@ public int copyTo(ByteBuffer target) {\n         return length;\n     }\n \n+    @Override\n+    public List<ByteBuffer> getContents() {\n+        ArrayList<ByteBuffer> result = new ArrayList<>();\n+        for (int i = 0; i < this.arrays.length; i++) {\n+            byte[] a = getArray(i, false);\n+            if (a == null) {\n+                int size = i == this.arrays.length - 1 ? this.length % this.arraySize : this.arraySize;\n+                result.add(ByteBuffer.allocate(size));", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTk2Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410435967", "bodyText": "Fixed the javadoc on CompositeArrayView to explain this.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjI2OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410397345", "bodyText": "The streamHelpers method should be updated, as there are probably other callers.", "author": "tkaitchuck", "createdAt": "2020-04-17T18:26:36Z", "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/ReadResult.java", "diffHunk": "@@ -104,25 +101,25 @@ default int readRemaining(byte[] target, Duration fetchTimeout) {\n                 entry.requestContent(fetchTimeout);\n             }\n \n-            ReadResultEntryContents contents = entry.getContent().join();\n-            StreamHelpers.readAll(contents.getData(), target, bytesRead, Math.min(contents.getLength(), target.length - bytesRead));", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTQzMQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410449431", "bodyText": "I opened this a while back, with no clear solution in mind (at the time):  #2924.", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMTQzNA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410501434", "bodyText": "Ok, let's link to that issue in the Javadoc for the method so that it doesn't get used when it doesn't have to be.", "author": "tkaitchuck", "createdAt": "2020-04-17T22:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyODQwMA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r411728400", "bodyText": "done", "author": "andreipaduroiu", "createdAt": "2020-04-20T22:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NzM0NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDc5Mg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410420792", "bodyText": "It should be noted this can return null.", "author": "tkaitchuck", "createdAt": "2020-04-17T19:15:00Z", "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java", "diffHunk": "@@ -757,34 +758,34 @@ private boolean canContinueFlushingExcess() {\n     }\n \n     /**\n-     * Returns a FlushArgs which contains the data needing to be flushed to Storage.\n+     * Returns a {@link BufferView} which contains the data needing to be flushed to Storage.\n      *\n-     * @return The aggregated object that can be used for flushing.\n+     * @return A {@link BufferView} to flush.", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNjY0OA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410436648", "bodyText": "Fixed.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "chunk": "diff --git a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java\nindex ce6591dd16..0ffed90708 100644\n--- a/segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java\n+++ b/segmentstore/server/src/main/java/io/pravega/segmentstore/server/writer/SegmentAggregator.java\n\n@@ -760,9 +761,10 @@ class SegmentAggregator implements WriterSegmentProcessor, AutoCloseable {\n     /**\n      * Returns a {@link BufferView} which contains the data needing to be flushed to Storage.\n      *\n-     * @return A {@link BufferView} to flush.\n+     * @return A {@link BufferView} to flush or null if the segment was deleted.\n      * @throws DataCorruptionException If a unable to retrieve required data from the Data Source.\n      */\n+    @Nullable\n     private BufferView getFlushData() throws DataCorruptionException {\n         StorageOperation first = this.operations.getFirst();\n         if (!(first instanceof AggregatedAppendOperation)) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMzQ5OA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410423498", "bodyText": "This code is fine, but I don't see how it's any different than the code before. It's not saving any copies.", "author": "tkaitchuck", "createdAt": "2020-04-17T19:20:52Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/ByteBufWrapper.java", "diffHunk": "@@ -113,14 +120,17 @@ public void copyTo(OutputStream target) throws IOException {\n     @Override\n     public int copyTo(ByteBuffer byteBuffer) {\n         Exceptions.checkNotClosed(this.buf.refCnt() == 0, this);\n-        ByteBuf buf = this.buf.duplicate();\n+        ByteBuf source = this.buf.duplicate();", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNzIzMg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410437232", "bodyText": "The previous code had a bug in it where it would not update the target buffer's position after the write, thus ending up overwriting the same data over and over again.", "author": "andreipaduroiu", "createdAt": "2020-04-17T19:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMzQ5OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410425875", "bodyText": "This is adding a call to retain(). Where is the corresponding release() call?", "author": "tkaitchuck", "createdAt": "2020-04-17T19:26:04Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -828,10 +827,9 @@ public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOE\n             if (dataLength > length) {\n                 throw new BufferOverflowException();\n             }\n-            byte[] data = new byte[dataLength];\n-            in.readFully(data);\n-            long requestId =  in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, ByteBuffer.wrap(data), requestId);\n+            ByteBuf data = in.readFully(dataLength).retain();", "originalCommit": "c24747107387e6cbaeaf630ea83ac2929c901471", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5NA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410448094", "bodyText": "Good point. Due to the fact that this class is instantiated in 2 ways (with an external ByteBuf via the constructor, and by deserializing), I only need to retain for the serialization, so the solution is a bit less elegant than I wished. I added some unit tests to verify it works as I intend to.\nThe corresponding release has been added to SegmentInputStreamImpl.handleRequest", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODkyOA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410448928", "bodyText": "I am not 100% sure this is correct. But I do not know of any way to prevent memory leaks without making a copy in the deserialization. I am concerned about cancelled requests or other unexpected situations.", "author": "andreipaduroiu", "createdAt": "2020-04-17T20:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwMjg2MQ==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r410502861", "bodyText": "SegmentInputStreamImpl:89 is missing the logic to call release. In case setoffset is called before reading the data is complete.", "author": "tkaitchuck", "createdAt": "2020-04-17T22:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "chunk": "diff --git a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java\nindex b5f0efb9b9..8440d190cc 100644\n--- a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java\n+++ b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java\n\n@@ -829,7 +841,13 @@ public final class WireCommands {\n             }\n             ByteBuf data = in.readFully(dataLength).retain();\n             long requestId = in.available() >= Long.BYTES ? in.readLong() : -1L;\n-            return new SegmentRead(segment, offset, atTail, endOfSegment, data, requestId);\n+            return new SegmentRead(segment, offset, atTail, endOfSegment, data, requestId, true);\n+        }\n+\n+        public void release() {\n+            if (this.mustRelease) {\n+                this.data.release();\n+            }\n         }\n \n         @Override\n"}}, {"oid": "afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "url": "https://github.com/pravega/pravega/commit/afb2abc20e7d03ff7ffd9e6c28981c19a0e16598", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-17T20:39:28Z", "type": "commit"}, {"oid": "ed825a0384ef22458bd2063d66f7a0897228c765", "url": "https://github.com/pravega/pravega/commit/ed825a0384ef22458bd2063d66f7a0897228c765", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-20T22:08:55Z", "type": "commit"}, {"oid": "65704b6f9a548c32a248dc9c8a61f5acdc40e001", "url": "https://github.com/pravega/pravega/commit/65704b6f9a548c32a248dc9c8a61f5acdc40e001", "message": "Code review coverage:\n- BufferView.slice()\n- Futures.cancellableFuture()\n- SegmentInputStreamImpl: releasing SegmentRead if cancelled.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-20T23:04:59Z", "type": "commit"}, {"oid": "6d4e1884da79c9e105fcebfb22950461565fcced", "url": "https://github.com/pravega/pravega/commit/6d4e1884da79c9e105fcebfb22950461565fcced", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-21T15:34:20Z", "type": "commit"}, {"oid": "38849f65ce27284cd7841f0f7e708770440d4a0e", "url": "https://github.com/pravega/pravega/commit/38849f65ce27284cd7841f0f7e708770440d4a0e", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-21T21:33:37Z", "type": "commit"}, {"oid": "cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0", "url": "https://github.com/pravega/pravega/commit/cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-27T16:22:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyNzgzMA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416127830", "bodyText": "This is a complicated case:\nIf the buffer has completed but has not had any slices pulled out of it we need to call releaese() if it does, then those could become invalid. So we need to make sure they don't like longer than the scope of $lock", "author": "tkaitchuck", "createdAt": "2020-04-27T20:32:07Z", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -197,14 +198,20 @@ private int computeReadLength(long currentFetchOffset) {\n         return Math.toIntExact(Math.min(currentReadLength, numberOfBytesRemaining));\n     }\n \n+    @GuardedBy(\"$lock\")\n+    private void cancelOutstandingRequest() {\n+        outstandingRequest.cancel(true);", "originalCommit": "cb55b9b4ec7d31af14bdd9fe0f5696a73c758cf0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1c85fadbc581113beea43a61c6c9316c8d5d9ef3", "chunk": "diff --git a/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java b/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java\nindex 3ed8e84189..1c915c8342 100644\n--- a/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java\n+++ b/client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java\n\n@@ -200,7 +200,19 @@ class SegmentInputStreamImpl implements SegmentInputStream {\n \n     @GuardedBy(\"$lock\")\n     private void cancelOutstandingRequest() {\n+        // We need to make sure that we release the ByteBuf held on to by WireCommands.SegmentRead.\n+        // We first attempt to cancel the request. If it has not already completed (and will complete successfully at one point),\n+        // it will automatically release the buffer.\n         outstandingRequest.cancel(true);\n+\n+        // If the request has already completed successfully, attempt to release it anyway. Doing so multiple times will\n+        // have no adverse effect. We do this after attempting to cancel (as opposed to before) since the request may very\n+        // well complete while we're executing this method and we want to ensure no SegmentRead instances are left hanging.\n+        if (outstandingRequest.isDone() && !outstandingRequest.isCompletedExceptionally()) {\n+            SegmentRead request = outstandingRequest.join();\n+            request.release();\n+        }\n+\n         log.debug(\"Completed cancelling outstanding read request for segment {}\", asyncInput.getSegmentId());\n         outstandingRequest = null;\n     }\n"}}, {"oid": "1c85fadbc581113beea43a61c6c9316c8d5d9ef3", "url": "https://github.com/pravega/pravega/commit/1c85fadbc581113beea43a61c6c9316c8d5d9ef3", "message": "Fixing some cases.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T15:45:51Z", "type": "commit"}, {"oid": "c92cf38d5e33d9ecdc9cd2ceb72ff11a0ef2b51d", "url": "https://github.com/pravega/pravega/commit/c92cf38d5e33d9ecdc9cd2ceb72ff11a0ef2b51d", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-28T16:36:36Z", "type": "commit"}, {"oid": "bd96e442b2643aff9647e99180f1ad79d1dcf8ab", "url": "https://github.com/pravega/pravega/commit/bd96e442b2643aff9647e99180f1ad79d1dcf8ab", "message": "Fixed precondition check.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T17:26:45Z", "type": "commit"}, {"oid": "262117d6eba756acdf46de2e0e89654549ca5a86", "url": "https://github.com/pravega/pravega/commit/262117d6eba756acdf46de2e0e89654549ca5a86", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-28T17:57:22Z", "type": "commit"}, {"oid": "a3d0eed56a17a98edb29e8063937cfc82839dbd7", "url": "https://github.com/pravega/pravega/commit/a3d0eed56a17a98edb29e8063937cfc82839dbd7", "message": "Enabling resource leak detection on test classes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T18:00:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416890770", "bodyText": "These two exception listeners could be combined so as to avoid an extra link in the future chain.", "author": "tkaitchuck", "createdAt": "2020-04-28T20:10:14Z", "path": "common/src/main/java/io/pravega/common/concurrent/Futures.java", "diffHunk": "@@ -228,6 +229,40 @@\n         return result;\n     }\n \n+    /**\n+     * Returns a CompletableFuture that will complete with the same outcome or result as the given source, but when\n+     * cancelled, will apply a consumer to the eventual result of the original future.\n+     * <p>\n+     * If the returned CompletableFuture is NOT cancelled ({@link CompletableFuture#cancel}):\n+     * - If source completes normally, the result CompletableFuture will complete with the same result.\n+     * - If source completes exceptionally, the result CompletableFuture will complete with the same result.\n+     * <p>\n+     * If the returned CompletableFuture is cancelled ({@link CompletableFuture#cancel}):\n+     * - If the source has already completed, the result CompletableFuture will also be completed with the same outcome.\n+     * - If the source has not already been completed, if it completes normally, then `onCancel` will be applied to\n+     * the result when it eventually completes. The source completes exceptionally, nothing will happen.\n+     *\n+     * @param source   The CompletableFuture to wrap.\n+     * @param onCancel A Consumer to invoke on source's eventual completion result if the result of this method is cancelled.\n+     * @param <T>      Result type.\n+     * @return A CompletableFuture that will complete with the same outcome or result as the given source.\n+     */\n+    public static <T> CompletableFuture<T> cancellableFuture(CompletableFuture<T> source, Consumer<T> onCancel) {\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        val result = new CompletableFuture<T>();\n+        source.thenAccept(result::complete);\n+        Futures.exceptionListener(source, result::completeExceptionally);", "originalCommit": "a3d0eed56a17a98edb29e8063937cfc82839dbd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjA4Mg==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416976082", "bodyText": "These listeners are on different futures. The first one is on the source (which we're passed in) and propagates the failure to the result. The second one is on the result and invokes the onCancel callback if someone cancelled the result. I cannot combine them into one.\nAlso, these are not affecting the future chain. We are returning result directly, yet we are attaching these listeners to the result but not chain them anywhere. They will only be executed in case of some exception; they will not affect the normal path.", "author": "andreipaduroiu", "createdAt": "2020-04-28T23:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTU1NA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416979554", "bodyText": "I see my phrasing was confusing. I intended to refer to this and the above line.", "author": "tkaitchuck", "createdAt": "2020-04-28T23:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTU1Nw==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416981557", "bodyText": "Got it now. Fixed it.", "author": "andreipaduroiu", "createdAt": "2020-04-28T23:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg5MDc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "607728d67382279dabc79e154f8e04b45b2da00f", "chunk": "diff --git a/common/src/main/java/io/pravega/common/concurrent/Futures.java b/common/src/main/java/io/pravega/common/concurrent/Futures.java\nindex 62ae88bad5..df0d3218f9 100644\n--- a/common/src/main/java/io/pravega/common/concurrent/Futures.java\n+++ b/common/src/main/java/io/pravega/common/concurrent/Futures.java\n\n@@ -253,8 +253,13 @@ public final class Futures {\n         }\n \n         val result = new CompletableFuture<T>();\n-        source.thenAccept(result::complete);\n-        Futures.exceptionListener(source, result::completeExceptionally);\n+        source.whenComplete((r, ex) -> {\n+            if (ex == null) {\n+                result.complete(r);\n+            } else {\n+                result.completeExceptionally(ex);\n+            }\n+        });\n         Futures.exceptionListener(result, ex -> {\n             if (ex instanceof CancellationException && !source.isCancelled()) {\n                 source.thenAccept(onCancel);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzI2Ng==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416927266", "bodyText": "NotThreadSafe unless you want to make released an atomic boolean", "author": "tkaitchuck", "createdAt": "2020-04-28T21:14:57Z", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -792,15 +795,24 @@ public long getRequestId() {\n         }\n     }\n \n-    @Data\n+    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+    @Getter\n+    @ToString\n+    @EqualsAndHashCode(exclude = {\"mustRelease\", \"released\"})", "originalCommit": "a3d0eed56a17a98edb29e8063937cfc82839dbd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjEyMA==", "url": "https://github.com/pravega/pravega/pull/4698#discussion_r416976120", "bodyText": "Done.", "author": "andreipaduroiu", "createdAt": "2020-04-28T23:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzI2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "96abc80d6ad752c551f45cbb910fa8daa5a1dd97", "chunk": "diff --git a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java\nindex 91f31fcb20..b19e46d145 100644\n--- a/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java\n+++ b/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java\n\n@@ -799,6 +800,7 @@ public final class WireCommands {\n     @Getter\n     @ToString\n     @EqualsAndHashCode(exclude = {\"mustRelease\", \"released\"})\n+    @NotThreadSafe\n     public static final class SegmentRead implements Reply, WireCommand {\n         final WireCommandType type = WireCommandType.SEGMENT_READ;\n         final String segment;\n"}}, {"oid": "6195766f8a29c435c2a75b716b5e288dcacb364b", "url": "https://github.com/pravega/pravega/commit/6195766f8a29c435c2a75b716b5e288dcacb364b", "message": "Merge branch 'master' into issue-4694-bufferviews-on-reads", "committedDate": "2020-04-28T23:05:54Z", "type": "commit"}, {"oid": "96abc80d6ad752c551f45cbb910fa8daa5a1dd97", "url": "https://github.com/pravega/pravega/commit/96abc80d6ad752c551f45cbb910fa8daa5a1dd97", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T23:06:11Z", "type": "commit"}, {"oid": "607728d67382279dabc79e154f8e04b45b2da00f", "url": "https://github.com/pravega/pravega/commit/607728d67382279dabc79e154f8e04b45b2da00f", "message": "Combined futures callbacks.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>", "committedDate": "2020-04-28T23:20:21Z", "type": "commit"}]}