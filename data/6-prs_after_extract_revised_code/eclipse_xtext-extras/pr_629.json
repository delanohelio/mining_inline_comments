{"pr_number": 629, "pr_title": "[eclipse/xtext#1777] ported xtend code 2 java", "pr_createdAt": "2020-07-17T09:02:31Z", "pr_url": "https://github.com/eclipse/xtext-extras/pull/629", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MDczMw==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456350733", "bodyText": "use try-with-resources for url.openStream()?", "author": "kthoms", "createdAt": "2020-07-17T10:09:56Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDE2NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456354165", "bodyText": "please provide a proposal.\nhave no head for this today", "author": "cdietrich", "createdAt": "2020-07-17T10:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MDczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MTc0Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456361747", "bodyText": "try (InputStream is = url.openStream()) {\n\t\t\t\t\tClassFileReader reader = ClassFileReader.read(is, fileName);\n\t\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n\t\t\t\t\tcache.put(fileName, result);\n\t\t\t\t\treturn result;\n\t\t\t\t}", "author": "kthoms", "createdAt": "2020-07-17T10:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MDczMw=="}], "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTA3Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456351072", "bodyText": "use try-with-resources for url.openStream()?", "author": "kthoms", "createdAt": "2020-07-17T10:10:41Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MjAzNg==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456362036", "bodyText": "try (InputStream is = url.openStream()) {\n\t\t\t\t\tClassFileReader reader = ClassFileReader.read(is, fileName);\n\t\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n\t\t\t\t\tcache.put(fileName, result);\n\t\t\t\t\treturn result;\n\t\t\t\t}", "author": "kthoms", "createdAt": "2020-07-17T10:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MTM2NA==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456351364", "bodyText": "move constructor to top", "author": "kthoms", "createdAt": "2020-07-17T10:11:21Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MjI0Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456352246", "bodyText": "move constructor up", "author": "kthoms", "createdAt": "2020-07-17T10:13:10Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MzQ3Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456353476", "bodyText": "remove result var, use compilerOptions.targetJDK directly", "author": "kthoms", "createdAt": "2020-07-17T10:15:48Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDAyOA==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456354028", "bodyText": "??????????", "author": "cdietrich", "createdAt": "2020-07-17T10:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MzQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MjQwNg==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456362406", "bodyText": "long classFmt = toClassFmt(javaVersion);\n\t\tsetSourceLevel(classFmt);\n\t\tsetComplianceLevel(classFmt);\n\t\treturn compilerOptions.targetJDK = classFmt;", "author": "kthoms", "createdAt": "2020-07-17T10:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1MzQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDEyMA==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456354120", "bodyText": "introduces => introduced", "author": "kthoms", "createdAt": "2020-07-17T10:17:10Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;\n+\t\treturn result;\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduces in JDT 3.7", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NDM4Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456354387", "bodyText": "introduces => introduced", "author": "kthoms", "createdAt": "2020-07-17T10:17:48Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;\n+\t\treturn result;\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduces in JDT 3.7\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * sets the compliance level (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setComplianceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.complianceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduces in JDT 3.7", "originalCommit": "04e1a6c56e9c0f082169efd00d08984bbff637f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex baaa4d586..d858efbcb 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -49,6 +49,10 @@ public class InMemoryJavaCompiler {\n \n \t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n \n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n \t\t@Override\n \t\tpublic void cleanup() {\n \t\t\tcache.clear();\n"}}, {"oid": "8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "url": "https://github.com/eclipse/xtext-extras/commit/8b10fd1af6002efda6c09c76ac6d0ea9db4445c1", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-17T10:17:49Z", "type": "forcePushed"}, {"oid": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "url": "https://github.com/eclipse/xtext-extras/commit/e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-17T10:18:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NjU5Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456356597", "bodyText": "refactor to:\nICompilationUnit[] units = Stream.of(sources).map(it -> new CompilationUnit(it.getCode().toCharArray(), it.getFileName(), null)).toArray(ICompilationUnit[]::new);", "author": "kthoms", "createdAt": "2020-07-17T10:22:34Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.env.INameEnvironment;\n+import org.eclipse.jdt.internal.compiler.env.NameEnvironmentAnswer;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class InMemoryJavaCompiler {\n+\tprivate static class ClassLoaderBasedNameEnvironment implements INameEnvironment {\n+\t\tprivate final ClassLoader classLoader;\n+\n+\t\tprivate Map<String, NameEnvironmentAnswer> cache = new HashMap<>();\n+\n+\t\tpublic ClassLoaderBasedNameEnvironment(ClassLoader classLoader) {\n+\t\t\tthis.classLoader = classLoader;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void cleanup() {\n+\t\t\tcache.clear();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[][] compoundTypeName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(compoundTypeName, '/')) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic NameEnvironmentAnswer findType(char[] typeName, char[][] packageName) {\n+\t\t\ttry {\n+\t\t\t\tString fileName = new String(CharOperation.concatWith(packageName, '/')) + \"/\"\n+\t\t\t\t\t\t+ String.valueOf(typeName) + \".class\";\n+\t\t\t\tif (cache.containsKey(fileName)) {\n+\t\t\t\t\treturn cache.get(fileName);\n+\t\t\t\t}\n+\t\t\t\tURL url = classLoader.getResource(fileName);\n+\t\t\t\tif (url == null) {\n+\t\t\t\t\tcache.put(fileName, null);\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n+\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n+\t\t\t\tcache.put(fileName, result);\n+\t\t\t\treturn result;\n+\t\t\t} catch (ClassFormatException | IOException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isPackage(char[][] parentPackageName, char[] packageName) {\n+\t\t\treturn Character.isLowerCase(packageName[0]);\n+\t\t}\n+\n+\t}\n+\n+\tstatic class ByteClassLoader extends ClassLoader {\n+\t\tprivate Map<String, byte[]> classMap;\n+\n+\t\tpublic ByteClassLoader(Map<String, byte[]> classMap, ClassLoader parent) {\n+\t\t\tsuper(parent);\n+\t\t\tthis.classMap = classMap;\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected Class<?> findClass(String name) throws ClassNotFoundException {\n+\t\t\tbyte[] bytes = classMap.get(name);\n+\t\t\tif (bytes == null) {\n+\t\t\t\treturn super.findClass(name);\n+\t\t\t} else {\n+\t\t\t\treturn defineClass(name, bytes, 0, bytes.length);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected URL findResource(String path) {\n+\t\t\ttry {\n+\t\t\t\tif (path.endsWith(\".class\")) {\n+\t\t\t\t\tbyte[] bytes = classMap.get(path.substring(0, path.length() - 6).replace(\"/\", \".\"));\n+\t\t\t\t\tif (bytes != null) {\n+\t\t\t\t\t\treturn new URL(\"in-memory\", null, -1, path, new URLStreamHandler() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tprotected URLConnection openConnection(URL it) throws IOException {\n+\t\t\t\t\t\t\t\treturn new URLConnection(it) {\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic void connect() {\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\t\t\tpublic InputStream getInputStream() {\n+\t\t\t\t\t\t\t\t\t\treturn new ByteArrayInputStream(bytes);\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn null;\n+\t\t\t} catch (MalformedURLException e) {\n+\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static class Result {\n+\t\tprivate final Set<CategorizedProblem> compilationProblems = new LinkedHashSet<>();\n+\n+\t\tprivate final HashMap<String, byte[]> classMap = new HashMap<String, byte[]>();\n+\n+\t\tprivate final ClassLoader parentClassLoader;\n+\n+\t\tpublic Result(ClassLoader parentClassLoader) {\n+\t\t\tthis.parentClassLoader = parentClassLoader;\n+\t\t}\n+\n+\t\tpublic ClassLoader getClassLoader() {\n+\t\t\treturn new ByteClassLoader(classMap, parentClassLoader);\n+\t\t}\n+\n+\t\tpublic Set<CategorizedProblem> getCompilationProblems() {\n+\t\t\treturn compilationProblems;\n+\t\t}\n+\t}\n+\n+\tprivate final INameEnvironment nameEnv;\n+\n+\tprivate final ClassLoader parentClassLoader;\n+\n+\tprivate final CompilerOptions compilerOptions;\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, JavaVersion javaVersion) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions();\n+\t\tthis.setJavaVersion(javaVersion);\n+\t\tthis.compilerOptions.inlineJsrBytecode = true;\n+\t\tthis.compilerOptions.preserveAllLocalVariables = true;\n+\t}\n+\n+\tpublic InMemoryJavaCompiler(ClassLoader parent, CompilerOptions compilerOptions) {\n+\t\tthis.nameEnv = new ClassLoaderBasedNameEnvironment(parent);\n+\t\tthis.parentClassLoader = parent;\n+\t\tthis.compilerOptions = new CompilerOptions(compilerOptions.getMap());\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic long setJavaVersion(JavaVersion javaVersion) {\n+\t\tlong result = 0;\n+\t\tlong classFmt = toClassFmt(javaVersion);\n+\t\tsetSourceLevel(classFmt);\n+\t\tsetComplianceLevel(classFmt);\n+\t\tresult = compilerOptions.targetJDK = classFmt;\n+\t\treturn result;\n+\t}\n+\n+\tprivate long toClassFmt(JavaVersion version) {\n+\t\treturn version.toJdtClassFileConstant();\n+\t}\n+\n+\t/**\n+\t * sets the source level\n+\t * (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setSourceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.sourceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduced in JDT 3.7\n+\t\t\t\tCompilerOptions.class.getField(\"originalSourceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * sets the compliance level\n+\t * (see @link(org.eclipse.jdt.internal.compiler.classfmt.ClassFileConstants))\n+\t */\n+\tprivate void setComplianceLevel(long jdkVersion) {\n+\t\ttry {\n+\t\t\tcompilerOptions.complianceLevel = jdkVersion;\n+\t\t\ttry {\n+\t\t\t\t// these fields have been introduced in JDT 3.7\n+\t\t\t\tCompilerOptions.class.getField(\"originalComplianceLevel\").setLong(compilerOptions, jdkVersion);\n+\t\t\t} catch (NoSuchFieldException e) {\n+\t\t\t\t// ignore\n+\t\t\t}\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tpublic Result compile(JavaSource... sources) {\n+\t\tResult result = new Result(parentClassLoader);\n+\t\tICompilerRequestor requestor = (CompilationResult it) -> {\n+\t\t\tfor (ClassFile cf : it.getClassFiles()) {\n+\t\t\t\tresult.classMap.put(CharOperation.toString(cf.getCompoundName()), cf.getBytes());\n+\t\t\t}\n+\t\t};\n+\t\torg.eclipse.jdt.internal.compiler.Compiler compiler = new org.eclipse.jdt.internal.compiler.Compiler(nameEnv,\n+\t\t\t\tDefaultErrorHandlingPolicies.proceedWithAllProblems(), compilerOptions, requestor,\n+\t\t\t\tnew DefaultProblemFactory() {\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic CategorizedProblem createProblem(char[] originatingFileName, int problemId,\n+\t\t\t\t\t\t\tString[] problemArguments, int elaborationId, String[] messageArguments, int severity,\n+\t\t\t\t\t\t\tint startPosition, int endPosition, int lineNumber, int columnNumber) {\n+\t\t\t\t\t\tCategorizedProblem problem = super.createProblem(originatingFileName, problemId,\n+\t\t\t\t\t\t\t\tproblemArguments, elaborationId, messageArguments, severity, startPosition, endPosition,\n+\t\t\t\t\t\t\t\tlineNumber, columnNumber);\n+\t\t\t\t\t\tresult.compilationProblems.add(problem);\n+\t\t\t\t\t\treturn problem;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t@Override\n+\t\t\t\t\tpublic CategorizedProblem createProblem(char[] originatingFileName, int problemId,\n+\t\t\t\t\t\t\tString[] problemArguments, String[] messageArguments, int severity, int startPosition,\n+\t\t\t\t\t\t\tint endPosition, int lineNumber, int columnNumber) {\n+\t\t\t\t\t\tCategorizedProblem problem = super.createProblem(originatingFileName, problemId,\n+\t\t\t\t\t\t\t\tproblemArguments, messageArguments, severity, startPosition, endPosition, lineNumber,\n+\t\t\t\t\t\t\t\tcolumnNumber);\n+\t\t\t\t\t\tresult.compilationProblems.add(problem);\n+\t\t\t\t\t\treturn problem;\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\tICompilationUnit[] units = ((ICompilationUnit[]) Conversions.unwrapArray(\n+\t\t\t\tListExtensions.map(Arrays.asList(sources),\n+\t\t\t\t\t\t(JavaSource it) -> new CompilationUnit(it.getCode().toCharArray(), it.getFileName(), null)),\n+\t\t\t\tICompilationUnit.class));\n+\t\tcompiler.compile(units);", "originalCommit": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MTE4Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456361182", "bodyText": "this is not about refactoring everything", "author": "cdietrich", "createdAt": "2020-07-17T10:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NjU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzExMjY0Mw==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r457112643", "bodyText": "The current code is way more hard to read. Above statement does the same.", "author": "kthoms", "createdAt": "2020-07-20T07:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1NjU5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "chunk": "diff --git a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\nindex af60e99e7..3e1f9aaf6 100644\n--- a/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n+++ b/org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/InMemoryJavaCompiler.java\n\n@@ -70,7 +70,13 @@ public class InMemoryJavaCompiler {\n \t\t\t\t\tcache.put(fileName, null);\n \t\t\t\t\treturn null;\n \t\t\t\t}\n-\t\t\t\tClassFileReader reader = ClassFileReader.read(url.openStream(), fileName);\n+\t\t\t\tClassFileReader reader = null;\n+\t\t\t\ttry (InputStream in = url.openStream()) {\n+\t\t\t\t\treader = ClassFileReader.read(in, fileName);\n+\t\t\t\t}\n+\t\t\t\tif (reader == null) {\n+\t\t\t\t\treturn null;\n+\t\t\t\t}\n \t\t\t\tNameEnvironmentAnswer result = new NameEnvironmentAnswer(reader, null);\n \t\t\t\tcache.put(fileName, result);\n \t\t\t\treturn result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1OTAwNQ==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456359005", "bodyText": "extract to method, sequence is used twice", "author": "kthoms", "createdAt": "2020-07-17T10:27:50Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ */\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\tprivate JavaVersion javaVersion;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t\tthis.javaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic void setJavaVersion(JavaVersion version) {\n+\t\tinMemoryCompiler.setJavaVersion(version);\n+\t\tjavaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic JavaVersion getJavaVersion() {\n+\t\treturn javaVersion;\n+\t}\n+\n+\tpublic Class<?> compileToClass(String classname, String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(\n+\t\t\t\t\t\tIterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"Code was:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(code);\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(message.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Couldn\\'t load \\'\");\n+\t\t\t\tmessage.append(classname);\n+\t\t\t\tmessage.append(\"\\' \");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"source :\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(code, \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"PROBLEMS : \");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();", "originalCommit": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MTUzOQ==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456361539", "bodyText": ":(", "author": "cdietrich", "createdAt": "2020-07-17T10:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1OTAwNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1OTI5NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456359295", "bodyText": "extract to method, sequence is used twice", "author": "kthoms", "createdAt": "2020-07-17T10:28:23Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ */\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\tprivate JavaVersion javaVersion;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t\tthis.javaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic void setJavaVersion(JavaVersion version) {\n+\t\tinMemoryCompiler.setJavaVersion(version);\n+\t\tjavaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic JavaVersion getJavaVersion() {\n+\t\treturn javaVersion;\n+\t}\n+\n+\tpublic Class<?> compileToClass(String classname, String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(\n+\t\t\t\t\t\tIterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();", "originalCommit": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MDMzNA==", "url": "https://github.com/eclipse/xtext-extras/pull/629#discussion_r456360334", "bodyText": "This may read better with\nsourceCode.append(String.format(\"public class __Generated implements org.eclipse.xtext.xbase.lib.Functions.Function0<%s> {\", returnType.getName())\n\nIf you agree there are other line candidates.", "author": "kthoms", "createdAt": "2020-07-17T10:30:41Z", "path": "org.eclipse.xtext.xbase.testing/src/org/eclipse/xtext/xbase/testing/OnTheFlyJavaCompiler2.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.testing;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.core.compiler.CategorizedProblem;\n+import org.eclipse.xtend2.lib.StringConcatenation;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function0;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @noextend This class is not intended to be subclassed by clients.\n+ * @noreference This class is not intended to be referenced by clients.\n+ * \n+ * @since 2.9\n+ */\n+@Singleton\n+public class OnTheFlyJavaCompiler2 {\n+\tprivate InMemoryJavaCompiler inMemoryCompiler;\n+\n+\tprivate JavaVersion javaVersion;\n+\n+\t/**\n+\t * Creates a new OnTheFlyCompiler that accepts Java6 compliant code.\n+\t */\n+\t@Inject\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope) {\n+\t\tthis(scope, JavaVersion.JAVA6);\n+\t}\n+\n+\tpublic OnTheFlyJavaCompiler2(ClassLoader scope, JavaVersion version) {\n+\t\tthis.inMemoryCompiler = new InMemoryJavaCompiler(scope, version);\n+\t\tthis.javaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic void setJavaVersion(JavaVersion version) {\n+\t\tinMemoryCompiler.setJavaVersion(version);\n+\t\tjavaVersion = version;\n+\t}\n+\n+\t/**\n+\t * @since 2.11\n+\t */\n+\tpublic JavaVersion getJavaVersion() {\n+\t\treturn javaVersion;\n+\t}\n+\n+\tpublic Class<?> compileToClass(String classname, String code) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(new JavaSource(toJavaFile(classname), code));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(\n+\t\t\t\t\t\tIterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"Code was:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(code);\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalArgumentException(message.toString());\n+\t\t\t}\n+\t\t\treturn result.getClassLoader().loadClass(classname);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Couldn\\'t load \\'\");\n+\t\t\t\tmessage.append(classname);\n+\t\t\t\tmessage.append(\"\\' \");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"source :\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(code, \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"PROBLEMS : \");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\").join(result.getCompilationProblems()), \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(message.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate String toJavaFile(String string) {\n+\t\treturn string.replace('.', '/') + \".java\";\n+\t}\n+\n+\tpublic Map<String, Class<?>> compileToClasses(Map<String, String> sources) {\n+\t\tInMemoryJavaCompiler.Result result = inMemoryCompiler.compile(((JavaSource[]) Conversions.unwrapArray(\n+\t\t\t\tIterables.transform(sources.entrySet(), e -> new JavaSource(toJavaFile(e.getKey()), e.getValue())),\n+\t\t\t\tJavaSource.class)));\n+\t\ttry {\n+\t\t\tif (Iterables.any(result.getCompilationProblems(), CategorizedProblem::isError)) {\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(\"Java code compiled with errors:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n\")\n+\t\t\t\t\t\t.join(Iterables.filter(result.getCompilationProblems(), CategorizedProblem::isError)));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"Code was:\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"=========\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(Joiner.on(\"\\n=========\\n\").join(sources.values()));\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"=========\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tthrow new IllegalArgumentException(message.toString());\n+\t\t\t}\n+\t\t\tClassLoader classLoader = result.getClassLoader();\n+\t\t\treturn IterableExtensions.toMap(\n+\t\t\t\t\tIterables.transform(sources.keySet(), (String it) -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\treturn classLoader.loadClass(it);\n+\t\t\t\t\t\t} catch (ClassNotFoundException e) {\n+\t\t\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}), Class::getName);\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof ClassNotFoundException) {\n+\t\t\t\tClassNotFoundException e = (ClassNotFoundException) t;\n+\t\t\t\tStringConcatenation message = new StringConcatenation();\n+\t\t\t\tmessage.append(e.getMessage());\n+\t\t\t\tmessage.append(\" \");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.append(\"source :\");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(sources, \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"PROBLEMS : \");\n+\t\t\t\tmessage.newLine();\n+\t\t\t\tmessage.append(\"\\t\");\n+\t\t\t\tmessage.append(IterableExtensions.join(result.getCompilationProblems(), \"\\n\"), \"\\t\");\n+\t\t\t\tmessage.newLineIfNotEmpty();\n+\t\t\t\tthrow new IllegalStateException(message.toString(), e);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic <RT extends Object> Function0<RT> createFunction(String expression, Class<RT> returnType) {\n+\t\ttry {\n+\t\t\tStringConcatenation sourceCode = new StringConcatenation();\n+\t\t\tsourceCode.append(\"public class __Generated implements org.eclipse.xtext.xbase.lib.Functions.Function0<\");\n+\t\t\tsourceCode.append(returnType.getName());\n+\t\t\tsourceCode.append(\"> {\");", "originalCommit": "e8f0a421f19b9b2d9ee9169f210b0e544653ebad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "url": "https://github.com/eclipse/xtext-extras/commit/e6ac1b9fdc2f8d946e711c23f6373daa8ae4c815", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-17T10:32:55Z", "type": "forcePushed"}, {"oid": "8b15a76cd705cd6ef5f716404ca6843de3c4407b", "url": "https://github.com/eclipse/xtext-extras/commit/8b15a76cd705cd6ef5f716404ca6843de3c4407b", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-17T10:39:12Z", "type": "forcePushed"}, {"oid": "a515e574aa7bc8c354df2d963356d2c0f562c886", "url": "https://github.com/eclipse/xtext-extras/commit/a515e574aa7bc8c354df2d963356d2c0f562c886", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-17T10:44:22Z", "type": "forcePushed"}, {"oid": "c641a5ce800d21a9f84be146240029008ae4a643", "url": "https://github.com/eclipse/xtext-extras/commit/c641a5ce800d21a9f84be146240029008ae4a643", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-24T11:55:01Z", "type": "commit"}, {"oid": "c641a5ce800d21a9f84be146240029008ae4a643", "url": "https://github.com/eclipse/xtext-extras/commit/c641a5ce800d21a9f84be146240029008ae4a643", "message": "[eclipse/xtext#1777] ported xtend code 2 java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-24T11:55:01Z", "type": "forcePushed"}]}