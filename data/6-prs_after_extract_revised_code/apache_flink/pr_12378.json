{"pr_number": 12378, "pr_title": "[FLINK-17965][sql-parser-hive] Hive dialect needs to unescape backslash in string literals", "pr_createdAt": "2020-05-28T11:21:37Z", "pr_url": "https://github.com/apache/flink/pull/12378", "timeline": [{"oid": "7730fcf16fe3ff8e0b7a3c3bc956b79050139030", "url": "https://github.com/apache/flink/commit/7730fcf16fe3ff8e0b7a3c3bc956b79050139030", "message": "fix test", "committedDate": "2020-06-01T07:20:03Z", "type": "forcePushed"}, {"oid": "aa2b18fb5b07aad9d2fe4664d9c311cfe3f591ef", "url": "https://github.com/apache/flink/commit/aa2b18fb5b07aad9d2fe4664d9c311cfe3f591ef", "message": "fix test", "committedDate": "2020-06-05T06:54:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4ODk1Mg==", "url": "https://github.com/apache/flink/pull/12378#discussion_r435788952", "bodyText": "I think we only need to unescape the option value.", "author": "danny0405", "createdAt": "2020-06-05T09:04:47Z", "path": "flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java", "diffHunk": "@@ -317,4 +321,54 @@ public static SqlTableColumn deepCopyTableColumn(SqlTableColumn column) {\n \t\t\t\tcolumn.getParserPosition()\n \t\t);\n \t}\n+\n+\t// the input of sql-client will escape '\\', unescape it so that users can write hive dialect\n+\tpublic static void unescapeProperties(SqlNodeList properties) {\n+\t\tif (properties != null) {\n+\t\t\tfor (int i = 0; i < properties.size(); i++) {\n+\t\t\t\tSqlNode node = properties.get(i);\n+\t\t\t\t// for properties\n+\t\t\t\tif (node instanceof SqlTableOption) {\n+\t\t\t\t\tnode = unescapeTableOption((SqlTableOption) node);\n+\t\t\t\t\tproperties.set(i, node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static SqlTableOption unescapeTableOption(SqlTableOption option) {\n+\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n+\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n+\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());", "originalCommit": "aa2b18fb5b07aad9d2fe4664d9c311cfe3f591ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MzIxOA==", "url": "https://github.com/apache/flink/pull/12378#discussion_r436493218", "bodyText": "Both key and value can have special characters in Hive.", "author": "lirui-apache", "createdAt": "2020-06-08T07:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4ODk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e30df6387ff2da57fa3a48b90dbae6d01633f15b", "chunk": "diff --git a/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java b/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\nindex 5e71ad3f7dd..478aac842b5 100644\n--- a/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\n+++ b/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\n\n@@ -325,50 +329,65 @@ public class HiveDDLUtils {\n \t// the input of sql-client will escape '\\', unescape it so that users can write hive dialect\n \tpublic static void unescapeProperties(SqlNodeList properties) {\n \t\tif (properties != null) {\n-\t\t\tfor (int i = 0; i < properties.size(); i++) {\n-\t\t\t\tSqlNode node = properties.get(i);\n-\t\t\t\t// for properties\n-\t\t\t\tif (node instanceof SqlTableOption) {\n-\t\t\t\t\tnode = unescapeTableOption((SqlTableOption) node);\n-\t\t\t\t\tproperties.set(i, node);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tproperties.accept(UNESCAPE_SHUTTLE);\n \t\t}\n \t}\n \n-\tpublic static SqlTableOption unescapeTableOption(SqlTableOption option) {\n-\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n-\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n-\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n-\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n-\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n-\t}\n-\n-\tpublic static SqlCharStringLiteral unescapeLiteral(SqlCharStringLiteral literal) {\n+\tpublic static SqlCharStringLiteral unescapeStringLiteral(SqlCharStringLiteral literal) {\n \t\tif (literal != null) {\n-\t\t\tString unescaped = StringEscapeUtils.unescapeJava(literal.getNlsString().getValue());\n-\t\t\treturn SqlLiteral.createCharString(unescaped, literal.getParserPosition());\n+\t\t\treturn (SqlCharStringLiteral) literal.accept(UNESCAPE_SHUTTLE);\n \t\t}\n \t\treturn null;\n \t}\n \n \tpublic static void unescapePartitionSpec(SqlNodeList partSpec) {\n \t\tif (partSpec != null) {\n-\t\t\tfor (int i = 0; i < partSpec.size(); i++) {\n-\t\t\t\tSqlNode node = partSpec.get(i);\n-\t\t\t\tif (node instanceof SqlProperty) {\n-\t\t\t\t\tSqlProperty property = (SqlProperty) node;\n-\t\t\t\t\tComparable comparable = SqlLiteral.value(property.getValue());\n-\t\t\t\t\tif (comparable instanceof NlsString) {\n-\t\t\t\t\t\tString val = StringEscapeUtils.unescapeJava(((NlsString) comparable).getValue());\n-\t\t\t\t\t\tproperty = new SqlProperty(\n-\t\t\t\t\t\t\t\tproperty.getKey(),\n-\t\t\t\t\t\t\t\tSqlLiteral.createCharString(val, property.getValue().getParserPosition()),\n-\t\t\t\t\t\t\t\tproperty.getParserPosition());\n-\t\t\t\t\t\tpartSpec.set(i, property);\n-\t\t\t\t\t}\n+\t\t\tpartSpec.accept(UNESCAPE_SHUTTLE);\n+\t\t}\n+\t}\n+\n+\tprivate static class UnescapeStringLiteralShuttle extends SqlShuttle {\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlNodeList nodeList) {\n+\t\t\tfor (int i = 0; i < nodeList.size(); i++) {\n+\t\t\t\tSqlNode unescaped = nodeList.get(i).accept(this);\n+\t\t\t\tnodeList.set(i, unescaped);\n+\t\t\t}\n+\t\t\treturn nodeList;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlCall call) {\n+\t\t\tif (call instanceof SqlProperty) {\n+\t\t\t\tSqlProperty property = (SqlProperty) call;\n+\t\t\t\tComparable comparable = SqlLiteral.value(property.getValue());\n+\t\t\t\tif (comparable instanceof NlsString) {\n+\t\t\t\t\tString val = StringEscapeUtils.unescapeJava(((NlsString) comparable).getValue());\n+\t\t\t\t\treturn new SqlProperty(\n+\t\t\t\t\t\t\tproperty.getKey(),\n+\t\t\t\t\t\t\tSqlLiteral.createCharString(val, property.getValue().getParserPosition()),\n+\t\t\t\t\t\t\tproperty.getParserPosition());\n \t\t\t\t}\n+\t\t\t} else if (call instanceof SqlTableOption) {\n+\t\t\t\tSqlTableOption option = (SqlTableOption) call;\n+\t\t\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n+\t\t\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n+\t\t\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n+\t\t\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n+\t\t\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n+\t\t\t}\n+\t\t\treturn call;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlLiteral literal) {\n+\t\t\tif (literal instanceof SqlCharStringLiteral) {\n+\t\t\t\tSqlCharStringLiteral stringLiteral = (SqlCharStringLiteral) literal;\n+\t\t\t\tString unescaped = StringEscapeUtils.unescapeJava(stringLiteral.getNlsString().getValue());\n+\t\t\t\treturn SqlLiteral.createCharString(unescaped, stringLiteral.getParserPosition());\n \t\t\t}\n+\t\t\treturn literal;\n \t\t}\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTQzNw==", "url": "https://github.com/apache/flink/pull/12378#discussion_r435789437", "bodyText": "unescapeLiteral  -> unescapeStringLiteral", "author": "danny0405", "createdAt": "2020-06-05T09:05:41Z", "path": "flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java", "diffHunk": "@@ -317,4 +321,54 @@ public static SqlTableColumn deepCopyTableColumn(SqlTableColumn column) {\n \t\t\t\tcolumn.getParserPosition()\n \t\t);\n \t}\n+\n+\t// the input of sql-client will escape '\\', unescape it so that users can write hive dialect\n+\tpublic static void unescapeProperties(SqlNodeList properties) {\n+\t\tif (properties != null) {\n+\t\t\tfor (int i = 0; i < properties.size(); i++) {\n+\t\t\t\tSqlNode node = properties.get(i);\n+\t\t\t\t// for properties\n+\t\t\t\tif (node instanceof SqlTableOption) {\n+\t\t\t\t\tnode = unescapeTableOption((SqlTableOption) node);\n+\t\t\t\t\tproperties.set(i, node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static SqlTableOption unescapeTableOption(SqlTableOption option) {\n+\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n+\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n+\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n+\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n+\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n+\t}\n+\n+\tpublic static SqlCharStringLiteral unescapeLiteral(SqlCharStringLiteral literal) {\n+\t\tif (literal != null) {\n+\t\t\tString unescaped = StringEscapeUtils.unescapeJava(literal.getNlsString().getValue());\n+\t\t\treturn SqlLiteral.createCharString(unescaped, literal.getParserPosition());\n+\t\t}", "originalCommit": "aa2b18fb5b07aad9d2fe4664d9c311cfe3f591ef", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e30df6387ff2da57fa3a48b90dbae6d01633f15b", "chunk": "diff --git a/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java b/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\nindex 5e71ad3f7dd..478aac842b5 100644\n--- a/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\n+++ b/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\n\n@@ -325,50 +329,65 @@ public class HiveDDLUtils {\n \t// the input of sql-client will escape '\\', unescape it so that users can write hive dialect\n \tpublic static void unescapeProperties(SqlNodeList properties) {\n \t\tif (properties != null) {\n-\t\t\tfor (int i = 0; i < properties.size(); i++) {\n-\t\t\t\tSqlNode node = properties.get(i);\n-\t\t\t\t// for properties\n-\t\t\t\tif (node instanceof SqlTableOption) {\n-\t\t\t\t\tnode = unescapeTableOption((SqlTableOption) node);\n-\t\t\t\t\tproperties.set(i, node);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tproperties.accept(UNESCAPE_SHUTTLE);\n \t\t}\n \t}\n \n-\tpublic static SqlTableOption unescapeTableOption(SqlTableOption option) {\n-\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n-\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n-\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n-\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n-\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n-\t}\n-\n-\tpublic static SqlCharStringLiteral unescapeLiteral(SqlCharStringLiteral literal) {\n+\tpublic static SqlCharStringLiteral unescapeStringLiteral(SqlCharStringLiteral literal) {\n \t\tif (literal != null) {\n-\t\t\tString unescaped = StringEscapeUtils.unescapeJava(literal.getNlsString().getValue());\n-\t\t\treturn SqlLiteral.createCharString(unescaped, literal.getParserPosition());\n+\t\t\treturn (SqlCharStringLiteral) literal.accept(UNESCAPE_SHUTTLE);\n \t\t}\n \t\treturn null;\n \t}\n \n \tpublic static void unescapePartitionSpec(SqlNodeList partSpec) {\n \t\tif (partSpec != null) {\n-\t\t\tfor (int i = 0; i < partSpec.size(); i++) {\n-\t\t\t\tSqlNode node = partSpec.get(i);\n-\t\t\t\tif (node instanceof SqlProperty) {\n-\t\t\t\t\tSqlProperty property = (SqlProperty) node;\n-\t\t\t\t\tComparable comparable = SqlLiteral.value(property.getValue());\n-\t\t\t\t\tif (comparable instanceof NlsString) {\n-\t\t\t\t\t\tString val = StringEscapeUtils.unescapeJava(((NlsString) comparable).getValue());\n-\t\t\t\t\t\tproperty = new SqlProperty(\n-\t\t\t\t\t\t\t\tproperty.getKey(),\n-\t\t\t\t\t\t\t\tSqlLiteral.createCharString(val, property.getValue().getParserPosition()),\n-\t\t\t\t\t\t\t\tproperty.getParserPosition());\n-\t\t\t\t\t\tpartSpec.set(i, property);\n-\t\t\t\t\t}\n+\t\t\tpartSpec.accept(UNESCAPE_SHUTTLE);\n+\t\t}\n+\t}\n+\n+\tprivate static class UnescapeStringLiteralShuttle extends SqlShuttle {\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlNodeList nodeList) {\n+\t\t\tfor (int i = 0; i < nodeList.size(); i++) {\n+\t\t\t\tSqlNode unescaped = nodeList.get(i).accept(this);\n+\t\t\t\tnodeList.set(i, unescaped);\n+\t\t\t}\n+\t\t\treturn nodeList;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlCall call) {\n+\t\t\tif (call instanceof SqlProperty) {\n+\t\t\t\tSqlProperty property = (SqlProperty) call;\n+\t\t\t\tComparable comparable = SqlLiteral.value(property.getValue());\n+\t\t\t\tif (comparable instanceof NlsString) {\n+\t\t\t\t\tString val = StringEscapeUtils.unescapeJava(((NlsString) comparable).getValue());\n+\t\t\t\t\treturn new SqlProperty(\n+\t\t\t\t\t\t\tproperty.getKey(),\n+\t\t\t\t\t\t\tSqlLiteral.createCharString(val, property.getValue().getParserPosition()),\n+\t\t\t\t\t\t\tproperty.getParserPosition());\n \t\t\t\t}\n+\t\t\t} else if (call instanceof SqlTableOption) {\n+\t\t\t\tSqlTableOption option = (SqlTableOption) call;\n+\t\t\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n+\t\t\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n+\t\t\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n+\t\t\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n+\t\t\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n+\t\t\t}\n+\t\t\treturn call;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlLiteral literal) {\n+\t\t\tif (literal instanceof SqlCharStringLiteral) {\n+\t\t\t\tSqlCharStringLiteral stringLiteral = (SqlCharStringLiteral) literal;\n+\t\t\t\tString unescaped = StringEscapeUtils.unescapeJava(stringLiteral.getNlsString().getValue());\n+\t\t\t\treturn SqlLiteral.createCharString(unescaped, stringLiteral.getParserPosition());\n \t\t\t}\n+\t\t\treturn literal;\n \t\t}\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MTQ1NQ==", "url": "https://github.com/apache/flink/pull/12378#discussion_r435791455", "bodyText": "Did you try SqlShuttle ?", "author": "danny0405", "createdAt": "2020-06-05T09:09:26Z", "path": "flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java", "diffHunk": "@@ -317,4 +321,54 @@ public static SqlTableColumn deepCopyTableColumn(SqlTableColumn column) {\n \t\t\t\tcolumn.getParserPosition()\n \t\t);\n \t}\n+\n+\t// the input of sql-client will escape '\\', unescape it so that users can write hive dialect\n+\tpublic static void unescapeProperties(SqlNodeList properties) {\n+\t\tif (properties != null) {\n+\t\t\tfor (int i = 0; i < properties.size(); i++) {\n+\t\t\t\tSqlNode node = properties.get(i);\n+\t\t\t\t// for properties\n+\t\t\t\tif (node instanceof SqlTableOption) {\n+\t\t\t\t\tnode = unescapeTableOption((SqlTableOption) node);\n+\t\t\t\t\tproperties.set(i, node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic static SqlTableOption unescapeTableOption(SqlTableOption option) {\n+\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n+\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n+\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n+\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n+\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n+\t}\n+\n+\tpublic static SqlCharStringLiteral unescapeLiteral(SqlCharStringLiteral literal) {\n+\t\tif (literal != null) {\n+\t\t\tString unescaped = StringEscapeUtils.unescapeJava(literal.getNlsString().getValue());\n+\t\t\treturn SqlLiteral.createCharString(unescaped, literal.getParserPosition());\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tpublic static void unescapePartitionSpec(SqlNodeList partSpec) {\n+\t\tif (partSpec != null) {\n+\t\t\tfor (int i = 0; i < partSpec.size(); i++) {", "originalCommit": "aa2b18fb5b07aad9d2fe4664d9c311cfe3f591ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUxMzg0NQ==", "url": "https://github.com/apache/flink/pull/12378#discussion_r436513845", "bodyText": "I have changed to use SqlShuttle", "author": "lirui-apache", "createdAt": "2020-06-08T07:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MTQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e30df6387ff2da57fa3a48b90dbae6d01633f15b", "chunk": "diff --git a/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java b/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\nindex 5e71ad3f7dd..478aac842b5 100644\n--- a/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\n+++ b/flink-table/flink-sql-parser-hive/src/main/java/org/apache/flink/sql/parser/hive/ddl/HiveDDLUtils.java\n\n@@ -325,50 +329,65 @@ public class HiveDDLUtils {\n \t// the input of sql-client will escape '\\', unescape it so that users can write hive dialect\n \tpublic static void unescapeProperties(SqlNodeList properties) {\n \t\tif (properties != null) {\n-\t\t\tfor (int i = 0; i < properties.size(); i++) {\n-\t\t\t\tSqlNode node = properties.get(i);\n-\t\t\t\t// for properties\n-\t\t\t\tif (node instanceof SqlTableOption) {\n-\t\t\t\t\tnode = unescapeTableOption((SqlTableOption) node);\n-\t\t\t\t\tproperties.set(i, node);\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tproperties.accept(UNESCAPE_SHUTTLE);\n \t\t}\n \t}\n \n-\tpublic static SqlTableOption unescapeTableOption(SqlTableOption option) {\n-\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n-\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n-\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n-\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n-\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n-\t}\n-\n-\tpublic static SqlCharStringLiteral unescapeLiteral(SqlCharStringLiteral literal) {\n+\tpublic static SqlCharStringLiteral unescapeStringLiteral(SqlCharStringLiteral literal) {\n \t\tif (literal != null) {\n-\t\t\tString unescaped = StringEscapeUtils.unescapeJava(literal.getNlsString().getValue());\n-\t\t\treturn SqlLiteral.createCharString(unescaped, literal.getParserPosition());\n+\t\t\treturn (SqlCharStringLiteral) literal.accept(UNESCAPE_SHUTTLE);\n \t\t}\n \t\treturn null;\n \t}\n \n \tpublic static void unescapePartitionSpec(SqlNodeList partSpec) {\n \t\tif (partSpec != null) {\n-\t\t\tfor (int i = 0; i < partSpec.size(); i++) {\n-\t\t\t\tSqlNode node = partSpec.get(i);\n-\t\t\t\tif (node instanceof SqlProperty) {\n-\t\t\t\t\tSqlProperty property = (SqlProperty) node;\n-\t\t\t\t\tComparable comparable = SqlLiteral.value(property.getValue());\n-\t\t\t\t\tif (comparable instanceof NlsString) {\n-\t\t\t\t\t\tString val = StringEscapeUtils.unescapeJava(((NlsString) comparable).getValue());\n-\t\t\t\t\t\tproperty = new SqlProperty(\n-\t\t\t\t\t\t\t\tproperty.getKey(),\n-\t\t\t\t\t\t\t\tSqlLiteral.createCharString(val, property.getValue().getParserPosition()),\n-\t\t\t\t\t\t\t\tproperty.getParserPosition());\n-\t\t\t\t\t\tpartSpec.set(i, property);\n-\t\t\t\t\t}\n+\t\t\tpartSpec.accept(UNESCAPE_SHUTTLE);\n+\t\t}\n+\t}\n+\n+\tprivate static class UnescapeStringLiteralShuttle extends SqlShuttle {\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlNodeList nodeList) {\n+\t\t\tfor (int i = 0; i < nodeList.size(); i++) {\n+\t\t\t\tSqlNode unescaped = nodeList.get(i).accept(this);\n+\t\t\t\tnodeList.set(i, unescaped);\n+\t\t\t}\n+\t\t\treturn nodeList;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlCall call) {\n+\t\t\tif (call instanceof SqlProperty) {\n+\t\t\t\tSqlProperty property = (SqlProperty) call;\n+\t\t\t\tComparable comparable = SqlLiteral.value(property.getValue());\n+\t\t\t\tif (comparable instanceof NlsString) {\n+\t\t\t\t\tString val = StringEscapeUtils.unescapeJava(((NlsString) comparable).getValue());\n+\t\t\t\t\treturn new SqlProperty(\n+\t\t\t\t\t\t\tproperty.getKey(),\n+\t\t\t\t\t\t\tSqlLiteral.createCharString(val, property.getValue().getParserPosition()),\n+\t\t\t\t\t\t\tproperty.getParserPosition());\n \t\t\t\t}\n+\t\t\t} else if (call instanceof SqlTableOption) {\n+\t\t\t\tSqlTableOption option = (SqlTableOption) call;\n+\t\t\t\tString key = StringEscapeUtils.unescapeJava(option.getKeyString());\n+\t\t\t\tString val = StringEscapeUtils.unescapeJava(option.getValueString());\n+\t\t\t\tSqlNode keyNode = SqlLiteral.createCharString(key, option.getKey().getParserPosition());\n+\t\t\t\tSqlNode valNode = SqlLiteral.createCharString(val, option.getValue().getParserPosition());\n+\t\t\t\treturn new SqlTableOption(keyNode, valNode, option.getParserPosition());\n+\t\t\t}\n+\t\t\treturn call;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic SqlNode visit(SqlLiteral literal) {\n+\t\t\tif (literal instanceof SqlCharStringLiteral) {\n+\t\t\t\tSqlCharStringLiteral stringLiteral = (SqlCharStringLiteral) literal;\n+\t\t\t\tString unescaped = StringEscapeUtils.unescapeJava(stringLiteral.getNlsString().getValue());\n+\t\t\t\treturn SqlLiteral.createCharString(unescaped, stringLiteral.getParserPosition());\n \t\t\t}\n+\t\t\treturn literal;\n \t\t}\n \t}\n }\n"}}, {"oid": "9fba272121e31430be278ac4a064f419f2164b11", "url": "https://github.com/apache/flink/commit/9fba272121e31430be278ac4a064f419f2164b11", "message": "[FLINK-17965][sql-parser-hive] Hive dialect needs to unescape backslash in string literals", "committedDate": "2020-06-08T07:47:20Z", "type": "commit"}, {"oid": "825c1178929c313441f856705c4897eec73c3bff", "url": "https://github.com/apache/flink/commit/825c1178929c313441f856705c4897eec73c3bff", "message": "fix SERIALIZATION_FORMAT", "committedDate": "2020-06-08T07:47:21Z", "type": "commit"}, {"oid": "8101802f238abe8bae4844fe1b2bba870c8dbfe0", "url": "https://github.com/apache/flink/commit/8101802f238abe8bae4844fe1b2bba870c8dbfe0", "message": "unescape for insert", "committedDate": "2020-06-08T07:47:21Z", "type": "commit"}, {"oid": "87d483174d4ffd11a6bdbda45c92f6e70c680af2", "url": "https://github.com/apache/flink/commit/87d483174d4ffd11a6bdbda45c92f6e70c680af2", "message": "fix test", "committedDate": "2020-06-08T07:47:21Z", "type": "commit"}, {"oid": "e30df6387ff2da57fa3a48b90dbae6d01633f15b", "url": "https://github.com/apache/flink/commit/e30df6387ff2da57fa3a48b90dbae6d01633f15b", "message": "address comments", "committedDate": "2020-06-08T07:47:21Z", "type": "commit"}, {"oid": "e30df6387ff2da57fa3a48b90dbae6d01633f15b", "url": "https://github.com/apache/flink/commit/e30df6387ff2da57fa3a48b90dbae6d01633f15b", "message": "address comments", "committedDate": "2020-06-08T07:47:21Z", "type": "forcePushed"}]}