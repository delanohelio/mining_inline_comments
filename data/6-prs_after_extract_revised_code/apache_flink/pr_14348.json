{"pr_number": 14348, "pr_title": "[FLINK-20433][tests] Stabilizing UnalignedCheckpointITCase.", "pr_createdAt": "2020-12-09T13:36:03Z", "pr_url": "https://github.com/apache/flink/pull/14348", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyNzAzNA==", "url": "https://github.com/apache/flink/pull/14348#discussion_r539327034", "bodyText": "Drawback of removing such timeout is, that if there are multiple deadlocks in single azure build, test level timeout would show all of them. Azure level would show just the first one. Secondly won't the Azure level timeout would take longer to kick in?\nI'm not saying I'm strictly against removing it. But I'm just pointing this out. Having test level timeout is also sometimes annoying during debugging, so all in all I'm +/- 0 for this change.", "author": "pnowojski", "createdAt": "2020-12-09T13:57:55Z", "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "diffHunk": "@@ -103,11 +101,6 @@\n \t@Rule\n \tpublic final TemporaryFolder temp = new TemporaryFolder();\n \n-\t@Rule\n-\tpublic final Timeout timeout = Timeout.builder()\n-\t\t.withTimeout(300, TimeUnit.SECONDS)\n-\t\t.build();", "originalCommit": "a64501c9e87e70f3093abc558d57d370e0645e8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyMzAxMw==", "url": "https://github.com/apache/flink/pull/14348#discussion_r543123013", "bodyText": "Yes, that was the reason why I added it initially. But we then have a timeout rule which prints the stack traces (just what JUnit5 does).", "author": "AHeise", "createdAt": "2020-12-15T07:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyNzAzNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA==", "url": "https://github.com/apache/flink/pull/14348#discussion_r539331684", "bodyText": "Simplify to just Thread.sleep(1)?", "author": "pnowojski", "createdAt": "2020-12-09T14:03:51Z", "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java", "diffHunk": "@@ -321,7 +321,7 @@ public void invoke(Long value, Context context) throws Exception {\n \t\t\tif (backpressure) {\n \t\t\t\t// induce backpressure until enough checkpoints have been written\n \t\t\t\tif (random.nextInt(100) == 42) {\n-\t\t\t\t\tThread.sleep(0, 100_000);\n+\t\t\t\t\tThread.sleep(100);", "originalCommit": "a64501c9e87e70f3093abc558d57d370e0645e8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzNDUyOA==", "url": "https://github.com/apache/flink/pull/14348#discussion_r539334528", "bodyText": "With modified Thread.sleep() I presume CPU usage went down, right?\nBut what about test duration? Has it increased? If so maybe\nif (random.nextInt(100) == 42) {\n\tThread.sleep(1);\n}\n\nis better?\nNote that previous Thread.sleep(0, 100_000); was basically an equivalent of Thread.sleep(0); which in turn was burning 100% cpu. In other words\nif (random() % 100 == 0) {\n  Thread.sleep(1);\n}\n\nworks usually much better and more like you would be expecting compared to\nThread.sleep(0, 100_000);\n\nwhich is for the most purposes just broken and not sleeping at all.", "author": "pnowojski", "createdAt": "2020-12-09T14:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNDIzOA==", "url": "https://github.com/apache/flink/pull/14348#discussion_r543124238", "bodyText": "Test duration was lower altogether because of the source throttling. In the worst case, with this change, a checkpoint needs 100+100 ms compared to the ideal time of 100 ms. But since the test is much more resource friendly now, it was effectively lower on my 8-core machine.\nThe issue with your proposition is now that there may be runs without any backpressure, which may or may not be beneficial.", "author": "AHeise", "createdAt": "2020-12-15T08:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NjMzOQ==", "url": "https://github.com/apache/flink/pull/14348#discussion_r543196339", "bodyText": "Err, I meant to say that two instances of backpressure may not occur that I like to see covered:\n\nBackpressure results in full buffers to be snapshotted and restored. If we just accumulate 100 record, then with the current record size and the min buffer size (4kb), it's likely that only a few bytes are snapshotted and restored and also only individual buffers and not multiples. So, we may never see in the ITCase if multiple buffers are snapshotted/recovered at all and in the correct order.\nConsequently, we may also not see backpressure in all exchanges, but just the last exchange. But I think it's important to cover all exchanges to test the different kinds of recovery, especially during rescaling (to come). It's also good to cover backpressure being propagated to the source ultimately.", "author": "AHeise", "createdAt": "2020-12-15T09:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTY4NA=="}], "type": "inlineReview", "revised_code": {"commit": "65f1903561a4d725112998ccc18e4e031b25fcf4", "chunk": "diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java\nindex 0c0589010ce..82bc317867d 100644\n--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java\n+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointITCase.java\n\n@@ -320,9 +323,7 @@ public class UnalignedCheckpointITCase extends UnalignedCheckpointTestBase {\n \n \t\t\tif (backpressure) {\n \t\t\t\t// induce backpressure until enough checkpoints have been written\n-\t\t\t\tif (random.nextInt(100) == 42) {\n-\t\t\t\t\tThread.sleep(100);\n-\t\t\t\t}\n+\t\t\t\tThread.sleep(1);\n \t\t\t}\n \t\t\t// after all checkpoints have been completed, the remaining data should be flushed out fairly quickly\n \t\t}\n"}}, {"oid": "65f1903561a4d725112998ccc18e4e031b25fcf4", "url": "https://github.com/apache/flink/commit/65f1903561a4d725112998ccc18e4e031b25fcf4", "message": "[FLINK-20433][tests] Stabilizing UnalignedCheckpointITCase.\n\nImproves UnalignedCheckpointITCase in the following ways to avoid running into rare issues or better deal with them:\n- Reduce load on test machine: Executing a test with p=10 may spawn up to 70 tasks that until backpressured can potentially lead to a full load on 70 cores. This may causes larger GC pauses and other JVM freezes that will trigger the rare PartitionNotFound exception. Now, sources are throttled until the sink backpressures.\n- Avoid relying completely on notifyCheckpointComplete to finish test: notifyCheckpointComplete is not guaranteed to be called but the test completely relied on it. This may lead to indefinite test runs: Some sources are finished while others are still running, but new checkpoints are canceled because of the finished sources. Thus, too many aborted checkpoints will also lead to a completed test.\n- Readding splits to enumerator (after FLINK-20290 has been fixed). Any unexpected failure may have caused all splits to be dropped, which causes indefinite running tests.\n- Removing test-class level timeout - AZP has its own timeout that also provides thread dumps - something that would require a tremendous effort in JUnit4.", "committedDate": "2020-12-16T17:12:05Z", "type": "forcePushed"}, {"oid": "562b597f6cbf499120f813a7e076b4915878f7b4", "url": "https://github.com/apache/flink/commit/562b597f6cbf499120f813a7e076b4915878f7b4", "message": "To be squashed:\n\n- Keep track of restart attempts in split enumerator and sink with source instances. Only finish sources if the desired numbers of failures occurred to avoid finishing too quickly.", "committedDate": "2020-12-17T13:04:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzNTY1NQ==", "url": "https://github.com/apache/flink/pull/14348#discussion_r545035655", "bodyText": "why ~?", "author": "pnowojski", "createdAt": "2020-12-17T11:59:45Z", "path": "flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java", "diffHunk": "@@ -219,14 +219,17 @@ public InputStatus pollNext(ReaderOutput<Long> output) throws InterruptedExcepti\n \t\t\t\t\treturn Collections.emptyList();\n \t\t\t\t}\n \t\t\t\tthrottle = split.numCompletedCheckpoints >= minCheckpoints;\n-\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (? attempt)\", split, split.nextNumber % split.increment);\n+\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (~{} attempt)\", split, split.nextNumber % split.increment, numRestarts);", "originalCommit": "7d5ff197d8a692bf2baa24e47c2548dc1be956ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE3NjcyNQ==", "url": "https://github.com/apache/flink/pull/14348#discussion_r545176725", "bodyText": "Good catch. It was approximate in the first version, but now it's not anymore.", "author": "AHeise", "createdAt": "2020-12-17T15:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzNTY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8d3b97de924fbbe87f5f37c8c572ea0194ccfa3f", "chunk": "diff --git a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java\nindex 115cc184bb8..2acf7b62a59 100644\n--- a/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java\n+++ b/flink-tests/src/test/java/org/apache/flink/test/checkpointing/UnalignedCheckpointTestBase.java\n\n@@ -219,14 +219,14 @@ public abstract class UnalignedCheckpointTestBase extends TestLogger {\n \t\t\t\t\treturn Collections.emptyList();\n \t\t\t\t}\n \t\t\t\tthrottle = split.numCompletedCheckpoints >= minCheckpoints;\n-\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask (~{} attempt)\", split, split.nextNumber % split.increment, numRestarts);\n+\t\t\t\tLOG.info(\"Snapshotted {} @ {} subtask ({} attempt)\", split, split.nextNumber % split.increment, numRestarts);\n \t\t\t\treturn singletonList(split);\n \t\t\t}\n \n \t\t\t@Override\n \t\t\tpublic void notifyCheckpointComplete(long checkpointId) {\n \t\t\t\tif (split != null) {\n-\t\t\t\t\tLOG.info(\"notifyCheckpointComplete {} @ {} subtask (~{} attempt)\",\n+\t\t\t\t\tLOG.info(\"notifyCheckpointComplete {} @ {} subtask ({} attempt)\",\n \t\t\t\t\t\tsplit.numCompletedCheckpoints,\n \t\t\t\t\t\tsplit.nextNumber % split.increment,\n \t\t\t\t\t\tnumRestarts);\n"}}, {"oid": "8d3b97de924fbbe87f5f37c8c572ea0194ccfa3f", "url": "https://github.com/apache/flink/commit/8d3b97de924fbbe87f5f37c8c572ea0194ccfa3f", "message": "To be squashed:\n\n- Keep track of restart attempts in split enumerator and sink with source instances. Only finish sources if the desired numbers of failures occurred to avoid finishing too quickly.", "committedDate": "2020-12-17T15:27:12Z", "type": "forcePushed"}, {"oid": "d13d56cb93c745ca2af5b7f5ef72a27027af43f1", "url": "https://github.com/apache/flink/commit/d13d56cb93c745ca2af5b7f5ef72a27027af43f1", "message": "[FLINK-20433][tests] Stabilizing UnalignedCheckpointITCase.\n\nImproves UnalignedCheckpointITCase in the following ways to avoid running into rare issues or better deal with them:\n- Reduce load on test machine: Executing a test with p=10 may spawn up to 70 tasks that until backpressured can potentially lead to a full load on 70 cores. This may causes larger GC pauses and other JVM freezes that will trigger the rare PartitionNotFound exception. Now, sources are throttled until the sink backpressures.\n- Keep track of restart attempts in split enumerator and sink with source instances. Only finish sources if the desired numbers of failures occurred to avoid finishing too quickly.\n- Avoid relying completely on notifyCheckpointComplete to finish test: notifyCheckpointComplete is not guaranteed to be called but the test completely relied on it. This may lead to indefinite test runs: Some sources are finished while others are still running, but new checkpoints are canceled because of the finished sources. Thus, too many aborted checkpoints will also lead to a completed test.\n- Readding splits to enumerator (after FLINK-20290 has been fixed). Any unexpected failure may have caused all splits to be dropped, which causes indefinite running tests.\n- Removing test-class level timeout - AZP has its own timeout that also provides thread dumps - something that would require a tremendous effort in JUnit4.", "committedDate": "2020-12-17T15:28:22Z", "type": "commit"}, {"oid": "d13d56cb93c745ca2af5b7f5ef72a27027af43f1", "url": "https://github.com/apache/flink/commit/d13d56cb93c745ca2af5b7f5ef72a27027af43f1", "message": "[FLINK-20433][tests] Stabilizing UnalignedCheckpointITCase.\n\nImproves UnalignedCheckpointITCase in the following ways to avoid running into rare issues or better deal with them:\n- Reduce load on test machine: Executing a test with p=10 may spawn up to 70 tasks that until backpressured can potentially lead to a full load on 70 cores. This may causes larger GC pauses and other JVM freezes that will trigger the rare PartitionNotFound exception. Now, sources are throttled until the sink backpressures.\n- Keep track of restart attempts in split enumerator and sink with source instances. Only finish sources if the desired numbers of failures occurred to avoid finishing too quickly.\n- Avoid relying completely on notifyCheckpointComplete to finish test: notifyCheckpointComplete is not guaranteed to be called but the test completely relied on it. This may lead to indefinite test runs: Some sources are finished while others are still running, but new checkpoints are canceled because of the finished sources. Thus, too many aborted checkpoints will also lead to a completed test.\n- Readding splits to enumerator (after FLINK-20290 has been fixed). Any unexpected failure may have caused all splits to be dropped, which causes indefinite running tests.\n- Removing test-class level timeout - AZP has its own timeout that also provides thread dumps - something that would require a tremendous effort in JUnit4.", "committedDate": "2020-12-17T15:28:22Z", "type": "forcePushed"}]}