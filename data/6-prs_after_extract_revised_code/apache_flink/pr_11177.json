{"pr_number": 11177, "pr_title": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.", "pr_createdAt": "2020-02-21T15:37:59Z", "pr_url": "https://github.com/apache/flink/pull/11177", "timeline": [{"oid": "61b28a39aa682892a746495931949ab20dd1979c", "url": "https://github.com/apache/flink/commit/61b28a39aa682892a746495931949ab20dd1979c", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.", "committedDate": "2020-02-21T15:39:21Z", "type": "forcePushed"}, {"oid": "3d36bd3136fd8b56ee367ee29dc9c92beaf4542a", "url": "https://github.com/apache/flink/commit/3d36bd3136fd8b56ee367ee29dc9c92beaf4542a", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.", "committedDate": "2020-02-21T19:58:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383135416", "bodyText": "Why can not we move headOperator.getChainingStrategy() != ChainingStrategy.NEVER into the canBeChainedTo(headOperator) call/check?", "author": "pnowojski", "createdAt": "2020-02-24T08:46:11Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDA0NQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384320045", "bodyText": "A different question imho. First, is upstream supporting chaining at all? Second, is this specific downstream chainable to the upstream.", "author": "AHeise", "createdAt": "2020-02-26T07:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0Nzk1NA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384347954", "bodyText": "I would prefer to have one method to rule them all (to have one definite answer how to handle the chaining strategy), but as you prefer.", "author": "pnowojski", "createdAt": "2020-02-26T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg=="}], "type": "inlineReview", "revised_code": {"commit": "42f920ac137b14f43923fcee4677dc57c849fac2", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex bafa2b2bf94..9857c53cdbf 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n\n@@ -587,29 +587,50 @@ public class StreamingJobGraphGenerator {\n \n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"CONNECTED: {} - {} -> {}\", partitioner.getClass().getSimpleName(),\n-\t\t\t\t\theadOfChain, downStreamvertexID);\n+\t\t\t\t\theadOfChain, downstreamVertexID);\n \t\t}\n \t}\n \n \tpublic static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n-\t\tStreamNode upStreamVertex = streamGraph.getSourceVertex(edge);\n-\t\tStreamNode downStreamVertex = streamGraph.getTargetVertex(edge);\n-\n-\t\tStreamOperatorFactory<?> headOperator = upStreamVertex.getOperatorFactory();\n-\t\tStreamOperatorFactory<?> outOperator = downStreamVertex.getOperatorFactory();\n-\n-\t\treturn downStreamVertex.getInEdges().size() == 1\n-\t\t\t\t&& outOperator != null\n-\t\t\t\t&& headOperator != null\n-\t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n-\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER\n+\t\tStreamNode upstreamVertex = streamGraph.getSourceVertex(edge);\n+\t\tStreamNode downstreamVertex = streamGraph.getTargetVertex(edge);\n+\n+\t\tStreamOperatorFactory<?> upstreamOperator = upstreamVertex.getOperatorFactory();\n+\t\tStreamOperatorFactory<?> downstreamOperator = downstreamVertex.getOperatorFactory();\n+\n+\t\treturn downstreamVertex.getInEdges().size() == 1\n+\t\t\t\t&& downstreamOperator != null\n+\t\t\t\t&& upstreamOperator != null\n+\t\t\t\t&& upstreamVertex.isSameSlotSharingGroup(downstreamVertex)\n+\t\t\t\t&& upstreamOperator.getChainingStrategy() != ChainingStrategy.NEVER\n+\t\t\t\t&& canBeChainedTo(upstreamVertex, streamGraph, downstreamOperator.getChainingStrategy())\n \t\t\t\t&& (edge.getPartitioner() instanceof ForwardPartitioner)\n \t\t\t\t&& edge.getShuffleMode() != ShuffleMode.BATCH\n-\t\t\t\t&& upStreamVertex.getParallelism() == downStreamVertex.getParallelism()\n+\t\t\t\t&& upstreamVertex.getParallelism() == downstreamVertex.getParallelism()\n \t\t\t\t&& streamGraph.isChainingEnabled();\n \t}\n \n+\tprivate static boolean canBeChainedTo(\n+\t\t\tStreamNode upstreamVertex,\n+\t\t\tStreamGraph streamGraph,\n+\t\t\tChainingStrategy chainingStrategy) {\n+\t\tif (chainingStrategy == ChainingStrategy.HEAD_AFTER_LEGACY_SOURCE) {\n+\t\t\t// unfortunately the information that vertices have been chained is not preserved at this point\n+\t\t\treturn !getHeadOperator(upstreamVertex, streamGraph).isStreamSource();\n+\t\t}\n+\t\treturn chainingStrategy == ChainingStrategy.ALWAYS;\n+\t}\n+\n+\t/**\n+\t * Backtraces the head of an operator chain.\n+\t */\n+\tprivate static StreamOperatorFactory<?> getHeadOperator(StreamNode upstreamVertex, StreamGraph streamGraph) {\n+\t\tif (upstreamVertex.getInEdges().size() == 1 && isChainable(upstreamVertex.getInEdges().get(0), streamGraph)) {\n+\t\t\treturn getHeadOperator(streamGraph.getSourceVertex(upstreamVertex.getInEdges().get(0)), streamGraph);\n+\t\t}\n+\t\treturn upstreamVertex.getOperatorFactory();\n+\t}\n+\n \tprivate void setSlotSharingAndCoLocation() {\n \t\tsetSlotSharing();\n \t\tsetCoLocation();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzA1Mg==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383137052", "bodyText": "headOperator is a misnomer, as it's not always \"head\". It's just previous/up stream operator.  So at least headOperator -> upStreamOperator ?\nHowever, also maybe optional/subjective, I would expect the call be here head chained with next instead of next chained to head:\nheadOperator.getChainingStrategy().canBeChainedWith/canBeChainedTo(outOperator)\n\nas that's usually how lists/chains are being constructed/traversed - head to tail, so maybe:\ncanBeChainedWith(StreamOperatorFactory<?> downStreamOperator)\n\nafter all?", "author": "pnowojski", "createdAt": "2020-02-24T08:50:33Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTY3OQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384319679", "bodyText": "Renamed vars in a separate hotfix.\nFor the remainder naming, I think it's the other way around. If I construct head to tail, I'd ask can this node by chained to the head?", "author": "AHeise", "createdAt": "2020-02-26T07:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "42f920ac137b14f43923fcee4677dc57c849fac2", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\nindex d1f7e6779fb..289b938e4d7 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\n\n@@ -38,33 +41,18 @@ public enum ChainingStrategy {\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn true;\n-\t\t}\n-\t},\n+\tALWAYS,\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn false;\n-\t\t}\n-\t},\n+\tNEVER,\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn false;\n-\t\t}\n-\t},\n+\tHEAD,\n \n \t/**\n \t * Operators will be eagerly chained whenever possible, except after legacy sources.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzk3OA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383137978", "bodyText": "Can we add a test coverage in StreamingJobGraphGeneratorTest?", "author": "pnowojski", "createdAt": "2020-02-24T08:52:44Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42f920ac137b14f43923fcee4677dc57c849fac2", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex bafa2b2bf94..9857c53cdbf 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n\n@@ -587,29 +587,50 @@ public class StreamingJobGraphGenerator {\n \n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"CONNECTED: {} - {} -> {}\", partitioner.getClass().getSimpleName(),\n-\t\t\t\t\theadOfChain, downStreamvertexID);\n+\t\t\t\t\theadOfChain, downstreamVertexID);\n \t\t}\n \t}\n \n \tpublic static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n-\t\tStreamNode upStreamVertex = streamGraph.getSourceVertex(edge);\n-\t\tStreamNode downStreamVertex = streamGraph.getTargetVertex(edge);\n-\n-\t\tStreamOperatorFactory<?> headOperator = upStreamVertex.getOperatorFactory();\n-\t\tStreamOperatorFactory<?> outOperator = downStreamVertex.getOperatorFactory();\n-\n-\t\treturn downStreamVertex.getInEdges().size() == 1\n-\t\t\t\t&& outOperator != null\n-\t\t\t\t&& headOperator != null\n-\t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n-\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER\n+\t\tStreamNode upstreamVertex = streamGraph.getSourceVertex(edge);\n+\t\tStreamNode downstreamVertex = streamGraph.getTargetVertex(edge);\n+\n+\t\tStreamOperatorFactory<?> upstreamOperator = upstreamVertex.getOperatorFactory();\n+\t\tStreamOperatorFactory<?> downstreamOperator = downstreamVertex.getOperatorFactory();\n+\n+\t\treturn downstreamVertex.getInEdges().size() == 1\n+\t\t\t\t&& downstreamOperator != null\n+\t\t\t\t&& upstreamOperator != null\n+\t\t\t\t&& upstreamVertex.isSameSlotSharingGroup(downstreamVertex)\n+\t\t\t\t&& upstreamOperator.getChainingStrategy() != ChainingStrategy.NEVER\n+\t\t\t\t&& canBeChainedTo(upstreamVertex, streamGraph, downstreamOperator.getChainingStrategy())\n \t\t\t\t&& (edge.getPartitioner() instanceof ForwardPartitioner)\n \t\t\t\t&& edge.getShuffleMode() != ShuffleMode.BATCH\n-\t\t\t\t&& upStreamVertex.getParallelism() == downStreamVertex.getParallelism()\n+\t\t\t\t&& upstreamVertex.getParallelism() == downstreamVertex.getParallelism()\n \t\t\t\t&& streamGraph.isChainingEnabled();\n \t}\n \n+\tprivate static boolean canBeChainedTo(\n+\t\t\tStreamNode upstreamVertex,\n+\t\t\tStreamGraph streamGraph,\n+\t\t\tChainingStrategy chainingStrategy) {\n+\t\tif (chainingStrategy == ChainingStrategy.HEAD_AFTER_LEGACY_SOURCE) {\n+\t\t\t// unfortunately the information that vertices have been chained is not preserved at this point\n+\t\t\treturn !getHeadOperator(upstreamVertex, streamGraph).isStreamSource();\n+\t\t}\n+\t\treturn chainingStrategy == ChainingStrategy.ALWAYS;\n+\t}\n+\n+\t/**\n+\t * Backtraces the head of an operator chain.\n+\t */\n+\tprivate static StreamOperatorFactory<?> getHeadOperator(StreamNode upstreamVertex, StreamGraph streamGraph) {\n+\t\tif (upstreamVertex.getInEdges().size() == 1 && isChainable(upstreamVertex.getInEdges().get(0), streamGraph)) {\n+\t\t\treturn getHeadOperator(streamGraph.getSourceVertex(upstreamVertex.getInEdges().get(0)), streamGraph);\n+\t\t}\n+\t\treturn upstreamVertex.getOperatorFactory();\n+\t}\n+\n \tprivate void setSlotSharingAndCoLocation() {\n \t\tsetSlotSharing();\n \t\tsetCoLocation();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MDcyMA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383140720", "bodyText": "Do we need this enum? Can not we replace HEAD_AFTER_LEGACY_SOURCE with a check if that we are in a legacy source task and the downStreamOpeartor instanceof YieldingOperatorFactory?", "author": "pnowojski", "createdAt": "2020-02-24T08:58:57Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAwMQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384319001", "bodyText": "Is yielding the root cause of not chainable to legacy sources? If so, then this is a valid way.\nI'm concerned though that we also disallow chaining of operators that just need access to the mailboxExecutor for submit.", "author": "AHeise", "createdAt": "2020-02-26T07:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MDcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "42f920ac137b14f43923fcee4677dc57c849fac2", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\nindex d1f7e6779fb..289b938e4d7 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\n\n@@ -38,33 +41,18 @@ public enum ChainingStrategy {\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn true;\n-\t\t}\n-\t},\n+\tALWAYS,\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn false;\n-\t\t}\n-\t},\n+\tNEVER,\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn false;\n-\t\t}\n-\t},\n+\tHEAD,\n \n \t/**\n \t * Operators will be eagerly chained whenever possible, except after legacy sources.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MTE1Mg==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383141152", "bodyText": "Is it working properly? What if we have StreamSource -> OP2 -> OP3 -> AsyncWaitOperator?", "author": "pnowojski", "createdAt": "2020-02-24T09:00:03Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODY0MQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384318641", "bodyText": "It was not. Good catch.", "author": "AHeise", "createdAt": "2020-02-26T07:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MTE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "42f920ac137b14f43923fcee4677dc57c849fac2", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\nindex d1f7e6779fb..289b938e4d7 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java\n\n@@ -38,33 +41,18 @@ public enum ChainingStrategy {\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn true;\n-\t\t}\n-\t},\n+\tALWAYS,\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn false;\n-\t\t}\n-\t},\n+\tNEVER,\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD {\n-\t\t@Override\n-\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n-\t\t\treturn false;\n-\t\t}\n-\t},\n+\tHEAD,\n \n \t/**\n \t * Operators will be eagerly chained whenever possible, except after legacy sources.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MjEyMA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383142120", "bodyText": "add a simple mapping function?\ninput = chainEnv.fromElements(1).map(....);", "author": "pnowojski", "createdAt": "2020-02-24T09:02:23Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java", "diffHunk": "@@ -365,10 +365,10 @@ private void testProcessingTime(AsyncDataStream.OutputMode mode) throws Exceptio\n \t}\n \n \t/**\n-\t * Test for the temporary fix to FLINK-13063.\n+\t * Tests FLINK-16219.\n \t */\n \t@Test\n-\tpublic void testAsyncOperatorIsNeverChained() {\n+\tpublic void testAsyncOperatorIsNotChainedToSources() {\n \t\tStreamExecutionEnvironment chainEnv = StreamExecutionEnvironment.getExecutionEnvironment();\n \n \t\tDataStream<Integer> input = chainEnv.fromElements(1);", "originalCommit": "3d36bd3136fd8b56ee367ee29dc9c92beaf4542a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42f920ac137b14f43923fcee4677dc57c849fac2", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java\nindex 61e97d347d5..19458a7a67c 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java\n\n@@ -369,9 +369,9 @@ public class AsyncWaitOperatorTest extends TestLogger {\n \t */\n \t@Test\n \tpublic void testAsyncOperatorIsNotChainedToSources() {\n-\t\tStreamExecutionEnvironment chainEnv = StreamExecutionEnvironment.getExecutionEnvironment();\n+\t\tStreamExecutionEnvironment chainEnv = StreamExecutionEnvironment.createLocalEnvironment(1);\n \n-\t\tDataStream<Integer> input = chainEnv.fromElements(1);\n+\t\tDataStream<Integer> input = chainEnv.fromElements(1).map((x) -> x);\n \t\tinput = AsyncDataStream.orderedWait(\n \t\t\tinput,\n \t\t\tnew LazyAsyncFunction(),\n"}}, {"oid": "42f920ac137b14f43923fcee4677dc57c849fac2", "url": "https://github.com/apache/flink/commit/42f920ac137b14f43923fcee4677dc57c849fac2", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.", "committedDate": "2020-02-26T07:44:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0ODg2MQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384348861", "bodyText": "nit: downstream -> downStream & upstream -> upStream. I quickly git grepped the code, and downstream is only used in text/docs. downStream is used in the code.", "author": "pnowojski", "createdAt": "2020-02-26T08:56:10Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -542,14 +542,14 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \n \t\tphysicalEdgesInOrder.add(edge);\n \n-\t\tInteger downStreamvertexID = edge.getTargetId();\n+\t\tInteger downstreamVertexID = edge.getTargetId();", "originalCommit": "1cab8f3199f86009056903418dc31e20313cae21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "810b12ab01637f7d70d091922ba9cbf9bc45680e", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex 41810a77d69..570a95b23c5 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n\n@@ -542,14 +543,14 @@ public class StreamingJobGraphGenerator {\n \n \t\tphysicalEdgesInOrder.add(edge);\n \n-\t\tInteger downstreamVertexID = edge.getTargetId();\n+\t\tInteger downStreamVertexID = edge.getTargetId();\n \n \t\tJobVertex headVertex = jobVertices.get(headOfChain);\n-\t\tJobVertex downstreamVertex = jobVertices.get(downstreamVertexID);\n+\t\tJobVertex downStreamVertex = jobVertices.get(downStreamVertexID);\n \n-\t\tStreamConfig downstreamConfig = new StreamConfig(downstreamVertex.getConfiguration());\n+\t\tStreamConfig downStreamConfig = new StreamConfig(downStreamVertex.getConfiguration());\n \n-\t\tdownstreamConfig.setNumberOfInputs(downstreamConfig.getNumberOfInputs() + 1);\n+\t\tdownStreamConfig.setNumberOfInputs(downStreamConfig.getNumberOfInputs() + 1);\n \n \t\tStreamPartitioner<?> partitioner = edge.getPartitioner();\n \n"}}, {"oid": "37d4a094fe466a22c2f3cc07a73d361a43928404", "url": "https://github.com/apache/flink/commit/37d4a094fe466a22c2f3cc07a73d361a43928404", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-26T09:16:56Z", "type": "forcePushed"}, {"oid": "810b12ab01637f7d70d091922ba9cbf9bc45680e", "url": "https://github.com/apache/flink/commit/810b12ab01637f7d70d091922ba9cbf9bc45680e", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-26T09:21:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNDU1NA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r385604554", "bodyText": "Can we unit test this method assuming that StreamNode and StreamGraph are easy to construct/mock?", "author": "pnowojski", "createdAt": "2020-02-28T09:59:02Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -587,30 +588,54 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"CONNECTED: {} - {} -> {}\", partitioner.getClass().getSimpleName(),\n-\t\t\t\t\theadOfChain, downStreamvertexID);\n+\t\t\t\t\theadOfChain, downStreamVertexID);\n \t\t}\n \t}\n \n \tpublic static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\tStreamNode upStreamVertex = streamGraph.getSourceVertex(edge);\n \t\tStreamNode downStreamVertex = streamGraph.getTargetVertex(edge);\n \n-\t\tStreamOperatorFactory<?> headOperator = upStreamVertex.getOperatorFactory();\n-\t\tStreamOperatorFactory<?> outOperator = downStreamVertex.getOperatorFactory();\n-\n \t\treturn downStreamVertex.getInEdges().size() == 1\n-\t\t\t\t&& outOperator != null\n-\t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& areOperatorsChainable(upStreamVertex, downStreamVertex, streamGraph)\n \t\t\t\t&& (edge.getPartitioner() instanceof ForwardPartitioner)\n \t\t\t\t&& edge.getShuffleMode() != ShuffleMode.BATCH\n \t\t\t\t&& upStreamVertex.getParallelism() == downStreamVertex.getParallelism()\n \t\t\t\t&& streamGraph.isChainingEnabled();\n \t}\n \n+\tprivate static boolean areOperatorsChainable(", "originalCommit": "810b12ab01637f7d70d091922ba9cbf9bc45680e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9918bd9191889dbc5a65c2f2982b4140b320bf99", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex 570a95b23c5..757851ba165 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n\n@@ -588,7 +587,7 @@ public class StreamingJobGraphGenerator {\n \n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"CONNECTED: {} - {} -> {}\", partitioner.getClass().getSimpleName(),\n-\t\t\t\t\theadOfChain, downStreamVertexID);\n+\t\t\t\t\theadOfChain, downStreamvertexID);\n \t\t}\n \t}\n \n"}}, {"oid": "9918bd9191889dbc5a65c2f2982b4140b320bf99", "url": "https://github.com/apache/flink/commit/9918bd9191889dbc5a65c2f2982b4140b320bf99", "message": "[hotfix][runtime] Removed duplicate isChainable.", "committedDate": "2020-02-28T14:39:47Z", "type": "commit"}, {"oid": "e9323852743d7fc32c6abd787f63fa5705eea530", "url": "https://github.com/apache/flink/commit/e9323852743d7fc32c6abd787f63fa5705eea530", "message": "[hotfix][runtime] Unified variable names in StreamingJobGraphGenerator.\n\nRemoved confusing headOperators in isChainable.", "committedDate": "2020-02-28T14:39:47Z", "type": "commit"}, {"oid": "613acf26bdd79ea6c10fb3b3ae8fe27376b5b259", "url": "https://github.com/apache/flink/commit/613acf26bdd79ea6c10fb3b3ae8fe27376b5b259", "message": "[FLINK-16219][runtime] Disallow chaining of legacy source and yielding operator.\n\nThis change allows yielding operators to be eagerly chained whenever possible, except after legacy sources.\nYielding operators do not properly work when processInput is called from another thread, but are usually fine in any other chain.", "committedDate": "2020-02-28T14:41:00Z", "type": "commit"}, {"oid": "c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "url": "https://github.com/apache/flink/commit/c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-28T14:41:00Z", "type": "commit"}, {"oid": "c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "url": "https://github.com/apache/flink/commit/c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-28T14:41:00Z", "type": "forcePushed"}]}