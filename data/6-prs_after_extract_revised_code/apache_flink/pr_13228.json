{"pr_number": 13228, "pr_title": "[FLINK-19026][network] Improve threading model of CheckpointBarrierUnaligner", "pr_createdAt": "2020-08-24T12:21:10Z", "pr_url": "https://github.com/apache/flink/pull/13228", "timeline": [{"oid": "249424b93f4963ef5875798dacb3f73f8ed18b0b", "url": "https://github.com/apache/flink/commit/249424b93f4963ef5875798dacb3f73f8ed18b0b", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-08-24T12:21:53Z", "type": "forcePushed"}, {"oid": "f0bb8a255816919a6578a6994499757075ab371b", "url": "https://github.com/apache/flink/commit/f0bb8a255816919a6578a6994499757075ab371b", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-08-24T12:23:30Z", "type": "forcePushed"}, {"oid": "67942d0ea538985ec25cecf7cefdc1bec0c1b53b", "url": "https://github.com/apache/flink/commit/67942d0ea538985ec25cecf7cefdc1bec0c1b53b", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-08-24T19:27:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg3NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476465875", "bodyText": "nit: it was a bit confusing for me for a moment which code paths are doing what. IMO it would be easier to follow it, if the shorter branch would be first, and if the more complicated part would have one lever of nesting less:\nif (!insertAsHead) {\n  buffers.add(bufferConsumer);\n  return;\n}\n//rest of the code\n\nin that case it's more obvious that !insertAsHead is a trivial case and that it doesn't interact with the other branch at all.", "author": "pnowojski", "createdAt": "2020-08-25T13:53:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tbuffers.add(bufferConsumer);", "originalCommit": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1NzIzMQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476657231", "bodyText": "Yes, good idea. In general that change looks a bit odd, because it's isolated from the upcoming changes (I had to split somewhere and probably didn't hit the sweet spot everywhere).", "author": "AHeise", "createdAt": "2020-08-25T18:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex fc09c18f1f8..bc44221c16f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -154,70 +157,74 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t\t\t}\n \n \t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n+\t\t\tnotifyPriority = addBuffer(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n+\t\t\tnotifyDataAvailable = finish || shouldNotifyDataAvailable();\n \n \t\t\tisFinished |= finish;\n \t\t}\n \n-\t\tif (notifyDataAvailable) {\n+\t\tif (notifyPriority) {\n+\t\t\tnotifyPriorityEvent();\n+\t\t} else if (notifyDataAvailable) {\n \t\t\tnotifyDataAvailable();\n \t\t}\n \n \t\treturn true;\n \t}\n \n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n+\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n-\n-\t\t\tfinal int pos = buffers.getNumPriorityElements();\n-\t\t\tbuffers.addPriorityElement(bufferConsumer);\n-\n-\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\t\tif (unalignedCheckpoint) {\n-\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n-\t\t\t\tIterators.advance(iterator, pos + 1);\n-\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\tBufferConsumer buffer = iterator.next();\n-\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n-\t\t\t\t\t\t}\n+\t\tif (!bufferConsumer.getDataType().hasPriority()) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn;\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n-\t\tbuffers.add(bufferConsumer);\n+\t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+\t\tCheckpointBarrier barrier;\n \t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n \t\t\tBuffer buffer = bc.build();\n \t\t\ttry {\n \t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t\tbarrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n \t\t\t} finally {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n-\t\treturn unalignedCheckpoint;\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n+\t\treturn barrier;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODc5Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476468797", "bodyText": "Why do we need this change? In what scenarios are you expecting more than one priority event in the output buffer?  (if there is a reason that I'm forgetting about, please add it to the commit message)\nedit: (after reading commit message a couple of times) Or you are just re-using here a class, that you are mostly intending to use later in the future (on the inputs?)? If so maybe it needs some more explanation in the commit message?", "author": "pnowojski", "createdAt": "2020-08-25T13:56:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}", "originalCommit": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1OTY2OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476659669", "bodyText": "In general, I wanted to drop the assumption that there is only one priority event going on at any given time. That's especially true when we make cancellation events also a priority and we have a more or less fully blocked channel.\nSpecifically, this change had following motivations:\n\ndrop the assumption that all priority events are unaligned checkpoints.\ndrop the assumption that the new priority event is always at position 0.\na small performance improvement where buffers are only copied after it's clear that they are not containing an event.", "author": "AHeise", "createdAt": "2020-08-25T18:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODc5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex fc09c18f1f8..bc44221c16f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -154,70 +157,74 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t\t\t}\n \n \t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n+\t\t\tnotifyPriority = addBuffer(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n+\t\t\tnotifyDataAvailable = finish || shouldNotifyDataAvailable();\n \n \t\t\tisFinished |= finish;\n \t\t}\n \n-\t\tif (notifyDataAvailable) {\n+\t\tif (notifyPriority) {\n+\t\t\tnotifyPriorityEvent();\n+\t\t} else if (notifyDataAvailable) {\n \t\t\tnotifyDataAvailable();\n \t\t}\n \n \t\treturn true;\n \t}\n \n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n+\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n-\n-\t\t\tfinal int pos = buffers.getNumPriorityElements();\n-\t\t\tbuffers.addPriorityElement(bufferConsumer);\n-\n-\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\t\tif (unalignedCheckpoint) {\n-\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n-\t\t\t\tIterators.advance(iterator, pos + 1);\n-\t\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\t\tBufferConsumer buffer = iterator.next();\n-\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n-\t\t\t\t\t\t}\n+\t\tif (!bufferConsumer.getDataType().hasPriority()) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\treturn;\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n-\t\tbuffers.add(bufferConsumer);\n+\t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+\t\tCheckpointBarrier barrier;\n \t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n \t\t\tBuffer buffer = bc.build();\n \t\t\ttry {\n \t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t\tbarrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n \t\t\t} finally {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n-\t\treturn unalignedCheckpoint;\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n+\t\treturn barrier;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MDg2Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476480862", "bodyText": "nit: add a javadoc explaining the returned value?", "author": "pnowojski", "createdAt": "2020-08-25T14:12:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable", "originalCommit": "f944eae8129d84d25b81e1d97ef573c15456ccb3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex b4502d165c8..837423aef15 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -127,23 +127,22 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\t@Nullable\n \tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!\n \t\tfinal Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n-\t\tif (numCreditsAvailable > 0 || (nextDataType != null && nextDataType.isEvent())) {\n+\t\tif (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n \t\t\treturn nextDataType;\n \t\t}\n-\t\treturn null;\n+\t\treturn Buffer.DataType.NONE;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MTY4MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476481681", "bodyText": "hmmm, maybe add another enum type for this purpose, instead of having null? (I'm not sure, just brain storming)", "author": "pnowojski", "createdAt": "2020-08-25T14:13:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n+\t\tfinal Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+\t\tif (numCreditsAvailable > 0 || (nextDataType != null && nextDataType.isEvent())) {\n+\t\t\treturn nextDataType;\n \t\t}\n+\t\treturn null;", "originalCommit": "f944eae8129d84d25b81e1d97ef573c15456ccb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MDc1OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476660758", "bodyText": "An enum type NONE would work for me and might make the code a bit clearer. However, be aware that this is mostly a copy&replace; I don't think it would simplify any code path.", "author": "AHeise", "createdAt": "2020-08-25T18:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MTY4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex b4502d165c8..837423aef15 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -127,23 +127,22 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\t@Nullable\n \tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!\n \t\tfinal Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n-\t\tif (numCreditsAvailable > 0 || (nextDataType != null && nextDataType.isEvent())) {\n+\t\tif (numCreditsAvailable > 0 || nextDataType.isEvent()) {\n \t\t\treturn nextDataType;\n \t\t}\n-\t\treturn null;\n+\t\treturn Buffer.DataType.NONE;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODQ5NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476498494", "bodyText": "maybe if the result variable rename and adding continue branch had happened in an independent \"refactor\" commit, It would have saved me a couple of minutes while reading this code while I was trying to understand the change :(\nmaybe not, as I can see how the changes are a bit interconnected.", "author": "pnowojski", "createdAt": "2020-08-25T14:35:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -621,61 +626,84 @@ public boolean isFinished() {\n \t\treturn Optional.of(transformToBufferOrEvent(\n \t\t\tinputWithData.data.buffer(),\n \t\t\tinputWithData.moreAvailable,\n-\t\t\tinputWithData.input));\n+\t\t\tinputWithData.input,\n+\t\t\tinputWithData.morePriorityEvents));\n \t}\n \n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n-\t\t\tif (!inputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> inputChannelOpt = getChannel(blocking);\n+\t\t\tif (!inputChannelOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n \n \t\t\t// Do not query inputChannel under the lock, to avoid potential deadlocks coming from\n \t\t\t// notifications.\n-\t\t\tOptional<BufferAndAvailability> result = inputChannel.get().getNextBuffer();\n+\t\t\tfinal InputChannel inputChannel = inputChannelOpt.get();\n+\t\t\tOptional<BufferAndAvailability> bufferAndAvailabilityOpt = inputChannel.getNextBuffer();\n \n \t\t\tsynchronized (inputChannelsWithData) {\n-\t\t\t\tif (result.isPresent() && result.get().moreAvailable()) {\n+\t\t\t\tif (!bufferAndAvailabilityOpt.isPresent()) {\n+\t\t\t\t\tif (inputChannelsWithData.isEmpty()) {\n+\t\t\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue;", "originalCommit": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MDkyMQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476660921", "bodyText": "Sry, I will split.", "author": "AHeise", "createdAt": "2020-08-25T18:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODQ5NA=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 6db6de81c03..60db7a9b450 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -631,7 +624,7 @@ public class SingleInputGate extends IndexedInputGate {\n \t}\n \n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n-\t\t\tthrows IOException, InterruptedException {\n+\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n \t\t\tOptional<InputChannel> inputChannelOpt = getChannel(blocking);\n \t\t\tif (!inputChannelOpt.isPresent()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwODcyNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476508727", "bodyText": "Heh, there are quite a bit more of corner/edge cases now.\nI wonder if there is maybe some other way to express the priority events, that would simplify the input gates code?", "author": "pnowojski", "createdAt": "2020-08-25T14:48:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -770,34 +808,50 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {", "originalCommit": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MjE5Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476662192", "bodyText": "Well this change is less about expressing priority events and more about making sure that channels with priority events are always polled first. It's some kind of potential double notification, where the priority notification overrides the normal data available notification.", "author": "AHeise", "createdAt": "2020-08-25T18:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwODcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 6db6de81c03..60db7a9b450 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -814,11 +811,22 @@ public class SingleInputGate extends IndexedInputGate {\n \t\tCompletableFuture<?> toNotify = null;\n \n \t\tsynchronized (inputChannelsWithData) {\n+\t\t\tif (channel == selectedChannel) {\n+\t\t\t\t// double-check if the channel still needs to be enqueued -- it could have been polled in the meantime\n+\t\t\t\t// because of FLINK-12510 (Deadlock when reading from InputGates) and priority notifications\n+\t\t\t\tfinal Buffer.DataType dataType = channel.peekDataType();\n+\t\t\t\tif (dataType == Buffer.DataType.NONE) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tpriority = dataType.hasPriority();\n+\t\t\t}\n+\n \t\t\tif (!queueChannelUnsafe(channel, priority)) {\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tif (priority && inputChannelsWithData.getNumPriorityElements() == 1) {\n+\t\t\t\tinputChannelsWithData.notifyAll();\n \t\t\t\ttoNotifyPriority = priorityAvailabilityHelper.getUnavailableToResetAvailable();\n \t\t\t}\n \t\t\tif (inputChannelsWithData.size() == 1) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjIxNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476522216", "bodyText": "shouldn't we remove also obsolete values from this map? (to prevent a potential memory leak?)", "author": "pnowojski", "createdAt": "2020-08-25T15:06:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2NTY0MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476665640", "bodyText": "Good catch, a leak could happen when the checkpoint is cancelled through another channel. The map itself is rather small, but it could add up over all channels and gates.\nI don't have a good idea on how to properly abstract this cleanup except by adding some kind of checkpoint-cancelled hook though.\nAlternatively, checkpoint barrier handler becomes more aware of the buffers to be spilled. So instead of calling channel.spillInflightBuffers, it could be channel.getSpilledBuffers().forEach(channelStateWriter::write) on a good checkpoint and channel.getSpilledBuffers().forEach(Buffer::recycle) on cancelled checkpoints, where getSpilledBuffers always cleans up this map.", "author": "AHeise", "createdAt": "2020-08-25T18:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 8cf7d0c789c..08a26965dfd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -192,28 +200,9 @@ public class RemoteInputChannel extends InputChannel {\n \t\treturn Optional.of(new BufferAndAvailability(next, nextDataType, 0));\n \t}\n \n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n+\tpublic Buffer.DataType peekDataType() {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);\n-\t\t\tPreconditions.checkState(numRecords != null, \"\");\n-\n-\t\t\tif (numRecords > 0) {\n-\t\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\t\tIterator<Buffer> iterator = receivedBuffers.iterator();\n-\t\t\t\tfor (int index = 0; index < numRecords; index++) {\n-\t\t\t\t\tfinal Buffer buffer = iterator.next();\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\t\tcheckpointId,\n-\t\t\t\t\tchannelInfo,\n-\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\t\tCloseableIterator.fromList(inflightBuffers, Buffer::recycleBuffer));\n-\t\t\t}\n+\t\t\treturn receivedBuffers.peek() != null ? receivedBuffers.peek().getDataType() : Buffer.DataType.NONE;\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNDQwOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476524408", "bodyText": "numRecordsOvertaken -> numBuffersOvertaken?", "author": "pnowojski", "createdAt": "2020-08-25T15:09:13Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 8cf7d0c789c..08a26965dfd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -192,28 +200,9 @@ public class RemoteInputChannel extends InputChannel {\n \t\treturn Optional.of(new BufferAndAvailability(next, nextDataType, 0));\n \t}\n \n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n+\tpublic Buffer.DataType peekDataType() {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);\n-\t\t\tPreconditions.checkState(numRecords != null, \"\");\n-\n-\t\t\tif (numRecords > 0) {\n-\t\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\t\tIterator<Buffer> iterator = receivedBuffers.iterator();\n-\t\t\t\tfor (int index = 0; index < numRecords; index++) {\n-\t\t\t\t\tfinal Buffer buffer = iterator.next();\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\t\tcheckpointId,\n-\t\t\t\t\tchannelInfo,\n-\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\t\tCloseableIterator.fromList(inflightBuffers, Buffer::recycleBuffer));\n-\t\t\t}\n+\t\t\treturn receivedBuffers.peek() != null ? receivedBuffers.peek().getDataType() : Buffer.DataType.NONE;\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNzI5Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476527296", "bodyText": "Do I understand it correctly? Currently there is a fragile contract, that numRecordsOvertaken value wouldn't change between onBuffer(...) where we are setting it and this spillInflightBuffers(...) call? In other words, it assumes that between enqueueing of the priority event and the spillInflightBuffers(...), task thread is not allowed to process any buffers?\nMaybe it would be better to embed the numRecordsOvertaken value in the priority event that would be processed by the task thread?", "author": "pnowojski", "createdAt": "2020-08-25T15:13:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2ODM5MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476668391", "bodyText": "It's not a fragile contract if you think about it. We are setting the values under buffer lock and we will poll the barrier as the first thing under buffer lock. Any buffer that has been pulled by the task before the barrier cannot be overtaken. The buffer after the barrier overtakes is always the barrier itself.\nHowever, now that I think about it. It is not working correctly when there is another priority event being inserted between the barrier and the overtaken buffers. The fix is simple though thanks to the simpler threading model: only count non-priority buffers.", "author": "AHeise", "createdAt": "2020-08-25T18:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNzI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 8cf7d0c789c..08a26965dfd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -192,28 +200,9 @@ public class RemoteInputChannel extends InputChannel {\n \t\treturn Optional.of(new BufferAndAvailability(next, nextDataType, 0));\n \t}\n \n-\t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n+\tpublic Buffer.DataType peekDataType() {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);\n-\t\t\tPreconditions.checkState(numRecords != null, \"\");\n-\n-\t\t\tif (numRecords > 0) {\n-\t\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\t\tIterator<Buffer> iterator = receivedBuffers.iterator();\n-\t\t\t\tfor (int index = 0; index < numRecords; index++) {\n-\t\t\t\t\tfinal Buffer buffer = iterator.next();\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\t\tcheckpointId,\n-\t\t\t\t\tchannelInfo,\n-\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\t\tCloseableIterator.fromList(inflightBuffers, Buffer::recycleBuffer));\n-\t\t\t}\n+\t\t\treturn receivedBuffers.peek() != null ? receivedBuffers.peek().getDataType() : Buffer.DataType.NONE;\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzMwNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476547304", "bodyText": "Again, do I understand this correctly? Is this assuming that nobody polls anything between completing getPriorityEventAvailableFuture and executing this::processPriorityEvents? Isn't that a bit fragile?\n\n\nWhat was the motivation for no passing the priority events to the StreamTaskNetworkInput?\n\n\nWhat about processing priority events as part of pollNext()?", "author": "pnowojski", "createdAt": "2020-08-25T15:40:43Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+\n+\t\t// re-enqueue mail to process priority events\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\tprivate void waitForPriorityEvents(InputGate inputGate, MailboxExecutor mailboxExecutor) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputGate.getPriorityEventAvailableFuture();\n+\t\tpriorityEventAvailableFuture.thenRun(() -> {\n+\t\t\tmailboxExecutor.execute(this::processPriorityEvents, \"process priority even @ gate %s\", inputGate);\n+\t\t});", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3MzM1NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476673355", "bodyText": "Nope, this assumption does not hold. That's why the first thing that processPriorityEvents does is to check if the future is still completed. If the task polled the only priority event in the meantime, the future has been reset. During the execution of processPriorityEvents in the task thread, the task cannot concurrently pull the priority event, so this is safe.\n2.+3. The basic idea of not involving StreamTaskNetworkInput#emitNext or using pollNext() is to not make non-blocking output more complicated. Currently, emitNext or pollNext are only called when an output buffer is available. In the meantime only mails are processed. Hence, I used a mail to perform processPriorityEvents.\nNote that the assumption here is that no priority event ever need to be handled in emitNext (which currently only handles EndOfPartitionEvent)", "author": "AHeise", "createdAt": "2020-08-25T19:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzMwNA=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\nindex 5bb94c64070..7247f66e654 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n\n@@ -82,11 +81,17 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven\n \t */\n \tprivate void processPriorityEvents() throws IOException, InterruptedException {\n \t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n-\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n-\t\tif (hasPriorityEvents) {\n-\t\t\t// process as many priority events as possible\n-\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\tboolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\t// process as many priority events as possible\n+\t\tint processed = 0;\n+\t\twhile (hasPriorityEvents) {\n+\t\t\tfinal Optional<BufferOrEvent> bufferOrEventOpt = pollNext();\n+\t\t\tif (!bufferOrEventOpt.isPresent()) {\n+\t\t\t\tbreak;\n \t\t\t}\n+\t\t\tfinal BufferOrEvent bufferOrEvent = bufferOrEventOpt.get();\n+\t\t\tcheckState(bufferOrEvent.isEvent(), \"Unexpected buffer @ \" + processed++);\n+\t\t\thasPriorityEvents = bufferOrEvent.morePriorityEvents();\n \t\t}\n \n \t\t// re-enqueue mail to process priority events\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTY3Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476551677", "bodyText": "Isn't it changing the semantic slightly? Am I right, that the only case on the master branch which actually causes another iteration of this loop is\nbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n\nand all of the other cases were exiting the loop? Are now all of the cases exiting always?", "author": "pnowojski", "createdAt": "2020-08-25T15:47:16Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NDAwNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476674004", "bodyText": "Yes, it's changing semantics (as I had written in commit message). I have not found a good reason why it's not always exited and it makes things easier especially since this method can now be used to process priority events.\nBtw I think it also changes semantics for all event that are not handled at all, but I'm not sure which events survive at this point (Superstep?).", "author": "AHeise", "createdAt": "2020-08-25T19:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTY3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\nindex 5bb94c64070..7247f66e654 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n\n@@ -118,8 +123,6 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven\n \n \t\tif (bufferOrEvent.isEvent()) {\n \t\t\thandleEvent(bufferOrEvent);\n-\t\t} else {\n-\t\t\tbarrierHandler.processBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.getChannelInfo());\n \t\t}\n \t\treturn next;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476557492", "bodyText": "As I understand it, it assumes that this pollNext() can not return anything else besides a priority event?", "author": "pnowojski", "createdAt": "2020-08-25T15:55:53Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NTA5Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476675096", "bodyText": "Yes, first this method checks if there is at least one priority event (priority future completed). If there is at least one, it starts processing the first one. At this point, it relies on BufferOrEvent::morePriorityEvents to be correct in both directions (no false positives or negatives; although a false negative would just be a tad slower).", "author": "AHeise", "createdAt": "2020-08-25T19:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MDM5MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492840391", "bodyText": "maybe add a checkState, that we are not loosing some unexpected data?", "author": "pnowojski", "createdAt": "2020-09-22T15:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\nindex 5bb94c64070..7247f66e654 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n\n@@ -82,11 +81,17 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven\n \t */\n \tprivate void processPriorityEvents() throws IOException, InterruptedException {\n \t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n-\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n-\t\tif (hasPriorityEvents) {\n-\t\t\t// process as many priority events as possible\n-\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\tboolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\t// process as many priority events as possible\n+\t\tint processed = 0;\n+\t\twhile (hasPriorityEvents) {\n+\t\t\tfinal Optional<BufferOrEvent> bufferOrEventOpt = pollNext();\n+\t\t\tif (!bufferOrEventOpt.isPresent()) {\n+\t\t\t\tbreak;\n \t\t\t}\n+\t\t\tfinal BufferOrEvent bufferOrEvent = bufferOrEventOpt.get();\n+\t\t\tcheckState(bufferOrEvent.isEvent(), \"Unexpected buffer @ \" + processed++);\n+\t\t\thasPriorityEvents = bufferOrEvent.morePriorityEvents();\n \t\t}\n \n \t\t// re-enqueue mail to process priority events\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476559505", "bodyText": "Is this spit into processBuffer and processEvent relevant?", "author": "pnowojski", "createdAt": "2020-08-25T15:58:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -159,10 +158,12 @@ public InputStatus emitNext(DataOutput<T> output) throws Exception {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n+\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n+\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n+\t\t\t\t} else {\n+\t\t\t\t\tprocessEvent(bufferOrEvent.get());", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3ODkwMw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476678903", "bodyText": "Nope, it's a refactoring that I should move out. We could also revert back. I had an intermediate version where processEvent signaled if the loop should be broken or not and there the split made more sense.", "author": "AHeise", "createdAt": "2020-08-25T19:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzkzMA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487967930", "bodyText": "Could you ether pull it to another commit or revert? This\n\nUse futures to listen to priority events and handle them in StreamTaskNetworkInput.\n\ncommit has a couple of other irrelevant changes", "author": "pnowojski", "createdAt": "2020-09-14T14:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwMzYxNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489203616", "bodyText": "Sorry I haven't pulled that change out, since it's more than a refactoring; it's the core change that modifies the semantics to always return on events.\nExcept for that change, everything else is more or less directly related to passing the priority future, so I'm not sure what to pull out.", "author": "AHeise", "createdAt": "2020-09-16T06:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java\nindex 4a93e3fb748..b24b4e15fa6 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java\n\n@@ -158,12 +159,10 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n-\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n-\t\t\t\t} else {\n-\t\t\t\t\tprocessEvent(bufferOrEvent.get());\n+\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n \t\t\t\t\treturn InputStatus.MORE_AVAILABLE;\n \t\t\t\t}\n+\t\t\t\tprocessBufferOrEvent(bufferOrEvent.get());\n \t\t\t} else {\n \t\t\t\tif (checkpointedInputGate.isFinished()) {\n \t\t\t\t\tcheckState(checkpointedInputGate.getAvailableFuture().isDone(), \"Finished BarrierHandler should be available\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTE2NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476561164", "bodyText": "for now in this commit, this is just a NO-OP call?", "author": "pnowojski", "createdAt": "2020-08-25T16:01:00Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {\n-\t\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n+\tpublic Optional<BufferOrEvent> pollNext() throws IOException, InterruptedException {\n+\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n \n-\t\t\tif (!next.isPresent()) {\n-\t\t\t\treturn handleEmptyBuffer();\n-\t\t\t}\n+\t\tif (!next.isPresent()) {\n+\t\t\treturn handleEmptyBuffer();\n+\t\t}\n \n-\t\t\tBufferOrEvent bufferOrEvent = next.get();\n-\t\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n+\t\tBufferOrEvent bufferOrEvent = next.get();\n+\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n \n-\t\t\tif (bufferOrEvent.isBuffer()) {\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();\n-\t\t\t\tbarrierHandler.processBarrier(checkpointBarrier, bufferOrEvent.getChannelInfo());\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {\n-\t\t\t\tbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class) {\n-\t\t\t\t\tbarrierHandler.processEndOfPartition();\n-\t\t\t\t}\n-\t\t\t\treturn next;\n-\t\t\t}\n+\t\tif (bufferOrEvent.isEvent()) {\n+\t\t\thandleEvent(bufferOrEvent);\n+\t\t} else {\n+\t\t\tbarrierHandler.processBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.getChannelInfo());", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NzkyNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476677925", "bodyText": "Yes, it's used in the next commit to persist in-flight data (replaces notifyBufferReceived).", "author": "AHeise", "createdAt": "2020-08-25T19:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\nindex 5bb94c64070..7247f66e654 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n\n@@ -118,8 +123,6 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven\n \n \t\tif (bufferOrEvent.isEvent()) {\n \t\t\thandleEvent(bufferOrEvent);\n-\t\t} else {\n-\t\t\tbarrierHandler.processBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.getChannelInfo());\n \t\t}\n \t\treturn next;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NDkwNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476564905", "bodyText": "Here, we are persisting in-flight buffers, only as they are being processed? Doesn't it mean, that unaligned checkpoint will be completed only after we process all of the buffers, making unaligned checkpoint just as quick as aligned?", "author": "pnowojski", "createdAt": "2020-08-25T16:06:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -92,306 +90,173 @@\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\t\thasInflightBuffers = Arrays.stream(inputGates)\n+\t\tthis.inputGates = inputGates;\n+\t\tstoreNewBuffers = Arrays.stream(inputGates)\n \t\t\t.flatMap(gate -> gate.getChannelInfos().stream())\n \t\t\t.collect(Collectors.toMap(Function.identity(), info -> false));\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(checkNotNull(checkpointCoordinator), this, inputGates);\n+\t\tnumOpenChannels = storeNewBuffers.size();\n+\t\tthis.checkpointCoordinator = checkpointCoordinator;\n \t}\n \n-\t/**\n-\t * We still need to trigger checkpoint via {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}\n-\t * while reading the first barrier from one channel, because this might happen\n-\t * earlier than the previous async trigger via mailbox by netty thread.\n-\t *\n-\t * <p>Note this is also suitable for the trigger case of local input channel.\n-\t */\n \t@Override\n-\tpublic void processBarrier(CheckpointBarrier receivedBarrier, InputChannelInfo channelInfo) throws IOException {\n-\t\tlong barrierId = receivedBarrier.getId();\n-\t\tif (currentConsumedCheckpointId > barrierId || (currentConsumedCheckpointId == barrierId && !isCheckpointPending())) {\n+\tpublic void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelInfo) throws IOException {\n+\t\tlong barrierId = barrier.getId();\n+\t\tif (currentCheckpointId > barrierId || (currentCheckpointId == barrierId && !isCheckpointPending())) {\n \t\t\t// ignore old and cancelled barriers\n \t\t\treturn;\n \t\t}\n-\t\tif (currentConsumedCheckpointId < barrierId) {\n-\t\t\tcurrentConsumedCheckpointId = barrierId;\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(true));\n+\t\tif (currentCheckpointId < barrierId) {\n+\t\t\thandleNewCheckpoint(barrier);\n+\t\t\tnotifyCheckpoint(barrier, 0);\n \t\t}\n-\t\tif (currentConsumedCheckpointId == barrierId) {\n-\t\t\thasInflightBuffers.put(channelInfo, false);\n-\t\t\tnumBarrierConsumed++;\n+\t\tif (currentCheckpointId == barrierId) {\n+\t\t\tif (storeNewBuffers.put(channelInfo, false)) {\n+\t\t\t\tLOG.debug(\"{}: Received barrier from channel {} @ {}.\", taskName, channelInfo, barrierId);\n+\n+\t\t\t\tinputGates[channelInfo.getGateIdx()].getChannel(channelInfo.getInputChannelIdx())\n+\t\t\t\t\t.spillInflightBuffers(barrierId, checkpointCoordinator.getChannelStateWriter());\n+\n+\t\t\t\tif (++numBarriersReceived == numOpenChannels) {\n+\t\t\t\t\tallBarriersReceivedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tthreadSafeUnaligner.notifyBarrierReceived(receivedBarrier, channelInfo);\n \t}\n \n \t@Override\n \tpublic void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {\n-\t\tthreadSafeUnaligner.tryAbortPendingCheckpoint(checkpointId, exception);\n+\t\ttryAbortPendingCheckpoint(checkpointId, exception);\n \n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(checkpointId);\n+\t\tif (checkpointId > currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws IOException {\n \t\tfinal long cancelledId = cancelBarrier.getCheckpointId();\n-\t\tboolean shouldAbort = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);\n+\t\tboolean shouldAbort = setCancelledCheckpointId(cancelledId);\n \t\tif (shouldAbort) {\n \t\t\tnotifyAbort(\n \t\t\t\tcancelledId,\n \t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER));\n \t\t}\n \n-\t\tif (cancelledId >= currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(cancelledId);\n-\t\t\tcurrentConsumedCheckpointId = cancelledId;\n+\t\tif (cancelledId >= currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentCheckpointId = cancelledId;\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processEndOfPartition() throws IOException {\n-\t\tthreadSafeUnaligner.onChannelClosed();\n-\t\tresetPendingCheckpoint(-1L);\n+\t\tnumOpenChannels--;\n+\n+\t\tresetPendingCheckpoint();\n+\t\tnotifyAbort(\n+\t\t\tcurrentCheckpointId,\n+\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n \t}\n \n-\tprivate void resetPendingCheckpoint(long checkpointId) {\n-\t\tif (isCheckpointPending()) {\n-\t\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) {} before completing current checkpoint {}. \" +\n-\t\t\t\t\t\"Skipping current checkpoint.\",\n-\t\t\t\ttaskName,\n-\t\t\t\tcheckpointId,\n-\t\t\t\tcurrentConsumedCheckpointId);\n+\tprivate void resetPendingCheckpoint() {\n+\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) before completing current checkpoint {}. \" +\n+\t\t\t\t\"Skipping current checkpoint.\",\n+\t\t\ttaskName,\n+\t\t\tcurrentCheckpointId);\n \n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(false));\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n+\t\tstoreNewBuffers.entrySet().forEach(storeNewBuffer -> storeNewBuffer.setValue(false));\n+\t\tnumBarriersReceived = 0;\n \t}\n \n \t@Override\n \tpublic long getLatestCheckpointId() {\n-\t\treturn currentConsumedCheckpointId;\n+\t\treturn currentCheckpointId;\n \t}\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentConsumedCheckpointId);\n+\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentCheckpointId);\n \t}\n \n \t@Override\n \tpublic void close() throws IOException {\n \t\tsuper.close();\n-\t\tthreadSafeUnaligner.close();\n-\t}\n-\n-\t@Override\n-\tpublic boolean hasInflightData(long checkpointId, InputChannelInfo channelInfo) {\n-\t\tif (checkpointId < currentConsumedCheckpointId) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn hasInflightBuffers.get(channelInfo);\n-\t}\n-\n-\t@Override\n-\tpublic CompletableFuture<Void> getAllBarriersReceivedFuture(long checkpointId) {\n-\t\treturn threadSafeUnaligner.getAllBarriersReceivedFuture(checkpointId);\n-\t}\n-\n-\t@Override\n-\tpublic Optional<BufferReceivedListener> getBufferReceivedListener() {\n-\t\treturn Optional.of(threadSafeUnaligner);\n+\t\tallBarriersReceivedFuture.cancel(false);\n \t}\n \n \t@Override\n \tprotected boolean isCheckpointPending() {\n-\t\treturn numBarrierConsumed > 0;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumOpenChannels() {\n-\t\treturn threadSafeUnaligner.getNumOpenChannels();\n-\t}\n-\n-\t@VisibleForTesting\n-\tThreadSafeUnaligner getThreadSafeUnaligner() {\n-\t\treturn threadSafeUnaligner;\n+\t\treturn numBarriersReceived > 0;\n \t}\n \n-\tprivate void notifyCheckpoint(CheckpointBarrier barrier) throws IOException {\n-\t\t// ignore the previous triggered checkpoint by netty thread if it was already canceled or aborted before.\n-\t\tif (barrier.getId() >= threadSafeUnaligner.getCurrentCheckpointId()) {\n-\t\t\tsuper.notifyCheckpoint(barrier, 0);\n+\t@Override\n+\tpublic void processBuffer(Buffer buffer, InputChannelInfo channelInfo) {\n+\t\tif (storeNewBuffers.get(channelInfo)) {\n+\t\t\tcheckpointCoordinator.getChannelStateWriter().addInputData(\n+\t\t\t\tcurrentCheckpointId,\n+\t\t\t\tchannelInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "originalCommit": "9836d4919062fa63212d16bc88a071cc31fc3977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY4MzQxNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476683415", "bodyText": "Let me sketch the most general data flow:\n\nWe have couple of buffers in our input channel.\nCheckpoint is triggered by another channel. *\nAll buffers that are now pulled by CheckpointedInputGate from the first channel get persisted by above function.\nThen the barrier comes in. *\nIt overtakes all buffers and is now at the head. *\nCheckpointedInputGate gets priority notification and polls the barrier.\nUpon dispatching, it calls Unaligner, which spills additionally all overtaken buffers.\nFurther buffers are not persisted.\n\nAll steps marked with * are performed in a different thread (other task thread / netty).\nFor me this is equivalent to the current behavior, but maybe I missed something.", "author": "AHeise", "createdAt": "2020-08-25T19:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NDkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\nindex bbd30e6277f..c378e83a970 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n\n@@ -91,10 +80,7 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {\n \n \t\tthis.taskName = taskName;\n \t\tthis.inputGates = inputGates;\n-\t\tstoreNewBuffers = Arrays.stream(inputGates)\n-\t\t\t.flatMap(gate -> gate.getChannelInfos().stream())\n-\t\t\t.collect(Collectors.toMap(Function.identity(), info -> false));\n-\t\tnumOpenChannels = storeNewBuffers.size();\n+\t\tnumOpenChannels = (int) Arrays.stream(inputGates).flatMap(gate -> gate.getChannelInfos().stream()).count();\n \t\tthis.checkpointCoordinator = checkpointCoordinator;\n \t}\n \n"}}, {"oid": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "url": "https://github.com/apache/flink/commit/273cc6bf445b4a44daca0e98d49aa0745a36a534", "message": "WIP", "committedDate": "2020-09-04T16:28:18Z", "type": "forcePushed"}, {"oid": "f1bfd2b98e8665739bd07ae828d2ca73e2e927fc", "url": "https://github.com/apache/flink/commit/f1bfd2b98e8665739bd07ae828d2ca73e2e927fc", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-09-04T20:19:03Z", "type": "forcePushed"}, {"oid": "234449f5731ecab6a2ed3ed2db2739d919c56398", "url": "https://github.com/apache/flink/commit/234449f5731ecab6a2ed3ed2db2739d919c56398", "message": "ChannelStateHolder", "committedDate": "2020-09-07T11:59:56Z", "type": "forcePushed"}, {"oid": "fce9f56a12b7c28a827c85669ce4bb0a8d31a48b", "url": "https://github.com/apache/flink/commit/fce9f56a12b7c28a827c85669ce4bb0a8d31a48b", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T12:14:42Z", "type": "forcePushed"}, {"oid": "d141f10ef060063162dc073b1cd66729f5f75a3b", "url": "https://github.com/apache/flink/commit/d141f10ef060063162dc073b1cd66729f5f75a3b", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T12:51:48Z", "type": "forcePushed"}, {"oid": "ef2c7ecea91a30e4d721efa759ca1b15728a24cb", "url": "https://github.com/apache/flink/commit/ef2c7ecea91a30e4d721efa759ca1b15728a24cb", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T13:28:33Z", "type": "forcePushed"}, {"oid": "755c3410f798bf7b3fffef91b7f2349b021613a9", "url": "https://github.com/apache/flink/commit/755c3410f798bf7b3fffef91b7f2349b021613a9", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T14:13:47Z", "type": "forcePushed"}, {"oid": "4af565f8d262b2ed2ebfb7614e0f24494eb22186", "url": "https://github.com/apache/flink/commit/4af565f8d262b2ed2ebfb7614e0f24494eb22186", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T19:48:00Z", "type": "forcePushed"}, {"oid": "b3a1520089c241fc74837902b6440d84a9636c14", "url": "https://github.com/apache/flink/commit/b3a1520089c241fc74837902b6440d84a9636c14", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-08T08:34:26Z", "type": "forcePushed"}, {"oid": "16c32eb1e2d49fa3c84cd4a82380fd72d5dcf5c0", "url": "https://github.com/apache/flink/commit/16c32eb1e2d49fa3c84cd4a82380fd72d5dcf5c0", "message": "[FLINK-19026][task] Pulling from input with priority events first.\n\nStreamTask pulls data if either input+output are available or a priority event happens. This commit ensures that StreamTask pulls from the correct input in the latter case to not block on output (and process priority events first).", "committedDate": "2020-09-08T16:53:26Z", "type": "forcePushed"}, {"oid": "11cb1939f8a98340acab9b795c6f1894808fb606", "url": "https://github.com/apache/flink/commit/11cb1939f8a98340acab9b795c6f1894808fb606", "message": "[FLINK-19026][task] Pulling from input with priority events first.\n\nStreamTask pulls data if either input+output are available or a priority event happens. This commit ensures that StreamTask pulls from the correct input in the latter case to not block on output (and process priority events first).", "committedDate": "2020-09-08T18:47:59Z", "type": "forcePushed"}, {"oid": "19c4f0d1d1710b829946a78cb58aff768baab684", "url": "https://github.com/apache/flink/commit/19c4f0d1d1710b829946a78cb58aff768baab684", "message": "[hotfix][source] Remove null-check from SourceCoordinatorContext#unregisterSourceReader.\n\nIf an error happens during startup, the reader may not be registered (yet), but cleanup is triggered anyways.", "committedDate": "2020-09-09T06:57:41Z", "type": "forcePushed"}, {"oid": "40c76a4ce74a5bbc800cf9833b96bb0156cacc41", "url": "https://github.com/apache/flink/commit/40c76a4ce74a5bbc800cf9833b96bb0156cacc41", "message": "[hotfix][source] Remove null-check from SourceCoordinatorContext#unregisterSourceReader.\n\nIf an error happens during startup, the reader may not be registered (yet), but cleanup is triggered anyways.", "committedDate": "2020-09-09T08:15:30Z", "type": "forcePushed"}, {"oid": "407169bc192b5d05bfba2c264849f1a6e7b81415", "url": "https://github.com/apache/flink/commit/407169bc192b5d05bfba2c264849f1a6e7b81415", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-09T14:38:18Z", "type": "forcePushed"}, {"oid": "89b0550c7b223f304b67a6f64dfc4252509eb76e", "url": "https://github.com/apache/flink/commit/89b0550c7b223f304b67a6f64dfc4252509eb76e", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-10T11:40:45Z", "type": "forcePushed"}, {"oid": "a6a2d36afcce1758e885f0751359ccf035ae2378", "url": "https://github.com/apache/flink/commit/a6a2d36afcce1758e885f0751359ccf035ae2378", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-10T12:17:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r486930588", "bodyText": "Is this a fix for an existing bug on the master branch? Or are you changing the behaviour/contract of this unregisterSourceReader call in some later commit?\nWould it be worthwhile/easy adding a test?", "author": "pnowojski", "createdAt": "2020-09-11T09:52:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java", "diffHunk": "@@ -261,8 +260,7 @@ void registerSourceReader(ReaderInfo readerInfo) {\n \t * @param subtaskId the subtask id of the source reader.\n \t */\n \tvoid unregisterSourceReader(int subtaskId) {\n-\t\tPreconditions.checkNotNull(registeredReaders.remove(subtaskId), String.format(\n-\t\t\t\t\"Failed to unregister source reader of id %s because it is not registered.\", subtaskId));\n+\t\tregisteredReaders.remove(subtaskId);", "originalCommit": "2286a09f24b69151445a0c75c52d83f9e6dd5120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDc3OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489230779", "bodyText": "It's a bug that I discovered in my UC ITCase and confirmed with Becket and Stephan. I added a small (trivial) test case.", "author": "AHeise", "createdAt": "2020-09-16T07:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4MTcyOQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492481729", "bodyText": "Added a ticket and referenced it properly https://issues.apache.org/jira/browse/FLINK-19338 .", "author": "AHeise", "createdAt": "2020-09-22T05:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java b/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java\nindex b97fbaceb97..c3b4666a0af 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java\n\n@@ -260,7 +261,8 @@ public class SourceCoordinatorContext<SplitT extends SourceSplit>\n \t * @param subtaskId the subtask id of the source reader.\n \t */\n \tvoid unregisterSourceReader(int subtaskId) {\n-\t\tregisteredReaders.remove(subtaskId);\n+\t\tPreconditions.checkNotNull(registeredReaders.remove(subtaskId), String.format(\n+\t\t\t\t\"Failed to unregister source reader of id %s because it is not registered.\", subtaskId));\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTg5Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487029893", "bodyText": "nit: maybe it's worth keeping this comment?", "author": "pnowojski", "createdAt": "2020-09-11T13:03:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMzY3MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489233671", "bodyText": "Moved the removal to the commit that spills immediately.", "author": "AHeise", "createdAt": "2020-09-16T07:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a413be221f2..8b1041ab0e9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -154,70 +158,74 @@ public class PipelinedSubpartition extends ResultSubpartition implements Checkpo\n \t\t\t}\n \n \t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n+\t\t\tnotifyPriority = addBuffer(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n+\t\t\tnotifyDataAvailable = finish || shouldNotifyDataAvailable();\n \n \t\t\tisFinished |= finish;\n \t\t}\n \n-\t\tif (notifyDataAvailable) {\n+\t\tif (notifyPriority) {\n+\t\t\tnotifyPriorityEvent();\n+\t\t} else if (notifyDataAvailable) {\n \t\t\tnotifyDataAvailable();\n \t\t}\n \n \t\treturn true;\n \t}\n \n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n+\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (!insertAsHead) {\n+\t\tif (!bufferConsumer.getDataType().hasPriority()) {\n \t\t\tbuffers.add(bufferConsumer);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n+\t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+\t\tCheckpointBarrier barrier;\n \t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n \t\t\tBuffer buffer = bc.build();\n \t\t\ttry {\n \t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t\tbarrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n \t\t\t} finally {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n-\t\treturn unalignedCheckpoint;\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n+\t\treturn barrier;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMDgyOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487030828", "bodyText": "nit: pos -> numberOfPriorityEvents? It would make the following line:\nIterators.advance(iterator, pos + 1);\n\nmore readable.", "author": "pnowojski", "createdAt": "2020-09-11T13:05:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a413be221f2..8b1041ab0e9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -154,70 +158,74 @@ public class PipelinedSubpartition extends ResultSubpartition implements Checkpo\n \t\t\t}\n \n \t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n+\t\t\tnotifyPriority = addBuffer(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n+\t\t\tnotifyDataAvailable = finish || shouldNotifyDataAvailable();\n \n \t\t\tisFinished |= finish;\n \t\t}\n \n-\t\tif (notifyDataAvailable) {\n+\t\tif (notifyPriority) {\n+\t\t\tnotifyPriorityEvent();\n+\t\t} else if (notifyDataAvailable) {\n \t\t\tnotifyDataAvailable();\n \t\t}\n \n \t\treturn true;\n \t}\n \n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n+\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (!insertAsHead) {\n+\t\tif (!bufferConsumer.getDataType().hasPriority()) {\n \t\t\tbuffers.add(bufferConsumer);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n+\t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+\t\tCheckpointBarrier barrier;\n \t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n \t\t\tBuffer buffer = bc.build();\n \t\t\ttry {\n \t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t\tbarrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n \t\t\t} finally {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n-\t\treturn unalignedCheckpoint;\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n+\t\treturn barrier;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMyNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487038327", "bodyText": "this method is only isCheckpointBarrier and it seems to not care if it's aligned or not, right?\nBesides, do we really need to deserialise the event? Previously we were snapshotting in-flight data every time we were inserting buffer as a head. I think it was just as not elegant, but simpler.\nI guess this is currently a dead code, but would change if we ever want to have priority cancelation markers? If that's a sole motivation, I would revisit this problem in the future. Who knows if we will need this with checkpoint abort RPC. And if we will do, there is also another option:\nInserting priority UC barrier, could go through a separate method , that would return overtaken in-flight data:\nCollection<Buffer> insertAsHeadAndGetInFlightData(checkpointBarrier)\n\nwhich would also eliminate the currently existing assumption/hack that requestInflightBufferSnapshot has to be always called immediately after inserting as a head.", "author": "pnowojski", "createdAt": "2020-09-11T13:17:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\tif (unalignedCheckpoint) {\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n \t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\tbuffers.addFirst(bufferConsumer);\n-\t\t} else {\n-\t\t\tbuffers.add(bufferConsumer);\n+\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n+\t\tboolean unalignedCheckpoint;\n+\t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n+\t\t\tBuffer buffer = bc.build();\n+\t\t\ttry {\n+\t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n+\t\t\t} finally {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n \t\t}\n+\t\treturn unalignedCheckpoint;", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNTUyMQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489235521", "bodyText": "Moved this method to the commit that spills immediately. We need it in that method to retrieve the checkpoint id to spill correctly.\nDeserialization is only necessary for priority events, which are very rare and rather cheap (30 bytes). I'd argue that adding a new call chain just to optimize it is not warranted.", "author": "AHeise", "createdAt": "2020-09-16T07:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMyNw=="}], "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a413be221f2..8b1041ab0e9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -154,70 +158,74 @@ public class PipelinedSubpartition extends ResultSubpartition implements Checkpo\n \t\t\t}\n \n \t\t\t// Add the bufferConsumer and update the stats\n-\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n+\t\t\tnotifyPriority = addBuffer(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n+\t\t\tnotifyDataAvailable = finish || shouldNotifyDataAvailable();\n \n \t\t\tisFinished |= finish;\n \t\t}\n \n-\t\tif (notifyDataAvailable) {\n+\t\tif (notifyPriority) {\n+\t\t\tnotifyPriorityEvent();\n+\t\t} else if (notifyDataAvailable) {\n \t\t\tnotifyDataAvailable();\n \t\t}\n \n \t\treturn true;\n \t}\n \n-\tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n+\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (!insertAsHead) {\n+\t\tif (!bufferConsumer.getDataType().hasPriority()) {\n \t\t\tbuffers.add(bufferConsumer);\n-\t\t\treturn;\n+\t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n+\t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {\n+\t\tCheckpointBarrier barrier;\n \t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n \t\t\tBuffer buffer = bc.build();\n \t\t\ttry {\n \t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n-\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t\tbarrier = event instanceof CheckpointBarrier ? (CheckpointBarrier) event : null;\n \t\t\t} catch (IOException e) {\n \t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n \t\t\t} finally {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n-\t\treturn unalignedCheckpoint;\n-\t}\n-\n-\t@Override\n-\tpublic List<Buffer> requestInflightBufferSnapshot() {\n-\t\tList<Buffer> snapshot = new ArrayList<>(inflightBufferSnapshot);\n-\t\tinflightBufferSnapshot.clear();\n-\t\treturn snapshot;\n+\t\treturn barrier;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI1OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487040259", "bodyText": "is this method being used? I think at least not in this commit", "author": "pnowojski", "createdAt": "2020-09-11T13:21:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition;\n+\n+import org.apache.flink.annotation.Internal;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+/**\n+ * A deque-like data structure that supports prioritization of elements, such they will be polled before any\n+ * non-priority elements.\n+ *\n+ * <p>{@implNote The current implementation deliberately does not implement the respective interface to minimize the maintenance\n+ * effort. Furthermore, it's optimized for handling non-priority elements, such that all operations for adding priority\n+ * elements are much slower than the non-priority counter-parts.}\n+ *\n+ * <p>Note that all element tests are performed by identity.\n+ *\n+ * @param <T> the element type.\n+ */\n+@Internal\n+public final class PrioritizedDeque<T> implements Iterable<T> {\n+\tprivate final Deque<T> deque = new ArrayDeque<>();\n+\tprivate int numPriorityElements;\n+\n+\t/**\n+\t * Adds a priority element to this deque, such that it will be polled after all existing priority elements but\n+\t * before any non-priority element.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void addPriorityElement(T element) {\n+\t\t// priority elements are rather rare and short-lived, so most of there are none\n+\t\tif (numPriorityElements == 0) {\n+\t\t\tdeque.addFirst(element);\n+\t\t} else if (numPriorityElements == deque.size()) {\n+\t\t\t// no non-priority elements\n+\t\t\tdeque.add(element);\n+\t\t} else {\n+\t\t\t// remove all priority elements\n+\t\t\tfinal ArrayDeque<T> priorPriority = new ArrayDeque<>(numPriorityElements);\n+\t\t\tfor (int index = 0; index < numPriorityElements; index++) {\n+\t\t\t\tpriorPriority.addFirst(deque.poll());\n+\t\t\t}\n+\t\t\tdeque.addFirst(element);\n+\t\t\t// readd them before the newly added element\n+\t\t\tfor (final T priorityEvent : priorPriority) {\n+\t\t\t\tdeque.addFirst(priorityEvent);\n+\t\t\t}\n+\t\t}\n+\t\tnumPriorityElements++;\n+\t}\n+\n+\t/**\n+\t * Adds a non-priority element to this deque, which will be polled last.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void add(T element) {\n+\t\tdeque.add(element);\n+\t}\n+\n+\t/**\n+\t * Convenience method for adding an element with optional priority and prior removal.\n+\t *\n+\t * @param element the element to add\n+\t * @param priority flag indicating if it's a priority or non-priority element\n+\t * @param alreadyContained flag that hints that the element is already in this deque, potentially as non-priority element.\n+\t */\n+\tpublic void add(T element, boolean priority, boolean alreadyContained) {", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjYzNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489236637", "bodyText": "I'm moving it to the commit that starts using it.", "author": "AHeise", "createdAt": "2020-09-16T07:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java\nindex 535f86eed4b..29d051cf295 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java\n\n@@ -87,13 +87,13 @@ public final class PrioritizedDeque<T> implements Iterable<T> {\n \t *\n \t * @param element the element to add\n \t * @param priority flag indicating if it's a priority or non-priority element\n-\t * @param alreadyContained flag that hints that the element is already in this deque, potentially as non-priority element.\n+\t * @param prioritize flag that hints that the element is already in this deque, potentially as non-priority element.\n \t */\n-\tpublic void add(T element, boolean priority, boolean alreadyContained) {\n+\tpublic void add(T element, boolean priority, boolean prioritize) {\n \t\tif (!priority) {\n \t\t\tadd(element);\n \t\t} else {\n-\t\t\tif (alreadyContained) {\n+\t\t\tif (prioritize) {\n \t\t\t\tprioritize(element);\n \t\t\t} else {\n \t\t\t\taddPriorityElement(element);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjE0OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487046148", "bodyText": "nit: you've broken a comment reference (L125):\n#isAvailable(BufferAndBacklog)\n\nreplace it with javadoc's {@link}?", "author": "pnowojski", "createdAt": "2020-09-11T13:30:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTE2Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489245166", "bodyText": "I added an implNote in the javadoc.", "author": "AHeise", "createdAt": "2020-09-16T08:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 8f92f286431..bfdf1b48cef 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -119,10 +119,12 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t/**\n \t * Returns true only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n+\t *\n+\t * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such that\n+\t * {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n \t */\n \t@Override\n \tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n \t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjgwNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487046805", "bodyText": "or {@link DataType.NONE}", "author": "pnowojski", "createdAt": "2020-09-11T13:31:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 8f92f286431..bfdf1b48cef 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -119,10 +119,12 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t/**\n \t * Returns true only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n+\t *\n+\t * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such that\n+\t * {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n \t */\n \t@Override\n \tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n \t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0ODIyMA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487048220", "bodyText": "It's hard to say now, what does it mean it should be kept in sync, as they return very different things. On the other hand, this comment is valuable, so would be nice to keep it?", "author": "pnowojski", "createdAt": "2020-09-11T13:34:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjczNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489246737", "bodyText": "I expanded the comment (now javadoc) to clearly state the contract.", "author": "AHeise", "createdAt": "2020-09-16T08:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0ODIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 8f92f286431..bfdf1b48cef 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -119,10 +119,12 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t/**\n \t * Returns true only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n+\t *\n+\t * @implSpec BEWARE: this must be in sync with {@link #getNextDataType(BufferAndBacklog)}, such that\n+\t * {@code getNextDataType(bufferAndBacklog) != NONE <=> isAvailable()}!\n \t */\n \t@Override\n \tpublic boolean isAvailable() {\n-\t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n \t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MzcxMg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487053712", "bodyText": "nit: whitespace?", "author": "pnowojski", "createdAt": "2020-09-11T13:43:11Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java", "diffHunk": "@@ -109,14 +113,14 @@ private void setupInputChannels() {\n \t\t\t\t\tbufferBuilder.finish();\n \n \t\t\t\t\t// Call getCurrentBuffer to ensure size is set\n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(bufferConsumer.build(), moreAvailable, 0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(bufferConsumer.build(), nextType, 0));\n \t\t\t\t} else if (input != null && input.isEvent()) {\n \t\t\t\t\tAbstractEvent event = input.getEvent();\n \t\t\t\t\tif (event instanceof EndOfPartitionEvent) {\n \t\t\t\t\t\tinputChannels[channelIndex].setReleased();\n \t\t\t\t\t}\n \n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), moreAvailable, 0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), nextType,\t0));", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java b/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java\nindex 3007faa475a..12ce69d7646 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java\n\n@@ -120,7 +120,7 @@ public class StreamTestSingleInputGate<T> extends TestSingleInputGate {\n \t\t\t\t\t\tinputChannels[channelIndex].setReleased();\n \t\t\t\t\t}\n \n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), nextType,\t0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), nextType, 0));\n \t\t\t\t} else {\n \t\t\t\t\treturn Optional.empty();\n \t\t\t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NjEyNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487056125", "bodyText": "good to know that it returns something :)", "author": "pnowojski", "createdAt": "2020-09-11T13:46:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -290,6 +294,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \t/**\n \t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n \t * returns null in all other cases.\n+\t * @return", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex 91f73d23682..deda3b4dd38 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n\n@@ -297,8 +316,8 @@ public abstract class InputChannel {\n \t * @return\n \t */\n \t@Nullable\n-\tprotected CheckpointBarrier parseCheckpointBarrierOrNull(Buffer buffer) throws IOException {\n-\t\tif (buffer.isBuffer()) {\n+\tprotected AbstractEvent parsePriorityEvent(Buffer buffer) throws IOException {\n+\t\tif (buffer.isBuffer() || !buffer.getDataType().hasPriority()) {\n \t\t\treturn null;\n \t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2NTQ3MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487065471", "bodyText": "add java doc what does it return?", "author": "pnowojski", "createdAt": "2020-09-11T14:01:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;\n \t\tCompletableFuture<?> toNotify = null;\n \n \t\tsynchronized (inputChannelsWithData) {\n-\t\t\tif (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) {\n+\t\t\t// do not enqueue if the channel is currently polled because priority event could have been polled already\n+\t\t\t// let #waitAndGetNextData re-enqueue the channel correctly instead\n+\t\t\tif (priority && selectedChannel == channel) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tavailableChannels = inputChannelsWithData.size();\n \n-\t\t\tinputChannelsWithData.add(channel);\n-\t\t\tenqueuedInputChannelsWithData.set(channel.getChannelIndex());\n+\t\t\tif (!queueChannelUnsafe(channel, priority)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\t\t\tif (availableChannels == 0) {\n+\t\t\tif (priority && inputChannelsWithData.getNumPriorityElements() == 1) {\n+\t\t\t\ttoNotifyPriority = priorityAvailabilityHelper.getUnavailableToResetAvailable();\n+\t\t\t}\n+\t\t\tif (inputChannelsWithData.size() == 1) {\n \t\t\t\tinputChannelsWithData.notifyAll();\n \t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n \t\t\t}\n \t\t}\n \n+\t\tif (toNotifyPriority != null) {\n+\t\t\ttoNotifyPriority.complete(null);\n+\t\t}\n \t\tif (toNotify != null) {\n \t\t\ttoNotify.complete(null);\n \t\t}\n \t}\n \n+\tprivate boolean queueChannelUnsafe(InputChannel channel, boolean priority) {", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 97515d0eebf..1885a18d9ac 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -868,27 +853,27 @@ public class SingleInputGate extends IndexedInputGate {\n \t}\n \n \tprivate Optional<InputChannel> getChannel(boolean blocking) throws InterruptedException {\n-\t\tsynchronized (inputChannelsWithData) {\n-\t\t\twhile (inputChannelsWithData.isEmpty()) {\n-\t\t\t\tif (closeFuture.isDone()) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Released\");\n-\t\t\t\t}\n+\t\tassert Thread.holdsLock(inputChannelsWithData);\n \n-\t\t\t\tif (blocking) {\n-\t\t\t\t\tinputChannelsWithData.wait();\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tavailabilityHelper.resetUnavailable();\n-\t\t\t\t\treturn Optional.empty();\n-\t\t\t\t}\n+\t\twhile (inputChannelsWithData.isEmpty()) {\n+\t\t\tif (closeFuture.isDone()) {\n+\t\t\t\tthrow new IllegalStateException(\"Released\");\n \t\t\t}\n \n-\t\t\tInputChannel inputChannel = inputChannelsWithData.poll();\n-\t\t\tenqueuedInputChannelsWithData.clear(inputChannel.getChannelIndex());\n-\t\t\tselectedChannel = inputChannel;\n-\n-\t\t\treturn Optional.of(inputChannel);\n+\t\t\tif (blocking) {\n+\t\t\t\tinputChannelsWithData.wait();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n \t\t}\n+\n+\t\tInputChannel inputChannel = inputChannelsWithData.poll();\n+\t\tenqueuedInputChannelsWithData.clear(inputChannel.getChannelIndex());\n+\t\tselectedChannel = inputChannel;\n+\n+\t\treturn Optional.of(inputChannel);\n \t}\n \n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2ODQzNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487068437", "bodyText": "nit: extract everything below to:\nreturn Optional.of(processBufferOrEvent(nextOpt.get()));\n\n?", "author": "pnowojski", "createdAt": "2020-09-11T14:06:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -186,34 +203,47 @@ public boolean isFinished() {\n \tprivate Optional<InputWithData<IndexedInputGate, BufferOrEvent>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<IndexedInputGate> inputGate = getInputGate(blocking);\n-\t\t\tif (!inputGate.isPresent()) {\n+\t\t\tOptional<IndexedInputGate> inputGateOpt = getInputGate(blocking);\n+\t\t\tif (!inputGateOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n+\t\t\tfinal IndexedInputGate inputGate = inputGateOpt.get();\n \n \t\t\t// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.\n \t\t\t// Do not poll the gate under inputGatesWithData lock, since this can trigger notifications\n \t\t\t// that could deadlock because of wrong locks taking order.\n-\t\t\tOptional<BufferOrEvent> bufferOrEvent = inputGate.get().pollNext();\n+\t\t\tOptional<BufferOrEvent> nextOpt = inputGate.pollNext();\n+\t\t\tif (!nextOpt.isPresent()) {\n+\t\t\t\tinputGate.getAvailableFuture().thenRun(() -> queueInputGate(inputGate, false));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfinal BufferOrEvent bufferOrEvent = nextOpt.get();", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\nindex aa35388bc44..9d4b80e6985 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n\n@@ -203,23 +202,20 @@ public class UnionInputGate extends InputGate {\n \tprivate Optional<InputWithData<IndexedInputGate, BufferOrEvent>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<IndexedInputGate> inputGateOpt = getInputGate(blocking);\n-\t\t\tif (!inputGateOpt.isPresent()) {\n-\t\t\t\treturn Optional.empty();\n-\t\t\t}\n-\t\t\tfinal IndexedInputGate inputGate = inputGateOpt.get();\n-\n-\t\t\t// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.\n-\t\t\t// Do not poll the gate under inputGatesWithData lock, since this can trigger notifications\n-\t\t\t// that could deadlock because of wrong locks taking order.\n-\t\t\tOptional<BufferOrEvent> nextOpt = inputGate.pollNext();\n-\t\t\tif (!nextOpt.isPresent()) {\n-\t\t\t\tinputGate.getAvailableFuture().thenRun(() -> queueInputGate(inputGate, false));\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tfinal BufferOrEvent bufferOrEvent = nextOpt.get();\n-\n \t\t\tsynchronized (inputGatesWithData) {\n+\t\t\t\tOptional<IndexedInputGate> inputGateOpt = getInputGate(blocking);\n+\t\t\t\tif (!inputGateOpt.isPresent()) {\n+\t\t\t\t\treturn Optional.empty();\n+\t\t\t\t}\n+\t\t\t\tfinal IndexedInputGate inputGate = inputGateOpt.get();\n+\n+\t\t\t\tOptional<BufferOrEvent> nextOpt = inputGate.pollNext();\n+\t\t\t\tif (!nextOpt.isPresent()) {\n+\t\t\t\t\tinputGate.getAvailableFuture().thenRun(() -> queueInputGate(inputGate, false));\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tfinal BufferOrEvent bufferOrEvent = nextOpt.get();\n+\n \t\t\t\tif (bufferOrEvent.moreAvailable()) {\n \t\t\t\t\t// enqueue the inputGate at the end to avoid starvation\n \t\t\t\t\tif (bufferOrEvent.morePriorityEvents()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MTI2Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487071263", "bodyText": "optional nit:\nextract toNotify and toNotifyPriority pair to some simple inner class `\npublic static class DataNotification() {\n  @Nullable\n  CompletableFuture<?> toNotifyPriority = null;\n  @Nullable\n  CompletableFuture<?> toNotify = null;\n\n  // two setters\n  setXYZ(...);\n\n  void complete() {\n \t\tif (toNotifyPriority != null) {\n\t\t\ttoNotifyPriority.complete(null);\n\t\t}\n\t\tif (toNotify != null) {\n\t\t\ttoNotify.complete(null);\n\t\t}\n  }\n}\n\nand re-use in UnionInputGate as well?", "author": "pnowojski", "createdAt": "2020-09-11T14:10:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2OTk2MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492569960", "bodyText": "Extracted into GateNotificationHelper, please check if it's actually helping to reduce complexity.", "author": "AHeise", "createdAt": "2020-09-22T08:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MTI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 97515d0eebf..1885a18d9ac 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -868,27 +853,27 @@ public class SingleInputGate extends IndexedInputGate {\n \t}\n \n \tprivate Optional<InputChannel> getChannel(boolean blocking) throws InterruptedException {\n-\t\tsynchronized (inputChannelsWithData) {\n-\t\t\twhile (inputChannelsWithData.isEmpty()) {\n-\t\t\t\tif (closeFuture.isDone()) {\n-\t\t\t\t\tthrow new IllegalStateException(\"Released\");\n-\t\t\t\t}\n+\t\tassert Thread.holdsLock(inputChannelsWithData);\n \n-\t\t\t\tif (blocking) {\n-\t\t\t\t\tinputChannelsWithData.wait();\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tavailabilityHelper.resetUnavailable();\n-\t\t\t\t\treturn Optional.empty();\n-\t\t\t\t}\n+\t\twhile (inputChannelsWithData.isEmpty()) {\n+\t\t\tif (closeFuture.isDone()) {\n+\t\t\t\tthrow new IllegalStateException(\"Released\");\n \t\t\t}\n \n-\t\t\tInputChannel inputChannel = inputChannelsWithData.poll();\n-\t\t\tenqueuedInputChannelsWithData.clear(inputChannel.getChannelIndex());\n-\t\t\tselectedChannel = inputChannel;\n-\n-\t\t\treturn Optional.of(inputChannel);\n+\t\t\tif (blocking) {\n+\t\t\t\tinputChannelsWithData.wait();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n \t\t}\n+\n+\t\tInputChannel inputChannel = inputChannelsWithData.poll();\n+\t\tenqueuedInputChannelsWithData.clear(inputChannel.getChannelIndex());\n+\t\tselectedChannel = inputChannel;\n+\n+\t\treturn Optional.of(inputChannel);\n \t}\n \n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODk5NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487148994", "bodyText": "I haven't fully understood this part yet. Maybe let's sync later off-line?", "author": "pnowojski", "createdAt": "2020-09-11T16:15:10Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -89,6 +92,14 @@\n \t */\n \tprivate final int[] inputGateChannelIndexOffsets;\n \n+\t/**\n+\t * The channel from which is currently polled, which allows interleaving of\n+\t * {@link #queueInputGate(IndexedInputGate, boolean)} and {@link #pollNext()} (FLINK-12510 (Deadlock when reading from InputGates)).\n+\t */\n+\t@GuardedBy(\"inputGatesWithData\")\n+\t@Nullable\n+\tprivate IndexedInputGate currentInputGate;\n+", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NjAwNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489746007", "bodyText": "Removed thanks to alternative fix of FLINK-12510 (see previous commit now).", "author": "AHeise", "createdAt": "2020-09-16T20:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODk5NA=="}], "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\nindex aa35388bc44..80787a5e9f5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n\n@@ -92,14 +88,6 @@ public class UnionInputGate extends InputGate {\n \t */\n \tprivate final int[] inputGateChannelIndexOffsets;\n \n-\t/**\n-\t * The channel from which is currently polled, which allows interleaving of\n-\t * {@link #queueInputGate(IndexedInputGate, boolean)} and {@link #pollNext()} (FLINK-12510 (Deadlock when reading from InputGates)).\n-\t */\n-\t@GuardedBy(\"inputGatesWithData\")\n-\t@Nullable\n-\tprivate IndexedInputGate currentInputGate;\n-\n \tpublic UnionInputGate(IndexedInputGate... inputGates) {\n \t\tinputGatesByGateIndex = Arrays.stream(inputGates).collect(Collectors.toMap(IndexedInputGate::getGateIndex, ig -> ig));\n \t\tcheckArgument(inputGates.length > 1, \"Union input gate should union at least two input gates.\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487150383", "bodyText": "could you elaborate a bit more in the commit message, what has been simplified, why and what are the benefits?", "author": "pnowojski", "createdAt": "2020-09-11T16:17:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java", "diffHunk": "@@ -34,11 +30,8 @@\n \tvoid notifyDataAvailable();\n \n \t/**\n-\t * Allows the listener to react to a priority event before it is added to the outgoing buffer queue.\n-\t *\n-\t * @return true if the event has been fully processed and should not be added to the buffer queue.\n+\t * Called when the first priority event is added to the head of the buffer queue.\n \t */\n-\tdefault boolean notifyPriorityEvent(BufferConsumer eventBufferConsumer) throws IOException {\n-\t\treturn false;\n+\tdefault void notifyPriorityEvent() {", "originalCommit": "5f1a1448b0654865a3dfd404b7027ad764790d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDMzNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492570334", "bodyText": "Added a few thoughts. Let me know if it makes things clearer.", "author": "AHeise", "createdAt": "2020-09-22T08:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java\nindex 2aaad53724b..cc99f226677 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java\n\n@@ -31,7 +31,9 @@ public interface BufferAvailabilityListener {\n \n \t/**\n \t * Called when the first priority event is added to the head of the buffer queue.\n+\t *\n+\t * @param priorityBufferNumber the sequence number that identifies the priority buffer.\n \t */\n-\tdefault void notifyPriorityEvent() {\n+\tdefault void notifyPriorityEvent(long priorityBufferNumber) {\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NTc0NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487965745", "bodyText": "This is an intermediate code that is being replaced later. Can you squash those changes?", "author": "pnowojski", "createdAt": "2020-09-14T14:17:32Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -147,6 +148,14 @@ else if (configuredInput instanceof SourceInputConfig) {\n \t\treturn anyInputAvailable;\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn CompletableFuture.anyOf(\n+\t\t\tArrays.stream(inputProcessors)\n+\t\t\t\t.map(inputProcessor -> inputProcessor.taskInput.getPriorityEventAvailableFuture())\n+\t\t\t\t.toArray(CompletableFuture[]::new));", "originalCommit": "0b9fe248c39645e93e5210430417cef3bdc2ed6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MTk1Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492571952", "bodyText": "Commit is removed.", "author": "AHeise", "createdAt": "2020-09-22T08:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NTc0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\nindex 414f906b15a..1520e05ea4d 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\n\n@@ -150,10 +165,7 @@ public final class StreamMultipleInputProcessor implements StreamInputProcessor\n \n \t@Override\n \tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n-\t\treturn CompletableFuture.anyOf(\n-\t\t\tArrays.stream(inputProcessors)\n-\t\t\t\t.map(inputProcessor -> inputProcessor.taskInput.getPriorityEventAvailableFuture())\n-\t\t\t\t.toArray(CompletableFuture[]::new));\n+\t\treturn priorityAvailability.getAvailableFuture();\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2OTcwOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487969708", "bodyText": "As we discussed online there is a bit of duplicated code here.", "author": "pnowojski", "createdAt": "2020-09-14T14:21:06Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -371,12 +371,16 @@ protected void processInput(MailboxDefaultAction.Controller controller) throws E\n \t */\n \t@VisibleForTesting\n \tCompletableFuture<?> getInputOutputJointFuture(InputStatus status) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputProcessor.getPriorityEventAvailableFuture();\n \t\tif (status == InputStatus.NOTHING_AVAILABLE && !recordWriter.isAvailable()) {\n-\t\t\treturn CompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture());\n+\t\t\treturn CompletableFuture.anyOf(\n+\t\t\t\tpriorityEventAvailableFuture,\n+\t\t\t\tCompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture()));\n \t\t} else if (status == InputStatus.NOTHING_AVAILABLE) {\n-\t\t\treturn inputProcessor.getAvailableFuture();\n+\t\t\treturn CompletableFuture.anyOf(inputProcessor.getAvailableFuture(),\n+\t\t\t\tpriorityEventAvailableFuture);\n \t\t} else {\n-\t\t\treturn recordWriter.getAvailableFuture();\n+\t\t\treturn CompletableFuture.anyOf(priorityEventAvailableFuture, recordWriter.getAvailableFuture());", "originalCommit": "0b9fe248c39645e93e5210430417cef3bdc2ed6e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\nindex 82d427a797d..12c864d1dc1 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n\n@@ -371,16 +387,12 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>\n \t */\n \t@VisibleForTesting\n \tCompletableFuture<?> getInputOutputJointFuture(InputStatus status) {\n-\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputProcessor.getPriorityEventAvailableFuture();\n \t\tif (status == InputStatus.NOTHING_AVAILABLE && !recordWriter.isAvailable()) {\n-\t\t\treturn CompletableFuture.anyOf(\n-\t\t\t\tpriorityEventAvailableFuture,\n-\t\t\t\tCompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture()));\n+\t\t\treturn CompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture());\n \t\t} else if (status == InputStatus.NOTHING_AVAILABLE) {\n-\t\t\treturn CompletableFuture.anyOf(inputProcessor.getAvailableFuture(),\n-\t\t\t\tpriorityEventAvailableFuture);\n+\t\t\treturn inputProcessor.getAvailableFuture();\n \t\t} else {\n-\t\t\treturn CompletableFuture.anyOf(priorityEventAvailableFuture, recordWriter.getAvailableFuture());\n+\t\t\treturn recordWriter.getAvailableFuture();\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjE2Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487986163", "bodyText": "Again I would point to the previous comment:\n#13228 (comment)\nCollection<Buffer> insertAsHeadAndGetInFlightData(checkpointBarrier)\n\nmight be a better option. (It might not, as I haven't tried to implement it)", "author": "pnowojski", "createdAt": "2020-09-14T14:41:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTQ3OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492591478", "bodyText": "Not relevant in the final version where the channel spills by itself (no return value on this method). I can make it clearer in the commit message if you want.", "author": "AHeise", "createdAt": "2020-09-22T09:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 8b1041ab0e9..c9f9873dd1b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -182,7 +182,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n \t\t\treturn false;\n \t\t}\n \n-\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tfinal int numPriorityElements = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n \t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjQ4MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487986481", "bodyText": "This is again modifying code that I have already reviewed in the previous commit :(", "author": "pnowojski", "createdAt": "2020-09-14T14:41:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n \t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NDIxNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492484214", "bodyText": "Hm I have a hard time coming up with a better code structure. I could add checkpoint parsing and the if in addBuffer already in the first commit [FLINK-19026][network] Adding PrioritizedDeque and use it in PipelinedSubpartition.. Then this diff would be only about persisting itself.\nBut I was convinced that you would be confused why we need to parse the barrier at that commit.", "author": "AHeise", "createdAt": "2020-09-22T05:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjQ4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "834c28da93d4b24e562e017979b483e288db02a2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 8b1041ab0e9..c9f9873dd1b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -182,7 +182,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n \t\t\treturn false;\n \t\t}\n \n-\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tfinal int numPriorityElements = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n \t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5OTk0Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487999943", "bodyText": "Are you sure it's going in the right direction this change? Previously spilling was explicit on demand, now it's happening magically (implicitly) inside LocalInputChannel.", "author": "pnowojski", "createdAt": "2020-09-14T14:59:01Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -232,19 +232,16 @@ public int getInputIndex() {\n \t\t\tChannelStateWriter channelStateWriter,\n \t\t\tlong checkpointId) throws IOException {\n \t\tfor (int channelIndex = 0; channelIndex < recordDeserializers.length; channelIndex++) {\n-\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n-\n-\t\t\t// Assumption for retrieving buffers = one concurrent checkpoint\n \t\t\tRecordDeserializer<?> deserializer = recordDeserializers[channelIndex];\n \t\t\tif (deserializer != null) {\n+\t\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n+\n \t\t\t\tchannelStateWriter.addInputData(\n \t\t\t\t\tcheckpointId,\n \t\t\t\t\tchannel.getChannelInfo(),\n \t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n \t\t\t\t\tdeserializer.getUnconsumedBuffer());\n \t\t\t}\n-\n-\t\t\tcheckpointedInputGate.spillInflightBuffers(checkpointId, channelIndex, channelStateWriter);", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NzA3OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492487079", "bodyText": "We discussed offline, but let me summarize the main point. When spilling in main thread, buffers would be spilled rather late as you pointed out initially.\nOne solution is to trigger the channel spilling in task thread as soon as possible and then resume spilling from netty until barrier arrives. However, that results in a complex threading model with lots of race condition as we found out in the version in master.\nAnother solution is to spill in task thread and use any poll to discover new buffers and spill them. It's slightly slower and also requires lots of internal knowledge at the Unaligner about the channels to work well (mark all spilled channels). It's probably also suboptimal as new buffers are usually enqueued right after the head is polled, so one buffer is enqueued in the channel but not persisted until the new head is polled.\nThe proposed solution is to spill in netty thread entirely. That's the fastest possible solution with an comparably easy threading model. Downside is the added complexity on channel-side, but the general idea is that upstream and downstream side of a channel is now self-contained.", "author": "AHeise", "createdAt": "2020-09-22T05:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5OTk0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a22657562a42dda270f89c176e5c260ee73c6698", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java\nindex 2b7fb24f933..3d90b707ccc 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java\n\n@@ -222,11 +222,6 @@ public final class StreamTaskNetworkInput<T> implements StreamTaskInput<T> {\n \t\treturn checkpointedInputGate.getAvailableFuture();\n \t}\n \n-\t@Override\n-\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n-\t\treturn checkpointedInputGate.getPriorityEventAvailableFuture();\n-\t}\n-\n \t@Override\n \tpublic CompletableFuture<Void> prepareSnapshot(\n \t\t\tChannelStateWriter channelStateWriter,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMDI2MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488010260", "bodyText": "Are you spilling only on polling the buffer? (I think RemoteInputChannel is working better in this regard)", "author": "pnowojski", "createdAt": "2020-09-14T15:11:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -210,15 +221,25 @@ public void spillInflightBuffers(long checkpointId, ChannelStateWriter channelSt\n \t\t}\n \n \t\tBuffer buffer = next.buffer();\n-\t\tCheckpointBarrier notifyReceivedBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\tif (notifyReceivedBarrier != null) {\n-\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t} else if (receivedCheckpointId < lastRequestedCheckpointId && buffer.isBuffer()) {\n-\t\t\tinputGate.getBufferReceivedListener().notifyBufferReceived(buffer.retainBuffer(), channelInfo);\n-\t\t}\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n+\t\tif (buffer.isBuffer()) {\n+\t\t\tfor (final long barrierId : pendingCheckpointBarriers) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MzgwOQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492593809", "bodyText": "LocalInputChannel only spills when it awaits barrier. So it spills the buffer on first sight and it cannot be better on downsteam level. We could of course also move spilling lingering buffers to the upstream. It might also be an improvement for later, but it adds quite a bit of complexity as barriers also need to be propagated upstream.", "author": "AHeise", "createdAt": "2020-09-22T09:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMDI2MA=="}], "type": "inlineReview", "revised_code": {"commit": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex ec7abaef67a..79ab67daee6 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n\n@@ -224,21 +219,10 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n-\t\tif (buffer.isBuffer()) {\n-\t\t\tfor (final long barrierId : pendingCheckpointBarriers) {\n-\t\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\t\tbarrierId,\n-\t\t\t\t\tgetChannelInfo(),\n-\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n-\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n-\t\t\t}\n-\t\t} else if (buffer.getDataType().hasPriority()) {\n-\t\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n-\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n-\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n-\t\t\t\tseenCheckpointBarriers.add(barrierId);\n-\t\t\t\tpendingCheckpointBarriers.remove(barrierId);\n-\t\t\t}\n+\t\tif (buffer.getDataType().hasPriority()) {\n+\t\t\tchannelStatePersister.checkForBarrier(buffer);\n+\t\t} else {\n+\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t}\n \t\treturn Optional.of(new BufferAndAvailability(buffer, next.getNextDataType(), next.buffersInBacklog()));\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODQ3NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488018474", "bodyText": "I don't think it's worth complicating the code with support for multiple concurrent checkpoints. It's not likely to be implemented soon, if ever.", "author": "pnowojski", "createdAt": "2020-09-14T15:22:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -89,17 +96,15 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n+\tprivate final BufferManager bufferManager;\n \n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n+\t/** Stores #overtaken buffers when a checkpoint barrier is received before task thread started checkpoint. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Map<Long, Integer> numBuffersOvertaken = new HashMap<>();\n \n-\tprivate final BufferManager bufferManager;\n+\t/** All started checkpoints where a barrier has not been received yet. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Deque<Long> pendingCheckpointBarriers = new ArrayDeque<>(2);", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTMxMw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492595313", "bodyText": "Changed it to support only one concurrent checkpoint. I also extracted the whole logic into one helper class that can be used by both LocalInputChannel and RemoteInputChannel (with syncrhonization).", "author": "AHeise", "createdAt": "2020-09-22T09:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODQ3NA=="}], "type": "inlineReview", "revised_code": {"commit": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex e1ff9f8a702..216ab6ac8dc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -100,11 +98,10 @@ public class RemoteInputChannel extends InputChannel {\n \n \t/** Stores #overtaken buffers when a checkpoint barrier is received before task thread started checkpoint. */\n \t@GuardedBy(\"receivedBuffers\")\n-\tprivate Map<Long, Integer> numBuffersOvertaken = new HashMap<>();\n+\tprivate int numBuffersOvertaken;\n \n-\t/** All started checkpoints where a barrier has not been received yet. */\n \t@GuardedBy(\"receivedBuffers\")\n-\tprivate Deque<Long> pendingCheckpointBarriers = new ArrayDeque<>(2);\n+\tprivate ChannelStatePersister channelStatePersister = new ChannelStatePersister(null);\n \n \tpublic RemoteInputChannel(\n \t\tSingleInputGate inputGate,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyMDgyOQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488020829", "bodyText": "This method has grown too large.", "author": "pnowojski", "createdAt": "2020-09-14T15:25:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTQ3Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492595477", "bodyText": "Much smaller now thanks to the helper class.", "author": "AHeise", "createdAt": "2020-09-22T09:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyMDgyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex e1ff9f8a702..216ab6ac8dc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -432,31 +433,17 @@ public class RemoteInputChannel extends InputChannel {\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n \n-\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n-\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\tif (buffer.getDataType().hasPriority()) {\n \t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n-\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n-\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n-\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n-\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n-\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n-\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n-\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n-\t\t\t\t\t\t}\n+\t\t\t\t\tif (channelStatePersister.checkForBarrier(buffer)) {\n+\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\tnumBuffersOvertaken = receivedBuffers.getNumUnprioritizedElements();\n \t\t\t\t\t}\n-\t\t\t\t\tfirstPriorityEvent = pos == 1;\n+\t\t\t\t\tfirstPriorityEvent = receivedBuffers.getNumPriorityElements() == 1;\n \t\t\t\t} else {\n \t\t\t\t\treceivedBuffers.add(buffer);\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n-\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\tchannelInfo,\n-\t\t\t\t\t\t\t\tsequenceNumber,\n-\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t}\n \t\t\t}\n \t\t\trecycleBuffer = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzc3NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488027775", "bodyText": "nitty nit: writeInFlightBuffers? (write as Romand picked writer for the \"spilling\" nomenclature)", "author": "pnowojski", "createdAt": "2020-09-14T15:32:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n \t\t\t}\n \t\t\trecycleBuffer = false;\n \n \t\t\t++expectedSequenceNumber;\n \n+\t\t\tif (firstPriorityEvent) {\n+\t\t\t\tnotifyPriorityEvent();\n+\t\t\t}\n \t\t\tif (wasEmpty) {\n \t\t\t\tnotifyChannelNonEmpty();\n \t\t\t}\n \n \t\t\tif (backlog >= 0) {\n \t\t\t\tonSenderBacklog(backlog);\n \t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tif (notifyReceivedBarrier.isCheckpoint()) {\n-\t\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t\t}\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n \t\t} finally {\n \t\t\tif (recycleBuffer) {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Spills all queued buffers on checkpoint start. If barrier has already been received (and reordered), spill only\n+\t * the overtaken buffers.\n+\t */\n+\tpublic void checkpointStarted(CheckpointBarrier barrier) {\n+\t\tcheckState(channelStateWriter != null, \"Channel state writer not injected\");\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tfinal Integer numBuffers = numBuffersOvertaken.get(barrier.getId());\n+\t\t\tif (numBuffers != null) {\n+\t\t\t\t// already received barrier before the task thread picked up the barrier of this or another channel\n+\t\t\t\tspillBuffers(barrier.getId(), numBuffers);\n+\t\t\t} else {\n+\t\t\t\t// barrier not yet received, spill all current and future buffers\n+\t\t\t\tspillBuffers(barrier.getId(), receivedBuffers.getNumUnprioritizedElements());\n+\t\t\t\tpendingCheckpointBarriers.add(barrier.getId());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void checkpointStopped(long checkpointId) {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tnumBuffersOvertaken.remove(checkpointId);\n+\t\t\tpendingCheckpointBarriers.remove(checkpointId);\n+\t\t}\n+\t}\n+\n+\tprivate void spillBuffers(long checkpointId, int numBuffers) {", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NjQ2Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492596462", "bodyText": "I added a helper class ChannelStatePersister and used persist everywhere to have a clear separation of the two names. Persister is more on the logical level and Writer on the physical implementation.", "author": "AHeise", "createdAt": "2020-09-22T09:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzc3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex e1ff9f8a702..216ab6ac8dc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -432,31 +433,17 @@ public class RemoteInputChannel extends InputChannel {\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n \n-\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n-\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\tif (buffer.getDataType().hasPriority()) {\n \t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n-\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n-\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n-\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n-\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n-\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n-\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n-\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n-\t\t\t\t\t\t}\n+\t\t\t\t\tif (channelStatePersister.checkForBarrier(buffer)) {\n+\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\tnumBuffersOvertaken = receivedBuffers.getNumUnprioritizedElements();\n \t\t\t\t\t}\n-\t\t\t\t\tfirstPriorityEvent = pos == 1;\n+\t\t\t\t\tfirstPriorityEvent = receivedBuffers.getNumPriorityElements() == 1;\n \t\t\t\t} else {\n \t\t\t\t\treceivedBuffers.add(buffer);\n-\t\t\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n-\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n-\t\t\t\t\t\t\t\tcheckpointId,\n-\t\t\t\t\t\t\t\tchannelInfo,\n-\t\t\t\t\t\t\t\tsequenceNumber,\n-\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t}\n \t\t\t}\n \t\t\trecycleBuffer = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyODEyMg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488028122", "bodyText": "\u2764\ufe0f", "author": "pnowojski", "createdAt": "2020-09-14T15:33:20Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -314,6 +315,21 @@ protected StreamTask(\n \t\t}\n \n \t\tthis.channelIOExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"channel-state-unspilling\"));\n+\n+\t\tinjectChannelStateWriterIntoChannels();\n+\t}\n+\n+\tprivate void injectChannelStateWriterIntoChannels() {\n+\t\tfinal Environment env = getEnvironment();\n+\t\tfinal ChannelStateWriter channelStateWriter = subtaskCheckpointCoordinator.getChannelStateWriter();\n+\t\tfor (final InputGate gate : env.getAllInputGates()) {\n+\t\t\tgate.setChannelStateWriter(channelStateWriter);\n+\t\t}\n+\t\tfor (ResultPartitionWriter writer : env.getAllWriters()) {\n+\t\t\tif (writer instanceof ChannelStateHolder) {\n+\t\t\t\t((ChannelStateHolder) writer).setChannelStateWriter(channelStateWriter);\n+\t\t\t}\n+\t\t}", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NzMxNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492487317", "bodyText": "Happy for any other suggestion. I think the cast itself is in line with recent changes done by Stephan.\nThe proper solution would be to inject in ctor but that will not happen until we merge runtime and streaming.", "author": "AHeise", "createdAt": "2020-09-22T05:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyODEyMg=="}], "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\nindex 8d4ff211bfc..d9b9f73c019 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java\n\n@@ -315,21 +313,6 @@ public abstract class StreamTask<OUT, OP extends StreamOperator<OUT>>\n \t\t}\n \n \t\tthis.channelIOExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"channel-state-unspilling\"));\n-\n-\t\tinjectChannelStateWriterIntoChannels();\n-\t}\n-\n-\tprivate void injectChannelStateWriterIntoChannels() {\n-\t\tfinal Environment env = getEnvironment();\n-\t\tfinal ChannelStateWriter channelStateWriter = subtaskCheckpointCoordinator.getChannelStateWriter();\n-\t\tfor (final InputGate gate : env.getAllInputGates()) {\n-\t\t\tgate.setChannelStateWriter(channelStateWriter);\n-\t\t}\n-\t\tfor (ResultPartitionWriter writer : env.getAllWriters()) {\n-\t\t\tif (writer instanceof ChannelStateHolder) {\n-\t\t\t\t((ChannelStateHolder) writer).setChannelStateWriter(channelStateWriter);\n-\t\t\t}\n-\t\t}\n \t}\n \n \tprivate CompletableFuture<Void> prepareInputSnapshot(ChannelStateWriter channelStateWriter, long checkpointId) throws IOException {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyOTYwNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488029606", "bodyText": "Is the code in a working state before:\n\nRemove synchronization from CheckpointBarrierUnaligner.\n\ncommit? It looks like data are spilled in two places, right?", "author": "pnowojski", "createdAt": "2020-09-14T15:35:22Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -22,13 +22,10 @@\n import org.apache.flink.annotation.VisibleForTesting;", "originalCommit": "6e3eafcdf62ecbe7e67f2b50b66f12a3b56af99e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4OTI1OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492489258", "bodyText": "I admit that it's an awkward cut.\nHowever, it's only spilled in one place as the BufferReceivedListener methods are effectively not called in the previous commits anymore. I will make a later pass to see that all tests pass though.", "author": "AHeise", "createdAt": "2020-09-22T05:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyOTYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\nindex 8dec24b8cd0..ccd5859c471 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n\n@@ -22,10 +22,13 @@ import org.apache.flink.annotation.Internal;\n import org.apache.flink.annotation.VisibleForTesting;\n import org.apache.flink.runtime.checkpoint.CheckpointException;\n import org.apache.flink.runtime.checkpoint.CheckpointFailureReason;\n+import org.apache.flink.runtime.checkpoint.channel.ChannelStateWriter;\n import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.concurrent.FutureUtils;\n import org.apache.flink.runtime.io.network.api.CancelCheckpointMarker;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferReceivedListener;\n import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n import org.apache.flink.streaming.runtime.tasks.SubtaskCheckpointCoordinator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMTQzOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488031438", "bodyText": "A minor rebasing/squashing mistake?", "author": "pnowojski", "createdAt": "2020-09-14T15:37:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java", "diffHunk": "@@ -122,8 +121,8 @@ public void close() throws Exception {\n \t}\n \n \t@Override\n-\tpublic void registerBufferReceivedListener(BufferReceivedListener listener) {\n-\t\tinputGate.registerBufferReceivedListener(listener);\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn inputGate.getPriorityEventAvailableFuture();", "originalCommit": "d47325cba6cafc4b69e300f56261f6c8157d7cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java\nindex 30a9820196e..806a4613e6f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java\n\n@@ -121,8 +116,8 @@ public class InputGateWithMetrics extends IndexedInputGate {\n \t}\n \n \t@Override\n-\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n-\t\treturn inputGate.getPriorityEventAvailableFuture();\n+\tpublic void registerBufferReceivedListener(BufferReceivedListener listener) {\n+\t\tinputGate.registerBufferReceivedListener(listener);\n \t}\n \n \tprivate BufferOrEvent updateMetrics(BufferOrEvent bufferOrEvent) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjY1NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488032655", "bodyText": "Why has this test and CheckpointBarrierTrackerTest.java changed in this commit? Rebasing/squashing mistake, or am I missing something about this commit (I thought it's a pure clean up without functional changes).", "author": "pnowojski", "createdAt": "2020-09-14T15:39:41Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -369,9 +369,7 @@ public void testMissingCancellationBarriers() throws Exception {\n \t\tinputGate = createBarrierBuffer(2, sequence, validator);", "originalCommit": "d47325cba6cafc4b69e300f56261f6c8157d7cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4ODcwMg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492488702", "bodyText": "A side-effect of this commit is that all events are handed over from CheckpointedInputGate to StreamTaskNetworkInput and break up the poll loop. However, since events are rare, it should have no visible impact on the throughput.\n\nThe changes to the tests are now handling the additionally emitted events. Imho tests are easier to read now (no magically disappearing buffers in the sequence).", "author": "AHeise", "createdAt": "2020-09-22T05:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\nindex c24f7a4d835..0c478a0b2cf 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\n\n@@ -369,7 +369,9 @@ public abstract class CheckpointBarrierAlignerTestBase {\n \t\tinputGate = createBarrierBuffer(2, sequence, validator);\n \n \t\tfor (BufferOrEvent boe : sequence) {\n-\t\t\tassertEquals(boe, inputGate.pollNext().get());\n+\t\t\tif (boe.isBuffer() || boe.getEvent().getClass() != CancelCheckpointMarker.class) {\n+\t\t\t\tassertEquals(boe, inputGate.pollNext().get());\n+\t\t\t}\n \t\t}\n \n \t\tInteger[] expectedUnblockedChannels = new Integer[] {0};\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNzg5Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488037897", "bodyText": "nit: add StreamMultipleInputProcessor to the mail's name?", "author": "pnowojski", "createdAt": "2020-09-14T15:47:05Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);\n+\t\t\t}, \"priority event {}\", index);", "originalCommit": "a6a2d36afcce1758e885f0751359ccf035ae2378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMTA4MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492601080", "bodyText": "Commit removed; on CheckpointedInputGate, I'm adding the gate.toString().", "author": "AHeise", "createdAt": "2020-09-22T09:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNzg5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a22657562a42dda270f89c176e5c260ee73c6698", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\nindex 1520e05ea4d..3949b513425 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\n\n@@ -182,37 +161,12 @@ public final class StreamMultipleInputProcessor implements StreamInputProcessor\n \t\t\treturn InputStatus.NOTHING_AVAILABLE;\n \t\t}\n \n+\t\tlastReadInputIndex = readingInputIndex;\n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n-\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n-\tprivate void updatePriorityAvailability() {\n-\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n-\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n-\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n-\t\t\t// no more priority events for the input\n-\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n-\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n-\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n-\t\t\t\t\tpriorityAvailability.resetUnavailable();\n-\t\t\t\t}\n-\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate Runnable onPriorityEvent(int index) {\n-\t\treturn () -> {\n-\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n-\t\t\tmainMailboxExecutor.execute(() -> {\n-\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n-\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);\n-\t\t\t}, \"priority event {}\", index);\n-\t\t};\n-\t}\n-\n \tprivate int selectFirstReadingInputIndex() {\n \t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n \t\t// is opened to ensure that any changes about the input selection in its open()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDAxMA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488040010", "bodyText": "Can not you maybe handle the priority message directly here, in this mail? Instead of relaying on the processDefaultAction to pick this up?\n(I'm asking/loudly thinking)", "author": "pnowojski", "createdAt": "2020-09-14T15:50:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);", "originalCommit": "a6a2d36afcce1758e885f0751359ccf035ae2378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMTU5NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492601594", "bodyText": "Moved it even further up towards CheckpointedInputGate. At this point, we need to make sure that a priority event is really at the top (hence the optimistic lock protocol for notification).", "author": "AHeise", "createdAt": "2020-09-22T09:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "a22657562a42dda270f89c176e5c260ee73c6698", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\nindex 1520e05ea4d..3949b513425 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java\n\n@@ -182,37 +161,12 @@ public final class StreamMultipleInputProcessor implements StreamInputProcessor\n \t\t\treturn InputStatus.NOTHING_AVAILABLE;\n \t\t}\n \n+\t\tlastReadInputIndex = readingInputIndex;\n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n-\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n-\tprivate void updatePriorityAvailability() {\n-\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n-\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n-\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n-\t\t\t// no more priority events for the input\n-\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n-\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n-\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n-\t\t\t\t\tpriorityAvailability.resetUnavailable();\n-\t\t\t\t}\n-\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate Runnable onPriorityEvent(int index) {\n-\t\treturn () -> {\n-\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n-\t\t\tmainMailboxExecutor.execute(() -> {\n-\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n-\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);\n-\t\t\t}, \"priority event {}\", index);\n-\t\t};\n-\t}\n-\n \tprivate int selectFirstReadingInputIndex() {\n \t\t// Note: the first call to nextSelection () on the operator must be made after this operator\n \t\t// is opened to ensure that any changes about the input selection in its open()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MzU0MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488043540", "bodyText": "What's the story behind this change?\n\nit seems it differs only by a single line numBarriersReceived = 0;, so at the very least we should deduplicate some code here\ncan you explain what's the functional change?\naren't we missing a unit test for that? It would help answer point 2., and if there was a bug discovered in e2e test, it would be nice to have a faster unit test for that as well.", "author": "pnowojski", "createdAt": "2020-09-14T15:55:10Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -113,7 +113,11 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \n \t\t\tif (++numBarriersReceived == numOpenChannels) {\n \t\t\t\tallBarriersReceivedFuture.complete(null);\n-\t\t\t\tresetPendingCheckpoint(barrierId);\n+\t\t\t\tfor (final InputGate gate : inputGates) {\n+\t\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n+\t\t\t\t\t\tgate.getChannel(index).checkpointStopped(currentCheckpointId);\n+\t\t\t\t\t}\n+\t\t\t\t}", "originalCommit": "fa3e495b6ba201769d908adea420e4944ddd7643", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjQ0Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492602447", "bodyText": "Sorry that was just a test commit to see if the stuck e2e failed because of this change. I removed it. The original change is covered by a few unit tests already.", "author": "AHeise", "createdAt": "2020-09-22T09:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MzU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "4fb30d405835251b799f70e28a39f31fb9678700", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\nindex 8a658c618a9..8dec24b8cd0 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n\n@@ -113,11 +113,7 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {\n \n \t\t\tif (++numBarriersReceived == numOpenChannels) {\n \t\t\t\tallBarriersReceivedFuture.complete(null);\n-\t\t\t\tfor (final InputGate gate : inputGates) {\n-\t\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n-\t\t\t\t\t\tgate.getChannel(index).checkpointStopped(currentCheckpointId);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tresetPendingCheckpoint(barrierId);\n \t\t\t}\n \t\t}\n \t}\n"}}, {"oid": "4fb30d405835251b799f70e28a39f31fb9678700", "url": "https://github.com/apache/flink/commit/4fb30d405835251b799f70e28a39f31fb9678700", "message": "[temp] Debug e2e", "committedDate": "2020-09-16T06:01:16Z", "type": "forcePushed"}, {"oid": "a1fb1c3114305ed5fce898dfcc03abed4d6963d4", "url": "https://github.com/apache/flink/commit/a1fb1c3114305ed5fce898dfcc03abed4d6963d4", "message": "[FLINK-19026][network] Revert FLINK-12510.", "committedDate": "2020-09-16T06:01:16Z", "type": "forcePushed"}, {"oid": "834c28da93d4b24e562e017979b483e288db02a2", "url": "https://github.com/apache/flink/commit/834c28da93d4b24e562e017979b483e288db02a2", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-16T21:14:05Z", "type": "forcePushed"}, {"oid": "a22657562a42dda270f89c176e5c260ee73c6698", "url": "https://github.com/apache/flink/commit/a22657562a42dda270f89c176e5c260ee73c6698", "message": "fixup! [FLINK-19026][network] Moving priority event handling from BufferReceivedListener to CheckpointedInputGate.", "committedDate": "2020-09-21T09:40:43Z", "type": "forcePushed"}, {"oid": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "url": "https://github.com/apache/flink/commit/f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-21T22:50:12Z", "type": "forcePushed"}, {"oid": "8f18616dbfce97d0fd6e1f442f7a3db892a6cf1e", "url": "https://github.com/apache/flink/commit/8f18616dbfce97d0fd6e1f442f7a3db892a6cf1e", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T05:08:46Z", "type": "forcePushed"}, {"oid": "5e442492671ac6d0557e8e8e158a693aaec4daa4", "url": "https://github.com/apache/flink/commit/5e442492671ac6d0557e8e8e158a693aaec4daa4", "message": "fix generalize", "committedDate": "2020-09-22T07:46:19Z", "type": "forcePushed"}, {"oid": "1a86b34a3cd22d0ae34d16e9fa96036650dd6323", "url": "https://github.com/apache/flink/commit/1a86b34a3cd22d0ae34d16e9fa96036650dd6323", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T08:19:19Z", "type": "forcePushed"}, {"oid": "35673098a49bdf2c6bc665cf8ec2abbf71fdc546", "url": "https://github.com/apache/flink/commit/35673098a49bdf2c6bc665cf8ec2abbf71fdc546", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:32:11Z", "type": "forcePushed"}, {"oid": "7b29e64308905545d3c9bab68c1322e69d89d23d", "url": "https://github.com/apache/flink/commit/7b29e64308905545d3c9bab68c1322e69d89d23d", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:45:45Z", "type": "forcePushed"}, {"oid": "a76104444a39646376ec0d6d5f761ec8cbcbe868", "url": "https://github.com/apache/flink/commit/a76104444a39646376ec0d6d5f761ec8cbcbe868", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:52:48Z", "type": "forcePushed"}, {"oid": "355fecafd9215ef93471360f84be51e0520ce1bc", "url": "https://github.com/apache/flink/commit/355fecafd9215ef93471360f84be51e0520ce1bc", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:56:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyOTg1MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492829851", "bodyText": "nit: move to a separate processCheckpointBarrier method?\nor maybe also one step further:\n\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n\t\tassert Thread.holdsLock(buffers);\t\n\t\tif (bufferConsumer.getDataType().hasPriority()) {\n\t\t\tprocessPriorityBuffer(bufferConsumer);\n\t\t}\n\t\tbuffers.add(bufferConsumer);\n\t\treturn false;\n\t}\n\nto highlight that on the hot path, (without priority) we are skipping this whole code?", "author": "pnowojski", "createdAt": "2020-09-22T15:27:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -177,32 +187,53 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tbuffers.addPriorityElement(bufferConsumer);\n \t\tfinal int numPriorityElements = buffers.getNumPriorityElements();\n \n-\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n-\t\tIterators.advance(iterator, numPriorityElements);\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tBufferConsumer buffer = iterator.next();\n-\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, numPriorityElements);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (!inflightBuffers.isEmpty()) {\n+\t\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\t\tbarrier.getId(),\n+\t\t\t\t\tsubpartitionInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n+\t\t\t}\n \t\t}", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ea5c6962348cf666b6b787eb7fad0cbec497b9af", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 2f6f9b844fd..cd980f92f29 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -183,11 +183,14 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n \tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (!bufferConsumer.getDataType().hasPriority()) {\n-\t\t\tbuffers.add(bufferConsumer);\n-\t\t\treturn false;\n+\t\tif (bufferConsumer.getDataType().hasPriority()) {\n+\t\t\treturn processPriorityBuffer(bufferConsumer);\n \t\t}\n+\t\tbuffers.add(bufferConsumer);\n+\t\treturn false;\n+\t}\n \n+\tprivate boolean processPriorityBuffer(BufferConsumer bufferConsumer) {\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \t\tfinal int numPriorityElements = buffers.getNumPriorityElements();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTcwNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492835707", "bodyText": "This doesn't seem to fit in the ChannelStatePersister interface. Maybe move those methods somewhere else? As static methods to InputChannel?\nAlso, aren't they duplicating the same logic as somewhere on the output sides?", "author": "pnowojski", "createdAt": "2020-09-22T15:35:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -361,4 +360,89 @@ public String toString() {\n \t\t\t\t'}';\n \t\t}\n \t}\n+\n+\t/**\n+\t * Helper class for persisting channel state via {@link ChannelStateWriter}.\n+\t */\n+\t@NotThreadSafe\n+\tprotected final class ChannelStatePersister {\n+\t\tprivate static final long CHECKPOINT_COMPLETED = -1;\n+\n+\t\tprivate static final long BARRIER_RECEIVED = -2;\n+\n+\t\t/** All started checkpoints where a barrier has not been received yet. */\n+\t\tprivate long pendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\n+\t\t/** Writer must be initialized before usage. {@link #startPersisting(long, List)} enforces this invariant. */\n+\t\t@Nullable\n+\t\tprivate final ChannelStateWriter channelStateWriter;\n+\n+\t\tpublic ChannelStatePersister(@Nullable ChannelStateWriter channelStateWriter) {\n+\t\t\tthis.channelStateWriter = channelStateWriter;\n+\t\t}\n+\n+\t\tprotected void startPersisting(long barrierId, List<Buffer> knownBuffers) {\n+\t\t\tcheckState(isInitialized(), \"Channel state writer not injected\");\n+\n+\t\t\tif (pendingCheckpointBarrierId != BARRIER_RECEIVED) {\n+\t\t\t\tpendingCheckpointBarrierId = barrierId;\n+\t\t\t}\n+\t\t\tif (knownBuffers.size() > 0) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tchannelInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.fromList(knownBuffers, Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean isInitialized() {\n+\t\t\treturn channelStateWriter != null;\n+\t\t}\n+\n+\t\tprotected void stopPersisting() {\n+\t\t\tpendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\t\t}\n+\n+\t\tprotected void maybePersist(Buffer buffer) {\n+\t\t\tif (pendingCheckpointBarrierId >= 0 && buffer.isBuffer()) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tpendingCheckpointBarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean checkForBarrier(Buffer buffer) throws IOException {\n+\t\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\tpendingCheckpointBarrierId = BARRIER_RECEIVED;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n+\t\t * returns null in all other cases.\n+\t\t */\n+\t\t@Nullable\n+\t\tprotected AbstractEvent parsePriorityEvent(Buffer buffer) throws IOException {\n+\t\t\tif (buffer.isBuffer() || !buffer.getDataType().hasPriority()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n+\t\t\t// we can further improve to avoid double deserialization in the future.\n+\t\t\tbuffer.setReaderIndex(0);\n+\t\t\treturn event;\n+\t\t}", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAyNTQ2NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493025464", "bodyText": "It's only used in this class and thus I inlined it. As is, it really looks like an interface of the Persister.\nThere is similar code for BufferConsumer on output side, but the implementation is too different to align (copy buffer vs. reader index reset, different EventSerializer.fromBuffer overloads).", "author": "AHeise", "createdAt": "2020-09-22T20:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTcwNw=="}], "type": "inlineReview", "revised_code": {"commit": "ea5c6962348cf666b6b787eb7fad0cbec497b9af", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex 94e9f04ffee..188b2dae059 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n\n@@ -415,29 +415,20 @@ public abstract class InputChannel {\n \t\t}\n \n \t\tprotected boolean checkForBarrier(Buffer buffer) throws IOException {\n-\t\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n-\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n-\t\t\t\tpendingCheckpointBarrierId = BARRIER_RECEIVED;\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t\treturn false;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n-\t\t * returns null in all other cases.\n-\t\t */\n-\t\t@Nullable\n-\t\tprotected AbstractEvent parsePriorityEvent(Buffer buffer) throws IOException {\n \t\t\tif (buffer.isBuffer() || !buffer.getDataType().hasPriority()) {\n-\t\t\t\treturn null;\n+\t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\tAbstractEvent priorityEvent = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n \t\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n \t\t\t// we can further improve to avoid double deserialization in the future.\n \t\t\tbuffer.setReaderIndex(0);\n-\t\t\treturn event;\n+\n+\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\tpendingCheckpointBarrierId = BARRIER_RECEIVED;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n \t\t}\n \n \t\tprotected boolean hasBarrierReceived() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNjkwOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492836908", "bodyText": "why was this test removed?", "author": "pnowojski", "createdAt": "2020-09-22T15:36:39Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java", "diffHunk": "@@ -120,67 +112,10 @@ public void testNoDataProcessedAfterCheckpointBarrier() throws Exception {\n \t\tassertEquals(0, output.getNumberOfEmittedRecords());\n \t}\n \n-\t@Test\n-\tpublic void testSnapshotWithTwoInputGates() throws Exception {", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNTg2Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493035866", "bodyText": "I added this test for FLINK-18139 - input gate index issues in Unaligner#hasInflightData, which is called by StreamTaskNetworkInput, hence the test here.\nHowever, in this commit, hasInflightData is removed. Spilling is fully encapsulated in InputChannel + CheckpointBarrierUnaligner/CheckpointedInputGate and this interaction is already covered in tests at CheckpointBarrierUnalignerTest.", "author": "AHeise", "createdAt": "2020-09-22T21:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNjkwOA=="}], "type": "inlineReview", "revised_code": {"commit": "0f60b006208d03b78878334579ef2906951d9e36", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java\nindex 4c0a94d0bfd..9f229716ad6 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java\n\n@@ -112,10 +120,67 @@ public class StreamTaskNetworkInputTest {\n \t\tassertEquals(0, output.getNumberOfEmittedRecords());\n \t}\n \n+\t@Test\n+\tpublic void testSnapshotWithTwoInputGates() throws Exception {\n+\t\tSingleInputGate inputGate1 = new SingleInputGateBuilder().setSingleInputGateIndex(0).build();\n+\t\tRemoteInputChannel channel1 = createRemoteInputChannel(inputGate1, 0);\n+\t\tinputGate1.setInputChannels(channel1);\n+\n+\t\tSingleInputGate inputGate2 = new SingleInputGateBuilder().setSingleInputGateIndex(1).build();\n+\t\tRemoteInputChannel channel2 = createRemoteInputChannel(inputGate2, 0);\n+\t\tinputGate2.setInputChannels(channel2);\n+\n+\t\tCheckpointBarrierUnaligner unaligner = new CheckpointBarrierUnaligner(\n+\t\t\tTestSubtaskCheckpointCoordinator.INSTANCE,\n+\t\t\t\"test\",\n+\t\t\tnew DummyCheckpointInvokable(),\n+\t\t\tinputGate1,\n+\t\t\tinputGate2);\n+\t\tinputGate1.registerBufferReceivedListener(unaligner.getBufferReceivedListener().get());\n+\t\tinputGate2.registerBufferReceivedListener(unaligner.getBufferReceivedListener().get());\n+\n+\t\tStreamTaskNetworkInput<Long> input1 = createInput(unaligner, inputGate1);\n+\t\tStreamTaskNetworkInput<Long> input2 = createInput(unaligner, inputGate2);\n+\n+\t\tCheckpointBarrier barrier = new CheckpointBarrier(0, 0L, CheckpointOptions.forCheckpointWithDefaultLocation());\n+\t\tchannel1.onBuffer(EventSerializer.toBuffer(barrier), 0, 0);\n+\t\tchannel1.onBuffer(BufferBuilderTestUtils.buildSomeBuffer(1), 1, 0);\n+\n+\t\t// all records on inputGate2 are now in-flight\n+\t\tchannel2.onBuffer(BufferBuilderTestUtils.buildSomeBuffer(2), 0, 0);\n+\t\tchannel2.onBuffer(BufferBuilderTestUtils.buildSomeBuffer(3), 1, 0);\n+\n+\t\t// now snapshot all inflight buffers\n+\t\tRecordingChannelStateWriter channelStateWriter = new RecordingChannelStateWriter();\n+\t\tchannelStateWriter.start(0, CheckpointOptions.forCheckpointWithDefaultLocation());\n+\t\tCompletableFuture<Void> completableFuture1 = input1.prepareSnapshot(channelStateWriter, 0);\n+\t\tCompletableFuture<Void> completableFuture2 = input2.prepareSnapshot(channelStateWriter, 0);\n+\n+\t\t// finish unaligned checkpoint on input side\n+\t\tchannel2.onBuffer(EventSerializer.toBuffer(barrier), 2, 0);\n+\n+\t\t// futures should be completed\n+\t\tcompletableFuture1.join();\n+\t\tcompletableFuture2.join();\n+\n+\t\tassertEquals(channelStateWriter.getAddedInput().get(channel1.getChannelInfo()), Collections.emptyList());\n+\t\tList<Buffer> storedBuffers = channelStateWriter.getAddedInput().get(channel2.getChannelInfo());\n+\t\tassertEquals(Arrays.asList(2, 3), storedBuffers.stream().map(Buffer::getSize).collect(Collectors.toList()));\n+\t}\n+\n+\tprivate StreamTaskNetworkInput<Long> createInput(CheckpointBarrierHandler handler, SingleInputGate inputGate) {\n+\t\treturn new StreamTaskNetworkInput<>(\n+\t\t\tnew CheckpointedInputGate(inputGate, handler),\n+\t\t\tLongSerializer.INSTANCE,\n+\t\t\tnew StatusWatermarkValve(inputGate.getNumberOfInputChannels(), new NoOpDataOutput<>()),\n+\t\t\tinputGate.getGateIndex(),\n+\t\t\tcreateDeserializers(inputGate.getNumberOfInputChannels()));\n+\t}\n+\n \tprivate TestRecordDeserializer[] createDeserializers(int numberOfInputChannels) {\n \t\treturn IntStream.range(0, numberOfInputChannels)\n-\t\t\t.mapToObj(index -> new TestRecordDeserializer(ioManager.getSpillingDirectoriesPaths()))\n-\t\t\t.toArray(TestRecordDeserializer[]::new);\n+\t\t\t\t.mapToObj(index -> new TestRecordDeserializer(ioManager.getSpillingDirectoriesPaths()))\n+\t\t\t\t.toArray(TestRecordDeserializer[]::new);\n \t}\n \n \t@Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODMwNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492838306", "bodyText": "Can you double check if indeed all of those test should be removed? I don't see how things like testPartitionNotFoundExceptionWhileGetNextBuffer should be related to this commit/PR?", "author": "pnowojski", "createdAt": "2020-09-22T15:38:24Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -812,242 +788,13 @@ public void testQueuedBuffers() throws Exception {\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testBufferReceivedListener() throws Exception {", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzOTg1Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493039856", "bodyText": "Good catch, my intent was to delete testBufferReceivedListener and testPartitionNotFoundExceptionWhileGetNextBuffer but not the test in between them.\ntestBufferReceivedListener tests BufferReceivedListener which this commits renders useless (and is later removed).\ntestPartitionNotFoundExceptionWhileGetNextBuffer tests concurrent spilling of lingering buffers and receiving of such lingering buffers. Both now happens in the same thread, so the test does not make any sense.", "author": "AHeise", "createdAt": "2020-09-22T21:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "ea5c6962348cf666b6b787eb7fad0cbec497b9af", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java\nindex 401001a3938..c17f0a55391 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java\n\n@@ -788,8 +797,105 @@ public class SingleInputGateTest extends InputGateTestBase {\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests that if the {@link PartitionNotFoundException} is set onto one {@link InputChannel},\n+\t * then it would be thrown directly via {@link SingleInputGate#getNext()}. So we\n+\t * could confirm the {@link SingleInputGate} would not swallow or transform the original exception.\n+\t */\n+\t@Test\n+\tpublic void testPartitionNotFoundExceptionWhileGetNextBuffer() throws Exception {\n+\t\tfinal SingleInputGate inputGate = createSingleInputGate(1);\n+\t\tfinal LocalInputChannel localChannel = createLocalInputChannel(inputGate, new ResultPartitionManager());\n+\t\tfinal ResultPartitionID partitionId = localChannel.getPartitionId();\n+\n+\t\tinputGate.setInputChannels(localChannel);\n+\t\tlocalChannel.setError(new PartitionNotFoundException(partitionId));\n+\t\ttry {\n+\t\t\tinputGate.getNext();\n+\n+\t\t\tfail(\"Should throw a PartitionNotFoundException.\");\n+\t\t} catch (PartitionNotFoundException notFound) {\n+\t\t\tassertThat(partitionId, is(notFound.getPartitionId()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testInputGateRemovalFromNettyShuffleEnvironment() throws Exception {\n+\t\tNettyShuffleEnvironment network = createNettyShuffleEnvironment();\n+\n+\t\ttry {\n+\t\t\tint numberOfGates = 10;\n+\t\t\tMap<InputGateID, SingleInputGate> createdInputGatesById =\n+\t\t\t\tcreateInputGateWithLocalChannels(network, numberOfGates, 1);\n+\n+\t\t\tassertEquals(numberOfGates, createdInputGatesById.size());\n+\n+\t\t\tfor (InputGateID id : createdInputGatesById.keySet()) {\n+\t\t\t\tassertThat(network.getInputGate(id).isPresent(), is(true));\n+\t\t\t\tcreatedInputGatesById.get(id).close();\n+\t\t\t\tassertThat(network.getInputGate(id).isPresent(), is(false));\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tnetwork.close();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testSingleInputGateInfo() {\n+\t\tfinal int numSingleInputGates = 2;\n+\t\tfinal int numInputChannels = 3;\n+\n+\t\tfor (int i = 0; i < numSingleInputGates; i++) {\n+\t\t\tfinal SingleInputGate gate = new SingleInputGateBuilder()\n+\t\t\t\t.setSingleInputGateIndex(i)\n+\t\t\t\t.setNumberOfChannels(numInputChannels)\n+\t\t\t\t.build();\n+\n+\t\t\tint channelCounter = 0;\n+\t\t\tfor (InputChannel inputChannel : gate.getInputChannels().values()) {\n+\t\t\t\tInputChannelInfo channelInfo = inputChannel.getChannelInfo();\n+\n+\t\t\t\tassertEquals(i, channelInfo.getGateIdx());\n+\t\t\t\tassertEquals(channelCounter++, channelInfo.getInputChannelIdx());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t// ---------------------------------------------------------------------------------------------\n \n+\tprivate static Map<InputGateID, SingleInputGate> createInputGateWithLocalChannels(\n+\t\t\tNettyShuffleEnvironment network,\n+\t\t\tint numberOfGates,\n+\t\t\t@SuppressWarnings(\"SameParameterValue\") int numberOfLocalChannels) {\n+\t\tShuffleDescriptor[] channelDescs = new NettyShuffleDescriptor[numberOfLocalChannels];\n+\t\tfor (int i = 0; i < numberOfLocalChannels; i++) {\n+\t\t\tchannelDescs[i] = createRemoteWithIdAndLocation(new IntermediateResultPartitionID(), ResourceID.generate());\n+\t\t}\n+\n+\t\tInputGateDeploymentDescriptor[] gateDescs = new InputGateDeploymentDescriptor[numberOfGates];\n+\t\tIntermediateDataSetID[] ids = new IntermediateDataSetID[numberOfGates];\n+\t\tfor (int i = 0; i < numberOfGates; i++) {\n+\t\t\tids[i] = new IntermediateDataSetID();\n+\t\t\tgateDescs[i] = new InputGateDeploymentDescriptor(\n+\t\t\t\tids[i],\n+\t\t\t\tResultPartitionType.PIPELINED,\n+\t\t\t\t0,\n+\t\t\t\tchannelDescs);\n+\t\t}\n+\n+\t\tExecutionAttemptID consumerID = new ExecutionAttemptID();\n+\t\tSingleInputGate[] gates = network.createInputGates(\n+\t\t\tnetwork.createShuffleIOOwnerContext(\"\", consumerID, new UnregisteredMetricsGroup()),\n+\t\t\tSingleInputGateBuilder.NO_OP_PRODUCER_CHECKER,\n+\t\t\tasList(gateDescs)).toArray(new SingleInputGate[] {});\n+\t\tMap<InputGateID, SingleInputGate> inputGatesById = new HashMap<>();\n+\t\tfor (int i = 0; i < numberOfGates; i++) {\n+\t\t\tinputGatesById.put(new InputGateID(ids[i], consumerID), gates[i]);\n+\t\t}\n+\n+\t\treturn inputGatesById;\n+\t}\n+\n \tprivate InputChannel buildUnknownInputChannel(\n \t\tNettyShuffleEnvironment network,\n \t\tSingleInputGate inputGate,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM4Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492843387", "bodyText": "add checkState(!inputGate.getPriorityEventAvailableFuture().isDone())?", "author": "pnowojski", "createdAt": "2020-09-22T15:45:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -62,9 +65,37 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tif (inputGate.getPriorityEventAvailableFuture().isDone()) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+", "originalCommit": "69cd2be36ce52a0de0be43602ebce454644897a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NDQ3MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493044470", "bodyText": "Good idea, I solved it in the following way:\n\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n\t\tboolean hasPriorityEvent = inputGate.getPriorityEventAvailableFuture().isDone();\n\t\twhile (hasPriorityEvent) {\n\t\t\t// process as many priority events as possible\n\t\t\tfinal Optional<BufferOrEvent> bufferOrEventOpt = pollNext();\n\t\t\tbufferOrEventOpt.ifPresent(bufferOrEvent ->\n\t\t\t\tcheckState(bufferOrEvent.hasPriority(), \"Should only poll priority events\"));\n\t\t\thasPriorityEvent = bufferOrEventOpt.map(BufferOrEvent::morePriorityEvents).orElse(false);\n\t\t}\n\ncheckState(!inputGate.getPriorityEventAvailableFuture().isDone()) might be failing if netty receives a new priority event and triggers this available future while the task thread polled the last priority event. This case should happen quite often when the first barrier arrives (at that time the only priority event, morePriorityEvents = false) and triggers the whole checkpointing process. The second barrier would then complete the getPriorityEventAvailableFuture causing a more or less immediate re-execution of this method.", "author": "AHeise", "createdAt": "2020-09-22T21:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ea5c6962348cf666b6b787eb7fad0cbec497b9af", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\nindex 185e96567ca..fb69cee2464 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n\n@@ -81,21 +81,23 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven\n \t */\n \tprivate void processPriorityEvents() throws IOException, InterruptedException {\n \t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n-\t\tif (inputGate.getPriorityEventAvailableFuture().isDone()) {\n+\t\tboolean hasPriorityEvent = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\twhile (hasPriorityEvent) {\n \t\t\t// process as many priority events as possible\n-\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n-\t\t\t}\n+\t\t\tfinal Optional<BufferOrEvent> bufferOrEventOpt = pollNext();\n+\t\t\tbufferOrEventOpt.ifPresent(bufferOrEvent ->\n+\t\t\t\tcheckState(bufferOrEvent.hasPriority(), \"Should only poll priority events\"));\n+\t\t\thasPriorityEvent = bufferOrEventOpt.map(BufferOrEvent::morePriorityEvents).orElse(false);\n \t\t}\n \n-\t\t// re-enqueue mail to process priority events\n+\t\t// re-enqueue mail to process future priority events\n \t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n \t}\n \n \tprivate void waitForPriorityEvents(InputGate inputGate, MailboxExecutor mailboxExecutor) {\n \t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputGate.getPriorityEventAvailableFuture();\n-\t\tpriorityEventAvailableFuture.thenRun(() -> {\n-\t\t\tmailboxExecutor.execute(this::processPriorityEvents, \"process priority event @ gate %s\", inputGate);\n-\t\t});\n+\t\tpriorityEventAvailableFuture.thenRun(() ->\n+\t\t\tmailboxExecutor.execute(this::processPriorityEvents, \"process priority event @ gate %s\", inputGate));\n \t}\n \n \t@Override\n"}}, {"oid": "74094b3c0206de0bad49bdb7526534a8c43a5934", "url": "https://github.com/apache/flink/commit/74094b3c0206de0bad49bdb7526534a8c43a5934", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T20:09:44Z", "type": "forcePushed"}, {"oid": "ea5c6962348cf666b6b787eb7fad0cbec497b9af", "url": "https://github.com/apache/flink/commit/ea5c6962348cf666b6b787eb7fad0cbec497b9af", "message": "fixup! [FLINK-19026][network] Moving priority event handling from BufferReceivedListener to CheckpointedInputGate.", "committedDate": "2020-09-22T21:23:28Z", "type": "forcePushed"}, {"oid": "ef87978fc0d3da0134ccf57eb144aeb456a5d345", "url": "https://github.com/apache/flink/commit/ef87978fc0d3da0134ccf57eb144aeb456a5d345", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T21:23:58Z", "type": "forcePushed"}, {"oid": "0f60b006208d03b78878334579ef2906951d9e36", "url": "https://github.com/apache/flink/commit/0f60b006208d03b78878334579ef2906951d9e36", "message": "[hotfix][network] Annotate NetworkSequenceViewReader#getNextBuffer as Nullable.", "committedDate": "2020-09-23T09:47:39Z", "type": "commit"}, {"oid": "3af229cf0709fecf357b9c91369c9f3e64c0696b", "url": "https://github.com/apache/flink/commit/3af229cf0709fecf357b9c91369c9f3e64c0696b", "message": "[FLINK-19338][connectors/common] Remove null-check from SourceCoordinatorContext#unregisterSourceReader.\n\nIf an error happens during startup, the reader may not be registered (yet), but cleanup is triggered anyways.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "2078a6dcf165d4ed7769af2b5d67697c4cd2a19c", "url": "https://github.com/apache/flink/commit/2078a6dcf165d4ed7769af2b5d67697c4cd2a19c", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "6a1cb4ca50c2629e9ae10b0d0c73414db7c574c2", "url": "https://github.com/apache/flink/commit/6a1cb4ca50c2629e9ae10b0d0c73414db7c574c2", "message": "[FLINK-19026][network] Adding priority events to buffer data type.\n\nIt generalizes the current special treatment of unaligned checkpoints and will allow a consistent treatment of priority events on both input and output.\nThe new type facilitates detection of priority events without the need to inspect the contents of a buffer on input side.\nIt also eases the special treatment of priority event on output side as the contextual priority flag is now inlined after the buffer has been created.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "24b8a5df5fe63fb9eaaf3753f691077e69f100b4", "url": "https://github.com/apache/flink/commit/24b8a5df5fe63fb9eaaf3753f691077e69f100b4", "message": "[FLINK-19026][network] Adding PrioritizedDeque and use it in PipelinedSubpartition.\n\nPrioritizedDeque supports enqueue elements with priority such that it will be polled after all existing priority elements but before any non-priority element.\nIt is a building block for fair scheduling with priority elevation that will be used also on input side in the next commits.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "d5cbd3e9bd08f311f53272b67c0935ab8cf28107", "url": "https://github.com/apache/flink/commit/d5cbd3e9bd08f311f53272b67c0935ab8cf28107", "message": "[FLINK-19026][network] Removing unnecessary priority flag on output side.\n\nThe priority information is fully incorporated in Buffer.DataType now.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "6f706554b8ee1db58b579bc4d4d6e1379b67a6d6", "url": "https://github.com/apache/flink/commit/6f706554b8ee1db58b579bc4d4d6e1379b67a6d6", "message": "[FLINK-19026][network] Generalizing BufferAndAvailability and BufferAndBacklog to capture the DataType of the next record.\n\nThe data type of the next record allows to check for availability, whether it's an event, and whether the event has a priority.\nIt also will allow handling future data types more smoothly.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "7ed17f2f8d8b67b72b0d453a006e7d26bfa54eaa", "url": "https://github.com/apache/flink/commit/7ed17f2f8d8b67b72b0d453a006e7d26bfa54eaa", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T09:47:42Z", "type": "forcePushed"}, {"oid": "3333fd4ca67be7345172128322ff1cf17951808f", "url": "https://github.com/apache/flink/commit/3333fd4ca67be7345172128322ff1cf17951808f", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T10:57:08Z", "type": "forcePushed"}, {"oid": "71efb8e87a3cd8adca13bf34dae610817136aa3f", "url": "https://github.com/apache/flink/commit/71efb8e87a3cd8adca13bf34dae610817136aa3f", "message": "[FLINK-19026][network] Move sequence number into PipelinedSubpartition and relay through BufferAndAvailability and BufferAndBacklog.\n\nThe sequence number will be used in input side to avoid spurious priority notification in later commits.", "committedDate": "2020-09-23T11:06:35Z", "type": "commit"}, {"oid": "3e46cb29622d4cff5a381afd90f68818d41c8004", "url": "https://github.com/apache/flink/commit/3e46cb29622d4cff5a381afd90f68818d41c8004", "message": "[FLINK-19026][network] Refactor SingleInputGate#waitAndGetNextData.\n\nBetter distinguishes between optional and non-optional variables. Add short cut for empty buffers.\nNext commit will build on this refactoring to incorporate priority events.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "99572b30742b436ca44cd9aa28578a0489b0534b", "url": "https://github.com/apache/flink/commit/99572b30742b436ca44cd9aa28578a0489b0534b", "message": "[hotfix][network] De-mockitofy InputGateFairnessTest.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "fa38f2e9e04564a67408961b74807eb8c97aa7c1", "url": "https://github.com/apache/flink/commit/fa38f2e9e04564a67408961b74807eb8c97aa7c1", "message": "[FLINK-19026][network] Simplify lock acquisition in InputGates while polling.\n\nThis is an alternative fix for FLINK-12510, where a cyclic deadlock can happen when a subpartition is being requested, another subpartition is freed, and data is being polled at the same time on an UnionInputGate. This fix avoids double-lock acquisition on polling by moving the availability notification for a newly acquired subpartitions outside of the lock of ResultPartitionManager. This change may trigger a availability notification on Subpartition without data being available, however, all relevant components are guarded against spurious wakeups.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "7bc29c9766689ee5ed9b7e62ecb9c4dfce70b7d0", "url": "https://github.com/apache/flink/commit/7bc29c9766689ee5ed9b7e62ecb9c4dfce70b7d0", "message": "[FLINK-19026][network] Using PrioritizedDeque on input side.\n\nPriorityDeque is also used in InputGates. BufferOrEvent and InputWithData are enriched with a flag indicating that there are more priority events.\n(Note relaying the DataType as on the output side would require lock acquisitions which are not warranted at this point in time)", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "76ea751d6d15829d8ed2e4717684aad81f5fc9ce", "url": "https://github.com/apache/flink/commit/76ea751d6d15829d8ed2e4717684aad81f5fc9ce", "message": "[FLINK-19026][network] Simplify output priority notification.\n\nBufferAvailabilityListener#notifyPriorityEvent now is a simple notification to avoid any kind of secondary data flow on output side as it was originally intended before.\nFor remote channels, notifyPriorityEvent behaves like an extra notifyDataAvailable call as an event is always pollable. For local channels, notifyPriorityEvent ultimately informs InputGate that the respective channel has a priority event.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "012c9a215468ad7f09605c618ffc9fc0d3b72f06", "url": "https://github.com/apache/flink/commit/012c9a215468ad7f09605c618ffc9fc0d3b72f06", "message": "[hotfix][network] Use IOExceptions where possible in CheckpointBarrierHandler.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "e126028005bbf5888aeff9eaa2346bc5afb67867", "url": "https://github.com/apache/flink/commit/e126028005bbf5888aeff9eaa2346bc5afb67867", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T11:07:00Z", "type": "forcePushed"}, {"oid": "bb6186d0fe5512241da664c3ce52e5104da77c12", "url": "https://github.com/apache/flink/commit/bb6186d0fe5512241da664c3ce52e5104da77c12", "message": "[FLINK-19026][network] Move spilling into channels.\n\nA future commit moves the Unaligner completely into task thread, which would result in late spilling of in-flight data during polling and potentially delay un\nBecause channels are now responsible for spilling in-flight data during unaligned checkpoint, in-flight data can be spilled as soon as the checkpoint has been.", "committedDate": "2020-09-23T11:09:02Z", "type": "commit"}, {"oid": "d509b2efe3603f3521ccb82a45096a4e1719ffd6", "url": "https://github.com/apache/flink/commit/d509b2efe3603f3521ccb82a45096a4e1719ffd6", "message": "[FLINK-19026][network] Moving priority event handling from BufferReceivedListener to CheckpointedInputGate.\n\nThis commit renders BufferReceivedListener obsolete and will allow a following commit to remove it entirely.\nA side-effect of this commit is that all events are handed over from CheckpointedInputGate to StreamTaskNetworkInput and break up the poll loop. However, since events are rare, it should have no visible impact on the throughput.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "7bd2390c24241e05cce6105927178584a208936c", "url": "https://github.com/apache/flink/commit/7bd2390c24241e05cce6105927178584a208936c", "message": "[FLINK-19026][checkpointing] Remove synchronization from CheckpointBarrierUnaligner.\n\nThis concludes the refactoring: All priority events use the same buffer hand-over as normal events; the buffers are just reordered.\nNotification of priority event bypasses CheckpointBarrierHandler and directly triggers CheckpointedInputGate#processPriorityEvents.\nNote that checkpoints are not cancelled anymore if Unaligner received all barriers. This behavior is now in line with Aligner.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "073b9f0e84b6823e8138985bdbf783838ca3c7ed", "url": "https://github.com/apache/flink/commit/073b9f0e84b6823e8138985bdbf783838ca3c7ed", "message": "[FLINK-19026][network/task] Remove unused BufferReceivedListener and\n\n AbstractInvokable#executeInTaskThread.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "url": "https://github.com/apache/flink/commit/36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "url": "https://github.com/apache/flink/commit/36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T11:09:18Z", "type": "forcePushed"}]}