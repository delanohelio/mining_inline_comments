{"pr_number": 14057, "pr_title": "[FLINK-19681][checkpointing] Timeout aligned checkpoints", "pr_createdAt": "2020-11-12T21:03:25Z", "pr_url": "https://github.com/apache/flink/pull/14057", "timeline": [{"oid": "bcd846138434e9990c388d970ff4d313c5099978", "url": "https://github.com/apache/flink/commit/bcd846138434e9990c388d970ff4d313c5099978", "message": "Revert \"(fixup) [FLINK-19681][checkpointing] Use time of start of alignment instead of checkpoint to timeout\"\n\nThis reverts commit 0236bbaabd478b18ab0e90497b8ec5d28cc4172f.", "committedDate": "2020-11-13T11:01:19Z", "type": "forcePushed"}, {"oid": "94b400f3a36ba2d65950b196a9d2650effb64cdc", "url": "https://github.com/apache/flink/commit/94b400f3a36ba2d65950b196a9d2650effb64cdc", "message": "Convert barrier to unaligned on announcement lest surprise UnalignedController", "committedDate": "2020-11-13T21:04:08Z", "type": "forcePushed"}, {"oid": "a0225769113bc5163d40f7dfa600f7636629a530", "url": "https://github.com/apache/flink/commit/a0225769113bc5163d40f7dfa600f7636629a530", "message": "[FLINK-20145][task] Don't expose modifiable PrioritizedDeque.iterator", "committedDate": "2020-11-14T23:17:20Z", "type": "forcePushed"}, {"oid": "6435a7da42247e8a59fc8bd3159470d761bd7127", "url": "https://github.com/apache/flink/commit/6435a7da42247e8a59fc8bd3159470d761bd7127", "message": "[FLINK-20145][task] Don't expose modifiable PrioritizedDeque.iterator", "committedDate": "2020-11-15T07:20:29Z", "type": "forcePushed"}, {"oid": "b3aa80f54805a5ca4b583c531c35aa64bf3d8d55", "url": "https://github.com/apache/flink/commit/b3aa80f54805a5ca4b583c531c35aa64bf3d8d55", "message": "[FLINK-19681][checkpointing] Don't timeout checkpoint on last barrier", "committedDate": "2020-12-03T09:53:44Z", "type": "forcePushed"}, {"oid": "3ecb27dc1ef7cb838d556c53aabb7bf327bc2491", "url": "https://github.com/apache/flink/commit/3ecb27dc1ef7cb838d556c53aabb7bf327bc2491", "message": "[refactor] Delegate option printing fully to CLIs\n\nBefore, the \"-t\" option was hardcoded in CliFrontendParser although that\noption comes from GenericCLI.\n\nNow, print printHelpForRunApplication() has the same signature and\nbehaviour as the other printHelp...() methods.\n\nThis lessens coupling but introduces the problem that we now filter\nmanually on the CLIs that support application mode in CliFrontendParser.\n\nIf we really wanted we could add a \"supportsApplicationMode()\" flag to\nCLIs but I think that would be pushing it a bit.", "committedDate": "2020-12-01T10:39:39Z", "type": "forcePushed"}, {"oid": "107985b487f186beaeddd7187a383fd268b997db", "url": "https://github.com/apache/flink/commit/107985b487f186beaeddd7187a383fd268b997db", "message": "[hotfix][checkpointing] Explicit creation of CheckpointOptions\n\nThe motivation is to eliminate subtle bugs when changing checkpoint\ntype on the fly.\n1. Only guess options when creating a new barrier from configuration\n2. For other cases provide explicit factory methods\n2. Carry the current checkpoint/barrier requirements instead of the\ninitial configuration.", "committedDate": "2020-12-03T11:31:43Z", "type": "forcePushed"}, {"oid": "e470bcdae1694f36a466767a457a54006432e5a8", "url": "https://github.com/apache/flink/commit/e470bcdae1694f36a466767a457a54006432e5a8", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-03T21:05:10Z", "type": "forcePushed"}, {"oid": "64f5b48580f748cc15bc7ee65db45dd937b4821a", "url": "https://github.com/apache/flink/commit/64f5b48580f748cc15bc7ee65db45dd937b4821a", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-04T09:41:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwMzY0NQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540103645", "bodyText": "optional nit: I would prefer to static import checkState for shorter code (we are using it frequently enough, that I think Preconditions.checkState is too verbose).", "author": "pnowojski", "createdAt": "2020-12-10T11:46:54Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "diffHunk": "@@ -23,6 +23,7 @@\n import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.CheckpointableInput;\n+import org.apache.flink.util.Preconditions;", "originalCommit": "3e08db569433493d0dc192ce5a1bed064d464f6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java\nindex 9d24522069..8f0e409abc 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java\n\n@@ -23,14 +23,10 @@ import org.apache.flink.runtime.checkpoint.CheckpointException;\n import org.apache.flink.runtime.checkpoint.channel.InputChannelInfo;\n import org.apache.flink.runtime.io.network.api.CheckpointBarrier;\n import org.apache.flink.runtime.io.network.partition.consumer.CheckpointableInput;\n-import org.apache.flink.util.Preconditions;\n \n import java.io.IOException;\n import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n import java.util.Map;\n-import java.util.Optional;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExMjg3OA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540112878", "bodyText": "Commit message is a bit misleading/out dated (pendingBarrier -> lastSeenBarrier). (also in a some of the following commits)", "author": "pnowojski", "createdAt": "2020-12-10T12:01:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java", "diffHunk": "@@ -88,16 +88,16 @@ protected void maybePersist(Buffer buffer) {\n \t}", "originalCommit": "c3bb1e044f3716d12abb0241589364889766fe82", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java\nindex 5742279be5..416c956462 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/ChannelStatePersister.java\n\n@@ -88,20 +89,14 @@ final class ChannelStatePersister {\n \t}\n \n \tprotected Optional<Long> checkForBarrier(Buffer buffer) throws IOException {\n-\t\tfinal AbstractEvent event = parseEvent(buffer);\n-\t\tif (event instanceof CheckpointBarrier) {\n-\t\t\tif (((CheckpointBarrier) event).getId() >= lastSeenBarrier) {\n+\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\tif (((CheckpointBarrier) priorityEvent).getId() >= lastSeenBarrier) {\n \t\t\t\tcheckpointStatus = CheckpointStatus.BARRIER_RECEIVED;\n-\t\t\t\tlastSeenBarrier = ((CheckpointBarrier) event).getId();\n+\t\t\t\tlastSeenBarrier = ((CheckpointBarrier) priorityEvent).getId();\n \t\t\t\treturn Optional.of(lastSeenBarrier);\n \t\t\t}\n \t\t}\n-\t\tif (event instanceof EventAnnouncement) { // NOTE: only remote channels\n-\t\t\tEventAnnouncement announcement = (EventAnnouncement) event;\n-\t\t\tif (announcement.getAnnouncedEvent() instanceof CheckpointBarrier) {\n-\t\t\t\treturn Optional.of(((CheckpointBarrier) announcement.getAnnouncedEvent()).getId());\n-\t\t\t}\n-\t\t}\n \t\treturn Optional.empty();\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNzQ1NA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540117454", "bodyText": "Can you add a unit test that would show/explain the problem?", "author": "pnowojski", "createdAt": "2020-12-10T12:09:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -229,11 +229,8 @@ public void run() {\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n-\t\tif (buffer.getDataType().hasPriority()) {\n-\t\t\tchannelStatePersister.checkForBarrier(buffer);\n-\t\t} else {\n-\t\t\tchannelStatePersister.maybePersist(buffer);\n-\t\t}\n+\t\tchannelStatePersister.checkForBarrier(buffer);\n+\t\tchannelStatePersister.maybePersist(buffer);", "originalCommit": "c3bb1e044f3716d12abb0241589364889766fe82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3Njg2Mw==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543676863", "bodyText": "I've added LocalInputChannelTest.testNoDataPersistedAfterReceivingAlignedBarrier.", "author": "rkhachatryan", "createdAt": "2020-12-15T20:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExNzQ1NA=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex 0fafb369ea..a0d69c5125 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n\n@@ -229,8 +229,11 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n-\t\tchannelStatePersister.checkForBarrier(buffer);\n-\t\tchannelStatePersister.maybePersist(buffer);\n+\t\tif (buffer.getDataType().hasPriority()) {\n+\t\t\tchannelStatePersister.checkForBarrier(buffer);\n+\t\t} else {\n+\t\t\tchannelStatePersister.maybePersist(buffer);\n+\t\t}\n \t\treturn Optional.of(new BufferAndAvailability(\n \t\t\tbuffer,\n \t\t\tnext.getNextDataType(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyMjk1Nw==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540122957", "bodyText": "ditto about a unit test? (What is the scenario that is working differently and how is it is supposed to be working)", "author": "pnowojski", "createdAt": "2020-12-10T12:18:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -451,11 +451,17 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n-\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tchannelStatePersister.checkForBarrier(sequenceBuffer.buffer).ifPresent(id -> {\n+\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+\t\t\t\t\tlastBarrierId = id;\n+\t\t\t\t});\n+\t\t\t\tchannelStatePersister.maybePersist(buffer);", "originalCommit": "c3bb1e044f3716d12abb0241589364889766fe82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODYyNw==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543678627", "bodyText": "I didn't add a unit test as after the other fixes in master (#14052) this change is not strictly necessary\n(though I think it's still less error-prone to not update SQN unnecessarily).", "author": "rkhachatryan", "createdAt": "2020-12-15T20:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyMjk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 101e2ab7b8..1992cdbd65 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -451,17 +451,11 @@ public class RemoteInputChannel extends InputChannel {\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n+\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tchannelStatePersister.checkForBarrier(sequenceBuffer.buffer).ifPresent(id -> {\n-\t\t\t\t\t// checkpoint was not yet started by task thread,\n-\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n-\t\t\t\t\tlastBarrierId = id;\n-\t\t\t\t});\n-\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t++expectedSequenceNumber;\n \t\t\t}\n \t\t\trecycleBuffer = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyNDc2NA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540124764", "bodyText": "ditto unit test", "author": "pnowojski", "createdAt": "2020-12-10T12:21:20Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java", "diffHunk": "@@ -120,6 +122,12 @@ public void obsoleteBarrierReceived(\n \t\tresumeConsumption(channelInfo);\n \t}\n \n+\tprotected void resetPendingCheckpoint(long cancelledId) {\n+\t\tfor (final CheckpointableInput input : inputs) {\n+\t\t\tinput.checkpointStopped(cancelledId);\n+\t\t}\n+\t}\n+", "originalCommit": "f066cdb9d50b0be0967d458581a855781b4e43ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3NTE1Mw==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543675153", "bodyText": "I've added AlternatingControllerTest.testChannelResetOnNewBarrier.", "author": "rkhachatryan", "createdAt": "2020-12-15T20:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEyNDc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java\nindex 10c69b4d83..8f0e409abc 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlignedController.java\n\n@@ -122,35 +86,16 @@ public class AlignedController implements CheckpointBarrierBehaviourController {\n \t\tresumeConsumption(channelInfo);\n \t}\n \n-\tprotected void resetPendingCheckpoint(long cancelledId) {\n-\t\tfor (final CheckpointableInput input : inputs) {\n-\t\t\tinput.checkpointStopped(cancelledId);\n-\t\t}\n-\t}\n-\n-\tpublic Collection<InputChannelInfo> getBlockedChannels() {\n-\t\treturn blockedChannels.entrySet()\n-\t\t\t.stream()\n-\t\t\t.filter(entry -> entry.getValue())\n-\t\t\t.map(entry -> entry.getKey())\n-\t\t\t.collect(Collectors.toSet());\n-\t}\n-\n-\tpublic Map<InputChannelInfo, Integer> getSequenceNumberInAnnouncedChannels() {\n-\t\treturn new HashMap<>(sequenceNumberInAnnouncedChannels);\n-\t}\n-\n-\tpublic void resumeConsumption() throws IOException {\n+\tprivate void resumeConsumption() throws IOException {\n \t\tfor (Map.Entry<InputChannelInfo, Boolean> blockedChannel : blockedChannels.entrySet()) {\n \t\t\tif (blockedChannel.getValue()) {\n \t\t\t\tresumeConsumption(blockedChannel.getKey());\n \t\t\t}\n \t\t\tblockedChannel.setValue(false);\n \t\t}\n-\t\tsequenceNumberInAnnouncedChannels.clear();\n \t}\n \n-\tvoid resumeConsumption(InputChannelInfo channelInfo) throws IOException {\n+\tprivate void resumeConsumption(InputChannelInfo channelInfo) throws IOException {\n \t\tCheckpointableInput input = inputs[channelInfo.getGateIdx()];\n \t\tinput.resumeConsumption(channelInfo);\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540249176", "bodyText": "I'm not entirely convinced if this a better approach.\nFor me, using global checkpoint time (in other words recently added checkpoinStartDelay metric) seemed easier to understand for the user. If aligned checkpoint barrier is taking too much time to reach given tasks - we are timeouting it to unaligned checkpoint that overtakes in-flight data. This seemed easier to comprehend and easier to explain  compared to time outing alignment on some subtask?\nSecondly your proposed change will not work with single input tasks without active timeouts?", "author": "pnowojski", "createdAt": "2020-12-10T15:13:53Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -193,6 +202,11 @@ private CheckpointBarrierBehaviourController chooseController(CheckpointBarrier\n \n \tprivate boolean canTimeout(CheckpointBarrier barrier) {\n \t\treturn barrier.getCheckpointOptions().isTimeoutable() &&\n-\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() < (System.currentTimeMillis() - barrier.getTimestamp());\n+\t\t\tbarrier.getId() <= lastSeenBarrier &&\n+\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() * 1_000_000 < (System.nanoTime() - firstBarrierArrivalTime);\n+\t}\n+\n+\tprivate long getArrivalTime(CheckpointBarrier announcedBarrier) {\n+\t\treturn announcedBarrier.getCheckpointOptions().isTimeoutable() ? System.nanoTime() : Long.MAX_VALUE;", "originalCommit": "781e25d56e06bcf4668470a393c1caeb35944e33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzODIzMg==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540438232", "bodyText": "easier to understand\n\nI agree that it might be true for some users, but not for all. During the previous discussion, and also the one before, the consensus was that it's not easier to understand. However, we can discuss it again.\n(also there are some more technical advantages of \"local\" timeouts)\n\nSecondly your proposed change will not work with single input tasks without active timeouts?\n\nWhy, could you explain?", "author": "rkhachatryan", "createdAt": "2020-12-10T19:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NDIwOQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540854209", "bodyText": "Why, could you explain?\n\nOn a second thought, maybe it will partially, but not fully as well.  guess we still have the code, that we can timeout to UC on the last processed barrier? So in case of single channel:\n\nannouncement is processed (first announcement will never timeout in this version) it won't timeout\nbarrier will be processed, and only it can timeout\n\nSo a timeout on the first network exchange will work worse. That's a bit problematic, especially for simple jobs, with for example just a single exchange. Previous version would cut the checkpointing time by half, this version will do worse than that, in a way that's hard to quantify for me.\nThere is some extreme corner case when imagine there is a heavy back pressure, but all CB are processed at the same time. That means announcements in this version wouldn't cause timeout (it would in my older proposal), and this version will need to wait for some CB to be processed (which can take long time).\nActive timeout would alleviate this problem though.", "author": "pnowojski", "createdAt": "2020-12-11T10:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3ODgzMQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543278831", "bodyText": "With a single input, this is not an alignment issue but a (related) back-pressure issue. And I think this is the right way to solve it:\n\nActive timeout would alleviate this problem though.", "author": "rkhachatryan", "createdAt": "2020-12-15T11:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0OTE3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\nindex 19ed640085..eb302ceaf0 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\n\n@@ -195,18 +89,4 @@ public class AlternatingController implements CheckpointBarrierBehaviourControll\n \tprivate CheckpointBarrierBehaviourController chooseController(CheckpointBarrier barrier) {\n \t\treturn isAligned(barrier) ? alignedController : unalignedController;\n \t}\n-\n-\tprivate Optional<CheckpointBarrier> asTimedOut(CheckpointBarrier barrier) {\n-\t\treturn Optional.of(barrier).filter(this::canTimeout).map(CheckpointBarrier::asUnaligned);\n-\t}\n-\n-\tprivate boolean canTimeout(CheckpointBarrier barrier) {\n-\t\treturn barrier.getCheckpointOptions().isTimeoutable() &&\n-\t\t\tbarrier.getId() <= lastSeenBarrier &&\n-\t\t\tbarrier.getCheckpointOptions().getAlignmentTimeout() * 1_000_000 < (System.nanoTime() - firstBarrierArrivalTime);\n-\t}\n-\n-\tprivate long getArrivalTime(CheckpointBarrier announcedBarrier) {\n-\t\treturn announcedBarrier.getCheckpointOptions().isTimeoutable() ? System.nanoTime() : Long.MAX_VALUE;\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540250869", "bodyText": "?\nWhy is it not enough to do this in preProcessFirstBarrierOrAnnouncement?\n(as in other places: a unit test would be helpful)", "author": "pnowojski", "createdAt": "2020-12-10T15:15:56Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -114,6 +114,7 @@ public void barrierAnnouncement(\n \t\t\tlastSeenBarrier = barrier.getId();\n \t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n \t\t}\n+\t\tactiveController = chooseController(barrier);", "originalCommit": "8317386822507ae18c796b34c886aca0e1c8b351", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyODg3NQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540428875", "bodyText": "Consider a checkpoint with two barriers from two channels: UC and AC:\n\nProcess AC announcement. Set SingleCheckpointBarrierHandler.currentCheckpointId. Don't timeout.\nProcess UC barrier (no announcements). Because currentCheckpointId was set checkSubsumedCheckpoint does nothing, i.e. preProcessFirstBarrierOrAnnouncement not called and controller so activeController == AC\nFurther process (UC) barrier - now AC controller is processing UC barrier\n\n\n(as in other places: a unit test would be helpful)\n\nI agree, will add it.", "author": "rkhachatryan", "createdAt": "2020-12-10T19:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1ODYxOQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540858619", "bodyText": "But doesn't it mean we should support time outing on every UC barrier? And it looks like we are doing that:\n\t@Override\n\tpublic Optional<CheckpointBarrier> barrierReceived(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint() && activeController == alignedController) {\n\t\t\tbarrier = barrier.asUnaligned();\n\t\t\tswitchToUnaligned(channelInfo, barrier);\n\t\t\tactiveController.barrierReceived(channelInfo, barrier);\n\t\t\treturn Optional.of(barrier);\n\t\t}", "author": "pnowojski", "createdAt": "2020-12-11T10:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI4MDAwNA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543280004", "bodyText": "But there is a preProcessFirstBarrier before the switch in barrierReceived.", "author": "rkhachatryan", "createdAt": "2020-12-15T11:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3NTg1MQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543675851", "bodyText": "I've added AlternatingControllerTest.testSwitchToUnalignedByUpstream.", "author": "rkhachatryan", "createdAt": "2020-12-15T20:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwNzQ5OA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544407498", "bodyText": "I still don't get this fix.\n\nBut there is a preProcessFirstBarrier before the switch in barrierReceived.\n\nYes, but my intention was that in that case, preProcessFirstBarrier would be called on the AlignedController. Next on the first barrier, we would switch to unaligned controller, which is doing this:\n\t\t// alignedController might has already processed some barriers, so \"migrate\"/forward those calls to unalignedController.\n\t\tunalignedController.preProcessFirstBarrier(channelInfo, barrier);\n\t\tfor (InputChannelInfo blockedChannel : blockedChannels) {\n\t\t\tunalignedController.barrierReceived(blockedChannel, barrier);\n\t\t}\n\nso preProcessFirstBarrier would be eventually called on the unaligned controller.", "author": "pnowojski", "createdAt": "2020-12-16T15:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\nindex 375e83a231..eb302ceaf0 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\n\n@@ -50,124 +44,23 @@ public class AlternatingController implements CheckpointBarrierBehaviourControll\n \t}\n \n \t@Override\n-\tpublic void preProcessFirstBarrierOrAnnouncement(CheckpointBarrier barrier) {\n-\t\tactiveController = chooseController(barrier);\n-\t\tactiveController.preProcessFirstBarrierOrAnnouncement(barrier);\n+\tpublic void barrierReceived(InputChannelInfo channelInfo, CheckpointBarrier barrier) {\n+\t\tcheckActiveController(barrier);\n+\t\tactiveController.barrierReceived(channelInfo, barrier);\n \t}\n \n \t@Override\n-\tpublic void barrierAnnouncement(\n-\t\t\tInputChannelInfo channelInfo,\n-\t\t\tCheckpointBarrier announcedBarrier,\n-\t\t\tint sequenceNumber) throws IOException {\n-\t\tif (lastSeenBarrier < announcedBarrier.getId()) {\n-\t\t\tlastSeenBarrier = announcedBarrier.getId();\n-\t\t\tfirstBarrierArrivalTime = getArrivalTime(announcedBarrier);\n-\t\t}\n-\n-\t\tOptional<CheckpointBarrier> maybeTimedOut = asTimedOut(announcedBarrier);\n-\t\tannouncedBarrier = maybeTimedOut.orElse(announcedBarrier);\n-\n-\t\tif (maybeTimedOut.isPresent() && activeController != unalignedController) {\n-\t\t\t// Let's timeout this barrier\n-\t\t\tunalignedController.barrierAnnouncement(channelInfo, announcedBarrier, sequenceNumber);\n-\t\t}\n-\t\telse {\n-\t\t\t// Either we have already timed out before, or we are still going with aligned checkpoints\n-\t\t\tactiveController.barrierAnnouncement(channelInfo, announcedBarrier, sequenceNumber);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Optional<CheckpointBarrier> barrierReceived(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint() && activeController == alignedController) {\n-\t\t\tbarrier = barrier.asUnaligned();\n-\t\t\tswitchToUnaligned(channelInfo, barrier);\n-\t\t\tactiveController.barrierReceived(channelInfo, barrier);\n-\t\t\treturn Optional.of(barrier);\n-\t\t}\n-\n-\t\tOptional<CheckpointBarrier> maybeTimedOut = asTimedOut(barrier);\n-\t\tbarrier = maybeTimedOut.orElse(barrier);\n-\n-\t\tcheckState(!activeController.barrierReceived(channelInfo, barrier).isPresent());\n-\n-\t\tif (maybeTimedOut.isPresent()) {\n-\t\t\tif (activeController == alignedController) {\n-\t\t\t\tswitchToUnaligned(channelInfo, maybeTimedOut.get());\n-\t\t\t\treturn maybeTimedOut;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\talignedController.resumeConsumption(channelInfo);\n-\t\t\t}\n-\t\t} else if (!barrier.getCheckpointOptions().isUnalignedCheckpoint() && activeController == unalignedController) {\n-\t\t\talignedController.resumeConsumption(channelInfo);\n-\t\t}\n-\t\treturn Optional.empty();\n-\t}\n-\n-\t@Override\n-\tpublic Optional<CheckpointBarrier> preProcessFirstBarrier(\n+\tpublic boolean preProcessFirstBarrier(\n \t\t\tInputChannelInfo channelInfo,\n \t\t\tCheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tif (lastSeenBarrier < barrier.getId()) {\n-\t\t\tlastSeenBarrier = barrier.getId();\n-\t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n-\t\t}\n \t\tactiveController = chooseController(barrier);\n \t\treturn activeController.preProcessFirstBarrier(channelInfo, barrier);\n \t}\n \n-\tprivate void switchToUnaligned(\n-\t\t\tInputChannelInfo channelInfo,\n-\t\t\tCheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tcheckState(alignedController == activeController);\n-\n-\t\t// timeout all not yet processed barriers for which alignedController has processed an announcement\n-\t\tfor (Map.Entry<InputChannelInfo, Integer> entry : alignedController.getSequenceNumberInAnnouncedChannels().entrySet()) {\n-\t\t\tInputChannelInfo unProcessedChannelInfo = entry.getKey();\n-\t\t\tint announcedBarrierSequenceNumber = entry.getValue();\n-\t\t\tunalignedController.barrierAnnouncement(unProcessedChannelInfo, barrier, announcedBarrierSequenceNumber);\n-\t\t}\n-\n-\t\t// get blocked channels before resuming consumption\n-\t\tCollection<InputChannelInfo> blockedChannels = alignedController.getBlockedChannels();\n-\n-\t\tactiveController = unalignedController;\n-\n-\t\t// alignedController might has already processed some barriers, so \"migrate\"/forward those calls to unalignedController.\n-\t\tunalignedController.preProcessFirstBarrier(channelInfo, barrier);\n-\t\tfor (InputChannelInfo blockedChannel : blockedChannels) {\n-\t\t\tunalignedController.barrierReceived(blockedChannel, barrier);\n-\t\t}\n-\n-\t\talignedController.resumeConsumption();\n-\t}\n-\n \t@Override\n-\tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tOptional<CheckpointBarrier> maybeTimeOut = asTimedOut(barrier);\n-\t\tif (maybeTimeOut.isPresent() && activeController == alignedController) {\n-\t\t\tswitchToUnaligned(channelInfo, maybeTimeOut.get());\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn maybeTimeOut;\n-\t\t}\n-\n-\t\tbarrier = maybeTimeOut.orElse(barrier);\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint()) {\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\telse {\n-\t\t\tcheckState(activeController == alignedController);\n-\t\t\tOptional<CheckpointBarrier> triggerResult = activeController.postProcessLastBarrier(\n-\t\t\t\tchannelInfo,\n-\t\t\t\tbarrier);\n-\t\t\tcheckState(triggerResult.isPresent());\n-\t\t\treturn triggerResult;\n-\t\t}\n+\tpublic boolean postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException {\n+\t\tcheckActiveController(barrier);\n+\t\treturn activeController.postProcessLastBarrier(channelInfo, barrier);\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540255278", "bodyText": "Why have you removed this code? What was the problem?\nWas it subsumed by switchToUnaligned  call happening in the last barrierReceived call?", "author": "pnowojski", "createdAt": "2020-12-10T15:21:15Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java", "diffHunk": "@@ -146,28 +146,7 @@ private void switchToUnaligned(\n \n \t@Override\n \tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tOptional<CheckpointBarrier> maybeTimeOut = asTimedOut(barrier);\n-\t\tif (maybeTimeOut.isPresent() && activeController == alignedController) {\n-\t\t\tswitchToUnaligned(channelInfo, maybeTimeOut.get());\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn maybeTimeOut;\n-\t\t}\n-\n-\t\tbarrier = maybeTimeOut.orElse(barrier);\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint()) {\n-\t\t\tcheckState(activeController == unalignedController);\n-\t\t\tcheckState(!activeController.postProcessLastBarrier(channelInfo, maybeTimeOut.orElse(barrier)).isPresent());\n-\t\t\treturn Optional.empty();\n-\t\t}\n-\t\telse {\n-\t\t\tcheckState(activeController == alignedController);\n-\t\t\tOptional<CheckpointBarrier> triggerResult = activeController.postProcessLastBarrier(\n-\t\t\t\tchannelInfo,\n-\t\t\t\tbarrier);\n-\t\t\tcheckState(triggerResult.isPresent());\n-\t\t\treturn triggerResult;\n-\t\t}", "originalCommit": "a28800009950ce82faf214cfd2540d92d858089d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NDQ3NQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540444475", "bodyText": "Yes, with switchToUnaligned in barrierReceived it seems unnecessary.\nWith this code, UnalignedCheckpointITCase fails: some tests on checkState (line 164 above), some hanging up.\nBesides, why timeout alignment if it's the last barrier? This essentially means that alignment is done.", "author": "rkhachatryan", "createdAt": "2020-12-10T19:38:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1OTc0Mg==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540859742", "bodyText": "Besides, why timeout alignment if it's the last barrier? This essentially means that alignment is done.\n\nThe alignment is done, but that's just input. As we do not have code to timeout outputs, it's better to timeout to UC even if the alignment was completed (although too late). Think especially about a case with just a single input channel.", "author": "pnowojski", "createdAt": "2020-12-11T10:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI4MzA2MQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543283061", "bodyText": "Isn't it enough to just convert the barrier upon triggering checkpoint in subtask?\nThis is what I've done in [FLINK-19681][checkpointing] Use converted barrier after disabling alignment. It is needed anyways for correct handling in SubtaskCheckpointCoordinatorImpl.", "author": "rkhachatryan", "createdAt": "2020-12-15T11:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NTI3OA=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\nindex 734f2aa315..eb302ceaf0 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/AlternatingController.java\n\n@@ -50,102 +44,22 @@ public class AlternatingController implements CheckpointBarrierBehaviourControll\n \t}\n \n \t@Override\n-\tpublic void preProcessFirstBarrierOrAnnouncement(CheckpointBarrier barrier) {\n-\t\tactiveController = chooseController(barrier);\n-\t\tactiveController.preProcessFirstBarrierOrAnnouncement(barrier);\n-\t}\n-\n-\t@Override\n-\tpublic void barrierAnnouncement(\n-\t\t\tInputChannelInfo channelInfo,\n-\t\t\tCheckpointBarrier announcedBarrier,\n-\t\t\tint sequenceNumber) throws IOException {\n-\t\tif (lastSeenBarrier < announcedBarrier.getId()) {\n-\t\t\tlastSeenBarrier = announcedBarrier.getId();\n-\t\t\tfirstBarrierArrivalTime = getArrivalTime(announcedBarrier);\n-\t\t}\n-\n-\t\tOptional<CheckpointBarrier> maybeTimedOut = asTimedOut(announcedBarrier);\n-\t\tannouncedBarrier = maybeTimedOut.orElse(announcedBarrier);\n-\n-\t\tif (maybeTimedOut.isPresent() && activeController != unalignedController) {\n-\t\t\t// Let's timeout this barrier\n-\t\t\tunalignedController.barrierAnnouncement(channelInfo, announcedBarrier, sequenceNumber);\n-\t\t}\n-\t\telse {\n-\t\t\t// Either we have already timed out before, or we are still going with aligned checkpoints\n-\t\t\tactiveController.barrierAnnouncement(channelInfo, announcedBarrier, sequenceNumber);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Optional<CheckpointBarrier> barrierReceived(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tif (barrier.getCheckpointOptions().isUnalignedCheckpoint() && activeController == alignedController) {\n-\t\t\tbarrier = barrier.asUnaligned();\n-\t\t\tswitchToUnaligned(channelInfo, barrier);\n-\t\t\tactiveController.barrierReceived(channelInfo, barrier);\n-\t\t\treturn Optional.of(barrier);\n-\t\t}\n-\n-\t\tOptional<CheckpointBarrier> maybeTimedOut = asTimedOut(barrier);\n-\t\tbarrier = maybeTimedOut.orElse(barrier);\n-\n-\t\tcheckState(!activeController.barrierReceived(channelInfo, barrier).isPresent());\n-\n-\t\tif (maybeTimedOut.isPresent()) {\n-\t\t\tif (activeController == alignedController) {\n-\t\t\t\tswitchToUnaligned(channelInfo, maybeTimedOut.get());\n-\t\t\t\treturn maybeTimedOut;\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\talignedController.resumeConsumption(channelInfo);\n-\t\t\t}\n-\t\t} else if (!barrier.getCheckpointOptions().isUnalignedCheckpoint() && activeController == unalignedController) {\n-\t\t\talignedController.resumeConsumption(channelInfo);\n-\t\t}\n-\t\treturn Optional.empty();\n+\tpublic void barrierReceived(InputChannelInfo channelInfo, CheckpointBarrier barrier) {\n+\t\tcheckActiveController(barrier);\n+\t\tactiveController.barrierReceived(channelInfo, barrier);\n \t}\n \n \t@Override\n-\tpublic Optional<CheckpointBarrier> preProcessFirstBarrier(\n+\tpublic boolean preProcessFirstBarrier(\n \t\t\tInputChannelInfo channelInfo,\n \t\t\tCheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tif (lastSeenBarrier < barrier.getId()) {\n-\t\t\tlastSeenBarrier = barrier.getId();\n-\t\t\tfirstBarrierArrivalTime = getArrivalTime(barrier);\n-\t\t}\n \t\tactiveController = chooseController(barrier);\n \t\treturn activeController.preProcessFirstBarrier(channelInfo, barrier);\n \t}\n \n-\tprivate void switchToUnaligned(\n-\t\t\tInputChannelInfo channelInfo,\n-\t\t\tCheckpointBarrier barrier) throws IOException, CheckpointException {\n-\t\tcheckState(alignedController == activeController);\n-\n-\t\t// timeout all not yet processed barriers for which alignedController has processed an announcement\n-\t\tfor (Map.Entry<InputChannelInfo, Integer> entry : alignedController.getSequenceNumberInAnnouncedChannels().entrySet()) {\n-\t\t\tInputChannelInfo unProcessedChannelInfo = entry.getKey();\n-\t\t\tint announcedBarrierSequenceNumber = entry.getValue();\n-\t\t\tunalignedController.barrierAnnouncement(unProcessedChannelInfo, barrier, announcedBarrierSequenceNumber);\n-\t\t}\n-\n-\t\t// get blocked channels before resuming consumption\n-\t\tCollection<InputChannelInfo> blockedChannels = alignedController.getBlockedChannels();\n-\n-\t\tactiveController = unalignedController;\n-\n-\t\t// alignedController might has already processed some barriers, so \"migrate\"/forward those calls to unalignedController.\n-\t\tunalignedController.preProcessFirstBarrier(channelInfo, barrier);\n-\t\tfor (InputChannelInfo blockedChannel : blockedChannels) {\n-\t\t\tunalignedController.barrierReceived(blockedChannel, barrier);\n-\t\t}\n-\n-\t\talignedController.resumeConsumption();\n-\t}\n-\n \t@Override\n-\tpublic Optional<CheckpointBarrier> postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException, CheckpointException {\n+\tpublic boolean postProcessLastBarrier(InputChannelInfo channelInfo, CheckpointBarrier barrier) throws IOException {\n+\t\tcheckActiveController(barrier);\n \t\treturn activeController.postProcessLastBarrier(channelInfo, barrier);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NzgzOQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540257839", "bodyText": "part of a previous fixup?", "author": "pnowojski", "createdAt": "2020-12-10T15:24:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java", "diffHunk": "@@ -119,6 +119,6 @@ public boolean isCheckpoint() {\n \t}\n \n \tpublic CheckpointBarrier asUnaligned() {\n-\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().asTimedOut());\n+\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().toUnaligned());", "originalCommit": "d17f1c3fdc7bdf4632f58d7d52150f45f5cb11cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0NjU4Mw==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540446583", "bodyText": "No, I think it belongs to the right commit. With CheckpointOptions hotfix/refactoring, this method converts it to unaligned, which can't be timed out.", "author": "rkhachatryan", "createdAt": "2020-12-10T19:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1NzgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java\nindex e7e78e47b9..2ff1632841 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java\n\n@@ -117,8 +117,4 @@ public class CheckpointBarrier extends RuntimeEvent {\n \tpublic boolean isCheckpoint() {\n \t\treturn !checkpointOptions.getCheckpointType().isSavepoint();\n \t}\n-\n-\tpublic CheckpointBarrier asUnaligned() {\n-\t\treturn checkpointOptions.isUnalignedCheckpoint() ? this : new CheckpointBarrier(getId(), getTimestamp(), getCheckpointOptions().toUnaligned());\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2MjU1NA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r540262554", "bodyText": "nit: I don't understand this comment, can you rephrase/elaborate a bit?", "author": "pnowojski", "createdAt": "2020-12-10T15:29:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -569,14 +569,23 @@ public void convertToPriorityEvent(int sequenceNumber) throws IOException {\n \t\t\t\t\"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n \t\t\t\ttoPrioritize,\n \t\t\t\tnumPriorityElementsBeforeRemoval);\n+\t\t\t// set the priority flag (checked on poll)\n+\t\t\t// don't convert the barrier itself (barrier controller might not have been switched yet)\n+\t\t\tAbstractEvent e = EventSerializer.fromBuffer(toPrioritize.buffer, this.getClass().getClassLoader());\n+\t\t\ttoPrioritize.buffer.setReaderIndex(0);\n+\t\t\ttoPrioritize = new SequenceBuffer(EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n \t\t\tfirstPriorityEvent = addPriorityBuffer(toPrioritize); \t// note that only position of the element is changed\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// converting the event itself would require switching the controller sooner\n \t\t}\n \t\tif (firstPriorityEvent) {\n-\t\t\tnotifyPriorityEvent(sequenceNumber);\n+\t\t\tnotifyPriorityEventForce(); // use force here because the barrier SQN might be seen by gate during the announcement", "originalCommit": "64f5b48580f748cc15bc7ee65db45dd937b4821a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3NjM3NQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r543676375", "bodyText": "Rephrased as:\n// forcibly notify about the priority event\n// instead of passing barrier SQN to be checked\n// because this SQN might have be seen by the input gate during the announcement", "author": "rkhachatryan", "createdAt": "2020-12-15T20:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2MjU1NA=="}], "type": "inlineReview", "revised_code": {"commit": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex a36cd15f02..1992cdbd65 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -554,38 +533,6 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\t@Override\n-\tpublic void convertToPriorityEvent(int sequenceNumber) throws IOException {\n-\t\tboolean firstPriorityEvent;\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(channelStatePersister.hasBarrierReceived());\n-\t\t\tint numPriorityElementsBeforeRemoval = receivedBuffers.getNumPriorityElements();\n-\t\t\tSequenceBuffer toPrioritize = receivedBuffers.getAndRemove(\n-\t\t\t\tsequenceBuffer -> sequenceBuffer.sequenceNumber == sequenceNumber);\n-\t\t\tcheckState(lastBarrierSequenceNumber == sequenceNumber);\n-\t\t\tcheckState(!toPrioritize.buffer.isBuffer());\n-\t\t\tcheckState(\n-\t\t\t\tnumPriorityElementsBeforeRemoval == receivedBuffers.getNumPriorityElements(),\n-\t\t\t\t\"Attempted to convertToPriorityEvent an event [%s] that has already been prioritized [%s]\",\n-\t\t\t\ttoPrioritize,\n-\t\t\t\tnumPriorityElementsBeforeRemoval);\n-\t\t\t// set the priority flag (checked on poll)\n-\t\t\t// don't convert the barrier itself (barrier controller might not have been switched yet)\n-\t\t\tAbstractEvent e = EventSerializer.fromBuffer(toPrioritize.buffer, this.getClass().getClassLoader());\n-\t\t\ttoPrioritize.buffer.setReaderIndex(0);\n-\t\t\ttoPrioritize = new SequenceBuffer(EventSerializer.toBuffer(e, true), toPrioritize.sequenceNumber);\n-\t\t\tfirstPriorityEvent = addPriorityBuffer(toPrioritize); \t// note that only position of the element is changed\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// converting the event itself would require switching the controller sooner\n-\t\t}\n-\t\tif (firstPriorityEvent) {\n-\t\t\tnotifyPriorityEventForce(); // use force here because the barrier SQN might be seen by gate during the announcement\n-\t\t}\n-\t}\n-\n-\tprivate void notifyPriorityEventForce() {\n-\t\tinputGate.notifyPriorityEventForce(this);\n-\t}\n-\n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n"}}, {"oid": "334d437db83c7e4cdc1085cc568b1a7f134f047a", "url": "https://github.com/apache/flink/commit/334d437db83c7e4cdc1085cc568b1a7f134f047a", "message": "[hotfix][test] Improve error message in ValidatingCheckpointHandler", "committedDate": "2020-12-15T19:33:08Z", "type": "commit"}, {"oid": "293fa78e92782f7c57d6bbc955a9492632e74944", "url": "https://github.com/apache/flink/commit/293fa78e92782f7c57d6bbc955a9492632e74944", "message": "[hotfix][test] Fix StreamConfig propagation to StreamTask in StreamTaskMailboxTestHarnessBuilder", "committedDate": "2020-12-15T19:33:08Z", "type": "commit"}, {"oid": "cbce4fc8b854e23dc7128b161336dc09e2d81e03", "url": "https://github.com/apache/flink/commit/cbce4fc8b854e23dc7128b161336dc09e2d81e03", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-15T19:33:08Z", "type": "forcePushed"}, {"oid": "c98b6606d03656b144f18c76a8af8b14c0b65b17", "url": "https://github.com/apache/flink/commit/c98b6606d03656b144f18c76a8af8b14c0b65b17", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-15T20:20:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM3NzExNA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544377114", "bodyText": "And what about test coverage for  those changes?\nSide question, shouldn't those two fixes be separate commits?", "author": "pnowojski", "createdAt": "2020-12-16T15:11:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -451,11 +451,20 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n-\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tchannelStatePersister\n+\t\t\t\t\t.checkForBarrier(sequenceBuffer.buffer)\n+\t\t\t\t\t.filter(id -> id > lastBarrierId)\n+\t\t\t\t\t.ifPresent(id -> {\n+\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\tlastBarrierId = id;\n+\t\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n+\t\t\t\t\t});\n+\t\t\t\tchannelStatePersister.maybePersist(buffer);", "originalCommit": "1bc2357282481837865c7c16a8d46e08a35a0b50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2NTEyNQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544865125", "bodyText": "Side question, shouldn't those two fixes be separate commits?\n\nThey were in the beginning, but it seemed to me just way too many commits :) So I tried to group some related changes. I can extract it if you prefer.\n\nAnd what about test coverage for those changes?\n\nAs noted above\n\nI didn't add a unit test as after the other fixes in master (#14052) this change is not strictly necessary\n(though I think it's still less error-prone to not update SQN unnecessarily).", "author": "rkhachatryan", "createdAt": "2020-12-17T07:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM3NzExNA=="}], "type": "inlineReview", "revised_code": {"commit": "b6fbb7d193e03d325ad2dc4ab2369826cf3be069", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c012766678..1992cdbd65 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -451,20 +451,11 @@ public class RemoteInputChannel extends InputChannel {\n \t\t\t\t}\n \t\t\t\telse {\n \t\t\t\t\treceivedBuffers.add(sequenceBuffer);\n+\t\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t\tif (dataType.requiresAnnouncement()) {\n \t\t\t\t\t\tfirstPriorityEvent = addPriorityBuffer(announce(sequenceBuffer));\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tchannelStatePersister\n-\t\t\t\t\t.checkForBarrier(sequenceBuffer.buffer)\n-\t\t\t\t\t.filter(id -> id > lastBarrierId)\n-\t\t\t\t\t.ifPresent(id -> {\n-\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n-\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\t\t\t\tlastBarrierId = id;\n-\t\t\t\t\t\tlastBarrierSequenceNumber = sequenceBuffer.sequenceNumber;\n-\t\t\t\t\t});\n-\t\t\t\tchannelStatePersister.maybePersist(buffer);\n \t\t\t\t++expectedSequenceNumber;\n \t\t\t}\n \t\t\trecycleBuffer = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NTg1NA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544395854", "bodyText": "Otherwise, channels may capture in-flight buffers from an older checkpoint\n\nIs this test actually checking for that? I do not see any buffer that would belong to an older checkpoint?\n(I think I still do not understand this fix)", "author": "pnowojski", "createdAt": "2020-12-16T15:34:21Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -68,6 +68,22 @@\n  */\n public class AlternatingControllerTest {\n \n+\t/**\n+\t * Upon subsuming (or canceling) a checkpoint, channels should be notified regardless of whether UC controller is\n+\t * currently being used or not. Otherwise, channels may capture in-flight buffers from an older checkpoint.", "originalCommit": "007d12dad11d4b24f24bebf6388f273a54b7c1f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg2ODAzOQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544868039", "bodyText": "Sorry, my bad, I didn't update the comment after updating the test.\nIt checks whether the buffer (on the other channel) was captured or not. I'll update the comment.", "author": "rkhachatryan", "createdAt": "2020-12-17T07:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NTg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "ababe2b0e179a44c59cd0a3b6909a3a79c10a8f5", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\nindex fdc839343a..2f9413d4d2 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\n\n@@ -70,7 +72,7 @@ public class AlternatingControllerTest {\n \n \t/**\n \t * Upon subsuming (or canceling) a checkpoint, channels should be notified regardless of whether UC controller is\n-\t * currently being used or not. Otherwise, channels may capture in-flight buffers from an older checkpoint.\n+\t * currently being used or not. Otherwise, channels may not capture in-flight buffers.\n \t */\n \t@Test\n \tpublic void testChannelResetOnNewBarrier() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTQ0NA==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544401444", "bodyText": "* If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n\t * then it should be processed by the UC controller.\n\n->\n\t * If a checkpoint announcement was processed from one channel and then UC-barrier arrives \n\t * on another channel, this UC barrier should be processed by the UC controller.\n\n?", "author": "pnowojski", "createdAt": "2020-12-16T15:41:01Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -84,6 +84,24 @@ public void testChannelResetOnNewBarrier() throws Exception {\n \t\tassertFalse(stateWriter.getAddedInput().isEmpty());\n \t}\n \n+\t/**\n+\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n+\t * then it should be processed by the UC controller.", "originalCommit": "8bf08a45c31dacf497440b2cc889ccb7bef95cce", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ababe2b0e179a44c59cd0a3b6909a3a79c10a8f5", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\nindex c433b6121f..2f9413d4d2 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\n\n@@ -85,8 +87,8 @@ public class AlternatingControllerTest {\n \t}\n \n \t/**\n-\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n-\t * then it should be processed by the UC controller.\n+\t * If a checkpoint announcement was processed from one channel and then UC-barrier arrives\n+\t * on another channel, this UC barrier should be processed by the UC controller.\n \t */\n \t@Test\n \tpublic void testSwitchToUnalignedByUpstream() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTkxNQ==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544401915", "bodyText": "Aren't we missing some assertion?", "author": "pnowojski", "createdAt": "2020-12-16T15:41:35Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java", "diffHunk": "@@ -84,6 +84,24 @@ public void testChannelResetOnNewBarrier() throws Exception {\n \t\tassertFalse(stateWriter.getAddedInput().isEmpty());\n \t}\n \n+\t/**\n+\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n+\t * then it should be processed by the UC controller.\n+\t */\n+\t@Test\n+\tpublic void testSwitchToUnalignedByUpstream() throws Exception {\n+\t\tSingleInputGate inputGate = new SingleInputGateBuilder().setNumberOfChannels(2).build();\n+\t\tinputGate.setInputChannels(new TestInputChannel(inputGate, 0), new TestInputChannel(inputGate, 1));\n+\t\tValidatingCheckpointHandler target = new ValidatingCheckpointHandler();\n+\t\tSingleCheckpointBarrierHandler barrierHandler = barrierHandler(inputGate, target);\n+\t\tCheckpointedInputGate gate = buildGate(target, 2);\n+\n+\t\tCheckpointBarrier aligned = new CheckpointBarrier(1, System.currentTimeMillis(), alignedWithTimeout(getDefault(), Integer.MAX_VALUE));\n+\n+\t\tsend(toBuffer(new EventAnnouncement(aligned, 0), true), 0, gate); // process announcement but not the barrier\n+\t\tsend(toBuffer(aligned.asUnaligned(), true), 1, gate); // pretend it came from upstream before the first (AC) barrier was picked up\n+\t}", "originalCommit": "8bf08a45c31dacf497440b2cc889ccb7bef95cce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDg3NjUyMg==", "url": "https://github.com/apache/flink/pull/14057#discussion_r544876522", "bodyText": "The expectation is that it just won't fail (without the fix, it will).", "author": "rkhachatryan", "createdAt": "2020-12-17T07:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ababe2b0e179a44c59cd0a3b6909a3a79c10a8f5", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\nindex c433b6121f..2f9413d4d2 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/AlternatingControllerTest.java\n\n@@ -85,8 +87,8 @@ public class AlternatingControllerTest {\n \t}\n \n \t/**\n-\t * If a checkpoint announcement was processed and then UC-barrier arrives (from the upstream)\n-\t * then it should be processed by the UC controller.\n+\t * If a checkpoint announcement was processed from one channel and then UC-barrier arrives\n+\t * on another channel, this UC barrier should be processed by the UC controller.\n \t */\n \t@Test\n \tpublic void testSwitchToUnalignedByUpstream() throws Exception {\n"}}, {"oid": "ababe2b0e179a44c59cd0a3b6909a3a79c10a8f5", "url": "https://github.com/apache/flink/commit/ababe2b0e179a44c59cd0a3b6909a3a79c10a8f5", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-17T07:53:13Z", "type": "forcePushed"}, {"oid": "8e85c514fcd09a767d76498da227d741e1b2d7e9", "url": "https://github.com/apache/flink/commit/8e85c514fcd09a767d76498da227d741e1b2d7e9", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-17T08:12:06Z", "type": "forcePushed"}, {"oid": "b6fbb7d193e03d325ad2dc4ab2369826cf3be069", "url": "https://github.com/apache/flink/commit/b6fbb7d193e03d325ad2dc4ab2369826cf3be069", "message": "[FLINK-19681][checkpointing] Choose controler before processing first barrier or announcement", "committedDate": "2020-12-17T13:45:25Z", "type": "commit"}, {"oid": "e24882f117c9bcc486f76db44119e4e35c77299c", "url": "https://github.com/apache/flink/commit/e24882f117c9bcc486f76db44119e4e35c77299c", "message": "[FLINK-19681][checkpointing] Timeout aligned checkpoints based on checkpointStartDelay", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "69827b6309f20667cbcdc59c68e8199cf2e133f6", "url": "https://github.com/apache/flink/commit/69827b6309f20667cbcdc59c68e8199cf2e133f6", "message": "[FLINK-19681][tests] Adjust alignmentTimeout in unaligned checkpoint ITCases", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "5784531fa1332fa542b2e65b0a5889dad68fc3ce", "url": "https://github.com/apache/flink/commit/5784531fa1332fa542b2e65b0a5889dad68fc3ce", "message": "[FLINK-19681][config][checkpointing] Un-hide alignment timeout option", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "8ad51ad90ecc973442da18520ddff19d6456f453", "url": "https://github.com/apache/flink/commit/8ad51ad90ecc973442da18520ddff19d6456f453", "message": "[hotfix][network] Report channel index if failied to deserialize", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "7645fe8892095d7590f6bd3c0e2b0fbc4b2c2e2a", "url": "https://github.com/apache/flink/commit/7645fe8892095d7590f6bd3c0e2b0fbc4b2c2e2a", "message": "[hotfix][checkpointing] Add preconditions to channels and controllers", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "348a71f216132c8fa5afa93c90414eaf6e86719e", "url": "https://github.com/apache/flink/commit/348a71f216132c8fa5afa93c90414eaf6e86719e", "message": "[FLINK-19681][checkpointing] Fix barrier tracking in input channels\n\nLocalInputChannel:\nReset lastSeenBarrier for any barriers, not just UC.\nIn local channels, there are no announcements,\ntherefore lastSeenBarrier may not be reset for AC,\ntherefore extra buffers may be added to state.\n\nReduces failure frequency in UnalignedCheckpointIT par-local case.\n\nRemoteInputChannel:\nDon't update tracking state during conversion. Only do it\nupon receiving a barrier.\n\nReduces failure frequency in UnalignedCheckpointIT par-remote case.", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "23261e05db735b0885978078e776ece3b4dabcee", "url": "https://github.com/apache/flink/commit/23261e05db735b0885978078e776ece3b4dabcee", "message": "[FLINK-19681][checkpointing] Reset channel barrier tracking from AlignedController\n\nInput channels are unaware of controller types and always update their\npendingCheckpointBarrierId.  Therefore, resetting it also should be done\nin either case.  Otherwise, pendingCheckpointBarrierId may be left in a\nwrong state upon receiving a new barrier.", "committedDate": "2020-12-17T13:45:30Z", "type": "commit"}, {"oid": "c59de8b0fe47edc681c0a82c8465013c34c92b46", "url": "https://github.com/apache/flink/commit/c59de8b0fe47edc681c0a82c8465013c34c92b46", "message": "[FLINK-19681][checkpointing] Resume consumption when receiving different upstream signals\n\nSolves hanging up in 1/12 uc tests.", "committedDate": "2020-12-17T17:17:16Z", "type": "commit"}, {"oid": "a74097650256dde7e570ea1cd98bbaa31142799a", "url": "https://github.com/apache/flink/commit/a74097650256dde7e570ea1cd98bbaa31142799a", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-17T17:19:13Z", "type": "forcePushed"}, {"oid": "6f6cb76abfc95b8a935ff660f30242605d3b6920", "url": "https://github.com/apache/flink/commit/6f6cb76abfc95b8a935ff660f30242605d3b6920", "message": "[FLINK-19681][checkpointing] Use converted barrier after disabling alignment\n\nOtherwise, further components (e.g. SubtaskCheckpointCoordinator) can\nget an AC barrier for the UC checkpoint.", "committedDate": "2020-12-17T17:40:53Z", "type": "commit"}, {"oid": "3d77f6e8b65a8399ca107b0272c4e00e6512e8b2", "url": "https://github.com/apache/flink/commit/3d77f6e8b65a8399ca107b0272c4e00e6512e8b2", "message": "[FLINK-19681][checkpointing] Address minor feedback", "committedDate": "2020-12-17T17:40:57Z", "type": "commit"}, {"oid": "a6e5654be7d12fa9dc04655dc3fdd756c701885f", "url": "https://github.com/apache/flink/commit/a6e5654be7d12fa9dc04655dc3fdd756c701885f", "message": "[FLINK-19681][checkpointing] Use time of start of alignment instead of checkpoint to timeout", "committedDate": "2020-12-17T17:40:57Z", "type": "commit"}, {"oid": "922c91ab69909da49bb36f344c96039d4c2a643f", "url": "https://github.com/apache/flink/commit/922c91ab69909da49bb36f344c96039d4c2a643f", "message": "[FLINK-19681][checkpointing] Switch controller before processing the first barrier\n\nIf a checkpoint announcement was processed and then UC-barrier arrives\n(from the upstream) then it should be processed by the UC controller.", "committedDate": "2020-12-17T17:40:57Z", "type": "commit"}, {"oid": "2eca343e852b8438cc566435a0cce0f3ef771fa5", "url": "https://github.com/apache/flink/commit/2eca343e852b8438cc566435a0cce0f3ef771fa5", "message": "[FLINK-19681][checkpointing] Don't timeout checkpoint on last barrier", "committedDate": "2020-12-17T17:40:57Z", "type": "commit"}, {"oid": "0e7a7ce0e682eabc4c4d37e7b5ab910b6a75364a", "url": "https://github.com/apache/flink/commit/0e7a7ce0e682eabc4c4d37e7b5ab910b6a75364a", "message": "[hotfix][checkpointing] Explicit creation of CheckpointOptions\n\nThe motivation is to eliminate subtle bugs when changing checkpoint\ntype on the fly.\n1. Only guess options when creating a new barrier from configuration\n2. For other cases provide explicit factory methods\n2. Carry the current checkpoint/barrier requirements instead of the\ninitial configuration.", "committedDate": "2020-12-17T17:40:57Z", "type": "commit"}, {"oid": "f984efa3d7eedacd36d5f2c12f1256a10cfbc87d", "url": "https://github.com/apache/flink/commit/f984efa3d7eedacd36d5f2c12f1256a10cfbc87d", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-17T17:40:57Z", "type": "commit"}, {"oid": "f984efa3d7eedacd36d5f2c12f1256a10cfbc87d", "url": "https://github.com/apache/flink/commit/f984efa3d7eedacd36d5f2c12f1256a10cfbc87d", "message": "[FLINK-19681][network] Force priority for converted barriers\n\nWithout this, gate interprets barrier as outdated\nbecause it has already seen its SQN during the announcement.\n\nPreventing announcements from updating gate lastSeenSqn\ndoesn't work because it provokes concurrency issue with\nnotification (by efficitively disable lastSeenSqn guard).", "committedDate": "2020-12-17T17:40:57Z", "type": "forcePushed"}]}