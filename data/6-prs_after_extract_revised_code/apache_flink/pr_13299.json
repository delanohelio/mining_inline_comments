{"pr_number": 13299, "pr_title": "[FLINK-19072][table-planner] Import Temporal Table join rule for Stream", "pr_createdAt": "2020-09-01T12:54:12Z", "pr_url": "https://github.com/apache/flink/pull/13299", "timeline": [{"oid": "2ed16425d7018bbb39be1edd6519fcb99cb45000", "url": "https://github.com/apache/flink/commit/2ed16425d7018bbb39be1edd6519fcb99cb45000", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition", "committedDate": "2020-09-01T15:33:24Z", "type": "forcePushed"}, {"oid": "ade459ff295c6994b7d6d377674e02d668faee71", "url": "https://github.com/apache/flink/commit/ade459ff295c6994b7d6d377674e02d668faee71", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition", "committedDate": "2020-09-02T06:57:23Z", "type": "forcePushed"}, {"oid": "8928b195cdec50dee6df1e364df250c9283d0af7", "url": "https://github.com/apache/flink/commit/8928b195cdec50dee6df1e364df250c9283d0af7", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition", "committedDate": "2020-09-23T13:38:20Z", "type": "forcePushed"}, {"oid": "1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "url": "https://github.com/apache/flink/commit/1b5a16ff124bb762352c8f31305ea3d3fcf4b694", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream", "committedDate": "2020-09-28T08:53:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzAxMw==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893013", "bodyText": "LegacyTemporalProcessTimeJoinOperator and TemporalProcessTimeJoinOperator is almost same, can we reuse them ?", "author": "godfreyhe", "createdAt": "2020-09-28T12:15:31Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.functions.util.FunctionUtils;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+\n+/**\n+ * The operator to temporal join a stream on processing time.\n+ */\n+public class LegacyTemporalProcessTimeJoinOperator", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "chunk": "diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperator.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperator.java\ndeleted file mode 100644\nindex b30752bbce..0000000000\n--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalProcessTimeJoinOperator.java\n+++ /dev/null\n\n@@ -1,126 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.flink.table.runtime.operators.join.temporal;\n-\n-import org.apache.flink.api.common.functions.util.FunctionUtils;\n-import org.apache.flink.api.common.state.ValueState;\n-import org.apache.flink.api.common.state.ValueStateDescriptor;\n-import org.apache.flink.configuration.Configuration;\n-import org.apache.flink.runtime.state.VoidNamespace;\n-import org.apache.flink.streaming.api.operators.InternalTimer;\n-import org.apache.flink.streaming.api.operators.TimestampedCollector;\n-import org.apache.flink.streaming.api.watermark.Watermark;\n-import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n-import org.apache.flink.table.data.JoinedRowData;\n-import org.apache.flink.table.data.RowData;\n-import org.apache.flink.table.data.util.RowDataUtil;\n-import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n-import org.apache.flink.table.runtime.generated.JoinCondition;\n-import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n-\n-/**\n- * The operator to temporal join a stream on processing time.\n- */\n-public class LegacyTemporalProcessTimeJoinOperator\n-\textends BaseTwoInputStreamOperatorWithStateRetention {\n-\n-\tprivate static final long serialVersionUID = -5182289624027523612L;\n-\n-\tprivate final InternalTypeInfo<RowData> rightType;\n-\tprivate final GeneratedJoinCondition generatedJoinCondition;\n-\n-\tprivate transient ValueState<RowData> rightState;\n-\tprivate transient JoinCondition joinCondition;\n-\n-\tprivate transient JoinedRowData outRow;\n-\tprivate transient TimestampedCollector<RowData> collector;\n-\n-\tpublic LegacyTemporalProcessTimeJoinOperator(\n-\t\t\tInternalTypeInfo<RowData> rightType,\n-\t\t\tGeneratedJoinCondition generatedJoinCondition,\n-\t\t\tlong minRetentionTime,\n-\t\t\tlong maxRetentionTime) {\n-\t\tsuper(minRetentionTime, maxRetentionTime);\n-\t\tthis.rightType = rightType;\n-\t\tthis.generatedJoinCondition = generatedJoinCondition;\n-\t}\n-\n-\t@Override\n-\tpublic void open() throws Exception {\n-\t\tthis.joinCondition = generatedJoinCondition.newInstance(getRuntimeContext().getUserCodeClassLoader());\n-\t\tFunctionUtils.setFunctionRuntimeContext(joinCondition, getRuntimeContext());\n-\t\tFunctionUtils.openFunction(joinCondition, new Configuration());\n-\n-\t\tValueStateDescriptor<RowData> rightStateDesc = new ValueStateDescriptor<>(\"right\", rightType);\n-\t\tthis.rightState = getRuntimeContext().getState(rightStateDesc);\n-\t\tthis.collector = new TimestampedCollector<>(output);\n-\t\tthis.outRow = new JoinedRowData();\n-\t\t// consider watermark from left stream only.\n-\t\tsuper.processWatermark2(Watermark.MAX_WATERMARK);\n-\t}\n-\n-\t@Override\n-\tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n-\t\tRowData rightSideRow = rightState.value();\n-\t\tif (rightSideRow == null) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tRowData leftSideRow = element.getValue();\n-\t\tif (joinCondition.apply(leftSideRow, rightSideRow)) {\n-\t\t\toutRow.setRowKind(leftSideRow.getRowKind());\n-\t\t\toutRow.replace(leftSideRow, rightSideRow);\n-\t\t\tcollector.collect(outRow);\n-\t\t}\n-\t\tregisterProcessingCleanupTimer();\n-\t}\n-\n-\t@Override\n-\tpublic void processElement2(StreamRecord<RowData> element) throws Exception {\n-\t\tif (RowDataUtil.isAccumulateMsg(element.getValue())) {\n-\t\t\trightState.update(element.getValue());\n-\t\t\tregisterProcessingCleanupTimer();\n-\t\t} else {\n-\t\t\trightState.clear();\n-\t\t\tcleanupLastTimer();\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void close() throws Exception {\n-\t\tFunctionUtils.closeFunction(joinCondition);\n-\t}\n-\n-\t/**\n-\t * The method to be called when a cleanup timer fires.\n-\t *\n-\t * @param time The timestamp of the fired timer.\n-\t */\n-\t@Override\n-\tpublic void cleanupState(long time) {\n-\t\trightState.clear();\n-\t}\n-\n-\t/**\n-\t * Invoked when an event-time timer fires.\n-\t */\n-\t@Override\n-\tpublic void onEventTime(InternalTimer<Object, VoidNamespace> timer) throws Exception {\n-\t}\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg5MzExNQ==", "url": "https://github.com/apache/flink/pull/13299#discussion_r495893115", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-09-28T12:15:44Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,404 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * This operator works by keeping on the state collection of probe and build records to process\n+ * on next watermark. The idea is that between watermarks we are collecting those elements\n+ * and once we are sure that there will be no updates we emit the correct result and clean up the\n+ * state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * however we always keep at least one record - the latest one - even if it's past the last\n+ * watermark.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class LegacyTemporalRowTimeJoinOperator", "originalCommit": "61ab18c9e4012d0c65d64c2456af0900577b90db", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "chunk": "diff --git a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperator.java b/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperator.java\ndeleted file mode 100644\nindex c3a4d1ee76..0000000000\n--- a/flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/LegacyTemporalRowTimeJoinOperator.java\n+++ /dev/null\n\n@@ -1,404 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.flink.table.runtime.operators.join.temporal;\n-\n-import org.apache.flink.api.common.state.MapState;\n-import org.apache.flink.api.common.state.MapStateDescriptor;\n-import org.apache.flink.api.common.state.ValueState;\n-import org.apache.flink.api.common.state.ValueStateDescriptor;\n-import org.apache.flink.api.common.typeinfo.Types;\n-import org.apache.flink.configuration.Configuration;\n-import org.apache.flink.runtime.state.VoidNamespace;\n-import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n-import org.apache.flink.streaming.api.operators.InternalTimer;\n-import org.apache.flink.streaming.api.operators.InternalTimerService;\n-import org.apache.flink.streaming.api.operators.TimestampedCollector;\n-import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n-import org.apache.flink.table.data.JoinedRowData;\n-import org.apache.flink.table.data.RowData;\n-import org.apache.flink.table.data.util.RowDataUtil;\n-import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n-import org.apache.flink.table.runtime.generated.JoinCondition;\n-import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n-import org.apache.flink.types.RowKind;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.Map;\n-import java.util.Optional;\n-\n-/**\n- * This operator works by keeping on the state collection of probe and build records to process\n- * on next watermark. The idea is that between watermarks we are collecting those elements\n- * and once we are sure that there will be no updates we emit the correct result and clean up the\n- * state.\n- *\n- * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n- * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n- * however we always keep at least one record - the latest one - even if it's past the last\n- * watermark.\n- *\n- * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n- * by registering timers for the keys. We could register a timer for every probe and build\n- * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n- * cleaning up the state). However this would cause huge number of registered timers. For example\n- * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n- * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n- * we always keep only one single registered timer for any given key, registered for the minimal\n- * value. Upon triggering it, we process all records with event times older then or equal to\n- * currentWatermark.\n- */\n-public class LegacyTemporalRowTimeJoinOperator\n-\textends BaseTwoInputStreamOperatorWithStateRetention {\n-\n-\tprivate static final long serialVersionUID = 6642514795175288193L;\n-\n-\tprivate static final String NEXT_LEFT_INDEX_STATE_NAME = \"next-index\";\n-\tprivate static final String LEFT_STATE_NAME = \"left\";\n-\tprivate static final String RIGHT_STATE_NAME = \"right\";\n-\tprivate static final String REGISTERED_TIMER_STATE_NAME = \"timer\";\n-\tprivate static final String TIMERS_STATE_NAME = \"timers\";\n-\n-\tprivate final InternalTypeInfo<RowData> leftType;\n-\tprivate final InternalTypeInfo<RowData> rightType;\n-\tprivate final GeneratedJoinCondition generatedJoinCondition;\n-\tprivate final int leftTimeAttribute;\n-\tprivate final int rightTimeAttribute;\n-\n-\tprivate final RowtimeComparator rightRowtimeComparator;\n-\n-\t/**\n-\t * Incremental index generator for {@link #leftState}'s keys.\n-\t */\n-\tprivate transient ValueState<Long> nextLeftIndex;\n-\n-\t/**\n-\t * Mapping from artificial row index (generated by `nextLeftIndex`) into the left side `Row`.\n-\t * We can not use List to accumulate Rows, because we need efficient deletes of the oldest rows.\n-\t *\n-\t * <p>TODO: this could be OrderedMultiMap[Jlong, Row] indexed by row's timestamp, to avoid\n-\t * full map traversals (if we have lots of rows on the state that exceed `currentWatermark`).\n-\t */\n-\tprivate transient MapState<Long, RowData> leftState;\n-\n-\t/**\n-\t * Mapping from timestamp to right side `Row`.\n-\t *\n-\t * <p>TODO: having `rightState` as an OrderedMapState would allow us to avoid sorting cost\n-\t * once per watermark\n-\t */\n-\tprivate transient MapState<Long, RowData> rightState;\n-\n-\t// Long for correct handling of default null\n-\tprivate transient ValueState<Long> registeredTimer;\n-\tprivate transient TimestampedCollector<RowData> collector;\n-\tprivate transient InternalTimerService<VoidNamespace> timerService;\n-\n-\tprivate transient JoinCondition joinCondition;\n-\tprivate transient JoinedRowData outRow;\n-\n-\tpublic LegacyTemporalRowTimeJoinOperator(\n-\t\t\tInternalTypeInfo<RowData> leftType,\n-\t\t\tInternalTypeInfo<RowData> rightType,\n-\t\t\tGeneratedJoinCondition generatedJoinCondition,\n-\t\t\tint leftTimeAttribute,\n-\t\t\tint rightTimeAttribute,\n-\t\t\tlong minRetentionTime,\n-\t\t\tlong maxRetentionTime) {\n-\t\tsuper(minRetentionTime, maxRetentionTime);\n-\t\tthis.leftType = leftType;\n-\t\tthis.rightType = rightType;\n-\t\tthis.generatedJoinCondition = generatedJoinCondition;\n-\t\tthis.leftTimeAttribute = leftTimeAttribute;\n-\t\tthis.rightTimeAttribute = rightTimeAttribute;\n-\t\tthis.rightRowtimeComparator = new RowtimeComparator(rightTimeAttribute);\n-\t}\n-\n-\t@Override\n-\tpublic void open() throws Exception {\n-\t\tjoinCondition = generatedJoinCondition.newInstance(getRuntimeContext().getUserCodeClassLoader());\n-\t\tjoinCondition.setRuntimeContext(getRuntimeContext());\n-\t\tjoinCondition.open(new Configuration());\n-\n-\t\tnextLeftIndex = getRuntimeContext().getState(\n-\t\t\tnew ValueStateDescriptor<>(NEXT_LEFT_INDEX_STATE_NAME, Types.LONG));\n-\t\tleftState = getRuntimeContext().getMapState(\n-\t\t\tnew MapStateDescriptor<>(LEFT_STATE_NAME, Types.LONG, leftType));\n-\t\trightState = getRuntimeContext().getMapState(\n-\t\t\tnew MapStateDescriptor<>(RIGHT_STATE_NAME, Types.LONG, rightType));\n-\t\tregisteredTimer = getRuntimeContext().getState(\n-\t\t\tnew ValueStateDescriptor<>(REGISTERED_TIMER_STATE_NAME, Types.LONG));\n-\n-\t\ttimerService = getInternalTimerService(\n-\t\t\tTIMERS_STATE_NAME, VoidNamespaceSerializer.INSTANCE, this);\n-\t\tcollector = new TimestampedCollector<>(output);\n-\t\toutRow = new JoinedRowData();\n-\t\t// all the output records should be INSERT only,\n-\t\t// because current temporal join only supports INSERT only left stream\n-\t\toutRow.setRowKind(RowKind.INSERT);\n-\t}\n-\n-\t@Override\n-\tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n-\t\tRowData row = element.getValue();\n-\t\tcheckNotRetraction(row);\n-\n-\t\tleftState.put(getNextLeftIndex(), row);\n-\t\tregisterSmallestTimer(getLeftTime(row)); // Timer to emit and clean up the state\n-\n-\t\tregisterProcessingCleanupTimer();\n-\t}\n-\n-\t@Override\n-\tpublic void processElement2(StreamRecord<RowData> element) throws Exception {\n-\t\tRowData row = element.getValue();\n-\t\tcheckNotRetraction(row);\n-\n-\t\tlong rowTime = getRightTime(row);\n-\t\trightState.put(rowTime, row);\n-\t\tregisterSmallestTimer(rowTime); // Timer to clean up the state\n-\n-\t\tregisterProcessingCleanupTimer();\n-\t}\n-\n-\t@Override\n-\tpublic void onEventTime(InternalTimer<Object, VoidNamespace> timer) throws Exception {\n-\t\tregisteredTimer.clear();\n-\t\tlong lastUnprocessedTime = emitResultAndCleanUpState(timerService.currentWatermark());\n-\t\tif (lastUnprocessedTime < Long.MAX_VALUE) {\n-\t\t\tregisterTimer(lastUnprocessedTime);\n-\t\t}\n-\n-\t\t// if we have more state at any side, then update the timer, else clean it up.\n-\t\tif (stateCleaningEnabled) {\n-\t\t\tif (lastUnprocessedTime < Long.MAX_VALUE || !rightState.isEmpty()) {\n-\t\t\t\tregisterProcessingCleanupTimer();\n-\t\t\t} else {\n-\t\t\t\tcleanupLastTimer();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic void close() throws Exception {\n-\t\tif (joinCondition != null) {\n-\t\t\tjoinCondition.close();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n-\t *         have been processed.\n-\t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n-\t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n-\t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n-\n-\t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n-\t\twhile (leftIterator.hasNext()) {\n-\t\t\tMap.Entry<Long, RowData> entry = leftIterator.next();\n-\t\t\tRowData leftRow = entry.getValue();\n-\t\t\tlong leftTime = getLeftTime(leftRow);\n-\n-\t\t\tif (leftTime <= timerTimestamp) {\n-\t\t\t\tOptional<RowData> rightRow = latestRightRowToJoin(rightRowsSorted, leftTime);\n-\t\t\t\tif (rightRow.isPresent()) {\n-\t\t\t\t\tif (joinCondition.apply(leftRow, rightRow.get())) {\n-\t\t\t\t\t\toutRow.replace(leftRow, rightRow.get());\n-\t\t\t\t\t\tcollector.collect(outRow);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tleftIterator.remove();\n-\t\t\t} else {\n-\t\t\t\tlastUnprocessedTime = Math.min(lastUnprocessedTime, leftTime);\n-\t\t\t}\n-\t\t}\n-\n-\t\tcleanupState(timerTimestamp, rightRowsSorted);\n-\t\treturn lastUnprocessedTime;\n-\t}\n-\n-\t/**\n-\t * Removes all right entries older then the watermark, except the latest one. For example with:\n-\t * rightState = [1, 5, 9]\n-\t * and\n-\t * watermark = 6\n-\t * we can not remove \"5\" from rightState, because left elements with rowtime of 7 or 8 could\n-\t * be joined with it later\n-\t */\n-\tprivate void cleanupState(long timerTimestamp, List<RowData> rightRowsSorted) throws Exception {\n-\t\tint i = 0;\n-\t\tint indexToKeep = firstIndexToKeep(timerTimestamp, rightRowsSorted);\n-\n-\t\twhile (i < indexToKeep) {\n-\t\t\tlong rightTime = getRightTime(rightRowsSorted.get(i));\n-\t\t\trightState.remove(rightTime);\n-\t\t\ti += 1;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * The method to be called when a cleanup timer fires.\n-\t *\n-\t * @param time The timestamp of the fired timer.\n-\t */\n-\t@Override\n-\tpublic void cleanupState(long time) {\n-\t\tleftState.clear();\n-\t\trightState.clear();\n-\t}\n-\n-\tprivate int firstIndexToKeep(long timerTimestamp, List<RowData> rightRowsSorted) {\n-\t\tint firstIndexNewerThenTimer =\n-\t\t\tindexOfFirstElementNewerThanTimer(timerTimestamp, rightRowsSorted);\n-\n-\t\tif (firstIndexNewerThenTimer < 0) {\n-\t\t\treturn rightRowsSorted.size() - 1;\n-\t\t}\n-\t\telse {\n-\t\t\treturn firstIndexNewerThenTimer - 1;\n-\t\t}\n-\t}\n-\n-\tprivate int indexOfFirstElementNewerThanTimer(long timerTimestamp, List<RowData> list) {\n-\t\tListIterator<RowData> iter = list.listIterator();\n-\t\twhile (iter.hasNext()) {\n-\t\t\tif (getRightTime(iter.next()) > timerTimestamp) {\n-\t\t\t\treturn iter.previousIndex();\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t}\n-\n-\t/**\n-\t * Binary search {@code rightRowsSorted} to find the latest right row to join with {@code leftTime}.\n-\t * Latest means a right row with largest time that is still smaller or equal to {@code leftTime}.\n-\t *\n-\t * @return found element or {@code Optional.empty} If such row was not found (either {@code rightRowsSorted}\n-\t *         is empty or all {@code rightRowsSorted} are are newer).\n-\t */\n-\tprivate Optional<RowData> latestRightRowToJoin(List<RowData> rightRowsSorted, long leftTime) {\n-\t\treturn latestRightRowToJoin(rightRowsSorted, 0, rightRowsSorted.size() - 1, leftTime);\n-\t}\n-\n-\tprivate Optional<RowData> latestRightRowToJoin(\n-\t\t\tList<RowData> rightRowsSorted,\n-\t\t\tint low,\n-\t\t\tint high,\n-\t\t\tlong leftTime) {\n-\t\tif (low > high) {\n-\t\t\t// exact value not found, we are returning largest from the values smaller then leftTime\n-\t\t\tif (low - 1 < 0) {\n-\t\t\t\treturn Optional.empty();\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\treturn Optional.of(rightRowsSorted.get(low - 1));\n-\t\t\t}\n-\t\t} else {\n-\t\t\tint mid = (low + high) >>> 1;\n-\t\t\tRowData midRow = rightRowsSorted.get(mid);\n-\t\t\tlong midTime = getRightTime(midRow);\n-\t\t\tint cmp = Long.compare(midTime, leftTime);\n-\t\t\tif (cmp < 0) {\n-\t\t\t\treturn latestRightRowToJoin(rightRowsSorted, mid + 1, high, leftTime);\n-\t\t\t}\n-\t\t\telse if (cmp > 0) {\n-\t\t\t\treturn latestRightRowToJoin(rightRowsSorted, low, mid - 1, leftTime);\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\treturn Optional.of(midRow);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void registerSmallestTimer(long timestamp) throws IOException {\n-\t\tLong currentRegisteredTimer = registeredTimer.value();\n-\t\tif (currentRegisteredTimer == null) {\n-\t\t\tregisterTimer(timestamp);\n-\t\t} else if (currentRegisteredTimer > timestamp) {\n-\t\t\ttimerService.deleteEventTimeTimer(VoidNamespace.INSTANCE, currentRegisteredTimer);\n-\t\t\tregisterTimer(timestamp);\n-\t\t}\n-\t}\n-\n-\tprivate void registerTimer(long timestamp) throws IOException {\n-\t\tregisteredTimer.update(timestamp);\n-\t\ttimerService.registerEventTimeTimer(VoidNamespace.INSTANCE, timestamp);\n-\t}\n-\n-\tprivate List<RowData> getRightRowSorted(RowtimeComparator rowtimeComparator) throws Exception {\n-\t\tList<RowData> rightRows = new ArrayList<>();\n-\t\tfor (RowData row : rightState.values()) {\n-\t\t\trightRows.add(row);\n-\t\t}\n-\t\trightRows.sort(rowtimeComparator);\n-\t\treturn rightRows;\n-\t}\n-\n-\tprivate long getNextLeftIndex() throws IOException {\n-\t\tLong index = nextLeftIndex.value();\n-\t\tif (index == null) {\n-\t\t\tindex = 0L;\n-\t\t}\n-\t\tnextLeftIndex.update(index + 1);\n-\t\treturn index;\n-\t}\n-\n-\tprivate long getLeftTime(RowData leftRow) {\n-\t\treturn leftRow.getLong(leftTimeAttribute);\n-\t}\n-\n-\tprivate long getRightTime(RowData rightRow) {\n-\t\treturn rightRow.getLong(rightTimeAttribute);\n-\t}\n-\n-\tprivate void checkNotRetraction(RowData row) {\n-\t\tif (RowDataUtil.isRetractMsg(row)) {\n-\t\t\tString className = getClass().getSimpleName();\n-\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\"Retractions are not supported by \" + className +\n-\t\t\t\t\t\". If this can happen it should be validated during planning!\");\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------------------------\n-\n-\tprivate static class RowtimeComparator implements Comparator<RowData>, Serializable {\n-\n-\t\tprivate static final long serialVersionUID = 8160134014590716914L;\n-\n-\t\tprivate final int timeAttribute;\n-\n-\t\tprivate RowtimeComparator(int timeAttribute) {\n-\t\t\tthis.timeAttribute = timeAttribute;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic int compare(RowData o1, RowData o2) {\n-\t\t\tlong o1Time = o1.getLong(timeAttribute);\n-\t\t\tlong o2Time = o2.getLong(timeAttribute);\n-\t\t\treturn Long.compare(o1Time, o2Time);\n-\t\t}\n-\t}\n-}\n"}}, {"oid": "b0e40b37f7993240764dce3280c9c59d5b0b6e75", "url": "https://github.com/apache/flink/commit/b0e40b37f7993240764dce3280c9c59d5b0b6e75", "message": "add tests", "committedDate": "2020-10-14T10:37:15Z", "type": "forcePushed"}, {"oid": "e7f001da22368aed31002c28199b4f97d2a2b63b", "url": "https://github.com/apache/flink/commit/e7f001da22368aed31002c28199b4f97d2a2b63b", "message": "add more tests", "committedDate": "2020-10-14T16:22:09Z", "type": "forcePushed"}, {"oid": "9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "url": "https://github.com/apache/flink/commit/9027c8cf3a5619d28f2d1c1a0076a37a4ca9b15d", "message": "add more tests(changelogmode tests)", "committedDate": "2020-10-15T02:08:45Z", "type": "forcePushed"}, {"oid": "55acd8f52fd5df5316efd04068754cdeca4d612f", "url": "https://github.com/apache/flink/commit/55acd8f52fd5df5316efd04068754cdeca4d612f", "message": "add more tests(changelogmode tests)", "committedDate": "2020-10-15T02:46:23Z", "type": "forcePushed"}, {"oid": "bb79e997201a60f34a935ee41905bbbb3969d6e8", "url": "https://github.com/apache/flink/commit/bb79e997201a60f34a935ee41905bbbb3969d6e8", "message": "[FLINK-19072][table-planner] Import Temporal Table join rule for stream", "committedDate": "2020-10-15T13:48:37Z", "type": "commit"}, {"oid": "a4175b42f65fec599c2821e33bce595b07cd8083", "url": "https://github.com/apache/flink/commit/a4175b42f65fec599c2821e33bce595b07cd8083", "message": "[FLINK-19073][table-planner] Imporve streamExecTemporalJoinRule for stream", "committedDate": "2020-10-15T13:49:08Z", "type": "commit"}, {"oid": "b8a59c245c0a51245ff397591222a26a473135ea", "url": "https://github.com/apache/flink/commit/b8a59c245c0a51245ff397591222a26a473135ea", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream", "committedDate": "2020-10-15T13:50:07Z", "type": "commit"}, {"oid": "b8a59c245c0a51245ff397591222a26a473135ea", "url": "https://github.com/apache/flink/commit/b8a59c245c0a51245ff397591222a26a473135ea", "message": "[FLINK-19076][table-planner] Import rule to deal Temporal Join condition for stream", "committedDate": "2020-10-15T13:50:07Z", "type": "forcePushed"}]}