{"pr_number": 11351, "pr_title": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "pr_createdAt": "2020-03-09T06:13:21Z", "pr_url": "https://github.com/apache/flink/pull/11351", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406708848", "bodyText": "why the blocked partition would be pulled buffer since it was unavailable.", "author": "zhijiangW", "createdAt": "2020-04-10T10:56:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -179,6 +182,10 @@ public void release() {\n \t@Nullable\n \tBufferAndBacklog pollBuffer() {\n \t\tsynchronized (buffers) {\n+\t\t\tif (isBlockedByCheckpoint) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2Njk3Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407166977", "bodyText": "Because there are redundant notifications for local channel which means we may notify data available even when the downstream task in the poll loop. Maybe we fix it in another ticket if we think it's a problem.", "author": "wsry", "createdAt": "2020-04-12T08:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0OTQyMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408649420", "bodyText": "I see, it is for the case of local channel. I think we should supplement a test to cover this change if possible.", "author": "zhijiangW", "createdAt": "2020-04-15T07:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NDg0Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408654847", "bodyText": "Also it is better to give some descriptions here to explain this situation for better understanding.", "author": "zhijiangW", "createdAt": "2020-04-15T08:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwODg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 2b8a7c4dec2..eb2f852606c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -182,10 +217,6 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t@Nullable\n \tBufferAndBacklog pollBuffer() {\n \t\tsynchronized (buffers) {\n-\t\t\tif (isBlockedByCheckpoint) {\n-\t\t\t\treturn null;\n-\t\t\t}\n-\n \t\t\tBuffer buffer = null;\n \n \t\t\tif (buffers.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMjY1Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406712652", "bodyText": "it is ambiguous to distinguish the semantics between isAvailableWithoutCredit and isMoreAvailable if not back to see the implementation. I prefer to using dataAvailable and eventAvailable instead.\nAnd from the outside view, we only provide the isAvailable(int credit) method for hiding the details.", "author": "zhijiangW", "createdAt": "2020-04-10T11:11:11Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java", "diffHunk": "@@ -136,13 +136,13 @@ public void initializeState(ChannelStateReader stateReader) throws IOException,\n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isMoreAvailable;\n \t\tprivate final int buffersInBacklog;\n-\t\tprivate final boolean nextBufferIsEvent;\n+\t\tprivate final boolean isAvailableWithoutCredit;", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex 41489c53f48..058d0cd19da 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n\n@@ -134,31 +134,31 @@ public abstract class ResultSubpartition {\n \tpublic static final class BufferAndBacklog {\n \n \t\tprivate final Buffer buffer;\n-\t\tprivate final boolean isMoreAvailable;\n+\t\tprivate final boolean isDataAvailable;\n \t\tprivate final int buffersInBacklog;\n-\t\tprivate final boolean isAvailableWithoutCredit;\n+\t\tprivate final boolean isEventAvailable;\n \n-\t\tpublic BufferAndBacklog(Buffer buffer, boolean isMoreAvailable, int buffersInBacklog, boolean isAvailableWithoutCredit) {\n+\t\tpublic BufferAndBacklog(Buffer buffer, boolean isDataAvailable, int buffersInBacklog, boolean isEventAvailable) {\n \t\t\tthis.buffer = checkNotNull(buffer);\n \t\t\tthis.buffersInBacklog = buffersInBacklog;\n-\t\t\tthis.isMoreAvailable = isMoreAvailable;\n-\t\t\tthis.isAvailableWithoutCredit = isAvailableWithoutCredit;\n+\t\t\tthis.isDataAvailable = isDataAvailable;\n+\t\t\tthis.isEventAvailable = isEventAvailable;\n \t\t}\n \n \t\tpublic Buffer buffer() {\n \t\t\treturn buffer;\n \t\t}\n \n-\t\tpublic boolean isMoreAvailable() {\n-\t\t\treturn isMoreAvailable;\n+\t\tpublic boolean isDataAvailable() {\n+\t\t\treturn isDataAvailable;\n \t\t}\n \n \t\tpublic int buffersInBacklog() {\n \t\t\treturn buffersInBacklog;\n \t\t}\n \n-\t\tpublic boolean isAvailableWithoutCredit() {\n-\t\t\treturn isAvailableWithoutCredit;\n+\t\tpublic boolean isEventAvailable() {\n+\t\t\treturn isEventAvailable;\n \t\t}\n \n \t\tpublic static BufferAndBacklog fromBufferAndLookahead(Buffer current, Buffer lookahead, int backlog) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMzY4Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406713682", "bodyText": "this change worths a separate hotfix commit", "author": "zhijiangW", "createdAt": "2020-04-10T11:14:59Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -883,16 +883,7 @@ private void configureCheckpointing() {\n \n \t\tCheckpointingMode mode = cfg.getCheckpointingMode();\n \n-\t\tboolean isExactlyOnce;\n-\t\tif (mode == CheckpointingMode.EXACTLY_ONCE) {\n-\t\t\tisExactlyOnce = true;\n-\t\t} else if (mode == CheckpointingMode.AT_LEAST_ONCE) {\n-\t\t\tisExactlyOnce = false;\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"Unexpected checkpointing mode. \" +\n-\t\t\t\t\"Did not expect there to be another checkpointing mode besides \" +\n-\t\t\t\t\"exactly-once or at-least-once.\");\n-\t\t}\n+\t\tboolean isExactlyOnce = cfg.isCheckpointingEnabled() && mode == CheckpointingMode.EXACTLY_ONCE;", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2NzUzNg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407167536", "bodyText": "I do something further in this round of fixup.", "author": "wsry", "createdAt": "2020-04-12T08:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2ODI1Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408568257", "bodyText": "I move this to another PR.", "author": "wsry", "createdAt": "2020-04-15T04:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxMzY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\nindex dea7908987d..678a9f80bff 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java\n\n@@ -881,9 +891,7 @@ public class StreamingJobGraphGenerator {\n \t\t\tretentionAfterTermination = CheckpointRetentionPolicy.NEVER_RETAIN_AFTER_TERMINATION;\n \t\t}\n \n-\t\tCheckpointingMode mode = cfg.getCheckpointingMode();\n-\n-\t\tboolean isExactlyOnce = cfg.isCheckpointingEnabled() && mode == CheckpointingMode.EXACTLY_ONCE;\n+\t\tboolean isExactlyOnce = getCheckpointingMode(cfg) == CheckpointingMode.EXACTLY_ONCE;\n \n \t\t//  --- configure the master-side checkpoint hooks ---\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTMyMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406719321", "bodyText": "nit: Integer -> int", "author": "zhijiangW", "createdAt": "2020-04-10T11:33:57Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -318,6 +325,13 @@ public long getAlignmentDurationNanos() {\n \t\t}\n \t}\n \n+\tprivate void unblockCheckpoint(Integer channelToUnblock) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTUyOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406719528", "bodyText": "I suggest renaming unblockCheckpoint to resumeConsumption to unify all the stacks.", "author": "zhijiangW", "createdAt": "2020-04-10T11:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcxOTMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 9ff9bbd64ec..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -325,11 +325,11 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t\t}\n \t}\n \n-\tprivate void unblockCheckpoint(Integer channelToUnblock) {\n-\t\tInputGate inputGate = channelIndexToInputGate[channelToUnblock];\n-\t\tif (!inputGate.isFinished()) {\n-\t\t\tinputGate.unblockCheckpoint(channelToUnblock - inputGateToChannelIndexOffset.get(inputGate));\n-\t\t}\n+\tprivate void resumeConsumption(int channelIndex) {\n+\t\tInputGate inputGate = channelIndexToInputGate[channelIndex];\n+\t\tcheckState(!inputGate.isFinished(), \"InputGate already finished.\");\n+\n+\t\tinputGate.resumeConsumption(channelIndex - inputGateToChannelIndexOffset.get(inputGate));\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxNjQ1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406816455", "bodyText": "channelIndexToInputChannel should be protected in sync by requestLock, because in code path this array would be modified by RPC thread via updateInputChannel. Although that method is never invoked in streaming job, it still has the potential risk to break this assumption.", "author": "zhijiangW", "createdAt": "2020-04-10T15:45:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -616,6 +622,11 @@ public void sendTaskEvent(TaskEvent event) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void unblockCheckpoint(int channelIndex) {\n+\t\tchannelIndexToInputChannel[channelIndex].unblockCheckpoint();", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex f929ed1a6dc..3d6e9b3cfb4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -623,8 +623,10 @@ public class SingleInputGate extends InputGate {\n \t}\n \n \t@Override\n-\tpublic void unblockCheckpoint(int channelIndex) {\n-\t\tchannelIndexToInputChannel[channelIndex].unblockCheckpoint();\n+\tpublic void resumeConsumption(int channelIndex) {\n+\t\tsynchronized (requestLock) {\n+\t\t\tchannelIndexToInputChannel[channelIndex].resumeConsumption();\n+\t\t}\n \t}\n \n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgxODI1Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406818252", "bodyText": "nit: this argument seems redundant because it can be got from channelIndexToInputGate.length", "author": "zhijiangW", "createdAt": "2020-04-10T15:49:41Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -69,10 +79,14 @@\n \tCheckpointBarrierAligner(\n \t\t\tint totalNumberOfInputChannels,", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 9ff9bbd64ec..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -77,16 +78,15 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \tprivate long latestAlignmentDurationNanos;\n \n \tCheckpointBarrierAligner(\n-\t\t\tint totalNumberOfInputChannels,\n \t\t\tString taskName,\n \t\t\tInputGate[] channelIndexToInputGate,\n \t\t\tMap<InputGate, Integer> inputGateToChannelIndexOffset,\n \t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n \t\tsuper(toNotifyOnCheckpoint);\n-\t\tthis.totalNumberOfInputChannels = totalNumberOfInputChannels;\n \t\tthis.taskName = taskName;\n \t\tthis.channelIndexToInputGate = checkNotNull(channelIndexToInputGate);\n \t\tthis.inputGateToChannelIndexOffset = checkNotNull(inputGateToChannelIndexOffset);\n+\t\tthis.totalNumberOfInputChannels = channelIndexToInputGate.length;\n \n \t\tthis.blockedChannels = new boolean[totalNumberOfInputChannels];\n \t}\n"}}, {"oid": "3b3428a844d7cb5903f505686881be27970205f0", "url": "https://github.com/apache/flink/commit/3b3428a844d7cb5903f505686881be27970205f0", "message": "Fixup.", "committedDate": "2020-04-13T03:04:02Z", "type": "forcePushed"}, {"oid": "a0c7ff983988f27f5e47f4c71c8fb1ef28f8a24a", "url": "https://github.com/apache/flink/commit/a0c7ff983988f27f5e47f4c71c8fb1ef28f8a24a", "message": "Fixup.", "committedDate": "2020-04-13T03:39:24Z", "type": "forcePushed"}, {"oid": "9673d7ea41a3c7eb78a7e0d723c81086002dcc52", "url": "https://github.com/apache/flink/commit/9673d7ea41a3c7eb78a7e0d723c81086002dcc52", "message": "Fixup.", "committedDate": "2020-04-13T05:19:25Z", "type": "forcePushed"}, {"oid": "ad77253294c49bf4e967494c3dd520faee6f2033", "url": "https://github.com/apache/flink/commit/ad77253294c49bf4e967494c3dd520faee6f2033", "message": "Fixup.", "committedDate": "2020-04-13T12:47:11Z", "type": "forcePushed"}, {"oid": "1130ffe32e1f27241f5bf1bd42df0a7c4032a5e0", "url": "https://github.com/apache/flink/commit/1130ffe32e1f27241f5bf1bd42df0a7c4032a5e0", "message": "Fixup.", "committedDate": "2020-04-13T13:36:22Z", "type": "forcePushed"}, {"oid": "ad3964bfb00f5b3f93c933ff0d559d9df7d1991c", "url": "https://github.com/apache/flink/commit/ad3964bfb00f5b3f93c933ff0d559d9df7d1991c", "message": "Fixup.", "committedDate": "2020-04-13T13:48:17Z", "type": "forcePushed"}, {"oid": "b614959c881f48111893d798a8a0d28a4bbbf44e", "url": "https://github.com/apache/flink/commit/b614959c881f48111893d798a8a0d28a4bbbf44e", "message": "Fixup.", "committedDate": "2020-04-14T06:08:50Z", "type": "forcePushed"}, {"oid": "f2ba8a55cb8e441a1377b2cc00957e13e7445e47", "url": "https://github.com/apache/flink/commit/f2ba8a55cb8e441a1377b2cc00957e13e7445e47", "message": "Fixup.", "committedDate": "2020-04-15T03:50:00Z", "type": "forcePushed"}, {"oid": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "url": "https://github.com/apache/flink/commit/2462af49621e9f2ce29a26879a4b97d4ad752dc2", "message": "Fixup.", "committedDate": "2020-04-15T04:02:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NjE5Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408656192", "bodyText": "Unify this assert also for above isDataAvailableUnsafe?", "author": "zhijiangW", "createdAt": "2020-04-15T08:05:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -275,14 +283,24 @@ public PipelinedSubpartitionView createReadView(BufferAvailabilityListener avail\n \t\treturn readView;\n \t}\n \n-\tpublic boolean isAvailable() {\n+\tpublic boolean isAvailable(int numCreditsAvailable) {\n \t\tsynchronized (buffers) {\n-\t\t\treturn isAvailableUnsafe();\n+\t\t\tif (numCreditsAvailable > 0) {\n+\t\t\t\treturn isDataAvailableUnsafe();\n+\t\t\t}\n+\n+\t\t\treturn isEventAvailableUnsafe();\n \t\t}\n \t}\n \n-\tprivate boolean isAvailableUnsafe() {\n-\t\treturn flushRequested || getNumberOfFinishedBuffers() > 0;\n+\tprivate boolean isDataAvailableUnsafe() {\n+\t\treturn !isBlockedByCheckpoint && (flushRequested || getNumberOfFinishedBuffers() > 0);\n+\t}\n+\n+\tprivate boolean isEventAvailableUnsafe() {\n+\t\tassert Thread.holdsLock(buffers);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 07207ed52a2..9885195bca0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -294,6 +294,8 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t}\n \n \tprivate boolean isDataAvailableUnsafe() {\n+\t\tassert Thread.holdsLock(buffers);\n+\n \t\treturn !isBlockedByCheckpoint && (flushRequested || getNumberOfFinishedBuffers() > 0);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczMTQwOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408731408", "bodyText": "nit: better to assert channelIndexToInputChannel[channelIndex] != null in advance and give some rich informations if exception.", "author": "zhijiangW", "createdAt": "2020-04-15T10:11:38Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -616,6 +625,11 @@ public void sendTaskEvent(TaskEvent event) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void resumeConsumption(int channelIndex) {\n+\t\tchannelIndexToInputChannel[channelIndex].resumeConsumption();", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 705016f99cb..4cdbfdc741c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -627,6 +627,9 @@ public class SingleInputGate extends InputGate {\n \n \t@Override\n \tpublic void resumeConsumption(int channelIndex) {\n+\t\tcheckState(channelIndexToInputChannel[channelIndex] != null,\n+\t\t\t\"Trying to resume data consumption of an unblocked or uninitialized channel.\");\n+\n \t\tchannelIndexToInputChannel[channelIndex].resumeConsumption();\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczNDY3MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408734670", "bodyText": "@VisibleForTesting", "author": "zhijiangW", "createdAt": "2020-04-15T10:17:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -297,4 +312,8 @@ private void queueInputGate(InputGate inputGate) {\n \t\t\treturn Optional.of(inputGate);\n \t\t}\n \t}\n+\n+\tList<InputGate> getChannelIndexToInputGate() {", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\nindex 79c5f5d6015..dedf114458d 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n\n@@ -313,6 +314,7 @@ public class UnionInputGate extends InputGate {\n \t\t}\n \t}\n \n+\t@VisibleForTesting\n \tList<InputGate> getChannelIndexToInputGate() {\n \t\treturn channelIndexToInputGate;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MTI3Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408741272", "bodyText": "I guess this channel index change is irrelevant?", "author": "zhijiangW", "createdAt": "2020-04-15T10:29:56Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentTest.java", "diffHunk": "@@ -130,18 +130,18 @@ private void testRegisterTaskWithLimitedBuffers(int bufferPoolSize) throws Excep\n \t\tfinal SingleInputGate[] inputGates = new SingleInputGate[] {ig1, ig2, ig3, ig4};\n \n \t\tcreateRemoteInputChannel(ig4, 0, rp1, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig4, 0, rp2, connManager, network.getNetworkBufferPool());", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQzMDU0Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409430546", "bodyText": "yes, it is irrelevant.", "author": "wsry", "createdAt": "2020-04-16T09:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MTI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentTest.java\nindex 026d4a0b296..b1a23a475d8 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/NettyShuffleEnvironmentTest.java\n\n@@ -130,18 +130,18 @@ public class NettyShuffleEnvironmentTest extends TestLogger {\n \t\tfinal SingleInputGate[] inputGates = new SingleInputGate[] {ig1, ig2, ig3, ig4};\n \n \t\tcreateRemoteInputChannel(ig4, 0, rp1, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig4, 1, rp2, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig4, 2, rp3, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig4, 3, rp4, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig4, 0, rp2, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig4, 0, rp3, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig4, 0, rp4, connManager, network.getNetworkBufferPool());\n \n-\t\tcreateRemoteInputChannel(ig1, 0, rp1, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig1, 1, rp1, connManager, network.getNetworkBufferPool());\n \t\tcreateRemoteInputChannel(ig1, 1, rp4, connManager, network.getNetworkBufferPool());\n \n-\t\tcreateRemoteInputChannel(ig2, 0, rp2, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig2, 1, rp4, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig2, 1, rp2, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig2, 2, rp4, connManager, network.getNetworkBufferPool());\n \n-\t\tcreateRemoteInputChannel(ig3, 0, rp3, connManager, network.getNetworkBufferPool());\n-\t\tcreateRemoteInputChannel(ig3, 1, rp4, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig3, 1, rp3, connManager, network.getNetworkBufferPool());\n+\t\tcreateRemoteInputChannel(ig3, 3, rp4, connManager, network.getNetworkBufferPool());\n \n \t\tTask.setupPartitionsAndGates(resultPartitions, inputGates);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MzM1Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408743357", "bodyText": "nit: actually we can still retain testRecycleBuffer(boolean isBuffer) method and get the respective dataType before newBuffer here. Then we can avoid many above changes.", "author": "zhijiangW", "createdAt": "2020-04-15T10:33:45Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java", "diffHunk": "@@ -98,79 +98,79 @@ private static NetworkBuffer newBuffer(int length, int maxCapacity, boolean isBu\n \n \t@Test\n \tpublic void testDataBufferIsBuffer() {\n-\t\tassertFalse(newBuffer(1024, 1024, false).isBuffer());\n+\t\tassertFalse(newBuffer(1024, 1024, Buffer.DataType.EVENT_BUFFER).isBuffer());\n \t}\n \n \t@Test\n \tpublic void testEventBufferIsBuffer() {\n-\t\tassertFalse(newBuffer(1024, 1024, false).isBuffer());\n+\t\tassertFalse(newBuffer(1024, 1024, Buffer.DataType.EVENT_BUFFER).isBuffer());\n \t}\n \n \t@Test\n \tpublic void testDataBufferTagAsEvent() {\n-\t\ttestTagAsEvent(true);\n+\t\ttestTagAsEvent(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferTagAsEvent() {\n-\t\ttestTagAsEvent(false);\n+\t\ttestTagAsEvent(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate static void testTagAsEvent(boolean isBuffer) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n-\t\tbuffer.tagAsEvent();\n+\tprivate static void testTagAsEvent(Buffer.DataType dataType) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);\n+\t\tbuffer.setDataType(Buffer.DataType.EVENT_BUFFER);\n \t\tassertFalse(buffer.isBuffer());\n \t}\n \n \t@Test\n \tpublic void testDataBufferGetMemorySegment() {\n-\t\ttestGetMemorySegment(true);\n+\t\ttestGetMemorySegment(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetMemorySegment() {\n-\t\ttestGetMemorySegment(false);\n+\t\ttestGetMemorySegment(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate static void testGetMemorySegment(boolean isBuffer) {\n+\tprivate static void testGetMemorySegment(Buffer.DataType dataType) {\n \t\tfinal MemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(1024);\n-\t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE, isBuffer);\n+\t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE, dataType);\n \t\tassertSame(segment, buffer.getMemorySegment());\n \t}\n \n \t@Test\n \tpublic void testDataBufferGetRecycler() {\n-\t\ttestGetRecycler(true);\n+\t\ttestGetRecycler(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetRecycler() {\n-\t\ttestGetRecycler(false);\n+\t\ttestGetRecycler(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate static void testGetRecycler(boolean isBuffer) {\n+\tprivate static void testGetRecycler(Buffer.DataType dataType) {\n \t\tBufferRecycler recycler = MemorySegment::free;\n \n-\t\tNetworkBuffer dataBuffer = newBuffer(1024, 1024, isBuffer, recycler);\n+\t\tNetworkBuffer dataBuffer = newBuffer(1024, 1024, dataType, recycler);\n \t\tassertSame(recycler, dataBuffer.getRecycler());\n \t}\n \n \t@Test\n \tpublic void testDataBufferRecycleBuffer() {\n-\t\ttestRecycleBuffer(true);\n+\t\ttestRecycleBuffer(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferRecycleBuffer() {\n-\t\ttestRecycleBuffer(false);\n+\t\ttestRecycleBuffer(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n \t/**\n \t * Tests that {@link NetworkBuffer#recycleBuffer()} and {@link NetworkBuffer#isRecycled()} are\n \t * coupled and are also consistent with {@link NetworkBuffer#refCnt()}.\n \t */\n-\tprivate static void testRecycleBuffer(boolean isBuffer) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n+\tprivate static void testRecycleBuffer(Buffer.DataType dataType) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java\nindex 527af904cd0..e2bd723287f 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java\n\n@@ -98,79 +99,80 @@ public class NetworkBufferTest extends AbstractByteBufTest {\n \n \t@Test\n \tpublic void testDataBufferIsBuffer() {\n-\t\tassertFalse(newBuffer(1024, 1024, Buffer.DataType.EVENT_BUFFER).isBuffer());\n+\t\tassertFalse(newBuffer(1024, 1024, false).isBuffer());\n \t}\n \n \t@Test\n \tpublic void testEventBufferIsBuffer() {\n-\t\tassertFalse(newBuffer(1024, 1024, Buffer.DataType.EVENT_BUFFER).isBuffer());\n+\t\tassertFalse(newBuffer(1024, 1024, false).isBuffer());\n \t}\n \n \t@Test\n \tpublic void testDataBufferTagAsEvent() {\n-\t\ttestTagAsEvent(Buffer.DataType.DATA_BUFFER);\n+\t\ttestTagAsEvent(true);\n \t}\n \n \t@Test\n \tpublic void testEventBufferTagAsEvent() {\n-\t\ttestTagAsEvent(Buffer.DataType.EVENT_BUFFER);\n+\t\ttestTagAsEvent(false);\n \t}\n \n-\tprivate static void testTagAsEvent(Buffer.DataType dataType) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);\n+\tprivate static void testTagAsEvent(boolean isBuffer) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n \t\tbuffer.setDataType(Buffer.DataType.EVENT_BUFFER);\n \t\tassertFalse(buffer.isBuffer());\n \t}\n \n \t@Test\n \tpublic void testDataBufferGetMemorySegment() {\n-\t\ttestGetMemorySegment(Buffer.DataType.DATA_BUFFER);\n+\t\ttestGetMemorySegment(true);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetMemorySegment() {\n-\t\ttestGetMemorySegment(Buffer.DataType.EVENT_BUFFER);\n+\t\ttestGetMemorySegment(false);\n \t}\n \n-\tprivate static void testGetMemorySegment(Buffer.DataType dataType) {\n+\tprivate static void testGetMemorySegment(boolean isBuffer) {\n \t\tfinal MemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(1024);\n+\t\tBuffer.DataType dataType = isBuffer ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.EVENT_BUFFER;\n \t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE, dataType);\n \t\tassertSame(segment, buffer.getMemorySegment());\n \t}\n \n \t@Test\n \tpublic void testDataBufferGetRecycler() {\n-\t\ttestGetRecycler(Buffer.DataType.DATA_BUFFER);\n+\t\ttestGetRecycler(true);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetRecycler() {\n-\t\ttestGetRecycler(Buffer.DataType.EVENT_BUFFER);\n+\t\ttestGetRecycler(false);\n \t}\n \n-\tprivate static void testGetRecycler(Buffer.DataType dataType) {\n+\tprivate static void testGetRecycler(boolean isBuffer) {\n \t\tBufferRecycler recycler = MemorySegment::free;\n \n-\t\tNetworkBuffer dataBuffer = newBuffer(1024, 1024, dataType, recycler);\n+\t\tNetworkBuffer dataBuffer = newBuffer(1024, 1024, isBuffer, recycler);\n \t\tassertSame(recycler, dataBuffer.getRecycler());\n \t}\n \n \t@Test\n \tpublic void testDataBufferRecycleBuffer() {\n-\t\ttestRecycleBuffer(Buffer.DataType.DATA_BUFFER);\n+\t\ttestRecycleBuffer(true);\n \t}\n \n \t@Test\n \tpublic void testEventBufferRecycleBuffer() {\n-\t\ttestRecycleBuffer(Buffer.DataType.EVENT_BUFFER);\n+\t\ttestRecycleBuffer(false);\n \t}\n \n \t/**\n \t * Tests that {@link NetworkBuffer#recycleBuffer()} and {@link NetworkBuffer#isRecycled()} are\n \t * coupled and are also consistent with {@link NetworkBuffer#refCnt()}.\n \t */\n-\tprivate static void testRecycleBuffer(Buffer.DataType dataType) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);\n+\tprivate static void testRecycleBuffer(boolean isBuffer) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n \t\tassertFalse(buffer.isRecycled());\n \t\tbuffer.recycleBuffer();\n \t\tassertTrue(buffer.isRecycled());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MzYzNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408743635", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-15T10:34:16Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java", "diffHunk": "@@ -341,16 +341,16 @@ private static void testReadableBytes(boolean isBuffer) {\n \n \t@Test\n \tpublic void testDataBufferGetNioBufferReadable() {\n-\t\ttestGetNioBufferReadable(true);\n+\t\ttestGetNioBufferReadable(Buffer.DataType.DATA_BUFFER);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetNioBufferReadable() {\n-\t\ttestGetNioBufferReadable(false);\n+\t\ttestGetNioBufferReadable(Buffer.DataType.EVENT_BUFFER);\n \t}\n \n-\tprivate void testGetNioBufferReadable(boolean isBuffer) {", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java\nindex 527af904cd0..e2bd723287f 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferTest.java\n\n@@ -341,16 +343,16 @@ public class NetworkBufferTest extends AbstractByteBufTest {\n \n \t@Test\n \tpublic void testDataBufferGetNioBufferReadable() {\n-\t\ttestGetNioBufferReadable(Buffer.DataType.DATA_BUFFER);\n+\t\ttestGetNioBufferReadable(true);\n \t}\n \n \t@Test\n \tpublic void testEventBufferGetNioBufferReadable() {\n-\t\ttestGetNioBufferReadable(Buffer.DataType.EVENT_BUFFER);\n+\t\ttestGetNioBufferReadable(false);\n \t}\n \n-\tprivate void testGetNioBufferReadable(Buffer.DataType dataType) {\n-\t\tNetworkBuffer buffer = newBuffer(1024, 1024, dataType);\n+\tprivate void testGetNioBufferReadable(boolean isBuffer) {\n+\t\tNetworkBuffer buffer = newBuffer(1024, 1024, isBuffer);\n \n \t\tByteBuffer byteBuffer = buffer.getNioBufferReadable();\n \t\tassertFalse(byteBuffer.isReadOnly());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0NDE0Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408744143", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-15T10:35:19Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyMessageClientDecoderDelegateTest.java", "diffHunk": "@@ -219,20 +219,17 @@ private void testNettyMessageClientDecoding(\n \tprivate void addBufferResponse(\n \t\tList<NettyMessage> messages,\n \t\tInputChannelID inputChannelId,\n-\t\tboolean isBuffer,", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyMessageClientDecoderDelegateTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyMessageClientDecoderDelegateTest.java\nindex d8a57f8ade8..8b32e28e514 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyMessageClientDecoderDelegateTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyMessageClientDecoderDelegateTest.java\n\n@@ -219,17 +222,20 @@ public class NettyMessageClientDecoderDelegateTest extends TestLogger {\n \tprivate void addBufferResponse(\n \t\tList<NettyMessage> messages,\n \t\tInputChannelID inputChannelId,\n-\t\tBuffer.DataType dataType,\n+\t\tboolean isBuffer,\n \t\tint bufferSize,\n \t\tint seqNumber) {\n \n-\t\tBuffer buffer = createDataBuffer(bufferSize, dataType);\n+\t\tBuffer buffer = createDataBuffer(bufferSize);\n+\t\tif (!isBuffer) {\n+\t\t\tbuffer.tagAsEvent();\n+\t\t}\n \t\tmessages.add(new BufferResponse(buffer, seqNumber, inputChannelId, 1));\n \t}\n \n-\tprivate Buffer createDataBuffer(int size, Buffer.DataType dataType) {\n+\tprivate Buffer createDataBuffer(int size) {\n \t\tMemorySegment segment = MemorySegmentFactory.allocateUnpooledSegment(size);\n-\t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE, dataType);\n+\t\tNetworkBuffer buffer = new NetworkBuffer(segment, FreeingBufferRecycler.INSTANCE);\n \t\tfor (int i = 0; i < size / 4; ++i) {\n \t\t\tbuffer.writeInt(i);\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNTcwNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408905704", "bodyText": "\"and after that the buffered elements\" is not invalid", "author": "zhijiangW", "createdAt": "2020-04-15T14:53:20Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -146,7 +144,6 @@ public void testCheckpointBarriers() throws Exception {\n \n \t\t\t// now we should see the barrier and after that the buffered elements", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java\nindex 39d8adc5b27..129974001ef 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java\n\n@@ -142,7 +142,7 @@ public class MultipleInputStreamTaskTest {\n \t\t\ttestHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 2, 0);\n \t\t\ttestHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 2, 1);\n \n-\t\t\t// now we should see the barrier and after that the buffered elements\n+\t\t\t// now we should see the barrier\n \t\t\texpectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()));\n \n \t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyOTA4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408929085", "bodyText": "It should be put before testHarness.waitForInputProcessing()", "author": "zhijiangW", "createdAt": "2020-04-15T15:23:40Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java", "diffHunk": "@@ -464,16 +452,16 @@ public void testOvertakingCheckpointBarriers() throws Exception {\n \t\t// we should not yet see the barrier, only the two elements from non-blocked input\n \t\tTestHarnessUtil.assertOutputEquals(\"Output was not correct.\", expectedOutput, testHarness.getOutput());\n \n-\t\t// Now give a later barrier to all inputs, this should unblock the first channel,\n-\t\t// thereby allowing the two blocked elements through\n-\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n+\t\t// Now give a later barrier to all inputs, this should unblock the first channel\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1);\n \n+\t\t// wait until the channel is unblocked\n+\t\ttestHarness.waitForInputProcessing();\n+\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java\nindex 2fdcbdc20b8..aeb4e025f43 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTaskTest.java\n\n@@ -454,13 +454,10 @@ public class OneInputStreamTaskTest extends TestLogger {\n \n \t\t// Now give a later barrier to all inputs, this should unblock the first channel\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1);\n+\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1);\n \n-\t\t// wait until the channel is unblocked\n-\t\ttestHarness.waitForInputProcessing();\n-\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n-\n \t\texpectedOutput.add(new CancelCheckpointMarker(0));\n \t\texpectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyOTY4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408929685", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-15T15:24:27Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java", "diffHunk": "@@ -369,16 +359,16 @@ public void testOvertakingCheckpointBarriers() throws Exception {\n \t\t\t\texpectedOutput,\n \t\t\t\ttestHarness.getOutput());\n \n-\t\t// Now give a later barrier to all inputs, this should unblock the first channel,\n-\t\t// thereby allowing the two blocked elements through\n-\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n+\t\t// Now give a later barrier to all inputs, this should unblock the first channel\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1);\n \n+\t\t// wait until the channel is unblocked\n+\t\ttestHarness.waitForInputProcessing();\n+\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java\nindex c519ee896ea..b770167de33 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTaskTest.java\n\n@@ -361,13 +361,10 @@ public class TwoInputStreamTaskTest {\n \n \t\t// Now give a later barrier to all inputs, this should unblock the first channel\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1);\n+\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0);\n \t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1);\n \n-\t\t// wait until the channel is unblocked\n-\t\ttestHarness.waitForInputProcessing();\n-\t\ttestHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0);\n-\n \t\texpectedOutput.add(new CancelCheckpointMarker(0));\n \t\texpectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()));\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MDk5NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408960994", "bodyText": "This tests the?", "author": "zhijiangW", "createdAt": "2020-04-15T16:07:32Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -900,247 +580,185 @@ public void testMultiChannelAbortCheckpoint() throws Exception {\n \t\t\t\t// some buffers and a successful checkpoint\n \t\t\t/* 0 */ createBuffer(0), createBuffer(2), createBuffer(0),\n \t\t\t/* 3 */ createBarrier(1, 1), createBarrier(1, 2),\n-\t\t\t/* 5 */ createBuffer(2), createBuffer(1),\n-\t\t\t/* 7 */ createBarrier(1, 0),\n-\t\t\t/* 8 */ createBuffer(0), createBuffer(2),\n+\t\t\t/* 5 */ createBuffer(0),\n+\t\t\t/* 6 */ createBarrier(1, 0),\n+\t\t\t/* 7 */ createBuffer(0), createBuffer(2),\n \n \t\t\t\t// aborted on last barrier\n-\t\t\t/* 10 */ createBarrier(2, 0), createBarrier(2, 2),\n-\t\t\t/* 12 */ createBuffer(0), createBuffer(2),\n-\t\t\t/* 14 */ createCancellationBarrier(2, 1),\n+\t\t\t/* 9 */  createBarrier(2, 0), createBarrier(2, 2),\n+\t\t\t/* 11 */ createBuffer(1),\n+\t\t\t/* 12 */ createCancellationBarrier(2, 1),\n \n \t\t\t\t// successful checkpoint\n-\t\t\t/* 15 */ createBuffer(2), createBuffer(1),\n-\t\t\t/* 17 */ createBarrier(3, 1), createBarrier(3, 2), createBarrier(3, 0),\n+\t\t\t/* 13 */ createBuffer(2), createBuffer(1),\n+\t\t\t/* 15 */ createBarrier(3, 1), createBarrier(3, 2), createBarrier(3, 0),\n \n \t\t\t\t// abort on first barrier\n-\t\t\t/* 20 */ createBuffer(0), createBuffer(1),\n-\t\t\t/* 22 */ createCancellationBarrier(4, 1), createBarrier(4, 2),\n-\t\t\t/* 24 */ createBuffer(0),\n-\t\t\t/* 25 */ createBarrier(4, 0),\n+\t\t\t/* 18 */ createBuffer(0), createBuffer(1),\n+\t\t\t/* 20 */ createCancellationBarrier(4, 1), createBarrier(4, 2),\n+\t\t\t/* 22 */ createBuffer(2),\n+\t\t\t/* 23 */ createBarrier(4, 0),\n \n \t\t\t\t// another successful checkpoint\n-\t\t\t/* 26 */ createBuffer(0), createBuffer(1), createBuffer(2),\n-\t\t\t/* 29 */ createBarrier(5, 2), createBarrier(5, 1), createBarrier(5, 0),\n-\t\t\t/* 32 */ createBuffer(0), createBuffer(1),\n+\t\t\t/* 24 */ createBuffer(0), createBuffer(1), createBuffer(2),\n+\t\t\t/* 27 */ createBarrier(5, 2), createBarrier(5, 1), createBarrier(5, 0),\n+\t\t\t/* 30 */ createBuffer(0), createBuffer(1),\n \n \t\t\t\t// abort multiple cancellations and a barrier after the cancellations\n-\t\t\t/* 34 */ createCancellationBarrier(6, 1), createCancellationBarrier(6, 2),\n-\t\t\t/* 36 */ createBarrier(6, 0),\n+\t\t\t/* 32 */ createCancellationBarrier(6, 1), createCancellationBarrier(6, 2),\n+\t\t\t/* 34 */ createBarrier(6, 0),\n \n-\t\t\t/* 37 */ createBuffer(0)\n+\t\t\t/* 35 */ createBuffer(0)\n \t\t};\n-\t\tAbstractInvokable toNotify = mock(AbstractInvokable.class);\n+\t\tValidatingCheckpointHandler toNotify = new ValidatingCheckpointHandler();\n \t\tinputGate = createBarrierBuffer(3, sequence, toNotify);\n \n \t\tlong startTs;\n \n \t\t// successful first checkpoint, with some aligned buffers\n+\t\ttoNotify.setNextExpectedCheckpointId(1);\n \t\tcheck(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[1], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[2], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tstartTs = System.nanoTime();\n \t\tcheck(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n+\t\tcheck(sequence[7], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tvalidateAlignmentTime(startTs, inputGate);\n+\t\tInteger[] expectedUnblockedChannels1 = new Integer[] {0, 1, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels1, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n-\t\tcheck(sequence[6], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tcheck(sequence[11], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// canceled checkpoint on last barrier\n-\t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(2L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n-\t\tvalidateAlignmentTime(startTs, inputGate);\n \t\tcheck(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tassertEquals(2, toNotify.getLastCanceledCheckpointId());\n+\t\tInteger[] expectedUnblockedChannels2 = new Integer[] {0, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels2, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tassertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());\n+\t\tcheck(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// one more successful checkpoint\n-\t\tcheck(sequence[15], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[20], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(3L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n+\t\ttoNotify.setNextExpectedCheckpointId(3);\n+\t\tcheck(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tvalidateAlignmentTime(startTs, inputGate);\n-\t\tcheck(sequence[21], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tInteger[] expectedUnblockedChannels3 = new Integer[] {0, 1, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels3, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tcheck(sequence[19], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// this checkpoint gets immediately canceled\n-\t\tcheck(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(4L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n+\t\tcheck(sequence[22], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tassertEquals(4, toNotify.getLastCanceledCheckpointId());\n+\t\tassertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());\n \t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n+\t\tInteger[] expectedUnblockedChannels4 = new Integer[] {2};\n+\t\tassertArrayEquals(expectedUnblockedChannels4, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n \t\t// some buffers\n+\t\tcheck(sequence[24], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tInteger[] expectedUnblockedChannels5 = new Integer[] {0};\n+\t\tassertArrayEquals(expectedUnblockedChannels5, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tcheck(sequence[25], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tcheck(sequence[26], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[27], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[28], inputGate.pollNext().get(), PAGE_SIZE);\n \n \t\t// a simple successful checkpoint\n \t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[32], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(5L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n-\t\tvalidateAlignmentTime(startTs, inputGate);\n-\t\tcheck(sequence[33], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\tcheck(sequence[37], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(6L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n-\t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n-\t}\n-\n-\t@Test\n-\tpublic void testAbortViaQueuedBarriers() throws Exception {\n-\t\tBufferOrEvent[] sequence = {\n-\t\t\t\t// starting a checkpoint\n-\t\t\t/* 0 */ createBuffer(1),\n-\t\t\t/* 1 */ createBarrier(1, 1), createBarrier(1, 2),\n-\t\t\t/* 3 */ createBuffer(2), createBuffer(0), createBuffer(1),\n-\n-\t\t\t\t// queued barrier and cancellation barrier\n-\t\t\t/* 6 */ createCancellationBarrier(2, 2),\n-\t\t\t/* 7 */ createBarrier(2, 1),\n-\n-\t\t\t\t// some intermediate buffers (some queued)\n-\t\t\t/* 8 */ createBuffer(0), createBuffer(1), createBuffer(2),\n-\n-\t\t\t\t// complete initial checkpoint\n-\t\t\t/* 11 */ createBarrier(1, 0),\n-\n-\t\t\t\t// some buffers (none queued, since checkpoint is aborted)\n-\t\t\t/* 12 */ createBuffer(2), createBuffer(1), createBuffer(0),\n-\n-\t\t\t\t// final barrier of aborted checkpoint\n-\t\t\t/* 15 */ createBarrier(2, 0),\n-\n-\t\t\t\t// some more buffers\n-\t\t\t/* 16 */ createBuffer(0), createBuffer(1), createBuffer(2)\n-\t\t};\n-\t\tAbstractInvokable toNotify = mock(AbstractInvokable.class);\n-\t\tinputGate = createBarrierBuffer(3, sequence, toNotify);\n-\n-\t\tlong startTs;\n-\n-\t\tcheck(sequence[0], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// starting first checkpoint\n-\t\tstartTs = System.nanoTime();\n-\t\tcheck(sequence[4], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[8], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// finished first checkpoint\n-\t\tcheck(sequence[3], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(argThat(new CheckpointMatcher(1L)), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n+\t\ttoNotify.setNextExpectedCheckpointId(5);\n+\t\tcheck(sequence[30], inputGate.pollNext().get(), PAGE_SIZE);\n \t\tvalidateAlignmentTime(startTs, inputGate);\n+\t\tInteger[] expectedUnblockedChannels6 = new Integer[] {0, 1, 2};\n+\t\tassertArrayEquals(expectedUnblockedChannels6, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n+\t\tcheck(sequence[31], inputGate.pollNext().get(), PAGE_SIZE);\n \n-\t\tcheck(sequence[5], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// re-read the queued cancellation barriers\n-\t\tcheck(sequence[9], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(eq(2L),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n-\t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n-\n-\t\tcheck(sequence[10], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[12], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[13], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[14], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\tcheck(sequence[16], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[17], inputGate.pollNext().get(), PAGE_SIZE);\n-\t\tcheck(sequence[18], inputGate.pollNext().get(), PAGE_SIZE);\n-\n-\t\t// no further alignment should have happened\n+\t\tcheck(sequence[35], inputGate.pollNext().get(), PAGE_SIZE);\n+\t\tassertEquals(6, toNotify.getLastCanceledCheckpointId());\n+\t\tassertEquals(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER, toNotify.getCheckpointFailureReason());\n \t\tassertEquals(0L, inputGate.getAlignmentDurationNanos());\n+\t\tInteger[] expectedUnblockedChannels7 = new Integer[] {0};\n+\t\tassertArrayEquals(expectedUnblockedChannels7, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n-\t\t// no further checkpoint (abort) notifications\n-\t\tverify(toNotify, times(1)).triggerCheckpointOnBarrier(any(CheckpointMetaData.class), any(CheckpointOptions.class), any(CheckpointMetrics.class));\n-\t\tverify(toNotify, times(1)).abortCheckpointOnBarrier(anyLong(),\n-\t\t\targThat(new CheckpointExceptionMatcher(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER)));\n+\t\tassertEquals(3, toNotify.getTriggerCheckpointCounter());\n+\t\tassertEquals(3, toNotify.getAbortCheckpointCounter());\n \t}\n \n \t/**\n-\t * This tests the where a replay of queued checkpoint barriers meets\n-\t * a canceled checkpoint.\n+\t * This tests the where a checkpoint barriers meets a canceled checkpoint.", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\nindex 26f2dbf1698..03d2a0f96a5 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\n\n@@ -678,12 +678,12 @@ public abstract class CheckpointBarrierAlignerTestBase {\n \t\tInteger[] expectedUnblockedChannels7 = new Integer[] {0};\n \t\tassertArrayEquals(expectedUnblockedChannels7, mockInputGate.getAndResetLastUnblockedChannels().toArray());\n \n-\t\tassertEquals(3, toNotify.getTriggerCheckpointCounter());\n-\t\tassertEquals(3, toNotify.getAbortCheckpointCounter());\n+\t\tassertEquals(3, toNotify.getTriggeredCheckpointCounter());\n+\t\tassertEquals(3, toNotify.getAbortedCheckpointCounter());\n \t}\n \n \t/**\n-\t * This tests the where a checkpoint barriers meets a canceled checkpoint.\n+\t * This tests where a checkpoint barriers meets a canceled checkpoint.\n \t *\n \t * <p>The newer checkpoint barrier must not try to cancel the already canceled checkpoint.\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MzQ1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408963455", "bodyText": "nit: triggeredCheckpointCounter, abortedCheckpointCounter", "author": "zhijiangW", "createdAt": "2020-04-15T16:11:05Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -1284,8 +902,11 @@ private static void validateAlignmentTime(long alignmentStartTimestamp, Checkpoi\n \t */\n \tprivate static class ValidatingCheckpointHandler extends AbstractInvokable {\n \n+\t\tprivate CheckpointFailureReason failureReason;\n+\t\tprivate long lastCanceledCheckpointId = -1L;\n \t\tprivate long nextExpectedCheckpointId = -1L;\n-\t\tprivate long lastReportedBytesBufferedInAlignment = -1;\n+\t\tprivate long triggerCheckpointCounter = 0;", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\nindex 26f2dbf1698..03d2a0f96a5 100644\n--- a/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\n+++ b/flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java\n\n@@ -905,8 +905,8 @@ public abstract class CheckpointBarrierAlignerTestBase {\n \t\tprivate CheckpointFailureReason failureReason;\n \t\tprivate long lastCanceledCheckpointId = -1L;\n \t\tprivate long nextExpectedCheckpointId = -1L;\n-\t\tprivate long triggerCheckpointCounter = 0;\n-\t\tprivate long abortCheckpointCounter = 0;\n+\t\tprivate long triggeredCheckpointCounter = 0;\n+\t\tprivate long abortedCheckpointCounter = 0;\n \n \t\tpublic ValidatingCheckpointHandler() {\n \t\t\tsuper(new DummyEnvironment(\"test\", 1, 0));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3Njc0Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408976743", "bodyText": "nit: formatting  only make the argument getConfiguration().isExactlyOnceCheckpointMode() as as separate line", "author": "zhijiangW", "createdAt": "2020-04-15T16:31:31Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java", "diffHunk": "@@ -89,7 +89,8 @@ public void triggerCheckpoint(long checkpointId) throws FlinkException {\n \t\t\t\t\t// TODO - we need to see how to derive those. We should probably not encode this in the\n \t\t\t\t\t// TODO -   source's trigger message, but do a handshake in this task between the trigger\n \t\t\t\t\t// TODO -   message from the master, and the source's trigger notification\n-\t\t\t\t\tfinal CheckpointOptions checkpointOptions = CheckpointOptions.forCheckpointWithDefaultLocation();\n+\t\t\t\t\tfinal CheckpointOptions checkpointOptions = CheckpointOptions.", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java\nindex 21de7357b49..55b3b9bca27 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/SourceStreamTask.java\n\n@@ -89,8 +89,8 @@ public class SourceStreamTask<OUT, SRC extends SourceFunction<OUT>, OP extends S\n \t\t\t\t\t// TODO - we need to see how to derive those. We should probably not encode this in the\n \t\t\t\t\t// TODO -   source's trigger message, but do a handshake in this task between the trigger\n \t\t\t\t\t// TODO -   message from the master, and the source's trigger notification\n-\t\t\t\t\tfinal CheckpointOptions checkpointOptions = CheckpointOptions.\n-\t\t\t\t\t\tforCheckpointWithDefaultLocation(getConfiguration().isExactlyOnceCheckpointMode());\n+\t\t\t\t\tfinal CheckpointOptions checkpointOptions = CheckpointOptions.forCheckpointWithDefaultLocation(\n+\t\t\t\t\t\tgetConfiguration().isExactlyOnceCheckpointMode());\n \t\t\t\t\tfinal long timestamp = System.currentTimeMillis();\n \n \t\t\t\t\tfinal CheckpointMetaData checkpointMetaData = new CheckpointMetaData(checkpointId, timestamp);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI1OTkwOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409259909", "bodyText": "it is no need to call finish for this test, otherwise we also need to assert EndofPartitionEvent below.", "author": "zhijiangW", "createdAt": "2020-04-16T03:29:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -353,14 +354,32 @@ private void testBacklogConsistentWithNumberOfConsumableBuffers(boolean isFlushR\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.finish();", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\nindex aa14515725a..9dc2c4e98e2 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n\n@@ -356,39 +356,78 @@ public class PipelinedSubpartitionWithReadViewTest {\n \n \t@Test\n \tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n-\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tblockSubpartitionByCheckpoint(1);\n+\n+\t\t// add an event after subpartition blocked\n \t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\t// no data available notification after adding an event\n+\t\tcheckNumNotificationsAndAvailability(1);\n+\n+\t\tresumeConsumptionAndCheckAvailability(0, true);\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\n+\t\tblockSubpartitionByCheckpoint(2);\n+\n+\t\t// add a buffer and flush the subpartition\n \t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.finish();\n+\t\tsubpartition.flush();\n+\t\t// no data available notification after adding a buffer and flushing the subpartition\n+\t\tcheckNumNotificationsAndAvailability(2);\n \n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 1, true, true);\n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 1, false, true);\n-\t\tassertNoNextBuffer(readView);\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, false);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \n-\t\treadView.resumeConsumption();\n+\t\tblockSubpartitionByCheckpoint(3);\n \n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, true, 1, false, true);\n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 0, true, true);\n+\t\t// add two buffers to the subpartition\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\t// no data available notification after adding the second buffer\n+\t\tcheckNumNotificationsAndAvailability(3);\n+\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \t}\n \n \t// ------------------------------------------------------------------------\n \n+\tprivate void blockSubpartitionByCheckpoint(int numNotifications) throws IOException, InterruptedException {\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\t}\n+\n+\tprivate void checkNumNotificationsAndAvailability(int numNotifications) throws IOException, InterruptedException {\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\n+\t\t// view not available and no buffer can be read\n+\t\tassertFalse(readView.isAvailable(Integer.MAX_VALUE));\n+\t\tassertNoNextBuffer(readView);\n+\t}\n+\n+\tprivate void resumeConsumptionAndCheckAvailability(int availableCredit, boolean dataAvailable) {\n+\t\treadView.resumeConsumption();\n+\n+\t\tassertEquals(dataAvailable, readView.isAvailable(availableCredit));\n+\t}\n+\n \tstatic void assertNextBuffer(\n \t\t\tResultSubpartitionView readView,\n \t\t\tint expectedReadableBufferSize,\n-\t\t\tboolean expectedIsMoreAvailable,\n+\t\t\tboolean expectedIsDataAvailable,\n \t\t\tint expectedBuffersInBacklog,\n-\t\t\tboolean expectedIsMoreAvailableWithoutCredit,\n+\t\t\tboolean expectedIsEventAvailable,\n \t\t\tboolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {\n \t\tassertNextBufferOrEvent(\n \t\t\t\treadView,\n \t\t\t\texpectedReadableBufferSize,\n \t\t\t\ttrue,\n \t\t\t\tnull,\n-\t\t\t\texpectedIsMoreAvailable,\n+\t\t\t\texpectedIsDataAvailable,\n \t\t\t\texpectedBuffersInBacklog,\n-\t\t\t\texpectedIsMoreAvailableWithoutCredit,\n+\t\t\t\texpectedIsEventAvailable,\n \t\t\t\texpectedRecycledAfterRecycle);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDI4NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409260284", "bodyText": "why we can not verify the real event class here and pass null for all the events, otherwise it is no need to introduce this expectedEventClass argument in assertNextEvent", "author": "zhijiangW", "createdAt": "2020-04-16T03:31:13Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -353,14 +354,32 @@ private void testBacklogConsistentWithNumberOfConsumableBuffers(boolean isFlushR\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.finish();\n+\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 1, true, true);\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 1, false, true);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ2MTgwOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409461808", "bodyText": "The expectedEventClass is never used currently, and if we want to check the event class, we need to create a real event, however, we use fake events only.", "author": "wsry", "createdAt": "2020-04-16T10:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MDI4NA=="}], "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\nindex aa14515725a..9dc2c4e98e2 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n\n@@ -356,39 +356,78 @@ public class PipelinedSubpartitionWithReadViewTest {\n \n \t@Test\n \tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n-\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tblockSubpartitionByCheckpoint(1);\n+\n+\t\t// add an event after subpartition blocked\n \t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\t// no data available notification after adding an event\n+\t\tcheckNumNotificationsAndAvailability(1);\n+\n+\t\tresumeConsumptionAndCheckAvailability(0, true);\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\n+\t\tblockSubpartitionByCheckpoint(2);\n+\n+\t\t// add a buffer and flush the subpartition\n \t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.finish();\n+\t\tsubpartition.flush();\n+\t\t// no data available notification after adding a buffer and flushing the subpartition\n+\t\tcheckNumNotificationsAndAvailability(2);\n \n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 1, true, true);\n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 1, false, true);\n-\t\tassertNoNextBuffer(readView);\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, false);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \n-\t\treadView.resumeConsumption();\n+\t\tblockSubpartitionByCheckpoint(3);\n \n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, true, 1, false, true);\n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 0, true, true);\n+\t\t// add two buffers to the subpartition\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\t// no data available notification after adding the second buffer\n+\t\tcheckNumNotificationsAndAvailability(3);\n+\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \t}\n \n \t// ------------------------------------------------------------------------\n \n+\tprivate void blockSubpartitionByCheckpoint(int numNotifications) throws IOException, InterruptedException {\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\t}\n+\n+\tprivate void checkNumNotificationsAndAvailability(int numNotifications) throws IOException, InterruptedException {\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\n+\t\t// view not available and no buffer can be read\n+\t\tassertFalse(readView.isAvailable(Integer.MAX_VALUE));\n+\t\tassertNoNextBuffer(readView);\n+\t}\n+\n+\tprivate void resumeConsumptionAndCheckAvailability(int availableCredit, boolean dataAvailable) {\n+\t\treadView.resumeConsumption();\n+\n+\t\tassertEquals(dataAvailable, readView.isAvailable(availableCredit));\n+\t}\n+\n \tstatic void assertNextBuffer(\n \t\t\tResultSubpartitionView readView,\n \t\t\tint expectedReadableBufferSize,\n-\t\t\tboolean expectedIsMoreAvailable,\n+\t\t\tboolean expectedIsDataAvailable,\n \t\t\tint expectedBuffersInBacklog,\n-\t\t\tboolean expectedIsMoreAvailableWithoutCredit,\n+\t\t\tboolean expectedIsEventAvailable,\n \t\t\tboolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {\n \t\tassertNextBufferOrEvent(\n \t\t\t\treadView,\n \t\t\t\texpectedReadableBufferSize,\n \t\t\t\ttrue,\n \t\t\t\tnull,\n-\t\t\t\texpectedIsMoreAvailable,\n+\t\t\t\texpectedIsDataAvailable,\n \t\t\t\texpectedBuffersInBacklog,\n-\t\t\t\texpectedIsMoreAvailableWithoutCredit,\n+\t\t\t\texpectedIsEventAvailable,\n \t\t\t\texpectedRecycledAfterRecycle);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2MTMxMw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409261313", "bodyText": "I guess we also need to supplement the tests for covering the blocked subpartition for flush operation.", "author": "zhijiangW", "createdAt": "2020-04-16T03:35:32Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -353,14 +354,32 @@ private void testBacklogConsistentWithNumberOfConsumableBuffers(boolean isFlushR\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\nindex aa14515725a..9dc2c4e98e2 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n\n@@ -356,39 +356,78 @@ public class PipelinedSubpartitionWithReadViewTest {\n \n \t@Test\n \tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n-\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tblockSubpartitionByCheckpoint(1);\n+\n+\t\t// add an event after subpartition blocked\n \t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\t// no data available notification after adding an event\n+\t\tcheckNumNotificationsAndAvailability(1);\n+\n+\t\tresumeConsumptionAndCheckAvailability(0, true);\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\n+\t\tblockSubpartitionByCheckpoint(2);\n+\n+\t\t// add a buffer and flush the subpartition\n \t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.finish();\n+\t\tsubpartition.flush();\n+\t\t// no data available notification after adding a buffer and flushing the subpartition\n+\t\tcheckNumNotificationsAndAvailability(2);\n \n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 1, true, true);\n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 1, false, true);\n-\t\tassertNoNextBuffer(readView);\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, false);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \n-\t\treadView.resumeConsumption();\n+\t\tblockSubpartitionByCheckpoint(3);\n \n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, true, 1, false, true);\n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 0, true, true);\n+\t\t// add two buffers to the subpartition\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\t// no data available notification after adding the second buffer\n+\t\tcheckNumNotificationsAndAvailability(3);\n+\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \t}\n \n \t// ------------------------------------------------------------------------\n \n+\tprivate void blockSubpartitionByCheckpoint(int numNotifications) throws IOException, InterruptedException {\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\t}\n+\n+\tprivate void checkNumNotificationsAndAvailability(int numNotifications) throws IOException, InterruptedException {\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\n+\t\t// view not available and no buffer can be read\n+\t\tassertFalse(readView.isAvailable(Integer.MAX_VALUE));\n+\t\tassertNoNextBuffer(readView);\n+\t}\n+\n+\tprivate void resumeConsumptionAndCheckAvailability(int availableCredit, boolean dataAvailable) {\n+\t\treadView.resumeConsumption();\n+\n+\t\tassertEquals(dataAvailable, readView.isAvailable(availableCredit));\n+\t}\n+\n \tstatic void assertNextBuffer(\n \t\t\tResultSubpartitionView readView,\n \t\t\tint expectedReadableBufferSize,\n-\t\t\tboolean expectedIsMoreAvailable,\n+\t\t\tboolean expectedIsDataAvailable,\n \t\t\tint expectedBuffersInBacklog,\n-\t\t\tboolean expectedIsMoreAvailableWithoutCredit,\n+\t\t\tboolean expectedIsEventAvailable,\n \t\t\tboolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {\n \t\tassertNextBufferOrEvent(\n \t\t\t\treadView,\n \t\t\t\texpectedReadableBufferSize,\n \t\t\t\ttrue,\n \t\t\t\tnull,\n-\t\t\t\texpectedIsMoreAvailable,\n+\t\t\t\texpectedIsDataAvailable,\n \t\t\t\texpectedBuffersInBacklog,\n-\t\t\t\texpectedIsMoreAvailableWithoutCredit,\n+\t\t\t\texpectedIsEventAvailable,\n \t\t\t\texpectedRecycledAfterRecycle);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Mjg4Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409262886", "bodyText": "Unify the same naming for expectedIsMoreAvailableWithoutCredit as below expectedIsEventAvailable? also for expectedIsMoreAvailable", "author": "zhijiangW", "createdAt": "2020-04-16T03:42:06Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java", "diffHunk": "@@ -369,7 +388,7 @@ static void assertNextBuffer(\n \t\t\t\tnull,\n \t\t\t\texpectedIsMoreAvailable,\n \t\t\t\texpectedBuffersInBacklog,\n-\t\t\t\texpectedNextBufferIsEvent,\n+\t\t\t\texpectedIsMoreAvailableWithoutCredit,", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\nindex aa14515725a..9dc2c4e98e2 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionWithReadViewTest.java\n\n@@ -356,39 +356,78 @@ public class PipelinedSubpartitionWithReadViewTest {\n \n \t@Test\n \tpublic void testBlockedByCheckpointAndResumeConsumption() throws IOException, InterruptedException {\n-\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tblockSubpartitionByCheckpoint(1);\n+\n+\t\t// add an event after subpartition blocked\n \t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EVENT_BUFFER));\n+\t\t// no data available notification after adding an event\n+\t\tcheckNumNotificationsAndAvailability(1);\n+\n+\t\tresumeConsumptionAndCheckAvailability(0, true);\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\n+\t\tblockSubpartitionByCheckpoint(2);\n+\n+\t\t// add a buffer and flush the subpartition\n \t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n-\t\tsubpartition.finish();\n+\t\tsubpartition.flush();\n+\t\t// no data available notification after adding a buffer and flushing the subpartition\n+\t\tcheckNumNotificationsAndAvailability(2);\n \n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 1, true, true);\n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 1, false, true);\n-\t\tassertNoNextBuffer(readView);\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, false);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \n-\t\treadView.resumeConsumption();\n+\t\tblockSubpartitionByCheckpoint(3);\n \n-\t\tassertNextEvent(readView, BUFFER_SIZE, null, true, 1, false, true);\n-\t\tassertNextBuffer(readView, BUFFER_SIZE, true, 0, true, true);\n+\t\t// add two buffers to the subpartition\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\tsubpartition.add(createFilledFinishedBufferConsumer(BUFFER_SIZE));\n+\t\t// no data available notification after adding the second buffer\n+\t\tcheckNumNotificationsAndAvailability(3);\n+\n+\t\tresumeConsumptionAndCheckAvailability(Integer.MAX_VALUE, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n+\t\tassertNextBuffer(readView, BUFFER_SIZE, false, 0, false, true);\n \t}\n \n \t// ------------------------------------------------------------------------\n \n+\tprivate void blockSubpartitionByCheckpoint(int numNotifications) throws IOException, InterruptedException {\n+\t\tsubpartition.add(createEventBufferConsumer(BUFFER_SIZE, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\t\tassertNextEvent(readView, BUFFER_SIZE, null, false, 0, false, true);\n+\t}\n+\n+\tprivate void checkNumNotificationsAndAvailability(int numNotifications) throws IOException, InterruptedException {\n+\t\tassertEquals(numNotifications, availablityListener.getNumNotifications());\n+\n+\t\t// view not available and no buffer can be read\n+\t\tassertFalse(readView.isAvailable(Integer.MAX_VALUE));\n+\t\tassertNoNextBuffer(readView);\n+\t}\n+\n+\tprivate void resumeConsumptionAndCheckAvailability(int availableCredit, boolean dataAvailable) {\n+\t\treadView.resumeConsumption();\n+\n+\t\tassertEquals(dataAvailable, readView.isAvailable(availableCredit));\n+\t}\n+\n \tstatic void assertNextBuffer(\n \t\t\tResultSubpartitionView readView,\n \t\t\tint expectedReadableBufferSize,\n-\t\t\tboolean expectedIsMoreAvailable,\n+\t\t\tboolean expectedIsDataAvailable,\n \t\t\tint expectedBuffersInBacklog,\n-\t\t\tboolean expectedIsMoreAvailableWithoutCredit,\n+\t\t\tboolean expectedIsEventAvailable,\n \t\t\tboolean expectedRecycledAfterRecycle) throws IOException, InterruptedException {\n \t\tassertNextBufferOrEvent(\n \t\t\t\treadView,\n \t\t\t\texpectedReadableBufferSize,\n \t\t\t\ttrue,\n \t\t\t\tnull,\n-\t\t\t\texpectedIsMoreAvailable,\n+\t\t\t\texpectedIsDataAvailable,\n \t\t\t\texpectedBuffersInBacklog,\n-\t\t\t\texpectedIsMoreAvailableWithoutCredit,\n+\t\t\t\texpectedIsEventAvailable,\n \t\t\t\texpectedRecycledAfterRecycle);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2NDYzNg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409264636", "bodyText": "typo adequate?", "author": "zhijiangW", "createdAt": "2020-04-16T03:49:10Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java", "diffHunk": "@@ -381,6 +387,47 @@ public void testEnqueueReaderByNotifyingBufferAndCredit() throws Exception {\n \t\tassertNull(channel.readOutbound());\n \t}\n \n+\t/**\n+\t * Tests {@link PartitionRequestQueue#enqueueAvailableReader(NetworkSequenceViewReader)},\n+\t * verifying the reader would be enqueued in the pipeline after resuming data consumption if there\n+\t * are credit and data available.\n+\t */\n+\t@Test\n+\tpublic void testEnqueueReaderByResumingConsumption() throws Exception {\n+\t\tPipelinedSubpartition subpartition = PipelinedSubpartitionTest.createPipelinedSubpartition();\n+\t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.DATA_BUFFER));\n+\n+\t\tBufferAvailabilityListener bufferAvailabilityListener = new NoOpBufferAvailablityListener();\n+\t\tPipelinedSubpartitionView view = subpartition.createReadView(bufferAvailabilityListener);\n+\t\tResultPartitionProvider partitionProvider = (partitionId, index, availabilityListener) -> view;\n+\n+\t\tInputChannelID receiverId = new InputChannelID();\n+\t\tPartitionRequestQueue queue = new PartitionRequestQueue();\n+\t\tCreditBasedSequenceNumberingViewReader reader = new CreditBasedSequenceNumberingViewReader(receiverId, 0, queue);\n+\t\tEmbeddedChannel channel = new EmbeddedChannel(queue);\n+\n+\t\treader.requestSubpartitionView(partitionProvider, new ResultPartitionID(), 0);\n+\t\tqueue.notifyReaderCreated(reader);\n+\t\t// we have adequate credits", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ3MTUxMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409471511", "bodyText": "There seems no problem?", "author": "wsry", "createdAt": "2020-04-16T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2NDYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "3f566d7286ffa73fb26b729d76ccb5129ca3f974", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java\nindex 71992f309ee..18871439431 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueueTest.java\n\n@@ -395,7 +395,7 @@ public class PartitionRequestQueueTest {\n \t@Test\n \tpublic void testEnqueueReaderByResumingConsumption() throws Exception {\n \t\tPipelinedSubpartition subpartition = PipelinedSubpartitionTest.createPipelinedSubpartition();\n-\t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER));\n+\t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.ALIGNED_EXACTLY_ONCE_CHECKPOINT_BARRIER));\n \t\tsubpartition.add(createEventBufferConsumer(4096, Buffer.DataType.DATA_BUFFER));\n \n \t\tBufferAvailabilityListener bufferAvailabilityListener = new NoOpBufferAvailablityListener();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTQ4MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r409271481", "bodyText": "is it possible to call inputChannel#resumeConsumption instead of client.resumeConsumption, then we can further verify the interaction between input channel and client.", "author": "zhijiangW", "createdAt": "2020-04-16T04:16:54Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyPartitionRequestClientTest.java", "diffHunk": "@@ -142,6 +147,45 @@ public void testDoublePartitionRequest() throws Exception {\n \t\t}\n \t}\n \n+\t@Test\n+\tpublic void testResumeConsumption() throws Exception {\n+\t\tfinal CreditBasedPartitionRequestClientHandler handler = new CreditBasedPartitionRequestClientHandler();\n+\t\tfinal EmbeddedChannel channel = new EmbeddedChannel(handler);\n+\t\tfinal PartitionRequestClient client = createPartitionRequestClient(channel, handler);\n+\n+\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(10, 32, 2);\n+\t\tfinal SingleInputGate inputGate = createSingleInputGate(1);\n+\t\tfinal RemoteInputChannel inputChannel = createRemoteInputChannel(inputGate, client, networkBufferPool);\n+\n+\t\ttry {\n+\t\t\tclient.resumeConsumption(inputChannel);", "originalCommit": "2462af49621e9f2ce29a26879a4b97d4ad752dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2433d3d69e6e18b138a8672259da42bf619e994e", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyPartitionRequestClientTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyPartitionRequestClientTest.java\nindex 9ce91bdd97e..e63ab36c365 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyPartitionRequestClientTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/NettyPartitionRequestClientTest.java\n\n@@ -158,9 +158,17 @@ public class NettyPartitionRequestClientTest {\n \t\tfinal RemoteInputChannel inputChannel = createRemoteInputChannel(inputGate, client, networkBufferPool);\n \n \t\ttry {\n-\t\t\tclient.resumeConsumption(inputChannel);\n+\t\t\tfinal BufferPool bufferPool = networkBufferPool.createBufferPool(6, 6);\n+\t\t\tinputGate.setBufferPool(bufferPool);\n+\t\t\tinputGate.assignExclusiveSegments();\n+\t\t\tinputChannel.requestSubpartition(0);\n+\n+\t\t\tinputChannel.resumeConsumption();\n \t\t\tchannel.runPendingTasks();\n \t\t\tObject readFromOutbound = channel.readOutbound();\n+\t\t\tassertThat(readFromOutbound, instanceOf(PartitionRequest.class));\n+\n+\t\t\treadFromOutbound = channel.readOutbound();\n \t\t\tassertThat(readFromOutbound, instanceOf(ResumeConsumption.class));\n \t\t\tassertEquals(inputChannel.getInputChannelId(), ((ResumeConsumption) readFromOutbound).receiverId);\n \n"}}, {"oid": "2433d3d69e6e18b138a8672259da42bf619e994e", "url": "https://github.com/apache/flink/commit/2433d3d69e6e18b138a8672259da42bf619e994e", "message": "Fixup.", "committedDate": "2020-04-16T14:12:56Z", "type": "forcePushed"}, {"oid": "57564cc22bdc5fb9055a9896fce66bc0305b4e31", "url": "https://github.com/apache/flink/commit/57564cc22bdc5fb9055a9896fce66bc0305b4e31", "message": "Fixup.", "committedDate": "2020-04-16T14:24:39Z", "type": "forcePushed"}, {"oid": "3f566d7286ffa73fb26b729d76ccb5129ca3f974", "url": "https://github.com/apache/flink/commit/3f566d7286ffa73fb26b729d76ccb5129ca3f974", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-04-21T06:43:22Z", "type": "forcePushed"}, {"oid": "a11d205402403f51c637b6605e7e97ee98e37151", "url": "https://github.com/apache/flink/commit/a11d205402403f51c637b6605e7e97ee98e37151", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-04-21T07:09:34Z", "type": "forcePushed"}, {"oid": "f8c88d15d2c173ab2dd0c03b0a6d702d7bcfbf18", "url": "https://github.com/apache/flink/commit/f8c88d15d2c173ab2dd0c03b0a6d702d7bcfbf18", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-04-21T08:31:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzNjEyNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r412036125", "bodyText": "nit: final", "author": "zhijiangW", "createdAt": "2020-04-21T09:43:29Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializerTest.java", "diffHunk": "@@ -44,16 +45,16 @@\n  */\n public class EventSerializerTest {\n \n+\tprivate AbstractEvent[] events = {", "originalCommit": "f8c88d15d2c173ab2dd0c03b0a6d702d7bcfbf18", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da21a760104d6786dcfce33022bd3fd8ce659218", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializerTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializerTest.java\nindex 36135912e39..fb579f61bb2 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializerTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/io/network/api/serialization/EventSerializerTest.java\n\n@@ -45,7 +45,7 @@ import static org.junit.Assert.fail;\n  */\n public class EventSerializerTest {\n \n-\tprivate AbstractEvent[] events = {\n+\tprivate final AbstractEvent[] events = {\n \t\tEndOfPartitionEvent.INSTANCE,\n \t\tEndOfSuperstepEvent.INSTANCE,\n \t\tnew CheckpointBarrier(1678L, 4623784L, CheckpointOptions.forCheckpointWithDefaultLocation()),\n"}}, {"oid": "da21a760104d6786dcfce33022bd3fd8ce659218", "url": "https://github.com/apache/flink/commit/da21a760104d6786dcfce33022bd3fd8ce659218", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of sender side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-21T13:18:31Z", "type": "forcePushed"}, {"oid": "0058feb1dfb56caaf7e4322948f5b9c05782f8c1", "url": "https://github.com/apache/flink/commit/0058feb1dfb56caaf7e4322948f5b9c05782f8c1", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of receiver side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-22T07:09:15Z", "type": "forcePushed"}, {"oid": "725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "url": "https://github.com/apache/flink/commit/725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "message": "[hotfix][checkpointing] Make CheckpointBarrierUnaligner#processEndOfPartition always return false\n\nFor unaligned checkpoint, no buffer is stored in BufferStorage so CheckpointBarrierUnaligner#processEndOfPartition should always return false.\n\nThis closes #11351.", "committedDate": "2020-04-27T02:42:56Z", "type": "commit"}, {"oid": "8d9b20a00c83e8c65904dd9dfc179298481f7759", "url": "https://github.com/apache/flink/commit/8d9b20a00c83e8c65904dd9dfc179298481f7759", "message": "[hotfix] Add more information to CheckpointCoordinatorConfiguration#toString\n\nThis closes #11351.", "committedDate": "2020-04-27T02:42:56Z", "type": "commit"}, {"oid": "d05bfb1ccc492a22a738da35135e372f7f2c48dc", "url": "https://github.com/apache/flink/commit/d05bfb1ccc492a22a738da35135e372f7f2c48dc", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of receiver side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-27T02:42:56Z", "type": "commit"}, {"oid": "d05bfb1ccc492a22a738da35135e372f7f2c48dc", "url": "https://github.com/apache/flink/commit/d05bfb1ccc492a22a738da35135e372f7f2c48dc", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment\n\nThis commit is the first part of implementation to solve the dead lock problem when reducing the exclusive buffer of receiver side to 0.\n\nReducing the number of exclusive buffers of receiver side to 0 can bring several advantages (may at the cost of some performance regression). One is that memory can be saved from the reduced network buffer usage. Another important benefit is that the in-flight data can be reduced so we can speed up checkpoint in cases of back pressure. However, for the current implementation, reducing the exclusive buffer of receiver side can incur deadlock problem because all the floating buffers might be requested away by some blocked input channels and never recycled until barrier alignment.\n\nTo solve the problem, this commit mainly makes the following changes:\n1. At sender side, after sending a checkpoint barrier when aligned exactly-once checkpoint mode is used, the outgoing channel will be blocked and no data will be sent out until the channel is unblocked.\n2. At receiver side, no buffer will be stored in BufferStorage any more and after a checkpoint is completed or canceled, the receiver side will resume data consumption and unblock the upstream by sending a special event to the sender side.\n\nNote that after this patch we still can't set the exclusive buffer of receiver side to 0 because there is still deadlock problem which will be totally solved in the following up patches.", "committedDate": "2020-04-27T02:42:56Z", "type": "forcePushed"}, {"oid": "715889a35cfcc3aaf1b17f39dadaa86f755cc75d", "url": "https://github.com/apache/flink/commit/715889a35cfcc3aaf1b17f39dadaa86f755cc75d", "message": "POC implementation.", "committedDate": "2020-03-09T06:45:35Z", "type": "forcePushed"}, {"oid": "5e0b21e2f80bc5c36a535f551b4092d65ecd5b2d", "url": "https://github.com/apache/flink/commit/5e0b21e2f80bc5c36a535f551b4092d65ecd5b2d", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-09T11:46:38Z", "type": "forcePushed"}, {"oid": "390cd7b46787bfc633f9389b9ad58e49e6ac5dde", "url": "https://github.com/apache/flink/commit/390cd7b46787bfc633f9389b9ad58e49e6ac5dde", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-09T12:44:46Z", "type": "forcePushed"}, {"oid": "72e2d899c555775ea9c91a34133ea53c1d30b476", "url": "https://github.com/apache/flink/commit/72e2d899c555775ea9c91a34133ea53c1d30b476", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-09T12:59:36Z", "type": "forcePushed"}, {"oid": "75745bb56c70eac5bbb2e5300097bb6a8c7bb59d", "url": "https://github.com/apache/flink/commit/75745bb56c70eac5bbb2e5300097bb6a8c7bb59d", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-10T01:08:40Z", "type": "forcePushed"}, {"oid": "548b22258f5e87fd53b45c7f4bb6de40bfd4e6d2", "url": "https://github.com/apache/flink/commit/548b22258f5e87fd53b45c7f4bb6de40bfd4e6d2", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-10T01:35:08Z", "type": "forcePushed"}, {"oid": "b797d2725d26d67674de8339e6d2714cf5ae98f3", "url": "https://github.com/apache/flink/commit/b797d2725d26d67674de8339e6d2714cf5ae98f3", "message": "Make buffer per incoming/outgoing channel configurable separately.", "committedDate": "2020-03-10T05:11:46Z", "type": "forcePushed"}, {"oid": "9dba52d31972da8bc11d85737443253f764c6508", "url": "https://github.com/apache/flink/commit/9dba52d31972da8bc11d85737443253f764c6508", "message": "Fix.", "committedDate": "2020-03-12T05:36:06Z", "type": "forcePushed"}, {"oid": "00bb983974bea0bed9158d48df1731e16f946495", "url": "https://github.com/apache/flink/commit/00bb983974bea0bed9158d48df1731e16f946495", "message": "Fix.", "committedDate": "2020-03-12T08:09:13Z", "type": "forcePushed"}, {"oid": "5397788869b81d0748153365bca510869fcb517a", "url": "https://github.com/apache/flink/commit/5397788869b81d0748153365bca510869fcb517a", "message": "Fix.", "committedDate": "2020-03-12T10:52:37Z", "type": "forcePushed"}, {"oid": "9179aab74eeaf80ea30c0894f3e5a0171338baed", "url": "https://github.com/apache/flink/commit/9179aab74eeaf80ea30c0894f3e5a0171338baed", "message": "Fix.", "committedDate": "2020-03-12T15:25:59Z", "type": "forcePushed"}, {"oid": "b55b4758c11950f6f1458ce707159fa0aca49311", "url": "https://github.com/apache/flink/commit/b55b4758c11950f6f1458ce707159fa0aca49311", "message": "Fix.", "committedDate": "2020-03-12T15:51:06Z", "type": "forcePushed"}, {"oid": "7c8f2ea9149fda45a6185323d2ed2312f2999acb", "url": "https://github.com/apache/flink/commit/7c8f2ea9149fda45a6185323d2ed2312f2999acb", "message": "Fix.", "committedDate": "2020-03-13T01:24:56Z", "type": "forcePushed"}, {"oid": "a90d241233087fe4f3aa753dbf1fe993a4724b3b", "url": "https://github.com/apache/flink/commit/a90d241233087fe4f3aa753dbf1fe993a4724b3b", "message": "Fix.", "committedDate": "2020-03-13T04:32:55Z", "type": "forcePushed"}, {"oid": "cd89aaad78cc8d5aaa3189725c8a3a183be23c2c", "url": "https://github.com/apache/flink/commit/cd89aaad78cc8d5aaa3189725c8a3a183be23c2c", "message": "Fix.", "committedDate": "2020-03-13T06:55:10Z", "type": "forcePushed"}, {"oid": "037afa2d30072bcb7822ec2933aac81b7e60a52b", "url": "https://github.com/apache/flink/commit/037afa2d30072bcb7822ec2933aac81b7e60a52b", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-18T18:41:11Z", "type": "forcePushed"}, {"oid": "eff786e8e89a13d4603daefdbcf841b9bfccf9f5", "url": "https://github.com/apache/flink/commit/eff786e8e89a13d4603daefdbcf841b9bfccf9f5", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T01:26:32Z", "type": "forcePushed"}, {"oid": "659fc3566aa008d1b688d189049add6944fed460", "url": "https://github.com/apache/flink/commit/659fc3566aa008d1b688d189049add6944fed460", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T03:15:10Z", "type": "forcePushed"}, {"oid": "7345f2aaac30d38cde01e0e84e7f127287d5c0c6", "url": "https://github.com/apache/flink/commit/7345f2aaac30d38cde01e0e84e7f127287d5c0c6", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T06:16:04Z", "type": "forcePushed"}, {"oid": "e068c1bff7d95844e1e24612abb1e66fc51c7925", "url": "https://github.com/apache/flink/commit/e068c1bff7d95844e1e24612abb1e66fc51c7925", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T07:59:49Z", "type": "forcePushed"}, {"oid": "5027d78272e7ff61fb81c07dd3b14da7db0b953d", "url": "https://github.com/apache/flink/commit/5027d78272e7ff61fb81c07dd3b14da7db0b953d", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-19T14:55:53Z", "type": "forcePushed"}, {"oid": "618ee8eece00841d86c0566c6e7c68cf0579be9e", "url": "https://github.com/apache/flink/commit/618ee8eece00841d86c0566c6e7c68cf0579be9e", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-21T13:27:18Z", "type": "forcePushed"}, {"oid": "0a9fd0d3530d2d504d8b535d0892a34a5d2d5e07", "url": "https://github.com/apache/flink/commit/0a9fd0d3530d2d504d8b535d0892a34a5d2d5e07", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-22T05:06:03Z", "type": "forcePushed"}, {"oid": "cd385c55e9dc111a061e19e2387f2ae9ce21369e", "url": "https://github.com/apache/flink/commit/cd385c55e9dc111a061e19e2387f2ae9ce21369e", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-22T05:21:13Z", "type": "forcePushed"}, {"oid": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "url": "https://github.com/apache/flink/commit/395bc07a4fca4e2f3ee8b96b4ef8054595227157", "message": "[FLINK-16404][runtime] Avoid caching buffers for blocked input channels before barrier alignment", "committedDate": "2020-03-22T08:52:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwNjk1Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396206957", "bodyText": "This change is irrelated?\nIf so, I suggest not making this change.", "author": "zhijiangW", "createdAt": "2020-03-23T04:23:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +309,13 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\tcheckState(!isBlockedByCheckpoint, \"Channel blocked by checkpoint.\");\n+\n+\t\t\tint numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\tnotifyAvailable = numAddedBuffers > 0 && unannouncedCredit++ == 0;\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n+\t\tif (notifyAvailable) {", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex e024e94e413..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -309,13 +311,10 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcheckState(!isBlockedByCheckpoint, \"Channel blocked by checkpoint.\");\n-\n-\t\t\tint numAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\tnotifyAvailable = numAddedBuffers > 0 && unannouncedCredit++ == 0;\n+\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (notifyAvailable) {\n+\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n \t\t\tnotifyCreditAvailable();\n \t\t}\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxMTEyMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396211120", "bodyText": "inputChannel ->  optionalInputChannel , irrelated changes, should revert.", "author": "zhijiangW", "createdAt": "2020-03-23T04:45:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -507,20 +510,27 @@ public boolean isFinished() {\n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n-\t\t\tif (!inputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> optionalInputChannel = getChannel(blocking);", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM1Njk5Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396356997", "bodyText": "name conflicts with the flowing InputChannel", "author": "wsry", "createdAt": "2020-03-23T10:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxMTEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 3486cda7d3c..3d6e9b3cfb4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -510,27 +513,20 @@ public class SingleInputGate extends InputGate {\n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> optionalInputChannel = getChannel(blocking);\n-\t\t\tif (!optionalInputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n+\t\t\tif (!inputChannel.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n \n-\t\t\tInputChannel inputChannel = optionalInputChannel.get();\n-\t\t\tsynchronized (inputChannelsWithData) {\n-\t\t\t\tif (channelsBlockedByCheckpoint.containsKey(inputChannel.getChannelIndex())) {\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n \t\t\t// Do not query inputChannel under the lock, to avoid potential deadlocks coming from\n \t\t\t// notifications.\n-\t\t\tOptional<BufferAndAvailability> result = inputChannel.getNextBuffer();\n+\t\t\tOptional<BufferAndAvailability> result = inputChannel.get().getNextBuffer();\n \n \t\t\tsynchronized (inputChannelsWithData) {\n \t\t\t\tif (result.isPresent() && result.get().moreAvailable()) {\n \t\t\t\t\t// enqueue the inputChannel at the end to avoid starvation\n-\t\t\t\t\tinputChannelsWithData.add(inputChannel);\n-\t\t\t\t\tenqueuedInputChannelsWithData.set(inputChannel.getChannelIndex());\n+\t\t\t\t\tinputChannelsWithData.add(inputChannel.get());\n+\t\t\t\t\tenqueuedInputChannelsWithData.set(inputChannel.get().getChannelIndex());\n \t\t\t\t}\n \n \t\t\t\tif (inputChannelsWithData.isEmpty()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2NDc2NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396264764", "bodyText": "It is better to reuse the blocked states from CheckpointBarrierAligner if possible to avoid managing it duplicated in another place and causing potential inconsistency.", "author": "zhijiangW", "createdAt": "2020-03-23T07:59:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -140,6 +141,8 @@\n \t/** Channels, which notified this input gate about available data. */\n \tprivate final ArrayDeque<InputChannel> inputChannelsWithData = new ArrayDeque<>();\n \n+\tprivate final HashMap<Integer, InputChannel> channelsBlockedByCheckpoint = new HashMap<>();", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 3486cda7d3c..3d6e9b3cfb4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -138,11 +137,12 @@ public class SingleInputGate extends InputGate {\n \t */\n \tprivate final Map<IntermediateResultPartitionID, InputChannel> inputChannels;\n \n+\t/** Used to get InputChannel by channel index. */\n+\tprivate final InputChannel[] channelIndexToInputChannel;\n+\n \t/** Channels, which notified this input gate about available data. */\n \tprivate final ArrayDeque<InputChannel> inputChannelsWithData = new ArrayDeque<>();\n \n-\tprivate final HashMap<Integer, InputChannel> channelsBlockedByCheckpoint = new HashMap<>();\n-\n \t/**\n \t * Field guaranteeing uniqueness for inputChannelsWithData queue. Both of those fields should be unified\n \t * onto one.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI2OTY0Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r396269643", "bodyText": "It is tricky to make zero credit has a special meaning, and we also break the previous assumption without negative credits.\nI think it might be better to define a separate message to describe the semantic of barrier alignment to unblock upstream side. Then the credit is always positive to be consistent as before, and we only define another blocked state on upstream side to control the buffer transport besides with positive credits.", "author": "zhijiangW", "createdAt": "2020-03-23T08:10:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -416,7 +452,18 @@ public int getUnannouncedCredit() {\n \t * @return Credit which was not announced to the sender yet.\n \t */\n \tpublic int getAndResetUnannouncedCredit() {\n-\t\treturn unannouncedCredit.getAndSet(0);\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tint credit = unannouncedCredit;\n+\t\t\tunannouncedCredit = 0;\n+\t\t\tif (credit == 0) {", "originalCommit": "395bc07a4fca4e2f3ee8b96b4ef8054595227157", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex e024e94e413..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -452,18 +426,7 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t * @return Credit which was not announced to the sender yet.\n \t */\n \tpublic int getAndResetUnannouncedCredit() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tint credit = unannouncedCredit;\n-\t\t\tunannouncedCredit = 0;\n-\t\t\tif (credit == 0) {\n-\t\t\t\tcredit = -bufferQueue.getAvailableBufferSize();\n-\t\t\t\tcheckState(isBlockedByCheckpoint, \"Should be blocked by checkpoint.\");\n-\t\t\t\tcheckState(-credit == initialCredit, \"Illegal number of available buffers.\");\n-\n-\t\t\t\tisBlockedByCheckpoint = false;\n-\t\t\t}\n-\t\t\treturn credit;\n-\t\t}\n+\t\treturn unannouncedCredit.getAndSet(0);\n \t}\n \n \t/**\n"}}, {"oid": "0603121a692db91a39416b27977843bb7c7db0a7", "url": "https://github.com/apache/flink/commit/0603121a692db91a39416b27977843bb7c7db0a7", "message": "Fixup.", "committedDate": "2020-03-23T10:52:09Z", "type": "forcePushed"}, {"oid": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "url": "https://github.com/apache/flink/commit/47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "message": "Fixup.", "committedDate": "2020-03-23T14:16:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA1MDUzNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397050537", "bodyText": "It seems a bit strange to see this field in BufferConsumer.\nAfter discussing offline, we introduce another enum type for identifying the specific AbstractEvent instance inside Buffer without deserialization. Then the required components can judge the type from buffer to make some improvements. At the beginning we only focus on CheckpointBarrier event and make others unknown.", "author": "zhijiangW", "createdAt": "2020-03-24T10:32:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java", "diffHunk": "@@ -44,6 +44,8 @@\n \n \tprivate int currentReaderPosition;\n \n+\tprivate final boolean isExactlyOnceBarrier;", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java\nindex 3bd6dfa562a..863b231201b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java\n\n@@ -44,8 +44,6 @@ public class BufferConsumer implements Closeable {\n \n \tprivate int currentReaderPosition;\n \n-\tprivate final boolean isExactlyOnceBarrier;\n-\n \t/**\n \t * Constructs {@link BufferConsumer} instance with the initial reader position.\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzgxNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397113817", "bodyText": "inputChannels are accessed via synchronized requestLock in other places. Do we need the sync here?", "author": "zhijiangW", "createdAt": "2020-03-24T12:27:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -616,6 +628,13 @@ public void sendTaskEvent(TaskEvent event) throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n+\t\tfor (InputChannel inputChannel: inputChannels.values()) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM0MzA3NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398343075", "bodyText": "I have removed this code", "author": "wsry", "createdAt": "2020-03-26T06:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzgxNw=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\nindex 94e847e6d9d..3d6e9b3cfb4 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java\n\n@@ -629,9 +623,9 @@ public class SingleInputGate extends InputGate {\n \t}\n \n \t@Override\n-\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n-\t\tfor (InputChannel inputChannel: inputChannels.values()) {\n-\t\t\tinputChannel.onExactlyOnceCheckpointCompletedOrCanceled(checkpointId);\n+\tpublic void resumeConsumption(int channelIndex) {\n+\t\tsynchronized (requestLock) {\n+\t\t\tchannelIndexToInputChannel[channelIndex].resumeConsumption();\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODQzNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397598435", "bodyText": "There are five paths for calling notifyCheckpointCompletedOrCanceled in this method, then it is a bit hard to trace every path and analysis whether it needs this call. In contrast, we can analysis this issue from a reverse way to make it easy. E.g. only two paths (begin new alignment and under current alignment) do not need the notify call, so we can make a boolean tag only for these two paths, and handle the unified notification at the end of this method.\nIn detail, we can define a boolean shouldNotify = true at the beginning of this method and also set the notifyCheckpointId = currentCheckpointId. Then tag this boolean as false in below two paths, and finally call notifyCheckpointCompletedOrCanceled at the end of this method if shouldNotify = true.", "author": "zhijiangW", "createdAt": "2020-03-25T04:05:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -100,21 +105,20 @@ public boolean isBlocked(int channelIndex) {\n \t}\n \n \t@Override\n-\tpublic boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception {\n+\tpublic void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {\n \t\tfinal long barrierId = receivedBarrier.getId();\n \n \t\t// fast path for single channel cases\n \t\tif (totalNumberOfInputChannels == 1) {\n \t\t\tif (barrierId > currentCheckpointId) {\n \t\t\t\t// new checkpoint\n \t\t\t\tcurrentCheckpointId = barrierId;\n-\t\t\t\tnotifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);\n+\t\t\t\tnotifyCheckpoint(receivedBarrier, latestAlignmentDurationNanos);\n \t\t\t}\n-\t\t\treturn false;\n+\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODg4Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397598886", "bodyText": "For the case of totalNumberOfInputChannels == 1, it should be handled separately for fast path. Then I suggest moving this path as a separate method to make #processBarrier seem shorter, and also it can be reused by below processCancellationBarrier if providing a function argument.", "author": "zhijiangW", "createdAt": "2020-03-25T04:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM0NDkwOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398344908", "bodyText": "I have changed the implementation", "author": "wsry", "createdAt": "2020-03-26T06:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODQzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -115,7 +127,7 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t\t\t\tcurrentCheckpointId = barrierId;\n \t\t\t\tnotifyCheckpoint(receivedBarrier, latestAlignmentDurationNanos);\n \t\t\t}\n-\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);\n+\t\t\tresumeConsumption(channelIndex);\n \t\t\treturn;\n \t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5ODk4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397598985", "bodyText": "we can reduce this path for simple by https://github.com/apache/flink/pull/11351/files#r397598435", "author": "zhijiangW", "createdAt": "2020-03-25T04:08:29Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -140,14 +144,15 @@ else if (barrierId > currentCheckpointId) {\n \n \t\t\t\t// abort the current checkpoint\n \t\t\t\treleaseBlocksAndResetBarriers();\n-\t\t\t\tcheckpointAborted = true;\n+\t\t\t\tnotifyCheckpointCompletedOrCanceled(currentCheckpointId);\n \n \t\t\t\t// begin a new checkpoint\n \t\t\t\tbeginNewAlignment(barrierId, channelIndex, receivedBarrier.getTimestamp());\n \t\t\t}\n \t\t\telse {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -144,15 +156,13 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \n \t\t\t\t// abort the current checkpoint\n \t\t\t\treleaseBlocksAndResetBarriers();\n-\t\t\t\tnotifyCheckpointCompletedOrCanceled(currentCheckpointId);\n \n \t\t\t\t// begin a new checkpoint\n \t\t\t\tbeginNewAlignment(barrierId, channelIndex, receivedBarrier.getTimestamp());\n \t\t\t}\n \t\t\telse {\n \t\t\t\t// ignore trailing barrier from an earlier checkpoint (obsolete now)\n-\t\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);\n-\t\t\t\treturn;\n+\t\t\t\tresumeConsumption(channelIndex);\n \t\t\t}\n \t\t}\n \t\telse if (barrierId > currentCheckpointId) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTA2OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397599068", "bodyText": "we can also reduce this path for simple by https://github.com/apache/flink/pull/11351/files#r397598435", "author": "zhijiangW", "createdAt": "2020-03-25T04:08:46Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -157,7 +162,8 @@ else if (barrierId > currentCheckpointId) {\n \t\telse {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -162,8 +172,7 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t\telse {\n \t\t\t// either the current checkpoint was canceled (numBarriers == 0) or\n \t\t\t// this barrier is from an old subsumed checkpoint\n-\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);\n-\t\t\treturn;\n+\t\t\tresumeConsumption(channelIndex);\n \t\t}\n \n \t\t// check if we have all barriers - since canceled checkpoints always have zero barriers\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTQ3OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397599479", "bodyText": "Refer to this idea https://github.com/apache/flink/pull/11351/files#r397598435, we can also avoid calling notifyCheckpointCompletedOrCanceled in five paths.", "author": "zhijiangW", "createdAt": "2020-03-25T04:10:21Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -214,7 +219,7 @@ protected void onBarrier(int channelIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic boolean processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n+\tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..7c6f002a18c 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -219,7 +214,7 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t}\n \n \t@Override\n-\tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n+\tpublic boolean processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tfinal long barrierId = cancelBarrier.getCheckpointId();\n \n \t\t// fast path for single channel cases\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTY5NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397599694", "bodyText": "nit: should be private method.", "author": "zhijiangW", "createdAt": "2020-03-25T04:11:27Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -318,6 +326,16 @@ public long getAlignmentDurationNanos() {\n \t\t}\n \t}\n \n+\tpublic void registerInputGate(CheckpointedInputGate inputGate) {\n+\t\tinputGates.add(checkNotNull(inputGate));\n+\t}\n+\n+\tpublic void notifyCheckpointCompletedOrCanceled(long checkpointId) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMTgwOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397601809", "bodyText": "We might need to adjust this method naming, because it is not indicating for the checkpoint really completed (the async checkpoint process). notifyUnblockInputChannels?", "author": "zhijiangW", "createdAt": "2020-03-25T04:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5OTY5NA=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -326,14 +325,11 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t\t}\n \t}\n \n-\tpublic void registerInputGate(CheckpointedInputGate inputGate) {\n-\t\tinputGates.add(checkNotNull(inputGate));\n-\t}\n+\tprivate void resumeConsumption(int channelIndex) {\n+\t\tInputGate inputGate = channelIndexToInputGate[channelIndex];\n+\t\tcheckState(!inputGate.isFinished(), \"InputGate already finished.\");\n \n-\tpublic void notifyCheckpointCompletedOrCanceled(long checkpointId) {\n-\t\tfor (CheckpointedInputGate inputGate: inputGates) {\n-\t\t\tinputGate.onExactlyOnceCheckpointCompletedOrCanceled(checkpointId);\n-\t\t}\n+\t\tinputGate.resumeConsumption(channelIndex - inputGateToChannelIndexOffset.get(inputGate));\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMDk1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397600950", "bodyText": "I am considering the call sequence for notifyCheckpoint and notifyCheckpointCompletedOrCanceled.\nnotifyCheckpoint might take some time for local IO operations I guess. If we can notifyCheckpointCompletedOrCanceled beforehand to unblock upstream to send data, then it might get benefit for performance.", "author": "zhijiangW", "createdAt": "2020-03-25T04:16:56Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -172,10 +178,9 @@ else if (barrierId > currentCheckpointId) {\n \t\t\t}\n \n \t\t\treleaseBlocksAndResetBarriers();\n-\t\t\tnotifyCheckpoint(receivedBarrier, bufferedBytes, latestAlignmentDurationNanos);\n-\t\t\treturn true;\n+\t\t\tnotifyCheckpoint(receivedBarrier, latestAlignmentDurationNanos);\n+\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM0Njk5MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398346990", "bodyText": "As suggested above, I move notify to the end of this method which unifies the notify process", "author": "wsry", "createdAt": "2020-03-26T06:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMDk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM1OTExMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r398359110", "bodyText": "As suggested above, I have moved the notify to the end of the method to unify the notifications.", "author": "wsry", "createdAt": "2020-03-26T07:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMDk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -179,7 +188,6 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \n \t\t\treleaseBlocksAndResetBarriers();\n \t\t\tnotifyCheckpoint(receivedBarrier, latestAlignmentDurationNanos);\n-\t\t\tnotifyCheckpointCompletedOrCanceled(barrierId);\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMjUyOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397602529", "bodyText": "Another option is passing inputGate in constructor instead to avoid exposing another methods outside. Otherwise in tests if someone constructs the CheckpointBarrierAligner, but forgets to register gate afterwards, then the gates are actually touched in the internal related processes to bring unexpected behaviors.", "author": "zhijiangW", "createdAt": "2020-03-25T04:24:00Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -318,6 +326,16 @@ public long getAlignmentDurationNanos() {\n \t\t}\n \t}\n \n+\tpublic void registerInputGate(CheckpointedInputGate inputGate) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex 233eae1aa08..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -326,14 +325,11 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t\t}\n \t}\n \n-\tpublic void registerInputGate(CheckpointedInputGate inputGate) {\n-\t\tinputGates.add(checkNotNull(inputGate));\n-\t}\n+\tprivate void resumeConsumption(int channelIndex) {\n+\t\tInputGate inputGate = channelIndexToInputGate[channelIndex];\n+\t\tcheckState(!inputGate.isFinished(), \"InputGate already finished.\");\n \n-\tpublic void notifyCheckpointCompletedOrCanceled(long checkpointId) {\n-\t\tfor (CheckpointedInputGate inputGate: inputGates) {\n-\t\t\tinputGate.onExactlyOnceCheckpointCompletedOrCanceled(checkpointId);\n-\t\t}\n+\t\tinputGate.resumeConsumption(channelIndex - inputGateToChannelIndexOffset.get(inputGate));\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwMzE2Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397603167", "bodyText": "we can avoid introducing the interface method and this empty implementation by https://github.com/apache/flink/pull/11351/files#r397602529", "author": "zhijiangW", "createdAt": "2020-03-25T04:26:53Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java", "diffHunk": "@@ -230,8 +227,7 @@ public long getAlignmentDurationNanos() {\n \t}\n \n \t@Override\n-\tpublic void checkpointSizeLimitExceeded(long maxBufferedBytes) throws Exception {\n-\t\tthrow new UnsupportedOperationException(\"This should never happened as this class doesn't block any data\");\n+\tpublic void registerInputGate(CheckpointedInputGate inputGate) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java\nindex 20214bdb654..e93063594b1 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierTracker.java\n\n@@ -226,10 +226,6 @@ public class CheckpointBarrierTracker extends CheckpointBarrierHandler {\n \t\treturn 0;\n \t}\n \n-\t@Override\n-\tpublic void registerInputGate(CheckpointedInputGate inputGate) {\n-\t}\n-\n \t/**\n \t * Simple class for a checkpoint ID with a barrier counter.\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNTg3MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397605870", "bodyText": "We can also avoid this synchronized after removing states by #11351 (comment)", "author": "zhijiangW", "createdAt": "2020-03-25T04:40:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -397,6 +409,17 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n+\t\tsynchronized (bufferQueue) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 0ba3faf18d9..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -410,14 +398,13 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t}\n \n \t@Override\n-\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (!isBlockedByCheckpoint(checkpointId)) {\n-\t\t\t\treturn;\n-\t\t\t}\n+\tpublic void resumeConsumption() {\n+\t\tcheckState(!isReleased.get(), \"Channel released.\");\n+\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n \n-\t\t\tnotifyResumeConsumption();\n-\t\t}\n+\t\t// notifies the producer that this channel is ready to\n+\t\t// unblock from checkpoint and resume data consumption\n+\t\tpartitionRequestClient.resumeConsumption(this);\n \t}\n \n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYwNjAzNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397606034", "bodyText": "if (isBlockedByCheckpoint(checkpointId)) {\n    notifyResumeConsumption()\n}", "author": "zhijiangW", "createdAt": "2020-03-25T04:40:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -397,6 +409,17 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tif (!isBlockedByCheckpoint(checkpointId)) {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 0ba3faf18d9..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -410,14 +398,13 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t}\n \n \t@Override\n-\tpublic void onExactlyOnceCheckpointCompletedOrCanceled(long checkpointId) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (!isBlockedByCheckpoint(checkpointId)) {\n-\t\t\t\treturn;\n-\t\t\t}\n+\tpublic void resumeConsumption() {\n+\t\tcheckState(!isReleased.get(), \"Channel released.\");\n+\t\tcheckState(partitionRequestClient != null, \"Trying to send event to producer before requesting a queue.\");\n \n-\t\t\tnotifyResumeConsumption();\n-\t\t}\n+\t\t// notifies the producer that this channel is ready to\n+\t\t// unblock from checkpoint and resume data consumption\n+\t\tpartitionRequestClient.resumeConsumption(this);\n \t}\n \n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxMDUxNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397610517", "bodyText": "I considered discarding these two states in InputChannel level to unify reuse the states inside CheckpointBarrierAligner.\nRegarding the RemoteInputChannel case, these two states are used for avoiding unnecessary notification for upstream side if the unblock is triggered by other channels.\nOne possible option is to pass the boolean array of blocked channelsfromCheckpointBarrierAlignerwhile callingnotifyCheckpointCompletedOrCanceled. In CheckpointedInputGateandUnionInputGatelevel, they can also  pass the maintainedoffsetIndexto dedicatedSingleInputGate, then the single gate can judge whether the respective RemoteInputChannel` is actually blocked or not to notify the upstream side if necessary.\nRegarding the LocalInputChannel case, we can consider it separately.", "author": "zhijiangW", "createdAt": "2020-03-25T05:01:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -56,6 +57,10 @@\n \n \tprotected final SingleInputGate inputGate;\n \n+\tprotected long currentCheckpointId = -1;\n+\n+\tprotected ChannelState channelState = ChannelState.CONSUMING;", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxODI2Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397618266", "bodyText": "For the case of LocalInputChannel, the current problem is that when the subparition view notifies the data available, then the respective local channel would be added into gate data queue. When the gate pools buffer from such local channel, it should be aware whether this local channel was already blocked by CheckpointBarrierAligner or not. If blocked, it should not return this buffer to upper component to avoid caching.\nAnother option to solve this issue is to avoid adding local channel into gate queue via tagging the blocked state in ResultSubpartitionView. We already added this state in NetworkSequenceViewReader for remote channel. If we can migrate this state into ResultSubpartitionView level, then we can make reuse of this state for both remote and local channels. And I think it should be transparent to do the similar things either in  NetworkSequenceViewReader or ResultSubpartitionView.", "author": "zhijiangW", "createdAt": "2020-03-25T05:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYxMDUxNw=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex 75b4135fc96..40aac5b048c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n\n@@ -57,10 +56,6 @@ public abstract class InputChannel {\n \n \tprotected final SingleInputGate inputGate;\n \n-\tprotected long currentCheckpointId = -1;\n-\n-\tprotected ChannelState channelState = ChannelState.CONSUMING;\n-\n \t// - Asynchronous error notification --------------------------------------\n \n \tprivate final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY0Njc1Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397646752", "bodyText": "This can be removed if removing states by #11351 (comment)", "author": "zhijiangW", "createdAt": "2020-03-25T07:14:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -419,6 +442,17 @@ public int getAndResetUnannouncedCredit() {\n \t\treturn unannouncedCredit.getAndSet(0);\n \t}\n \n+\t/**\n+\t * Unblocks this channel from exactly once checkpoint.\n+\t */\n+\tpublic void unblockChannel() {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 0ba3faf18d9..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -442,17 +429,6 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\treturn unannouncedCredit.getAndSet(0);\n \t}\n \n-\t/**\n-\t * Unblocks this channel from exactly once checkpoint.\n-\t */\n-\tpublic void unblockChannel() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tcheckState(channelState == ChannelState.RESUMING, \"Channel should be in RESUMING state.\");\n-\n-\t\t\tchannelState = ChannelState.CONSUMING;\n-\t\t}\n-\t}\n-\n \t/**\n \t * Gets the current number of received buffers which have not been processed yet.\n \t *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MDQ0MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r397650441", "bodyText": "It should make use of existing writeAndFlushNextMessageIfPossible for writing any messages on downstream side, otherwise we might miss some conditions such as if (channelError.get() != null || !channel.isWritable())  inside previous writeAndFlushNextMessageIfPossible. And also bring much overhead work for maintaining two different paths (e.g. for failure handling).\nWe can refactor the existing inputChannelsWithCredit as a more general outbound message queue to insert both AddCredit and ResumeConsumption messages. And define an abstract ClientOutboundMessage with buildMessage method to be implemented by AddCredit and ResumeConsumption separately during writeAndFlushNextMessageIfPossible.", "author": "zhijiangW", "createdAt": "2020-03-25T07:25:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -193,6 +199,16 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exc\n \t\t\tif (triggerWrite) {\n \t\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n \t\t\t}\n+\t\t} else if (msg instanceof ResumeConsumptionEvent) {\n+\t\t\tRemoteInputChannel inputChannel = ((ResumeConsumptionEvent) msg).inputChannel;\n+\t\t\tinputChannel.unblockChannel();\n+\t\t\tResumeConsumption resumeConsumption = new ResumeConsumption(inputChannel.getInputChannelId());\n+\n+\t\t\tctx.channel().writeAndFlush(resumeConsumption).addListener((ChannelFutureListener) channelFuture -> {", "originalCommit": "47267a0ddd0dd8fded91dc33eeaecac3c83cbb36", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex ce4bd05e62b..4f3d872a692 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -191,24 +193,14 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \t */\n \t@Override\n \tpublic void userEventTriggered(ChannelHandlerContext ctx, Object msg) throws Exception {\n-\t\tif (msg instanceof RemoteInputChannel) {\n-\t\t\tboolean triggerWrite = inputChannelsWithCredit.isEmpty();\n+\t\tif (msg instanceof ClientOutboundMessage) {\n+\t\t\tboolean triggerWrite = clientOutboundMessages.isEmpty();\n \n-\t\t\tinputChannelsWithCredit.add((RemoteInputChannel) msg);\n+\t\t\tclientOutboundMessages.add((ClientOutboundMessage) msg);\n \n \t\t\tif (triggerWrite) {\n \t\t\t\twriteAndFlushNextMessageIfPossible(ctx.channel());\n \t\t\t}\n-\t\t} else if (msg instanceof ResumeConsumptionEvent) {\n-\t\t\tRemoteInputChannel inputChannel = ((ResumeConsumptionEvent) msg).inputChannel;\n-\t\t\tinputChannel.unblockChannel();\n-\t\t\tResumeConsumption resumeConsumption = new ResumeConsumption(inputChannel.getInputChannelId());\n-\n-\t\t\tctx.channel().writeAndFlush(resumeConsumption).addListener((ChannelFutureListener) channelFuture -> {\n-\t\t\t\tif (!channelFuture.isSuccess()) {\n-\t\t\t\t\tnotifyAllChannelsOfErrorAndClose(channelFuture.cause());\n-\t\t\t\t}\n-\t\t\t});\n \t\t} else {\n \t\t\tctx.fireUserEventTriggered(msg);\n \t\t}\n"}}, {"oid": "59b1e101500b638019f58c27daa18b19ebcbaa3b", "url": "https://github.com/apache/flink/commit/59b1e101500b638019f58c27daa18b19ebcbaa3b", "message": "Fixup.", "committedDate": "2020-03-26T08:38:10Z", "type": "forcePushed"}, {"oid": "f86372054c1c4724b8dabc8d06e369475e64ac29", "url": "https://github.com/apache/flink/commit/f86372054c1c4724b8dabc8d06e369475e64ac29", "message": "Fixup.", "committedDate": "2020-03-26T10:43:25Z", "type": "forcePushed"}, {"oid": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "url": "https://github.com/apache/flink/commit/ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "message": "Fixup.", "committedDate": "2020-03-26T15:48:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5NTEwMA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402795100", "bodyText": "It seems not clear whether the passed dataType must be an event type or not. So the method naming with argument seems not consistent, i prefer to naming the method as tagDataType or setDataType", "author": "zhijiangW", "createdAt": "2020-04-03T07:45:37Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -55,9 +57,9 @@\n \tboolean isBuffer();\n \n \t/**\n-\t * Tags this buffer to represent an event.\n+\t * Tags this buffer to represent an event of the given type.\n \t */\n-\tvoid tagAsEvent();\n+\tvoid tagAsEvent(DataType dataType);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex b25444e9673..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -56,11 +56,6 @@ public interface Buffer {\n \t */\n \tboolean isBuffer();\n \n-\t/**\n-\t * Tags this buffer to represent an event of the given type.\n-\t */\n-\tvoid tagAsEvent(DataType dataType);\n-\n \t/**\n \t * Returns the underlying memory segment. This method is dangerous since it ignores read only protections and omits\n \t * slices. Use it only along the {@link #getMemorySegmentOffset()}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5ODE1NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402798154", "bodyText": "nit: add an empty line after each value.", "author": "zhijiangW", "createdAt": "2020-04-03T07:50:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true, false),\n+\t\t/**", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex b25444e9673..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -231,51 +226,58 @@ public interface Buffer {\n \tvoid setCompressed(boolean isCompressed);\n \n \t/**\n-\t * Gets the type of data this buffer contains.\n+\t * Gets the type of data this buffer represents.\n \t */\n \tDataType getDataType();\n \n \t/**\n-\t * Used to identify the type of data contained in {@link Buffer}.\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in the {@link Buffer} so that we can get\n+\t * the information without deserializing the serialized data.\n \t */\n \tenum DataType {\n \t\t/**\n \t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n \t\t */\n-\t\tDATA_BUFFER(true, false),\n+\t\tDATA_BUFFER(true),\n+\n \t\t/**\n-\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n-\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t * EVENT_BUFFER indicates that this buffer represents serialized data of an event.\n+\t\t * Note that this type can be further divided into more fine-grained event types\n+\t\t * like {@link #EXACTLY_ONCE_CHECKPOINT_BARRIER} and etc.\n \t\t */\n-\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\tEVENT_BUFFER(false),\n+\n \t\t/**\n-\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n-\t\t * unknown event.\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a serialized\n+\t\t * checkpoint barrier of exactly once checkpoint mode.\n \t\t */\n-\t\tUNKNOWN_EVENT(false, false);\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false);\n \n \t\tprivate final boolean isBuffer;\n \n-\t\tprivate final boolean isExactlyOnceCheckpointBarrier;\n-\n-\t\tDataType(boolean isBuffer, boolean isExactlyOnceCheckpointBarrier) {\n+\t\tDataType(boolean isBuffer) {\n \t\t\tthis.isBuffer = isBuffer;\n-\t\t\tthis.isExactlyOnceCheckpointBarrier = isExactlyOnceCheckpointBarrier;\n \t\t}\n \n \t\tpublic boolean isBuffer() {\n \t\t\treturn isBuffer;\n \t\t}\n \n-\t\tpublic boolean isExactlyOnceCheckpointBarrier() {\n-\t\t\treturn isExactlyOnceCheckpointBarrier;\n+\t\tpublic static boolean isExactlyOnceCheckpointBarrier(Buffer buffer) {\n+\t\t\treturn buffer.getDataType() == EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t}\n \n \t\tpublic static DataType getDataType(AbstractEvent event) {\n-\t\t\tif (event instanceof CheckpointBarrier && ((CheckpointBarrier) event).isExactlyOnceMode()) {\n+\t\t\tif (event instanceof CheckpointBarrier &&\n+\t\t\t\t\t((CheckpointBarrier) event).getCheckpointOptions().isExactlyOnceMode()) {\n \t\t\t\treturn EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t\t}\n-\t\t\treturn UNKNOWN_EVENT;\n+\t\t\treturn EVENT_BUFFER;\n \t\t}\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc5OTM2NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402799364", "bodyText": "OTHER_EVENT instead", "author": "zhijiangW", "createdAt": "2020-04-03T07:52:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true, false),\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n+\t\t * unknown event.\n+\t\t */\n+\t\tUNKNOWN_EVENT(false, false);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex b25444e9673..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -231,51 +226,58 @@ public interface Buffer {\n \tvoid setCompressed(boolean isCompressed);\n \n \t/**\n-\t * Gets the type of data this buffer contains.\n+\t * Gets the type of data this buffer represents.\n \t */\n \tDataType getDataType();\n \n \t/**\n-\t * Used to identify the type of data contained in {@link Buffer}.\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in the {@link Buffer} so that we can get\n+\t * the information without deserializing the serialized data.\n \t */\n \tenum DataType {\n \t\t/**\n \t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n \t\t */\n-\t\tDATA_BUFFER(true, false),\n+\t\tDATA_BUFFER(true),\n+\n \t\t/**\n-\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n-\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t * EVENT_BUFFER indicates that this buffer represents serialized data of an event.\n+\t\t * Note that this type can be further divided into more fine-grained event types\n+\t\t * like {@link #EXACTLY_ONCE_CHECKPOINT_BARRIER} and etc.\n \t\t */\n-\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\tEVENT_BUFFER(false),\n+\n \t\t/**\n-\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n-\t\t * unknown event.\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a serialized\n+\t\t * checkpoint barrier of exactly once checkpoint mode.\n \t\t */\n-\t\tUNKNOWN_EVENT(false, false);\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false);\n \n \t\tprivate final boolean isBuffer;\n \n-\t\tprivate final boolean isExactlyOnceCheckpointBarrier;\n-\n-\t\tDataType(boolean isBuffer, boolean isExactlyOnceCheckpointBarrier) {\n+\t\tDataType(boolean isBuffer) {\n \t\t\tthis.isBuffer = isBuffer;\n-\t\t\tthis.isExactlyOnceCheckpointBarrier = isExactlyOnceCheckpointBarrier;\n \t\t}\n \n \t\tpublic boolean isBuffer() {\n \t\t\treturn isBuffer;\n \t\t}\n \n-\t\tpublic boolean isExactlyOnceCheckpointBarrier() {\n-\t\t\treturn isExactlyOnceCheckpointBarrier;\n+\t\tpublic static boolean isExactlyOnceCheckpointBarrier(Buffer buffer) {\n+\t\t\treturn buffer.getDataType() == EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t}\n \n \t\tpublic static DataType getDataType(AbstractEvent event) {\n-\t\t\tif (event instanceof CheckpointBarrier && ((CheckpointBarrier) event).isExactlyOnceMode()) {\n+\t\t\tif (event instanceof CheckpointBarrier &&\n+\t\t\t\t\t((CheckpointBarrier) event).getCheckpointOptions().isExactlyOnceMode()) {\n \t\t\t\treturn EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t\t}\n-\t\t\treturn UNKNOWN_EVENT;\n+\t\t\treturn EVENT_BUFFER;\n \t\t}\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwMzkxOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402803918", "bodyText": "It does not need to maintain this so specific property, otherwise when we further extend the data type enum future, it also needs to extend the respective field here.\nisBuffer is a general property to be retained for widely use.  Then we can also judge via getDataType == DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER  to replace isExactlyOnceCheckpointBarrier.", "author": "zhijiangW", "createdAt": "2020-04-03T07:58:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true, false),\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n+\t\t * unknown event.\n+\t\t */\n+\t\tUNKNOWN_EVENT(false, false);\n+\n+\t\tprivate final boolean isBuffer;\n+\n+\t\tprivate final boolean isExactlyOnceCheckpointBarrier;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex b25444e9673..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -231,51 +226,58 @@ public interface Buffer {\n \tvoid setCompressed(boolean isCompressed);\n \n \t/**\n-\t * Gets the type of data this buffer contains.\n+\t * Gets the type of data this buffer represents.\n \t */\n \tDataType getDataType();\n \n \t/**\n-\t * Used to identify the type of data contained in {@link Buffer}.\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in the {@link Buffer} so that we can get\n+\t * the information without deserializing the serialized data.\n \t */\n \tenum DataType {\n \t\t/**\n \t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n \t\t */\n-\t\tDATA_BUFFER(true, false),\n+\t\tDATA_BUFFER(true),\n+\n \t\t/**\n-\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n-\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t * EVENT_BUFFER indicates that this buffer represents serialized data of an event.\n+\t\t * Note that this type can be further divided into more fine-grained event types\n+\t\t * like {@link #EXACTLY_ONCE_CHECKPOINT_BARRIER} and etc.\n \t\t */\n-\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\tEVENT_BUFFER(false),\n+\n \t\t/**\n-\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n-\t\t * unknown event.\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a serialized\n+\t\t * checkpoint barrier of exactly once checkpoint mode.\n \t\t */\n-\t\tUNKNOWN_EVENT(false, false);\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false);\n \n \t\tprivate final boolean isBuffer;\n \n-\t\tprivate final boolean isExactlyOnceCheckpointBarrier;\n-\n-\t\tDataType(boolean isBuffer, boolean isExactlyOnceCheckpointBarrier) {\n+\t\tDataType(boolean isBuffer) {\n \t\t\tthis.isBuffer = isBuffer;\n-\t\t\tthis.isExactlyOnceCheckpointBarrier = isExactlyOnceCheckpointBarrier;\n \t\t}\n \n \t\tpublic boolean isBuffer() {\n \t\t\treturn isBuffer;\n \t\t}\n \n-\t\tpublic boolean isExactlyOnceCheckpointBarrier() {\n-\t\t\treturn isExactlyOnceCheckpointBarrier;\n+\t\tpublic static boolean isExactlyOnceCheckpointBarrier(Buffer buffer) {\n+\t\t\treturn buffer.getDataType() == EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t}\n \n \t\tpublic static DataType getDataType(AbstractEvent event) {\n-\t\t\tif (event instanceof CheckpointBarrier && ((CheckpointBarrier) event).isExactlyOnceMode()) {\n+\t\t\tif (event instanceof CheckpointBarrier &&\n+\t\t\t\t\t((CheckpointBarrier) event).getCheckpointOptions().isExactlyOnceMode()) {\n \t\t\t\treturn EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t\t}\n-\t\t\treturn UNKNOWN_EVENT;\n+\t\t\treturn EVENT_BUFFER;\n \t\t}\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNDg4MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402804880", "bodyText": "nit: bufferDataType -> dataType", "author": "zhijiangW", "createdAt": "2020-04-03T07:59:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java", "diffHunk": "@@ -53,23 +53,23 @@ public BufferConsumer(\n \t\t\tPositionMarker currentWriterPosition,\n \t\t\tint currentReaderPosition) {\n \t\tthis(\n-\t\t\tnew NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler), true),\n+\t\t\tnew NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler)),\n \t\t\tcurrentWriterPosition,\n \t\t\tcurrentReaderPosition);\n \t}\n \n \t/**\n \t * Constructs {@link BufferConsumer} instance with static content.\n \t */\n-\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, boolean isBuffer) {\n-\t\tthis(memorySegment, recycler, memorySegment.size(), isBuffer);\n+\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, Buffer.DataType bufferDataType) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java\nindex 2da6ce8c175..863b231201b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java\n\n@@ -61,15 +61,15 @@ public class BufferConsumer implements Closeable {\n \t/**\n \t * Constructs {@link BufferConsumer} instance with static content.\n \t */\n-\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, Buffer.DataType bufferDataType) {\n-\t\tthis(memorySegment, recycler, memorySegment.size(), bufferDataType);\n+\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, Buffer.DataType dataType) {\n+\t\tthis(memorySegment, recycler, memorySegment.size(), dataType);\n \t}\n \n \t/**\n \t * Constructs {@link BufferConsumer} instance with static content of a certain size.\n \t */\n-\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, int size, Buffer.DataType bufferDataType) {\n-\t\tthis(new NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler), bufferDataType),\n+\tpublic BufferConsumer(MemorySegment memorySegment, BufferRecycler recycler, int size, Buffer.DataType dataType) {\n+\t\tthis(new NetworkBuffer(checkNotNull(memorySegment), checkNotNull(recycler), dataType),\n \t\t\t\t() -> -size,\n \t\t\t\t0);\n \t\tcheckState(memorySegment.size() > 0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNTY1OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402805658", "bodyText": "ditto: dataType", "author": "zhijiangW", "createdAt": "2020-04-03T07:59:54Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java", "diffHunk": "@@ -52,8 +52,8 @@\n \t/** The recycler for the backing {@link MemorySegment}. */\n \tprivate final BufferRecycler recycler;\n \n-\t/** Whether this buffer represents a buffer or an event. */\n-\tprivate boolean isBuffer;\n+\t/** The {@link DataType} this buffer contains. */\n+\tprivate DataType bufferDataType;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\nindex 37a769d03a0..02f98920f90 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\n\n@@ -52,8 +52,8 @@ public class NetworkBuffer extends AbstractReferenceCountedByteBuf implements Bu\n \t/** The recycler for the backing {@link MemorySegment}. */\n \tprivate final BufferRecycler recycler;\n \n-\t/** The {@link DataType} this buffer contains. */\n-\tprivate DataType bufferDataType;\n+\t/** The {@link DataType} this buffer represents. */\n+\tprivate DataType dataType;\n \n \t/** Allocator for further byte buffers (needed by netty). */\n \tprivate ByteBufAllocator allocator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgwNTk1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402805950", "bodyText": "contains -> represents", "author": "zhijiangW", "createdAt": "2020-04-03T08:00:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java", "diffHunk": "@@ -52,8 +52,8 @@\n \t/** The recycler for the backing {@link MemorySegment}. */\n \tprivate final BufferRecycler recycler;\n \n-\t/** Whether this buffer represents a buffer or an event. */\n-\tprivate boolean isBuffer;\n+\t/** The {@link DataType} this buffer contains. */", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\nindex 37a769d03a0..02f98920f90 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\n\n@@ -52,8 +52,8 @@ public class NetworkBuffer extends AbstractReferenceCountedByteBuf implements Bu\n \t/** The recycler for the backing {@link MemorySegment}. */\n \tprivate final BufferRecycler recycler;\n \n-\t/** The {@link DataType} this buffer contains. */\n-\tprivate DataType bufferDataType;\n+\t/** The {@link DataType} this buffer represents. */\n+\tprivate DataType dataType;\n \n \t/** Allocator for further byte buffers (needed by netty). */\n \tprivate ByteBufAllocator allocator;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTg4Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402811882", "bodyText": "why remove condition of finish?", "author": "zhijiangW", "createdAt": "2020-04-03T08:07:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -114,7 +114,7 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = shouldNotifyDataAvailable() || finish;\n+\t\t\tnotifyDataAvailable = shouldNotifyDataAvailable();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc3NjMyNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404776325", "bodyText": "We don't need special handling for EOF here, if I keep the || finish, considering the blockByCheckpoint tag, the condition looks this\nnotifyDataAvailable = shouldNotifyDataAvailable() || (finish && !isBlockedByCheckpoint);, which is not elegant enough.", "author": "wsry", "createdAt": "2020-04-07T12:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwNjI3MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406606270", "bodyText": "If this condition is actually redundant irrelevant with this PR, then we can create a separate ticket for removing it.\nI am not sure whether there were any considerations for adding this tag before and might impact behaviors, then it is better for a separate ticket for checking instead of a hotfix commit.", "author": "zhijiangW", "createdAt": "2020-04-10T05:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxMTg4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3f566d7286ffa73fb26b729d76ccb5129ca3f974", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a2f8d1fa854..95f1168a142 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -111,10 +147,10 @@ class PipelinedSubpartition extends ResultSubpartition {\n \t\t\t}\n \n \t\t\t// Add the bufferConsumer and update the stats\n-\t\t\tbuffers.add(bufferConsumer);\n+\t\t\thandleAddingBarrier(bufferConsumer, insertAsHead);\n \t\t\tupdateStatistics(bufferConsumer);\n \t\t\tincreaseBuffersInBacklog(bufferConsumer);\n-\t\t\tnotifyDataAvailable = shouldNotifyDataAvailable();\n+\t\t\tnotifyDataAvailable = insertAsHead || finish || shouldNotifyDataAvailable();\n \n \t\t\tisFinished |= finish;\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNTk3MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402815971", "bodyText": "use buffer.getDataType() == Buffer.DataType.EXACTLY_ONCE_CHECKPOINT_BARRIER instead.", "author": "zhijiangW", "createdAt": "2020-04-03T08:11:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -197,13 +197,18 @@ BufferAndBacklog pollBuffer() {\n \t\t\t\treturn null;\n \t\t\t}\n \n+\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NzgwMg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402897802", "bodyText": "I add a util method in Buffer.DataType to judge if a Buffer is an ExactlyOnceCheckpointBarrier", "author": "wsry", "createdAt": "2020-04-03T10:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxNTk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a2f8d1fa854..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -197,9 +225,8 @@ class PipelinedSubpartition extends ResultSubpartition {\n \t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n-\t\t\tif (isExactlyOnceCheckpointBarrier) {\n-\t\t\t\treadView.blockOnCheckpointBarrier();\n+\t\t\tif (Buffer.DataType.isExactlyOnceCheckpointBarrier(buffer)) {\n+\t\t\t\tisBlockedByCheckpoint = true;\n \t\t\t}\n \n \t\t\tupdateStatistics(buffer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxODQ5MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402818491", "bodyText": "The readerView maintains the blocked state, then I prefer to moving this judgement inside subpartition view. So we can remove this method blockOnCheckpointBarrier completely.", "author": "zhijiangW", "createdAt": "2020-04-03T08:14:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -197,13 +197,18 @@ BufferAndBacklog pollBuffer() {\n \t\t\t\treturn null;\n \t\t\t}\n \n+\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n+\t\t\tif (isExactlyOnceCheckpointBarrier) {\n+\t\t\t\treadView.blockOnCheckpointBarrier();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyMzAyNg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402823026", "bodyText": "To do so, we have three components to maintain the separate states to finalize the final available state.\nResultSubpartition:  data available via BufferAndBacklog internal state\nResultSubpartitionView: blocked state when polling barrier\nNetworkSequenceViewReader: credit available", "author": "zhijiangW", "createdAt": "2020-04-03T08:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxODQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MzA5MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404583090", "bodyText": "As discussed, I moved the blockedByCheckpoint tag to subpartition.", "author": "wsry", "createdAt": "2020-04-07T07:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgxODQ5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a2f8d1fa854..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -197,9 +225,8 @@ class PipelinedSubpartition extends ResultSubpartition {\n \t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n-\t\t\tif (isExactlyOnceCheckpointBarrier) {\n-\t\t\t\treadView.blockOnCheckpointBarrier();\n+\t\t\tif (Buffer.DataType.isExactlyOnceCheckpointBarrier(buffer)) {\n+\t\t\t\tisBlockedByCheckpoint = true;\n \t\t\t}\n \n \t\t\tupdateStatistics(buffer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNDQwNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402824407", "bodyText": "Remove !isExactlyOnceCheckpointBarrier to not mix this state with ResultSubpartition component, we can get this blocked state separately from ResultSubpartitionView, then every concept is clean.", "author": "zhijiangW", "createdAt": "2020-04-03T08:21:34Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -197,13 +197,18 @@ BufferAndBacklog pollBuffer() {\n \t\t\t\treturn null;\n \t\t\t}\n \n+\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n+\t\t\tif (isExactlyOnceCheckpointBarrier) {\n+\t\t\t\treadView.blockOnCheckpointBarrier();\n+\t\t\t}\n+\n \t\t\tupdateStatistics(buffer);\n \t\t\t// Do not report last remaining buffer on buffers as available to read (assuming it's unfinished).\n \t\t\t// It will be reported for reading either on flush or when the number of buffers in the queue\n \t\t\t// will be 2 or more.\n \t\t\treturn new BufferAndBacklog(\n \t\t\t\tbuffer,\n-\t\t\t\tisAvailableUnsafe(),\n+\t\t\t\tisAvailableUnsafe() && !isExactlyOnceCheckpointBarrier,", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDY4OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402900689", "bodyText": "the downstream task of LocalChannel will check this isAvailable state and decide whether to add the corresponding input channel to available queue again.\nI will move this to constructor of BufferAndBacklog.", "author": "wsry", "createdAt": "2020-04-03T10:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNDQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MzU3Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404583572", "bodyText": "I have unified this tag with isAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNDQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a2f8d1fa854..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -197,9 +225,8 @@ class PipelinedSubpartition extends ResultSubpartition {\n \t\t\t\treturn null;\n \t\t\t}\n \n-\t\t\tboolean isExactlyOnceCheckpointBarrier = buffer.getDataType().isExactlyOnceCheckpointBarrier();\n-\t\t\tif (isExactlyOnceCheckpointBarrier) {\n-\t\t\t\treadView.blockOnCheckpointBarrier();\n+\t\t\tif (Buffer.DataType.isExactlyOnceCheckpointBarrier(buffer)) {\n+\t\t\t\tisBlockedByCheckpoint = true;\n \t\t\t}\n \n \t\t\tupdateStatistics(buffer);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzMzU0MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402833540", "bodyText": "I know it can avoid entering the following actions if readerView is not fitted.  But another issue is that notifyDataAvailable would be called in three places in this class, and it already judges the readerView inside for unification. So I suggested to add the condition readView.isBlockedByCheckpoint() inside notifyDataAvailable.", "author": "zhijiangW", "createdAt": "2020-04-03T08:32:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -302,7 +307,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \tpublic void flush() {\n \t\tfinal boolean notifyDataAvailable;\n \t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty()) {\n+\t\t\tif (buffers.isEmpty() || readView == null || readView.isBlockedByCheckpoint()) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NDUzOQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404584539", "bodyText": "Some tags should be  checked in lock, I removed the check in notifyDataAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzMzU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a2f8d1fa854..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -307,12 +340,15 @@ class PipelinedSubpartition extends ResultSubpartition {\n \tpublic void flush() {\n \t\tfinal boolean notifyDataAvailable;\n \t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty() || readView == null || readView.isBlockedByCheckpoint()) {\n+\t\t\tif (buffers.isEmpty()) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t// if there is more then 1 buffer, we already notified the reader\n \t\t\t// (at the latest when adding the second buffer)\n-\t\t\tnotifyDataAvailable = !flushRequested && buffers.size() == 1 && buffers.peek().isDataAvailable();\n+\t\t\tnotifyDataAvailable = !flushRequested\n+\t\t\t\t&& !isBlockedByCheckpoint\n+\t\t\t\t&& buffers.size() == 1\n+\t\t\t\t&& buffers.peek().isDataAvailable();\n \t\t\tflushRequested = flushRequested || buffers.size() > 1 || notifyDataAvailable;\n \t\t}\n \t\tif (notifyDataAvailable) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzNTM4Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402835387", "bodyText": "also we can remove this condition by reusing it inside notifyDataAvailable as mentioned above.", "author": "zhijiangW", "createdAt": "2020-04-03T08:34:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -376,7 +381,7 @@ public int getBuffersInBacklog() {\n \n \tprivate boolean shouldNotifyDataAvailable() {\n \t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && getNumberOfFinishedBuffers() == 1;\n+\t\treturn readView != null && !flushRequested && !readView.isBlockedByCheckpoint() && getNumberOfFinishedBuffers() == 1;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NDgxMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404584811", "bodyText": "Some tags should be checked in lock, I removed the check in notifyDataAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzNTM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex a2f8d1fa854..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -381,7 +417,7 @@ class PipelinedSubpartition extends ResultSubpartition {\n \n \tprivate boolean shouldNotifyDataAvailable() {\n \t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && !readView.isBlockedByCheckpoint() && getNumberOfFinishedBuffers() == 1;\n+\t\treturn readView != null && !flushRequested && !isBlockedByCheckpoint && getNumberOfFinishedBuffers() == 1;\n \t}\n \n \tprivate void notifyDataAvailable() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NjI5MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402896291", "bodyText": "It is sensitive to maintain a volatile variable in core stack. Actually we can avoid it for RemoteInputChannel by accessing it only by netty stack, it would only bring one more unnecessary UserEventTrigger in netty stack. But for local channel, it has problems now, let us think whether they are other options to bypass.", "author": "zhijiangW", "createdAt": "2020-04-03T10:01:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionView.java", "diffHunk": "@@ -39,6 +40,8 @@\n \t/** Flag indicating whether this view has been released. */\n \tprivate final AtomicBoolean isReleased;\n \n+\tprivate volatile boolean isBlockedByCheckpoint = false;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NTAxNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404585014", "bodyText": "As discussed, I moved the blockedByCheckpoint tag to subpartition.", "author": "wsry", "createdAt": "2020-04-07T07:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5NjI5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionView.java\nindex abf2c0e8171..b056ff74554 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartitionView.java\n\n@@ -40,9 +39,7 @@ class PipelinedSubpartitionView implements ResultSubpartitionView {\n \t/** Flag indicating whether this view has been released. */\n \tprivate final AtomicBoolean isReleased;\n \n-\tprivate volatile boolean isBlockedByCheckpoint = false;\n-\n-\tPipelinedSubpartitionView(PipelinedSubpartition parent, BufferAvailabilityListener listener) {\n+\tpublic PipelinedSubpartitionView(PipelinedSubpartition parent, BufferAvailabilityListener listener) {\n \t\tthis.parent = checkNotNull(parent);\n \t\tthis.availabilityListener = checkNotNull(listener);\n \t\tthis.isReleased = new AtomicBoolean();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5OTg3MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402899871", "bodyText": "From subpartitionView prospective , it is better to give a overall method for judging its condition, not spreading multiple conditions. we might need to refactor the current ResultSubpartition#isAvailable for also considering blocked state with nextBufferIsEvent.", "author": "zhijiangW", "createdAt": "2020-04-03T10:08:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -119,7 +124,7 @@ public boolean isAvailable() {\n \t\t\treturn subpartitionView.isAvailable();\n \t\t}\n \t\telse {\n-\t\t\treturn subpartitionView.nextBufferIsEvent();\n+\t\t\treturn !subpartitionView.isBlockedByCheckpoint() && subpartitionView.nextBufferIsEvent();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NTk1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404585950", "bodyText": "I unified the isBlockedByCheckpoint tag with isAvailable.", "author": "wsry", "createdAt": "2020-04-07T07:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5OTg3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 7740a8eee2c..281cae1a121 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -120,12 +120,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t@Override\n \tpublic boolean isAvailable() {\n \t\t// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn subpartitionView.isAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn !subpartitionView.isBlockedByCheckpoint() && subpartitionView.nextBufferIsEvent();\n-\t\t}\n+\t\treturn subpartitionView.isAvailable(numCreditsAvailable);\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDcxNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402900715", "bodyText": "As above commented, if we can avoid task thread touching the blocked state, then together with https://github.com/apache/flink/pull/11351/files#r402899871, we can remove this method completely.", "author": "zhijiangW", "createdAt": "2020-04-03T10:09:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java", "diffHunk": "@@ -50,6 +50,10 @@\n \n \tboolean isReleased();\n \n+\tboolean isBlockedByCheckpoint();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTE1MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402901150", "bodyText": "Actually i want this state already be covered by part of existing isAvailable method.", "author": "zhijiangW", "createdAt": "2020-04-03T10:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMDcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java\nindex b56735c6d1a..6105f3cd67a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java\n\n@@ -50,18 +50,11 @@ public interface ResultSubpartitionView {\n \n \tboolean isReleased();\n \n-\tboolean isBlockedByCheckpoint();\n-\n \tvoid resumeConsumption();\n \n \tThrowable getFailureCause();\n \n-\t/**\n-\t * Returns whether the next buffer is an event or not.\n-\t */\n-\tboolean nextBufferIsEvent();\n-\n-\tboolean isAvailable();\n+\tboolean isAvailable(int numCreditsAvailable);\n \n \tint unsynchronizedGetNumberOfQueuedBuffers();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMjIyNA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402912224", "bodyText": "I notice that some usages are relying on the ordinal  of enum value. So do you think we should give some notes to avoid adjusting the existing sequence if extending it future?", "author": "zhijiangW", "createdAt": "2020-04-03T10:31:58Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +229,53 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer contains.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NzI1OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404587258", "bodyText": "The ordinal of enum value is used when writing buffer to disk and sending buffers through network. As suggested, I have removed those logic so the ordinal of enum value is never used now.", "author": "wsry", "createdAt": "2020-04-07T07:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMjIyNA=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex b25444e9673..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -231,51 +226,58 @@ public interface Buffer {\n \tvoid setCompressed(boolean isCompressed);\n \n \t/**\n-\t * Gets the type of data this buffer contains.\n+\t * Gets the type of data this buffer represents.\n \t */\n \tDataType getDataType();\n \n \t/**\n-\t * Used to identify the type of data contained in {@link Buffer}.\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in the {@link Buffer} so that we can get\n+\t * the information without deserializing the serialized data.\n \t */\n \tenum DataType {\n \t\t/**\n \t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n \t\t */\n-\t\tDATA_BUFFER(true, false),\n+\t\tDATA_BUFFER(true),\n+\n \t\t/**\n-\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n-\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t * EVENT_BUFFER indicates that this buffer represents serialized data of an event.\n+\t\t * Note that this type can be further divided into more fine-grained event types\n+\t\t * like {@link #EXACTLY_ONCE_CHECKPOINT_BARRIER} and etc.\n \t\t */\n-\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false, true),\n+\t\tEVENT_BUFFER(false),\n+\n \t\t/**\n-\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n-\t\t * unknown event.\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a serialized\n+\t\t * checkpoint barrier of exactly once checkpoint mode.\n \t\t */\n-\t\tUNKNOWN_EVENT(false, false);\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false);\n \n \t\tprivate final boolean isBuffer;\n \n-\t\tprivate final boolean isExactlyOnceCheckpointBarrier;\n-\n-\t\tDataType(boolean isBuffer, boolean isExactlyOnceCheckpointBarrier) {\n+\t\tDataType(boolean isBuffer) {\n \t\t\tthis.isBuffer = isBuffer;\n-\t\t\tthis.isExactlyOnceCheckpointBarrier = isExactlyOnceCheckpointBarrier;\n \t\t}\n \n \t\tpublic boolean isBuffer() {\n \t\t\treturn isBuffer;\n \t\t}\n \n-\t\tpublic boolean isExactlyOnceCheckpointBarrier() {\n-\t\t\treturn isExactlyOnceCheckpointBarrier;\n+\t\tpublic static boolean isExactlyOnceCheckpointBarrier(Buffer buffer) {\n+\t\t\treturn buffer.getDataType() == EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t}\n \n \t\tpublic static DataType getDataType(AbstractEvent event) {\n-\t\t\tif (event instanceof CheckpointBarrier && ((CheckpointBarrier) event).isExactlyOnceMode()) {\n+\t\t\tif (event instanceof CheckpointBarrier &&\n+\t\t\t\t\t((CheckpointBarrier) event).getCheckpointOptions().isExactlyOnceMode()) {\n \t\t\t\treturn EXACTLY_ONCE_CHECKPOINT_BARRIER;\n \t\t\t}\n-\t\t\treturn UNKNOWN_EVENT;\n+\t\t\treturn EVENT_BUFFER;\n \t\t}\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxMzg3OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402913879", "bodyText": "we can still retain the isBuffer as before, because it is enough now to avoid increasing the header size.", "author": "zhijiangW", "createdAt": "2020-04-03T10:35:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java", "diffHunk": "@@ -276,22 +279,22 @@ protected Object decode(ChannelHandlerContext ctx, ByteBuf in) throws Exception\n \n \t\tfinal int backlog;\n \n-\t\tfinal boolean isBuffer;\n+\t\tfinal Buffer.DataType bufferDataType;", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java\nindex d04dd2a1a5b..166e3165127 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java\n\n@@ -279,7 +279,7 @@ public abstract class NettyMessage {\n \n \t\tfinal int backlog;\n \n-\t\tfinal Buffer.DataType bufferDataType;\n+\t\tfinal boolean isBuffer;\n \n \t\tfinal boolean isCompressed;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDU2Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402914566", "bodyText": "unrelated change", "author": "zhijiangW", "createdAt": "2020-04-03T10:36:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +310,11 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n+", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c5036e63815..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -310,11 +311,10 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n-\n \t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndIncrement() == 0) {\n+\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n \t\t\tnotifyCreditAvailable();\n \t\t}\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDYzNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402914635", "bodyText": "unrelated change", "author": "zhijiangW", "createdAt": "2020-04-03T10:36:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -299,7 +299,6 @@ private void notifyCreditAvailable() {\n \t@Override\n \tpublic void recycle(MemorySegment segment) {\n \t\tint numAddedBuffers;\n-", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c5036e63815..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -299,6 +299,7 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t@Override\n \tpublic void recycle(MemorySegment segment) {\n \t\tint numAddedBuffers;\n+\n \t\tsynchronized (bufferQueue) {\n \t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n \t\t\t// after releaseAllResources() released all buffers (see below for details).\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNDgxMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402914811", "bodyText": "unrelated change", "author": "zhijiangW", "createdAt": "2020-04-03T10:37:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -482,7 +492,6 @@ public Buffer requestBuffer() {\n \t */\n \tvoid onSenderBacklog(int backlog) throws IOException {\n \t\tint numRequestedBuffers = 0;\n-", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c5036e63815..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -492,6 +492,7 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t */\n \tvoid onSenderBacklog(int backlog) throws IOException {\n \t\tint numRequestedBuffers = 0;\n+\n \t\tsynchronized (bufferQueue) {\n \t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n \t\t\t// after releaseAllResources() released all buffers (see above for details).\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNTE3MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402915171", "bodyText": "unrelated change?", "author": "zhijiangW", "createdAt": "2020-04-03T10:37:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -383,7 +383,7 @@ public NotificationResult notifyBufferAvailable(Buffer buffer) {\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n+\t\t\tif (unannouncedCredit.getAndIncrement() == 0) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c5036e63815..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -383,7 +383,7 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif (unannouncedCredit.getAndIncrement() == 0) {\n+\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n \t\t\t\tnotifyCreditAvailable();\n \t\t\t}\n \t\t} catch (Throwable t) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNTI2OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402915268", "bodyText": "unrelated change?", "author": "zhijiangW", "createdAt": "2020-04-03T10:38:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +310,11 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n+\n \t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n+\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndIncrement() == 0) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c5036e63815..42d86601b59 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -310,11 +311,10 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n-\n \t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndIncrement() == 0) {\n+\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n \t\t\tnotifyCreditAvailable();\n \t\t}\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkxNTU0MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r402915540", "bodyText": "unrelated change?", "author": "zhijiangW", "createdAt": "2020-04-03T10:38:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java", "diffHunk": "@@ -681,8 +684,6 @@ static CloseRequest readFrom(@SuppressWarnings(\"unused\") ByteBuf buffer) throws\n \t\tfinal InputChannelID receiverId;\n \n \t\tAddCredit(int credit, InputChannelID receiverId) {\n-\t\t\tcheckArgument(credit > 0, \"The announced credit should be greater than 0\");", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java\nindex d04dd2a1a5b..166e3165127 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NettyMessage.java\n\n@@ -684,6 +684,7 @@ public abstract class NettyMessage {\n \t\tfinal InputChannelID receiverId;\n \n \t\tAddCredit(int credit, InputChannelID receiverId) {\n+\t\t\tcheckArgument(credit > 0, \"The announced credit should be greater than 0\");\n \t\t\tthis.credit = credit;\n \t\t\tthis.receiverId = receiverId;\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzE3Mg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404517172", "bodyText": "nit: adjust the comment as well.", "author": "zhijiangW", "createdAt": "2020-04-07T03:40:59Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -310,19 +316,17 @@ private void writeAndFlushNextMessageIfPossible(Channel channel) {\n \t\t}\n \n \t\twhile (true) {\n-\t\t\tRemoteInputChannel inputChannel = inputChannelsWithCredit.poll();\n+\t\t\tClientOutboundMessage outboundMessage = clientOutboundMessages.poll();\n \n \t\t\t// The input channel may be null because of the write callbacks\n \t\t\t// that are executed after each write.\n-\t\t\tif (inputChannel == null) {\n+\t\t\tif (outboundMessage == null) {\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\t//It is no need to notify credit for the released channel.", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 575b28a736c..4f3d872a692 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -324,7 +326,7 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \t\t\t\treturn;\n \t\t\t}\n \n-\t\t\t//It is no need to notify credit for the released channel.\n+\t\t\t//It is no need to notify credit or resume data consumption for the released channel.\n \t\t\tif (!outboundMessage.inputChannel.isReleased()) {\n \t\t\t\tObject msg = outboundMessage.buildMessage();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzk1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404517955", "bodyText": "nit: checkNotNull(inputChannel)", "author": "zhijiangW", "createdAt": "2020-04-07T03:44:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -350,4 +354,38 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tprivate static abstract class ClientOutboundMessage {\n+\t\tprotected final RemoteInputChannel inputChannel;\n+\n+\t\tClientOutboundMessage(RemoteInputChannel inputChannel) {\n+\t\t\tthis.inputChannel = inputChannel;\n+\t\t}\n+\n+\t\tabstract Object buildMessage();\n+\t}\n+\n+\tprivate static class AddCreditMessage extends ClientOutboundMessage {\n+\n+\t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n+\t\t\tsuper(inputChannel);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 575b28a736c..4f3d872a692 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -368,7 +370,7 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \tprivate static class AddCreditMessage extends ClientOutboundMessage {\n \n \t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n-\t\t\tsuper(inputChannel);\n+\t\t\tsuper(checkNotNull(inputChannel));\n \t\t}\n \n \t\t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxNzk4OQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404517989", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-07T03:44:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -350,4 +354,38 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tprivate static abstract class ClientOutboundMessage {\n+\t\tprotected final RemoteInputChannel inputChannel;\n+\n+\t\tClientOutboundMessage(RemoteInputChannel inputChannel) {\n+\t\t\tthis.inputChannel = inputChannel;\n+\t\t}\n+\n+\t\tabstract Object buildMessage();\n+\t}\n+\n+\tprivate static class AddCreditMessage extends ClientOutboundMessage {\n+\n+\t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n+\t\t\tsuper(inputChannel);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object buildMessage() {\n+\t\t\treturn new AddCredit(inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+\t\t}\n+\t}\n+\n+\tprivate static class ResumeConsumptionMessage extends ClientOutboundMessage {\n+\n+\t\tResumeConsumptionMessage(RemoteInputChannel inputChannel) {\n+\t\t\tsuper(inputChannel);", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 575b28a736c..4f3d872a692 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -368,7 +370,7 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \tprivate static class AddCreditMessage extends ClientOutboundMessage {\n \n \t\tAddCreditMessage(RemoteInputChannel inputChannel) {\n-\t\t\tsuper(inputChannel);\n+\t\t\tsuper(checkNotNull(inputChannel));\n \t\t}\n \n \t\t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyMjEyMg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404522122", "bodyText": "request->requests, exactly-once", "author": "zhijiangW", "createdAt": "2020-04-07T04:03:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -161,6 +161,26 @@ void addCredit(InputChannelID receiverId, int credit) throws Exception {\n \t\t}\n \t}\n \n+\t/**\n+\t * The consumer request to resume data consumption after an exactly once checkpoint.", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 807dddb4f90..593c77f82a0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -140,40 +141,22 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t}\n \n \t/**\n-\t * Adds unannounced credits from the consumer and enqueues the corresponding reader for this\n-\t * consumer (if not enqueued yet).\n+\t * Adds unannounced credits from the consumer or resumes data consumption after an exactly-once\n+\t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n \t *\n \t * @param receiverId The input channel id to identify the consumer.\n-\t * @param credit The unannounced credits of the consumer.\n+\t * @param operation The operation to be performed (add credit or resume data consumption).\n \t */\n-\tvoid addCredit(InputChannelID receiverId, int credit) throws Exception {\n+\tvoid addCreditOrResumeConsumption(\n+\t\t\tInputChannelID receiverId,\n+\t\t\tConsumer<NetworkSequenceViewReader> operation) throws Exception {\n \t\tif (fatalError) {\n \t\t\treturn;\n \t\t}\n \n \t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n \t\tif (reader != null) {\n-\t\t\treader.addCredit(credit);\n-\n-\t\t\tenqueueAvailableReader(reader);\n-\t\t} else {\n-\t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * The consumer request to resume data consumption after an exactly once checkpoint.\n-\t *\n-\t * @param receiverId The input channel id identifying the consumer.\n-\t */\n-\tvoid resumeConsumption(InputChannelID receiverId) throws Exception {\n-\t\tif (fatalError) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n-\t\tif (reader != null) {\n-\t\t\treader.resumeConsumption();\n+\t\t\toperation.accept(reader);\n \n \t\t\tenqueueAvailableReader(reader);\n \t\t} else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyOTkxNQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404529915", "bodyText": "should we further remove this method because it is always return 0 after this PR? If so, how many changes it will be involved?", "author": "zhijiangW", "createdAt": "2020-04-07T04:36:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointMetrics.java", "diffHunk": "@@ -59,19 +56,13 @@ public CheckpointMetrics(\n \t\tcheckArgument(bytesBufferedInAlignment >= -1);\n \t\tcheckArgument(alignmentDurationNanos >= -1);\n \n-\t\tthis.bytesBufferedInAlignment = bytesBufferedInAlignment;\n \t\tthis.alignmentDurationNanos = alignmentDurationNanos;\n \t\tthis.syncDurationMillis = syncDurationMillis;\n \t\tthis.asyncDurationMillis = asyncDurationMillis;\n \t}\n \n \tpublic long getBytesBufferedInAlignment() {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4MzI2MQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404683261", "bodyText": "I further removed the relevant code except those in rest handler, the rest handler always return 0 to the web ui, I think we need another ticket to further remove it in web ui.", "author": "wsry", "createdAt": "2020-04-07T09:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyOTkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointMetrics.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointMetrics.java\nindex dd04a734c22..9420ef9e548 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointMetrics.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointMetrics.java\n\n@@ -61,10 +61,6 @@ public class CheckpointMetrics implements Serializable {\n \t\tthis.asyncDurationMillis = asyncDurationMillis;\n \t}\n \n-\tpublic long getBytesBufferedInAlignment() {\n-\t\treturn 0;\n-\t}\n-\n \tpublic long getAlignmentDurationNanos() {\n \t\treturn alignmentDurationNanos;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MTc4NA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404541784", "bodyText": "In mostly normal cases, this list should not be created beforehand, so it is better to create based on demand.\nI know it is for unification consideration. Another option is that we can migrate partial resume notification inside releaseBlocksAndResetBarriers which is involved in batch of channels to be notified.\nThen the other cases are all for the single channel notification which can be done inside #processBarrier. Then we can define boolean shouldNotify beforehand, and to remove unnecessary two else conditions below to make the logics seem shorter. And at the end to notify the channelIndex if shouldNotify set as false intermediate steps.\nAnother potential benefit is to make notification happen before notifyCheckpoint. notifyCheckpoint would be involved in some IO operations during sync process, so it is better to notify light-weight unblock actions beforehand to make data ready earlier.", "author": "zhijiangW", "createdAt": "2020-04-07T05:21:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -100,21 +119,22 @@ public boolean isBlocked(int channelIndex) {\n \t}\n \n \t@Override\n-\tpublic boolean processBarrier(CheckpointBarrier receivedBarrier, int channelIndex, long bufferedBytes) throws Exception {\n+\tpublic void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {\n \t\tfinal long barrierId = receivedBarrier.getId();\n+\t\tList<Integer> channelsToUnblock = new ArrayList<>();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex b320dec6774..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -121,7 +119,6 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t@Override\n \tpublic void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception {\n \t\tfinal long barrierId = receivedBarrier.getId();\n-\t\tList<Integer> channelsToUnblock = new ArrayList<>();\n \n \t\t// fast path for single channel cases\n \t\tif (totalNumberOfInputChannels == 1) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MjU1NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404542555", "bodyText": "Considering my above concerns, all the resume notification can be done inside releaseBlocksAndResetBarriers instead", "author": "zhijiangW", "createdAt": "2020-04-07T05:24:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -214,8 +233,9 @@ protected void onBarrier(int channelIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic boolean processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n+\tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tfinal long barrierId = cancelBarrier.getCheckpointId();\n+\t\tList<Integer> channelsToUnblock = new ArrayList<>();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex b320dec6774..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -235,7 +229,6 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tfinal long barrierId = cancelBarrier.getCheckpointId();\n-\t\tList<Integer> channelsToUnblock = new ArrayList<>();\n \n \t\t// fast path for single channel cases\n \t\tif (totalNumberOfInputChannels == 1) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MjkxOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404542918", "bodyText": "ditto: make notification inside releaseBlocksAndResetBarriers", "author": "zhijiangW", "createdAt": "2020-04-07T05:25:34Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -280,28 +298,29 @@ else if (barrierId > currentCheckpointId) {\n \t\t\t}\n \n \t\t\tnotifyAbortOnCancellationBarrier(barrierId);\n-\t\t\treturn false;\n \t\t}\n \n \t\t// else: trailing barrier from either\n \t\t//   - a previous (subsumed) checkpoint\n \t\t//   - the current checkpoint if it was already canceled\n-\t\treturn false;\n+\n+\t\tunblockCheckpoint(channelsToUnblock);\n \t}\n \n \t@Override\n-\tpublic boolean processEndOfPartition() throws Exception {\n+\tpublic void processEndOfPartition() throws Exception {\n \t\tnumClosedChannels++;\n \n+\t\tList<Integer> channelsToUnblock = new ArrayList<>();", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\nindex b320dec6774..106d63cd5da 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java\n\n@@ -303,24 +296,19 @@ public class CheckpointBarrierAligner extends CheckpointBarrierHandler {\n \t\t// else: trailing barrier from either\n \t\t//   - a previous (subsumed) checkpoint\n \t\t//   - the current checkpoint if it was already canceled\n-\n-\t\tunblockCheckpoint(channelsToUnblock);\n \t}\n \n \t@Override\n \tpublic void processEndOfPartition() throws Exception {\n \t\tnumClosedChannels++;\n \n-\t\tList<Integer> channelsToUnblock = new ArrayList<>();\n \t\tif (numBarriersReceived > 0) {\n \t\t\t// let the task know we skip a checkpoint\n \t\t\tnotifyAbort(currentCheckpointId,\n \t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n \t\t\t// no chance to complete this checkpoint\n-\t\t\treleaseBlocksAndResetBarriers(channelsToUnblock);\n+\t\t\treleaseBlocksAndResetBarriers();\n \t\t}\n-\n-\t\tunblockCheckpoint(channelsToUnblock);\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NTA3NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404575075", "bodyText": "return Optional.empty(); can be merged in condition. also remove throws Exception\n\nprivate Optional handleEmptyBuffer()  {\nif (inputGate.isFinished()) {\nisFinished = true;\n}\nreturn Optional.empty();\n}", "author": "zhijiangW", "createdAt": "2020-04-07T06:52:57Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -180,40 +141,15 @@ private int offsetChannelIndex(int channelIndex) {\n \t\t\treturn Optional.empty();\n \t\t}\n \n-\t\tif (endOfInputGate) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\nindex b09867b9cb4..bfe9fbda964 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java\n\n@@ -136,12 +135,11 @@ public class CheckpointedInputGate implements PullingAsyncDataInput<BufferOrEven\n \t\treturn channelIndex + channelIndexOffset;\n \t}\n \n-\tprivate Optional<BufferOrEvent> handleEmptyBuffer() throws Exception {\n-\t\tif (!inputGate.isFinished()) {\n-\t\t\treturn Optional.empty();\n+\tprivate Optional<BufferOrEvent> handleEmptyBuffer() {\n+\t\tif (inputGate.isFinished()) {\n+\t\t\tisFinished = true;\n \t\t}\n \n-\t\tisFinished = true;\n \t\treturn Optional.empty();\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MjY5OA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404582698", "bodyText": "it would be better to make isExactlyOnceMode as an internal field of CheckpointOptions, then we can avoid touching the changes of multiple related classes.", "author": "zhijiangW", "createdAt": "2020-04-07T07:08:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java", "diffHunk": "@@ -47,11 +48,18 @@\n \tprivate final long id;\n \tprivate final long timestamp;\n \tprivate final CheckpointOptions checkpointOptions;\n+\tprivate final boolean isExactlyOnceMode;\n \n+\t@VisibleForTesting\n \tpublic CheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) {\n+\t\tthis(id, timestamp, checkpointOptions, true);\n+\t}\n+\n+\tpublic CheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions, boolean isExactlyOnceMode) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java\nindex db3eae8f045..78d67077685 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/CheckpointBarrier.java\n\n@@ -48,18 +47,11 @@ public class CheckpointBarrier extends RuntimeEvent {\n \tprivate final long id;\n \tprivate final long timestamp;\n \tprivate final CheckpointOptions checkpointOptions;\n-\tprivate final boolean isExactlyOnceMode;\n \n-\t@VisibleForTesting\n \tpublic CheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) {\n-\t\tthis(id, timestamp, checkpointOptions, true);\n-\t}\n-\n-\tpublic CheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions, boolean isExactlyOnceMode) {\n \t\tthis.id = id;\n \t\tthis.timestamp = timestamp;\n \t\tthis.checkpointOptions = checkNotNull(checkpointOptions);\n-\t\tthis.isExactlyOnceMode = isExactlyOnceMode;\n \t}\n \n \tpublic long getId() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NjU0Nw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404586547", "bodyText": "nit: package private", "author": "zhijiangW", "createdAt": "2020-04-07T07:16:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -130,26 +112,26 @@ private static CheckpointBarrierHandler createCheckpointBarrierHandler(\n \t\t}\n \t}\n \n-\tprivate static BufferStorage createBufferStorage(\n-\t\t\tCheckpointingMode checkpointMode,\n-\t\t\tint pageSize,\n-\t\t\tConfiguration taskManagerConfig,\n-\t\t\tString taskName) {\n-\t\tswitch (checkpointMode) {\n-\t\t\tcase EXACTLY_ONCE: {\n-\t\t\t\tlong maxAlign = taskManagerConfig.getLong(TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT);\n-\t\t\t\tif (!(maxAlign == -1 || maxAlign > 0)) {\n-\t\t\t\t\tthrow new IllegalConfigurationException(\n-\t\t\t\t\t\tTaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT.key()\n-\t\t\t\t\t\t\t+ \" must be positive or -1 (infinite)\");\n-\t\t\t\t}\n-\t\t\t\treturn new CachedBufferStorage(pageSize, maxAlign, taskName);\n+\tpublic static InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\nindex 5314b3e2ae7..4e7eb742b88 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n\n@@ -100,19 +97,18 @@ public class InputProcessorUtil {\n \t\tswitch (checkpointMode) {\n \t\t\tcase EXACTLY_ONCE:\n \t\t\t\treturn new CheckpointBarrierAligner(\n-\t\t\t\t\tnumberOfInputChannels,\n \t\t\t\t\ttaskName,\n \t\t\t\t\tchannelIndexToInputGate,\n \t\t\t\t\tinputGateToChannelIndexOffset,\n \t\t\t\t\ttoNotifyOnCheckpoint);\n \t\t\tcase AT_LEAST_ONCE:\n-\t\t\t\treturn new CheckpointBarrierTracker(numberOfInputChannels, toNotifyOnCheckpoint);\n+\t\t\t\treturn new CheckpointBarrierTracker(channelIndexToInputGate.length, toNotifyOnCheckpoint);\n \t\t\tdefault:\n \t\t\t\tthrow new UnsupportedOperationException(\"Unrecognized Checkpointing Mode: \" + checkpointMode);\n \t\t}\n \t}\n \n-\tpublic static InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {\n+\tstatic InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {\n \t\tInputGate[] channelIndexToInputGate = new InputGate[numberOfInputChannels];\n \t\tint channelIndexOffset = 0;\n \t\tfor (InputGate inputGate: inputGates) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NjYyMg==", "url": "https://github.com/apache/flink/pull/11351#discussion_r404586622", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-04-07T07:16:17Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -130,26 +112,26 @@ private static CheckpointBarrierHandler createCheckpointBarrierHandler(\n \t\t}\n \t}\n \n-\tprivate static BufferStorage createBufferStorage(\n-\t\t\tCheckpointingMode checkpointMode,\n-\t\t\tint pageSize,\n-\t\t\tConfiguration taskManagerConfig,\n-\t\t\tString taskName) {\n-\t\tswitch (checkpointMode) {\n-\t\t\tcase EXACTLY_ONCE: {\n-\t\t\t\tlong maxAlign = taskManagerConfig.getLong(TaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT);\n-\t\t\t\tif (!(maxAlign == -1 || maxAlign > 0)) {\n-\t\t\t\t\tthrow new IllegalConfigurationException(\n-\t\t\t\t\t\tTaskManagerOptions.TASK_CHECKPOINT_ALIGNMENT_BYTES_LIMIT.key()\n-\t\t\t\t\t\t\t+ \" must be positive or -1 (infinite)\");\n-\t\t\t\t}\n-\t\t\t\treturn new CachedBufferStorage(pageSize, maxAlign, taskName);\n+\tpublic static InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {\n+\t\tInputGate[] channelIndexToInputGate = new InputGate[numberOfInputChannels];\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (InputGate inputGate: inputGates) {\n+\t\t\tfor (int i = 0; i < inputGate.getNumberOfInputChannels(); ++i) {\n+\t\t\t\tchannelIndexToInputGate[channelIndexOffset + i] = inputGate;\n \t\t\t}\n-\t\t\tcase AT_LEAST_ONCE:\n-\t\t\t\treturn new EmptyBufferStorage();\n-\t\t\tdefault:\n-\t\t\t\tthrow new UnsupportedOperationException(\"Unrecognized Checkpointing Mode: \" + checkpointMode);\n+\t\t\tchannelIndexOffset += inputGate.getNumberOfInputChannels();\n+\t\t}\n+\t\treturn channelIndexToInputGate;\n+\t}\n+\n+\tpublic static Map<InputGate, Integer> generateInputGateToChannelIndexOffsetMap(InputGate ...inputGates) {", "originalCommit": "ab2741cfd7192d0bbd4269b4cd3334ca084e2b67", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\nindex 5314b3e2ae7..4e7eb742b88 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n\n@@ -100,19 +97,18 @@ public class InputProcessorUtil {\n \t\tswitch (checkpointMode) {\n \t\t\tcase EXACTLY_ONCE:\n \t\t\t\treturn new CheckpointBarrierAligner(\n-\t\t\t\t\tnumberOfInputChannels,\n \t\t\t\t\ttaskName,\n \t\t\t\t\tchannelIndexToInputGate,\n \t\t\t\t\tinputGateToChannelIndexOffset,\n \t\t\t\t\ttoNotifyOnCheckpoint);\n \t\t\tcase AT_LEAST_ONCE:\n-\t\t\t\treturn new CheckpointBarrierTracker(numberOfInputChannels, toNotifyOnCheckpoint);\n+\t\t\t\treturn new CheckpointBarrierTracker(channelIndexToInputGate.length, toNotifyOnCheckpoint);\n \t\t\tdefault:\n \t\t\t\tthrow new UnsupportedOperationException(\"Unrecognized Checkpointing Mode: \" + checkpointMode);\n \t\t}\n \t}\n \n-\tpublic static InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {\n+\tstatic InputGate[] generateChannelIndexToInputGateMap(int numberOfInputChannels, InputGate ...inputGates) {\n \t\tInputGate[] channelIndexToInputGate = new InputGate[numberOfInputChannels];\n \t\tint channelIndexOffset = 0;\n \t\tfor (InputGate inputGate: inputGates) {\n"}}, {"oid": "302fb27f0a4a3639a442d2c54ddbcf0d323c7c76", "url": "https://github.com/apache/flink/commit/302fb27f0a4a3639a442d2c54ddbcf0d323c7c76", "message": "Fixup.", "committedDate": "2020-04-07T13:30:36Z", "type": "forcePushed"}, {"oid": "e2b1460ce15ca62960d1e4a4f431d6f7a7022e5a", "url": "https://github.com/apache/flink/commit/e2b1460ce15ca62960d1e4a4f431d6f7a7022e5a", "message": "Fixup.", "committedDate": "2020-04-08T04:32:02Z", "type": "forcePushed"}, {"oid": "16d04e41554d5244bb4907f1d0afed7826cda523", "url": "https://github.com/apache/flink/commit/16d04e41554d5244bb4907f1d0afed7826cda523", "message": "Fixup.", "committedDate": "2020-04-08T08:08:16Z", "type": "forcePushed"}, {"oid": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "url": "https://github.com/apache/flink/commit/20f4e859705d31fd8a0821241bc9813cb39d0c32", "message": "Fixup.", "committedDate": "2020-04-08T15:33:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwOTA4NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406609085", "bodyText": "nit: whitespace for { and =", "author": "zhijiangW", "createdAt": "2020-04-10T05:30:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java", "diffHunk": "@@ -90,7 +111,11 @@ else if (obj != null && obj.getClass() == CheckpointOptions.class) {\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn \"CheckpointOptions: \" + checkpointType + \" @ \" + targetLocation;\n+\t\treturn \"CheckpointOptions{\" +", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java\nindex 8e1c5f63115..be0f8b77000 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java\n\n@@ -111,10 +111,10 @@ public class CheckpointOptions implements Serializable {\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn \"CheckpointOptions{\" +\n-\t\t\t\"checkpointType=\" + checkpointType +\n-\t\t\t\", targetLocation=\" + targetLocation +\n-\t\t\t\", isExactlyOnceMode=\" + isExactlyOnceMode +\n+\t\treturn \"CheckpointOptions {\" +\n+\t\t\t\"checkpointType = \" + checkpointType +\n+\t\t\t\", targetLocation = \" + targetLocation +\n+\t\t\t\", isExactlyOnceMode = \" + isExactlyOnceMode +\n \t\t\t\"}\";\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwOTE4Mw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406609183", "bodyText": "nit: increase indentation for arguments", "author": "zhijiangW", "createdAt": "2020-04-10T05:31:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java", "diffHunk": "@@ -42,12 +43,23 @@\n \t/** Target location for the checkpoint. */\n \tprivate final CheckpointStorageLocationReference targetLocation;\n \n+\tprivate final boolean isExactlyOnceMode;\n+\n+\t@VisibleForTesting\n+\tpublic CheckpointOptions(\n+\t\tCheckpointType checkpointType,", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java\nindex 8e1c5f63115..be0f8b77000 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/CheckpointOptions.java\n\n@@ -47,8 +47,8 @@ public class CheckpointOptions implements Serializable {\n \n \t@VisibleForTesting\n \tpublic CheckpointOptions(\n-\t\tCheckpointType checkpointType,\n-\t\tCheckpointStorageLocationReference targetLocation) {\n+\t\t\tCheckpointType checkpointType,\n+\t\t\tCheckpointStorageLocationReference targetLocation) {\n \t\tthis(checkpointType, targetLocation, true);\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYzNTU0NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406635545", "bodyText": "the description is not correct.", "author": "zhijiangW", "createdAt": "2020-04-10T07:15:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/PartitionRequestClient.java", "diffHunk": "@@ -50,6 +50,13 @@ void requestSubpartition(\n \t */\n \tvoid notifyCreditAvailable(RemoteInputChannel inputChannel);\n \n+\t/**\n+\t * Notifies available credits from one remote input channel.", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/PartitionRequestClient.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/PartitionRequestClient.java\nindex 627602a66d1..4afbab43d7e 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/PartitionRequestClient.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/PartitionRequestClient.java\n\n@@ -51,7 +51,7 @@ public interface PartitionRequestClient {\n \tvoid notifyCreditAvailable(RemoteInputChannel inputChannel);\n \n \t/**\n-\t * Notifies available credits from one remote input channel.\n+\t * Requests to resume data consumption from one remote input channel.\n \t *\n \t * @param inputChannel The remote input channel who is ready to resume data consumption.\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MjI5MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406642290", "bodyText": "Is it necessary to ensureAccessible for setter?", "author": "zhijiangW", "createdAt": "2020-04-10T07:36:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java", "diffHunk": "@@ -639,4 +632,16 @@ public boolean isCompressed() {\n \tpublic void setCompressed(boolean isCompressed) {\n \t\tthis.isCompressed = isCompressed;\n \t}\n+\n+\t@Override\n+\tpublic DataType getDataType() {\n+\t\treturn dataType;\n+\t}\n+\n+\t@Override\n+\tpublic void setDataType(DataType dataType) {\n+\t\tensureAccessible();", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDA3Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407160076", "bodyText": "I copied this from tagAsEvent, IMO, ensureAccessible is not a must here and I checked the code, ensureAccessible method mainly checks about the reference count and ensures that the buffer is not recycled, so I  think it should be ok to keep this check.", "author": "wsry", "createdAt": "2020-04-12T07:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0MjI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "725c7e2e4e229cd4a18dab99531ec66457b4ba6d", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\nindex 02f98920f90..93ad6634fcd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBuffer.java\n\n@@ -632,16 +639,4 @@ public class NetworkBuffer extends AbstractReferenceCountedByteBuf implements Bu\n \tpublic void setCompressed(boolean isCompressed) {\n \t\tthis.isCompressed = isCompressed;\n \t}\n-\n-\t@Override\n-\tpublic DataType getDataType() {\n-\t\treturn dataType;\n-\t}\n-\n-\t@Override\n-\tpublic void setDataType(DataType dataType) {\n-\t\tensureAccessible();\n-\n-\t\tthis.dataType = dataType;\n-\t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NTQxNw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406645417", "bodyText": "Some general usages also reference this, so I prefer to defining EVENT_BUFFER instead for general purpose. The semantic here is also covering the above EXACTLY_ONCE_CHECKPOINT_BARRIER. If we defined as OTHER_EVENT, it seems exclude the EXACTLY_ONCE_CHECKPOINT_BARRIER.", "author": "zhijiangW", "createdAt": "2020-04-10T07:45:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +224,58 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer represents.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true),\n+\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false),\n+\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other\n+\t\t * unknown event.\n+\t\t */\n+\t\tOTHER_EVENT(false);", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex ecd29da598f..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -236,7 +236,8 @@ public interface Buffer {\n \tvoid setDataType(DataType dataType);\n \n \t/**\n-\t * Used to identify the type of data contained in {@link Buffer}.\n+\t * Used to identify the type of data contained in the {@link Buffer} so that we can get\n+\t * the information without deserializing the serialized data.\n \t */\n \tenum DataType {\n \t\t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0NTczOA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406645738", "bodyText": "The descriptions should also be adjusted.", "author": "zhijiangW", "createdAt": "2020-04-10T07:46:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java", "diffHunk": "@@ -227,4 +224,58 @@\n \t * Tags the buffer as compressed or uncompressed.\n \t */\n \tvoid setCompressed(boolean isCompressed);\n+\n+\t/**\n+\t * Gets the type of data this buffer represents.\n+\t */\n+\tDataType getDataType();\n+\n+\t/**\n+\t * Sets the type of data this buffer represents.\n+\t */\n+\tvoid setDataType(DataType dataType);\n+\n+\t/**\n+\t * Used to identify the type of data contained in {@link Buffer}.\n+\t */\n+\tenum DataType {\n+\t\t/**\n+\t\t * DATA_BUFFER indicates that this buffer represents a non-event data buffer.\n+\t\t */\n+\t\tDATA_BUFFER(true),\n+\n+\t\t/**\n+\t\t * EXACTLY_ONCE_CHECKPOINT_BARRIER indicates that this buffer represents a\n+\t\t * serialized checkpoint barrier of exactly once checkpoint mode.\n+\t\t */\n+\t\tEXACTLY_ONCE_CHECKPOINT_BARRIER(false),\n+\n+\t\t/**\n+\t\t * UNKNOWN_EVENT indicates this buffer represents serialized data of other", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\nindex ecd29da598f..757cd01dd08 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/Buffer.java\n\n@@ -236,7 +236,8 @@ public interface Buffer {\n \tvoid setDataType(DataType dataType);\n \n \t/**\n-\t * Used to identify the type of data contained in {@link Buffer}.\n+\t * Used to identify the type of data contained in the {@link Buffer} so that we can get\n+\t * the information without deserializing the serialized data.\n \t */\n \tenum DataType {\n \t\t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTExMw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406701113", "bodyText": "I think we should not modify the condition of flushRequested, and only work on the condition of notifyDataAvailable.\nThen isBlockedByCheckpoint can be added into below notifyDataAvailable, but now touch readerView condition which is out of scope of this PR.", "author": "zhijiangW", "createdAt": "2020-04-10T10:29:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -322,7 +341,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \tpublic void flush() {\n \t\tfinal boolean notifyDataAvailable;\n \t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty()) {\n+\t\t\tif (buffers.isEmpty() || readView == null || isBlockedByCheckpoint) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 2b8a7c4dec2..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -341,12 +340,15 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \tpublic void flush() {\n \t\tfinal boolean notifyDataAvailable;\n \t\tsynchronized (buffers) {\n-\t\t\tif (buffers.isEmpty() || readView == null || isBlockedByCheckpoint) {\n+\t\t\tif (buffers.isEmpty()) {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t// if there is more then 1 buffer, we already notified the reader\n \t\t\t// (at the latest when adding the second buffer)\n-\t\t\tnotifyDataAvailable = !flushRequested && buffers.size() == 1 && buffers.peek().isDataAvailable();\n+\t\t\tnotifyDataAvailable = !flushRequested\n+\t\t\t\t&& !isBlockedByCheckpoint\n+\t\t\t\t&& buffers.size() == 1\n+\t\t\t\t&& buffers.peek().isDataAvailable();\n \t\t\tflushRequested = flushRequested || buffers.size() > 1 || notifyDataAvailable;\n \t\t}\n \t\tif (notifyDataAvailable) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ0NQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406701445", "bodyText": "better to make this change as a separate hotfix commit", "author": "zhijiangW", "createdAt": "2020-04-10T10:30:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -396,13 +415,11 @@ public int getBuffersInBacklog() {\n \n \tprivate boolean shouldNotifyDataAvailable() {\n \t\t// Notify only when we added first finished buffer.\n-\t\treturn readView != null && !flushRequested && getNumberOfFinishedBuffers() == 1;\n+\t\treturn readView != null && !flushRequested && !isBlockedByCheckpoint && getNumberOfFinishedBuffers() == 1;\n \t}\n \n \tprivate void notifyDataAvailable() {\n-\t\tif (readView != null) {", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2Mzc0Ng==", "url": "https://github.com/apache/flink/pull/11351#discussion_r407163746", "bodyText": "I remove the readView != null condition check in flush as suggested, so I add this condition back.", "author": "wsry", "createdAt": "2020-04-12T08:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NTMzMw==", "url": "https://github.com/apache/flink/pull/11351#discussion_r408665333", "bodyText": "Actually this condition even this method can be removed if we can reuse the preceding three conditions inside shouldNotifyDataAvailable for #flush() operation, because only the available conditions inside #flush not check the readerView != null.", "author": "zhijiangW", "createdAt": "2020-04-15T08:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMTQ0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 2b8a7c4dec2..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -419,7 +421,9 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t}\n \n \tprivate void notifyDataAvailable() {\n-\t\treadView.notifyDataAvailable();\n+\t\tif (readView != null) {\n+\t\t\treadView.notifyDataAvailable();\n+\t\t}\n \t}\n \n \tprivate int getNumberOfFinishedBuffers() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNTQwMQ==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406705401", "bodyText": "it is better to merge isAvailableWithoutCredit() with existing isAvailable() to avoid maintaining two separate interface methods. We can integrate them into isAvailable(int credit) method for distinguishing the condition inside implementations.", "author": "zhijiangW", "createdAt": "2020-04-10T10:44:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java", "diffHunk": "@@ -50,12 +50,14 @@\n \n \tboolean isReleased();\n \n+\tvoid resumeConsumption();\n+\n \tThrowable getFailureCause();\n \n \t/**\n-\t * Returns whether the next buffer is an event or not.\n+\t * Returns true if we can read data without available credits.\n \t */\n-\tboolean nextBufferIsEvent();\n+\tboolean isAvailableWithoutCredit();", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java\nindex 05aec321b73..6105f3cd67a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartitionView.java\n\n@@ -54,12 +54,7 @@ public interface ResultSubpartitionView {\n \n \tThrowable getFailureCause();\n \n-\t/**\n-\t * Returns true if we can read data without available credits.\n-\t */\n-\tboolean isAvailableWithoutCredit();\n-\n-\tboolean isAvailable();\n+\tboolean isAvailable(int numCreditsAvailable);\n \n \tint unsynchronizedGetNumberOfQueuedBuffers();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwNjk2MA==", "url": "https://github.com/apache/flink/pull/11351#discussion_r406706960", "bodyText": "@GuardedBy(\"buffers\")", "author": "zhijiangW", "createdAt": "2020-04-10T10:49:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -86,6 +86,9 @@\n \t/** The total number of bytes (both data and event buffers). */\n \tprivate long totalNumberOfBytes;\n \n+\t/** Whether this subpartition is blocked by exactly once checkpoint and is waiting for resumption. */\n+\tprivate boolean isBlockedByCheckpoint = false;", "originalCommit": "20f4e859705d31fd8a0821241bc9813cb39d0c32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3428a844d7cb5903f505686881be27970205f0", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 2b8a7c4dec2..07207ed52a2 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -87,6 +87,7 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \tprivate long totalNumberOfBytes;\n \n \t/** Whether this subpartition is blocked by exactly once checkpoint and is waiting for resumption. */\n+\t@GuardedBy(\"buffers\")\n \tprivate boolean isBlockedByCheckpoint = false;\n \n \t// ------------------------------------------------------------------------\n"}}]}