{"pr_number": 12575, "pr_title": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.", "pr_createdAt": "2020-06-10T08:10:15Z", "pr_url": "https://github.com/apache/flink/pull/12575", "timeline": [{"oid": "d66b663e744026f16bda9effaa5b4c3481dd72a1", "url": "https://github.com/apache/flink/commit/d66b663e744026f16bda9effaa5b4c3481dd72a1", "message": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.\n\nFor multi-gate inputs, there existed inconsistent offset handling of BarrierHandlers and CheckpointedInputGates for unaligned checkpoints.\nThis commit uses the non-unioned (Indexed)InputGates as the main information source that is needed to create handlers.\nUnioned input gates are only used to create the CheckpointedInputGate.", "committedDate": "2020-06-10T08:29:14Z", "type": "forcePushed"}, {"oid": "0f4937a770629aaedc86bdf206fd225667965595", "url": "https://github.com/apache/flink/commit/0f4937a770629aaedc86bdf206fd225667965595", "message": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.\n\nFor multi-gate inputs, there existed inconsistent offset handling of BarrierHandlers and CheckpointedInputGates for unaligned checkpoints.\nThis commit uses the non-unioned (Indexed)InputGates as the main information source that is needed to create handlers.\nUnioned input gates are only used to create the CheckpointedInputGate.", "committedDate": "2020-06-10T09:46:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxMzgzNA==", "url": "https://github.com/apache/flink/pull/12575#discussion_r438013834", "bodyText": "Can we add a check that returned value is a single-element array to prevent future bugs?", "author": "rkhachatryan", "createdAt": "2020-06-10T10:11:37Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -28,39 +29,28 @@\n \n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.stream.IntStream;\n \n /**\n  * Utility for creating {@link CheckpointedInputGate} based on checkpoint mode\n  * for {@link StreamOneInputProcessor} and {@link StreamTwoInputProcessor}.\n  */\n @Internal\n public class InputProcessorUtil {\n-\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tAbstractInvokable toNotifyOnCheckpoint,\n \t\t\tStreamConfig config,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tIndexedInputGate[] inputGates,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n \t\t\tString taskName) {\n-\t\tInputGate inputGate = InputGateUtil.createInputGate(inputGates);\n-\t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n+\t\treturn createCheckpointedMultipleInputGate(\n+\t\t\ttoNotifyOnCheckpoint,\n \t\t\tconfig,\n-\t\t\tArrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels),\n \t\t\tcheckpointCoordinator,\n+\t\t\ttaskIOMetricGroup,\n \t\t\ttaskName,\n-\t\t\tgenerateChannelIndexToInputGateMap(inputGate),\n-\t\t\tgenerateInputGateToChannelIndexOffsetMap(inputGate),\n-\t\t\ttoNotifyOnCheckpoint);\n-\t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n-\n-\t\tbarrierHandler.getBufferReceivedListener().ifPresent(inputGate::registerBufferReceivedListener);\n-\n-\t\treturn new CheckpointedInputGate(inputGate, barrierHandler);\n+\t\t\tArrays.asList(inputGates))[0];", "originalCommit": "0f4937a770629aaedc86bdf206fd225667965595", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "636087d7dbb0ee504de703c83b9a10e934785fb6", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\nindex 4a49e00476a..c5044c5b3c9 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n\n@@ -27,8 +27,11 @@ import org.apache.flink.runtime.metrics.groups.TaskIOMetricGroup;\n import org.apache.flink.streaming.api.graph.StreamConfig;\n import org.apache.flink.streaming.runtime.tasks.SubtaskCheckpointCoordinator;\n \n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n \n /**\n  * Utility for creating {@link CheckpointedInputGate} based on checkpoint mode\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r438058716", "bodyText": "I see similar code in CheckpointBarrierAligner constructor and same in InputProcessorUtil.createCheckpointedInputGates.\nWDYT about extracting it into something like InputGateResolver and passing it to barrier handlers, input gates and whoever else need it?\nIdeally, I think we should use self-sufficient IDs, but I guess this would be too invasive change.", "author": "rkhachatryan", "createdAt": "2020-06-10T11:42:27Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -91,31 +91,25 @@\n \tprivate final ThreadSafeUnaligner threadSafeUnaligner;\n \n \tCheckpointBarrierUnaligner(\n-\t\t\tint[] numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n-\t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n+\t\t\tAbstractInvokable toNotifyOnCheckpoint,\n+\t\t\tIndexedInputGate... inputGates) {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\n-\t\tfinal int numGates = numberOfInputChannelsPerGate.length;\n-\n-\t\tgateChannelOffsets = new int[numGates];\n-\t\tfor (int index = 1; index < numGates; index++) {\n-\t\t\tgateChannelOffsets[index] = gateChannelOffsets[index - 1] + numberOfInputChannelsPerGate[index - 1];\n-\t\t}\n-\n-\t\tfinal int totalNumChannels = gateChannelOffsets[numGates - 1] + numberOfInputChannelsPerGate[numGates - 1];\n-\t\thasInflightBuffers = new boolean[totalNumChannels];\n-\n-\t\tchannelInfos = IntStream.range(0, numGates)\n-\t\t\t.mapToObj(gateIndex -> IntStream.range(0, numberOfInputChannelsPerGate[gateIndex])\n-\t\t\t\t.mapToObj(channelIndex -> new InputChannelInfo(gateIndex, channelIndex)))\n-\t\t\t.flatMap(Function.identity())\n+\t\tthis.channelInfos = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n \t\t\t.toArray(InputChannelInfo[]::new);\n-\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(checkpointCoordinator), this);\n+\t\thasInflightBuffers = new boolean[channelInfos.length];\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n+\n+\t\tgateChannelOffsets = new int[inputGates.length];\n+\t\tint offset = 0;\n+\t\tfor (final IndexedInputGate gate: inputGates) {\n+\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n+\t\t\toffset += gate.getNumberOfInputChannels();\n+\t\t}", "originalCommit": "0f4937a770629aaedc86bdf206fd225667965595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzMDUxMw==", "url": "https://github.com/apache/flink/pull/12575#discussion_r439030513", "bodyText": "That's a tough one; I had feared you pointing it out. The issue is that they are all similar but in the end also quite different.\nCheckpointBarrierAligner creates a map gate->offset, because it also creates an index->gate array, which it uses in resumeConsumption to first resolve the gate for a given flattened channel index and then delegate resumeConsumption with adjusted index (that's where the offset is needed).\nCheckpointBarrierUnaligner mainly uses the InputChannelInfo and hence creates a gate index->offset map to create the flattened index for other BarrierHandler stuff.\nThese two versions gets the SingleInputGates (only they have indices).\nInputProcessorUtil.createCheckpointedInputGates uses union input gates, so it cannot use indexes. So it goes by list index. However, now that I write it down this looks also suspicious...\nI guess to use simple offsets in CheckpointedInput (because of union gates), we actually need to assume consecutive indices... @pnowojski however also saw some strange cases, maybe he can add his observations.", "author": "AHeise", "createdAt": "2020-06-11T19:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NDQ5OA==", "url": "https://github.com/apache/flink/pull/12575#discussion_r439064498", "bodyText": "I look at it from a bit different perspective. InputProcessorUtil.createCheckpointedInputGates passes offsets to CheckpointedInputGate which uses them to talk with barrierHandler:\n// CheckpointedInputGate with offsetChannelIndex() inlined for clarity\nbarrierHandler.isBlocked(bufferOrEvent.getChannelIndex() + channelIndexOffset)\nbarrierHandler.processBarrier(checkpointBarrier, bufferOrEvent.getChannelIndex() + channelIndexOffset);\n\nCheckpointBarrierAligner.processBarrier internally calls resumeConsumption which unflattens index back:\nprivate void resumeConsumption(int channelIndex) {\n    InputGate inputGate = channelIndexToInputGate[channelIndex];\n    inputGate.resumeConsumption(channelIndex - inputGateToChannelIndexOffset.get(inputGate));\n}\n\nSo, they are related.\nNow, are they equal?\nThe fact that CheckpointedInputGate can use UnionInputGate is accounted by\nUnionInputGate.getNumberOfInputChannels which returns the total number of input channels. So these offsets indeed are the same.\nI'm more inclined now to use gateId+channelId pairs or InputChannelInfo s :)", "author": "rkhachatryan", "createdAt": "2020-06-11T20:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5Mjc1Mg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r439292752", "bodyText": "I'd actually love to use InputChannelInfos everywhere. Previous attempts to refactor proved difficult however. I'll check again.", "author": "AHeise", "createdAt": "2020-06-12T08:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMwNjgxNg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r439306816", "bodyText": "@AHeise are you asking about InputProcessorUtil#generateInputGateToChannelIndexOffsetMap not using the input gate indexes? I'm not sure. I guess it is inconsistent with the numberOfInputChannelsPerGate but it might be correct, as all of the references/usages of inputGateToChannelIndexOffset are going through the offsetting that also uses inputGateToChannelIndexOffset (for example CheckpointedInputGate#offsetChannelIndex). But it's really hard to reason about.\nIt's also quite strange that when polling records from input gate, we are first offsetting them once via using CheckpointedInputGate#offsetChannelIndex and then we are using basically the same information to revert the offset back, to the original value in CheckpointBarrierAligner#resumeConsumption.\nIf we could simplify it by always using pair of ids without affecting performance that would be really nice...", "author": "pnowojski", "createdAt": "2020-06-12T09:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxNg=="}], "type": "inlineReview", "revised_code": {"commit": "358bc25b01b746ad9e27d99359f120b66feaa4dc", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\nindex 03d789e612d..e466dcfb0c4 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java\n\n@@ -98,18 +92,10 @@ public class CheckpointBarrierUnaligner extends CheckpointBarrierHandler {\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\t\tthis.channelInfos = Arrays.stream(inputGates)\n-\t\t\t.flatMap(gate -> gate.getChannels().stream().map(InputChannel::getChannelInfo))\n-\t\t\t.toArray(InputChannelInfo[]::new);\n-\t\thasInflightBuffers = new boolean[channelInfos.length];\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(channelInfos.length, checkNotNull(checkpointCoordinator), this);\n-\n-\t\tgateChannelOffsets = new int[inputGates.length];\n-\t\tint offset = 0;\n-\t\tfor (final IndexedInputGate gate: inputGates) {\n-\t\t\tgateChannelOffsets[gate.getGateIndex()] = offset;\n-\t\t\toffset += gate.getNumberOfInputChannels();\n-\t\t}\n+\t\thasInflightBuffers = Arrays.stream(inputGates)\n+\t\t\t.flatMap(gate -> gate.getChannelInfos().stream())\n+\t\t\t.collect(Collectors.toMap(Function.identity(), e -> FALSE));\n+\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(checkNotNull(checkpointCoordinator), this, inputGates);\n \t}\n \n \t/**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTMxMg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r438059312", "bodyText": "Replacing an array with Collection allows to lose ordering. Why not to use List instead?", "author": "rkhachatryan", "createdAt": "2020-06-10T11:43:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java", "diffHunk": "@@ -38,18 +40,18 @@ public static InputGate createInputGate(Collection<IndexedInputGate> inputGates1\n \t\tList<IndexedInputGate> gates = new ArrayList<>(inputGates1.size() + inputGates2.size());\n \t\tgates.addAll(inputGates1);\n \t\tgates.addAll(inputGates2);\n-\t\treturn createInputGate(gates.toArray(new IndexedInputGate[gates.size()]));\n+\t\treturn createInputGate(gates);\n \t}\n \n-\tpublic static InputGate createInputGate(IndexedInputGate[] inputGates) {\n-\t\tif (inputGates.length <= 0) {\n+\tpublic static InputGate createInputGate(Collection<IndexedInputGate> inputGates) {", "originalCommit": "0f4937a770629aaedc86bdf206fd225667965595", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAyNDcxMg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r439024712", "bodyText": "I had to change a bit of the invoking code, but it's not much because ultimately Lists are used everywhere.", "author": "AHeise", "createdAt": "2020-06-11T19:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1OTMxMg=="}], "type": "inlineReview", "revised_code": {"commit": "636087d7dbb0ee504de703c83b9a10e934785fb6", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java\nindex 6f4b0b0401e..c913ba092d1 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputGateUtil.java\n\n@@ -43,13 +43,13 @@ public class InputGateUtil {\n \t\treturn createInputGate(gates);\n \t}\n \n-\tpublic static InputGate createInputGate(Collection<IndexedInputGate> inputGates) {\n+\tpublic static InputGate createInputGate(List<IndexedInputGate> inputGates) {\n \t\tif (inputGates.size() <= 0) {\n \t\t\tthrow new RuntimeException(\"No such input gate.\");\n \t\t}\n \n \t\tif (inputGates.size() == 1) {\n-\t\t\treturn Iterables.getOnlyElement(inputGates);\n+\t\t\treturn inputGates.get(0);\n \t\t} else {\n \t\t\treturn new UnionInputGate(inputGates.toArray(new IndexedInputGate[0]));\n \t\t}\n"}}, {"oid": "636087d7dbb0ee504de703c83b9a10e934785fb6", "url": "https://github.com/apache/flink/commit/636087d7dbb0ee504de703c83b9a10e934785fb6", "message": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.\n\nFor multi-gate inputs, there existed inconsistent offset handling of BarrierHandlers and CheckpointedInputGates for unaligned checkpoints.\nThis commit uses the non-unioned (Indexed)InputGates as the main information source that is needed to create handlers.\nUnioned input gates are only used to create the CheckpointedInputGate.", "committedDate": "2020-06-11T19:38:11Z", "type": "forcePushed"}, {"oid": "358bc25b01b746ad9e27d99359f120b66feaa4dc", "url": "https://github.com/apache/flink/commit/358bc25b01b746ad9e27d99359f120b66feaa4dc", "message": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.\n\nFor multi-gate inputs, there existed inconsistent offset handling of BarrierHandlers and CheckpointedInputGates for unaligned checkpoints.\nThis commit uses the non-unioned (Indexed)InputGates as the main information source that is needed to create handlers.\nUnioned input gates are only used to create the CheckpointedInputGate.", "committedDate": "2020-06-12T13:04:40Z", "type": "forcePushed"}, {"oid": "931f49223353cc7bd913f17dcfb91df970a24944", "url": "https://github.com/apache/flink/commit/931f49223353cc7bd913f17dcfb91df970a24944", "message": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.\n\nFor multi-gate inputs, there existed inconsistent offset handling of BarrierHandlers and CheckpointedInputGates for unaligned checkpoints.\nThis commit uses the non-unioned (Indexed)InputGates as the main information source that is needed to create handlers.\nUnioned input gates are only used to create the CheckpointedInputGate.", "committedDate": "2020-06-12T13:52:02Z", "type": "forcePushed"}, {"oid": "d34667c4703367173ab26e84caa111b4b2d5e652", "url": "https://github.com/apache/flink/commit/d34667c4703367173ab26e84caa111b4b2d5e652", "message": "[FLINK-18094][checkpointing] Unifies the creation of BarrierHandlers and CheckpointedInputGate.\n\nFor multi-gate inputs, there existed inconsistent offset handling of BarrierHandlers and CheckpointedInputGates for unaligned checkpoints.\nThis commit uses the non-unioned (Indexed)InputGates as the main information source that is needed to create handlers.\nUnioned input gates are only used to create the CheckpointedInputGate.", "committedDate": "2020-06-13T11:53:52Z", "type": "forcePushed"}, {"oid": "09707a507eb7346c5b3782385c416fcaa99ebbd5", "url": "https://github.com/apache/flink/commit/09707a507eb7346c5b3782385c416fcaa99ebbd5", "message": "[FLINK-18094][network] Buffers are only addressed through InputChannelInfo.\n\nThis removes the need to translate the InputChannelInfo back and forth to flattened indexes across all InputGates.\nAll index-based data structures are replaced by maps that associate a certain state to a given InputChannelInfo. For performance reasons, these maps are fully initialized upon construction, such that no nodes need to be added/removed during runtime and only values are updated.\nAdditionally, this commit unifies the creation of BarrierHandlers (similar signature) and removes the error-prone offset handling from CheckpointedInputGate.", "committedDate": "2020-06-15T19:38:48Z", "type": "forcePushed"}, {"oid": "cf35ad99fab120c4ea7795406e65dcb1073ab0ed", "url": "https://github.com/apache/flink/commit/cf35ad99fab120c4ea7795406e65dcb1073ab0ed", "message": "[FLINK-18094][network] Buffers are only addressed through InputChannelInfo.\n\nThis removes the need to translate the InputChannelInfo back and forth to flattened indexes across all InputGates.\nAll index-based data structures are replaced by maps that associate a certain state to a given InputChannelInfo. For performance reasons, these maps are fully initialized upon construction, such that no nodes need to be added/removed during runtime and only values are updated.\nAdditionally, this commit unifies the creation of BarrierHandlers (similar signature) and removes the error-prone offset handling from CheckpointedInputGate.", "committedDate": "2020-06-15T19:43:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NTY4Mw==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440595683", "bodyText": "This seems to be going in the opposite direction - we are replacing indexing based on the real IDs with those based on the order?", "author": "pnowojski", "createdAt": "2020-06-16T05:33:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -105,11 +105,11 @@ public UnionInputGate(IndexedInputGate... inputGates) {\n \t\tinputChannelToInputGateIndex = new int[totalNumberOfInputChannels];\n \n \t\tint currentNumberOfInputChannels = 0;\n-\t\tfor (final IndexedInputGate inputGate : inputGates) {\n-\t\t\tinputGateChannelIndexOffsets[inputGate.getGateIndex()] = currentNumberOfInputChannels;\n+\t\tfor (int index = 0; index < inputGates.length; index++) {", "originalCommit": "da20240bb34b4ba4b516d67867f9d84819f894fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0MTA3NQ==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440641075", "bodyText": "Yes you are right. I reverted the change and went into a different direction. The basic issue is that the field inputGates contains all gates in a dense array. We would need a sparse index/map if we access it completely through gateIndex.\nThere were 3 options:\n\nAlways use dense, which results in what you have mentioned.\nUse both, resulting in duplicate fields.\nAlways use sparse index, where we need to skip null values. Or use map and live with slightly longer accesses (current solution).", "author": "AHeise", "createdAt": "2020-06-16T07:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NTY4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0ODQ4MQ==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440748481", "bodyText": "Ok, let's try out the Map approach. In case of performance issues, we can later fallback to other solution, like sparse index.", "author": "pnowojski", "createdAt": "2020-06-16T10:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU5NTY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6713d2a86c8d3c95d14246a404c38aa9b7d97a32", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\nindex 2eb8db7132e..b6b423fe5d3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java\n\n@@ -100,16 +102,20 @@ public class UnionInputGate extends InputGate {\n \t\tthis.inputGatesWithRemainingData = Sets.newHashSetWithExpectedSize(inputGates.length);\n \n \t\tfinal int maxGateIndex = Arrays.stream(inputGates).mapToInt(IndexedInputGate::getGateIndex).max().orElse(0);\n-\t\tinputGateChannelIndexOffsets = new int[maxGateIndex + 1];\n \t\tint totalNumberOfInputChannels = Arrays.stream(inputGates).mapToInt(IndexedInputGate::getNumberOfInputChannels).sum();\n+\n+\t\tinputGatesByGateIndex = new InputGate[maxGateIndex + 1];\n+\t\tArrays.stream(inputGates).forEach(ig -> inputGatesByGateIndex[ig.getGateIndex()] = ig);\n+\t\tinputGateChannelIndexOffsets = new int[maxGateIndex + 1];\n \t\tinputChannelToInputGateIndex = new int[totalNumberOfInputChannels];\n \n \t\tint currentNumberOfInputChannels = 0;\n-\t\tfor (int index = 0; index < inputGates.length; index++) {\n-\t\t\tinputGateChannelIndexOffsets[index] = currentNumberOfInputChannels;\n+\t\tfor (final IndexedInputGate inputGate : inputGates) {\n+\t\t\tinputGatesByGateIndex[inputGate.getGateIndex()] = inputGate;\n+\t\t\tinputGateChannelIndexOffsets[inputGate.getGateIndex()] = currentNumberOfInputChannels;\n \t\t\tint previousNumberOfInputChannels = currentNumberOfInputChannels;\n-\t\t\tcurrentNumberOfInputChannels += inputGates[index].getNumberOfInputChannels();\n-\t\t\tArrays.fill(inputChannelToInputGateIndex, previousNumberOfInputChannels, currentNumberOfInputChannels, index);\n+\t\t\tcurrentNumberOfInputChannels += inputGate.getNumberOfInputChannels();\n+\t\t\tArrays.fill(inputChannelToInputGateIndex, previousNumberOfInputChannels, currentNumberOfInputChannels, inputGate.getGateIndex());\n \t\t}\n \n \t\tsynchronized (inputGatesWithData) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMTcxMg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440601712", "bodyText": "It's a bit confusing that above we have sortedInputGates and those input gates here are not sorted. It means we end up with a confusing state, where CheckpointBarrierHandler#inputGates can be accessed via inputGateIndex while UnionInputGate#inputGates can not be.\nI understand why is it so, first one is flattened structure of all input gates, while the other has only a subset of gates. Maybe we can keep it as it is for now, as this commit is already simplifying things, but maybe we should replace UnionInputGate#inputGates array with a map?", "author": "pnowojski", "createdAt": "2020-06-16T05:54:21Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java", "diffHunk": "@@ -71,108 +69,55 @@ public static CheckpointedInputGate createCheckpointedInputGate(\n \t\t\tString taskName,\n \t\t\tList<IndexedInputGate>... inputGates) {\n \n-\t\tIntStream numberOfInputChannelsPerGate =\n-\t\t\tArrays\n-\t\t\t\t.stream(inputGates)\n-\t\t\t\t.flatMap(collection -> collection.stream())\n-\t\t\t\t.sorted(Comparator.comparingInt(IndexedInputGate::getGateIndex))\n-\t\t\t\t.mapToInt(InputGate::getNumberOfInputChannels);\n-\n-\t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = generateInputGateToChannelIndexOffsetMap(unionedInputGates);\n-\t\t// Note that numberOfInputChannelsPerGate and inputGateToChannelIndexOffset have a bit different\n-\t\t// indexing and purposes.\n-\t\t//\n-\t\t// The numberOfInputChannelsPerGate is indexed based on flattened input gates, and sorted based on GateIndex,\n-\t\t// so that it can be used in combination with InputChannelInfo class.\n-\t\t//\n-\t\t// The inputGateToChannelIndexOffset is based upon unioned input gates and it's use for translating channel\n-\t\t// indexes from perspective of UnionInputGate to perspective of SingleInputGate.\n-\n+\t\tIndexedInputGate[] sortedInputGates = Arrays.stream(inputGates)\n+\t\t\t.flatMap(Collection::stream)\n+\t\t\t.sorted(Comparator.comparing(IndexedInputGate::getGateIndex))\n+\t\t\t.toArray(IndexedInputGate[]::new);\n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tconfig,\n-\t\t\tnumberOfInputChannelsPerGate,\n+\t\t\tsortedInputGates,\n \t\t\tcheckpointCoordinator,\n \t\t\ttaskName,\n-\t\t\tgenerateChannelIndexToInputGateMap(unionedInputGates),\n-\t\t\tinputGateToChannelIndexOffset,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n+\t\tInputGate[] unionedInputGates = Arrays.stream(inputGates)", "originalCommit": "cf35ad99fab120c4ea7795406e65dcb1073ab0ed", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "685bc5914bc96fbe89be63b64a9668cb38c995ed", "chunk": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\nindex 3ed85844009..b397b9eae66 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/InputProcessorUtil.java\n\n@@ -67,57 +73,115 @@ public class InputProcessorUtil {\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tTaskIOMetricGroup taskIOMetricGroup,\n \t\t\tString taskName,\n-\t\t\tList<IndexedInputGate>... inputGates) {\n+\t\t\tCollection<IndexedInputGate> ...inputGates) {\n+\n+\t\tInputGate[] unionedInputGates = new InputGate[inputGates.length];\n+\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\tunionedInputGates[i] = InputGateUtil.createInputGate(inputGates[i].toArray(new IndexedInputGate[0]));\n+\t\t}\n+\n+\t\tIntStream numberOfInputChannelsPerGate =\n+\t\t\tArrays\n+\t\t\t\t.stream(inputGates)\n+\t\t\t\t.flatMap(collection -> collection.stream())\n+\t\t\t\t.sorted(Comparator.comparingInt(IndexedInputGate::getGateIndex))\n+\t\t\t\t.mapToInt(InputGate::getNumberOfInputChannels);\n+\n+\t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = generateInputGateToChannelIndexOffsetMap(unionedInputGates);\n+\t\t// Note that numberOfInputChannelsPerGate and inputGateToChannelIndexOffset have a bit different\n+\t\t// indexing and purposes.\n+\t\t//\n+\t\t// The numberOfInputChannelsPerGate is indexed based on flattened input gates, and sorted based on GateIndex,\n+\t\t// so that it can be used in combination with InputChannelInfo class.\n+\t\t//\n+\t\t// The inputGateToChannelIndexOffset is based upon unioned input gates and it's use for translating channel\n+\t\t// indexes from perspective of UnionInputGate to perspective of SingleInputGate.\n \n-\t\tIndexedInputGate[] sortedInputGates = Arrays.stream(inputGates)\n-\t\t\t.flatMap(Collection::stream)\n-\t\t\t.sorted(Comparator.comparing(IndexedInputGate::getGateIndex))\n-\t\t\t.toArray(IndexedInputGate[]::new);\n \t\tCheckpointBarrierHandler barrierHandler = createCheckpointBarrierHandler(\n \t\t\tconfig,\n-\t\t\tsortedInputGates,\n+\t\t\tnumberOfInputChannelsPerGate,\n \t\t\tcheckpointCoordinator,\n \t\t\ttaskName,\n+\t\t\tgenerateChannelIndexToInputGateMap(unionedInputGates),\n+\t\t\tinputGateToChannelIndexOffset,\n \t\t\ttoNotifyOnCheckpoint);\n \t\tregisterCheckpointMetrics(taskIOMetricGroup, barrierHandler);\n \n-\t\tInputGate[] unionedInputGates = Arrays.stream(inputGates)\n-\t\t\t.map(InputGateUtil::createInputGate)\n-\t\t\t.toArray(InputGate[]::new);\n \t\tbarrierHandler.getBufferReceivedListener().ifPresent(listener -> {\n \t\t\tfor (final InputGate inputGate : unionedInputGates) {\n \t\t\t\tinputGate.registerBufferReceivedListener(listener);\n \t\t\t}\n \t\t});\n \n-\t\treturn Arrays.stream(unionedInputGates)\n-\t\t\t.map(unionedInputGate -> new CheckpointedInputGate(unionedInputGate, barrierHandler))\n-\t\t\t.toArray(CheckpointedInputGate[]::new);\n+\t\tCheckpointedInputGate[] checkpointedInputGates = new CheckpointedInputGate[unionedInputGates.length];\n+\n+\t\tfor (int i = 0; i < unionedInputGates.length; i++) {\n+\t\t\tcheckpointedInputGates[i] = new CheckpointedInputGate(\n+\t\t\t\tunionedInputGates[i], barrierHandler, inputGateToChannelIndexOffset.get(unionedInputGates[i]));\n+\t\t}\n+\n+\t\treturn checkpointedInputGates;\n \t}\n \n \tprivate static CheckpointBarrierHandler createCheckpointBarrierHandler(\n \t\t\tStreamConfig config,\n-\t\t\tInputGate[] inputGates,\n+\t\t\tIntStream numberOfInputChannelsPerGate,\n \t\t\tSubtaskCheckpointCoordinator checkpointCoordinator,\n \t\t\tString taskName,\n+\t\t\tInputGate[] channelIndexToInputGate,\n+\t\t\tMap<InputGate, Integer> inputGateToChannelIndexOffset,\n \t\t\tAbstractInvokable toNotifyOnCheckpoint) {\n \t\tswitch (config.getCheckpointMode()) {\n \t\t\tcase EXACTLY_ONCE:\n \t\t\t\tif (config.isUnalignedCheckpointsEnabled()) {\n \t\t\t\t\treturn new AlternatingCheckpointBarrierHandler(\n-\t\t\t\t\t\tnew CheckpointBarrierAligner(taskName, toNotifyOnCheckpoint, inputGates),\n-\t\t\t\t\t\tnew CheckpointBarrierUnaligner(checkpointCoordinator, taskName, toNotifyOnCheckpoint, inputGates),\n+\t\t\t\t\t\tnew CheckpointBarrierAligner(\n+\t\t\t\t\t\t\ttaskName,\n+\t\t\t\t\t\t\tchannelIndexToInputGate,\n+\t\t\t\t\t\t\tinputGateToChannelIndexOffset,\n+\t\t\t\t\t\t\ttoNotifyOnCheckpoint),\n+\t\t\t\t\t\tnew CheckpointBarrierUnaligner(\n+\t\t\t\t\t\t\tnumberOfInputChannelsPerGate.toArray(),\n+\t\t\t\t\t\t\tcheckpointCoordinator,\n+\t\t\t\t\t\t\ttaskName,\n+\t\t\t\t\t\t\ttoNotifyOnCheckpoint),\n \t\t\t\t\t\ttoNotifyOnCheckpoint);\n \t\t\t\t}\n-\t\t\t\treturn new CheckpointBarrierAligner(taskName, toNotifyOnCheckpoint, inputGates);\n+\t\t\t\treturn new CheckpointBarrierAligner(\n+\t\t\t\t\ttaskName,\n+\t\t\t\t\tchannelIndexToInputGate,\n+\t\t\t\t\tinputGateToChannelIndexOffset,\n+\t\t\t\t\ttoNotifyOnCheckpoint);\n \t\t\tcase AT_LEAST_ONCE:\n-\t\t\t\tint numInputChannels = Arrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels).sum();\n-\t\t\t\treturn new CheckpointBarrierTracker(numInputChannels, toNotifyOnCheckpoint);\n+\t\t\t\treturn new CheckpointBarrierTracker(numberOfInputChannelsPerGate.sum(), toNotifyOnCheckpoint);\n \t\t\tdefault:\n \t\t\t\tthrow new UnsupportedOperationException(\"Unrecognized Checkpointing Mode: \" + config.getCheckpointMode());\n \t\t}\n \t}\n \n+\tstatic InputGate[] generateChannelIndexToInputGateMap(InputGate ...inputGates) {\n+\t\tint numberOfInputChannels = Arrays.stream(inputGates).mapToInt(InputGate::getNumberOfInputChannels).sum();\n+\t\tInputGate[] channelIndexToInputGate = new InputGate[numberOfInputChannels];\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (InputGate inputGate: inputGates) {\n+\t\t\tfor (int i = 0; i < inputGate.getNumberOfInputChannels(); ++i) {\n+\t\t\t\tchannelIndexToInputGate[channelIndexOffset + i] = inputGate;\n+\t\t\t}\n+\t\t\tchannelIndexOffset += inputGate.getNumberOfInputChannels();\n+\t\t}\n+\t\treturn channelIndexToInputGate;\n+\t}\n+\n+\tstatic Map<InputGate, Integer> generateInputGateToChannelIndexOffsetMap(InputGate ...inputGates) {\n+\t\tMap<InputGate, Integer> inputGateToChannelIndexOffset = new HashMap<>();\n+\t\tint channelIndexOffset = 0;\n+\t\tfor (InputGate inputGate: inputGates) {\n+\t\t\tinputGateToChannelIndexOffset.put(inputGate, channelIndexOffset);\n+\t\t\tchannelIndexOffset += inputGate.getNumberOfInputChannels();\n+\t\t}\n+\t\treturn inputGateToChannelIndexOffset;\n+\t}\n+\n \tprivate static void registerCheckpointMetrics(TaskIOMetricGroup taskIOMetricGroup, CheckpointBarrierHandler barrierHandler) {\n \t\ttaskIOMetricGroup.gauge(MetricNames.CHECKPOINT_ALIGNMENT_TIME, barrierHandler::getAlignmentDurationNanos);\n \t\ttaskIOMetricGroup.gauge(MetricNames.CHECKPOINT_START_DELAY_TIME, barrierHandler::getCheckpointStartDelayNanos);\n"}}, {"oid": "6713d2a86c8d3c95d14246a404c38aa9b7d97a32", "url": "https://github.com/apache/flink/commit/6713d2a86c8d3c95d14246a404c38aa9b7d97a32", "message": "[FLINK-18094][network] Buffers are only addressed through InputChannelInfo.\n\nThis removes the need to translate the InputChannelInfo back and forth to flattened indexes across all InputGates.\nAll index-based data structures are replaced by maps that associate a certain state to a given InputChannelInfo. For performance reasons, these maps are fully initialized upon construction, such that no nodes need to be added/removed during runtime and only values are updated.\nAdditionally, this commit unifies the creation of BarrierHandlers (similar signature) and removes the error-prone offset handling from CheckpointedInputGate.", "committedDate": "2020-06-16T07:23:44Z", "type": "forcePushed"}, {"oid": "685bc5914bc96fbe89be63b64a9668cb38c995ed", "url": "https://github.com/apache/flink/commit/685bc5914bc96fbe89be63b64a9668cb38c995ed", "message": "[FLINK-18094][network] Fixed UnionInputGate#getChannel.\n\nThe method assumed that the gates have consecutive indexes starting at 0.", "committedDate": "2020-06-16T07:35:01Z", "type": "commit"}, {"oid": "193c2ba7d80ed5e3a1dccc4b9da69a422361c732", "url": "https://github.com/apache/flink/commit/193c2ba7d80ed5e3a1dccc4b9da69a422361c732", "message": "[FLINK-18094][network] Add InputGate#getChannelInfos for easier testing.\n\nIn the following commits, this method will be used to fetch information about all channels without explicitly needing to access the channels. Thus, for tests mocks just need to return meaningful InputChannelInfos instead of actually creating the respective channels.", "committedDate": "2020-06-16T07:35:24Z", "type": "commit"}, {"oid": "4d7deb349f271c6befc0d27e54113e40ddaed401", "url": "https://github.com/apache/flink/commit/4d7deb349f271c6befc0d27e54113e40ddaed401", "message": "[FLINK-18094][network] Simplifying InputProcessorUtil by delegating createCheckpointedInputGate to createCheckpointedMultipleInputGate.", "committedDate": "2020-06-16T07:35:24Z", "type": "commit"}, {"oid": "ae8782594f13b4bdaa92f1b8dc4ae77e4c701d24", "url": "https://github.com/apache/flink/commit/ae8782594f13b4bdaa92f1b8dc4ae77e4c701d24", "message": "[FLINK-18094][network] Using lists instead of collections of gates while creating checkpoint handlers.\n\nThe actual implementation have been lists all along and we assume ordering anyways.", "committedDate": "2020-06-16T07:35:24Z", "type": "commit"}, {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b", "url": "https://github.com/apache/flink/commit/0cd0ba630cea402c2aa45e8c5472858e93be757b", "message": "[FLINK-18094][network] Buffers are only addressed through InputChannelInfo.\n\nThis removes the need to translate the InputChannelInfo back and forth to flattened indexes across all InputGates.\nAll index-based data structures are replaced by maps that associate a certain state to a given InputChannelInfo. For performance reasons, these maps are fully initialized upon construction, such that no nodes need to be added/removed during runtime and only values are updated.\nAdditionally, this commit unifies the creation of BarrierHandlers (similar signature) and removes the error-prone offset handling from CheckpointedInputGate.", "committedDate": "2020-06-16T07:35:24Z", "type": "commit"}, {"oid": "0cd0ba630cea402c2aa45e8c5472858e93be757b", "url": "https://github.com/apache/flink/commit/0cd0ba630cea402c2aa45e8c5472858e93be757b", "message": "[FLINK-18094][network] Buffers are only addressed through InputChannelInfo.\n\nThis removes the need to translate the InputChannelInfo back and forth to flattened indexes across all InputGates.\nAll index-based data structures are replaced by maps that associate a certain state to a given InputChannelInfo. For performance reasons, these maps are fully initialized upon construction, such that no nodes need to be added/removed during runtime and only values are updated.\nAdditionally, this commit unifies the creation of BarrierHandlers (similar signature) and removes the error-prone offset handling from CheckpointedInputGate.", "committedDate": "2020-06-16T07:35:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440653529", "bodyText": "Why do we use Map<Key, Boolean> instead of just  Set<Key> (also in CheckpointBarrierUnaligner, ThreadSafeUnaligner)?\n(I guess we can avoid the penalty of dynamic reallocation by setting set capacity in advance)", "author": "rkhachatryan", "createdAt": "2020-06-16T07:49:42Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAligner.java", "diffHunk": "@@ -46,14 +49,8 @@\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(CheckpointBarrierAligner.class);\n \n-\t/** Used to get InputGate by channel index. */\n-\tprivate final InputGate[] channelIndexToInputGate;\n-\n-\t/** Used to get channel index offset by InputGate. */\n-\tprivate final Map<InputGate, Integer> inputGateToChannelIndexOffset;\n-\n \t/** Flags that indicate whether a channel is currently blocked/buffered. */\n-\tprivate final boolean[] blockedChannels;\n+\tprivate final Map<InputChannelInfo, Boolean> blockedChannels;", "originalCommit": "0cd0ba630cea402c2aa45e8c5472858e93be757b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1OTgyOQ==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440659829", "bodyText": "Yes, you are right (I tried to explain it in the commit message). Also internally HashSet uses LinkedHashMap, so it's even then slower than using HashMap directly even with dynamic reallocation.", "author": "AHeise", "createdAt": "2020-06-16T08:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDczOTI4MA==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440739280", "bodyText": "Also internally HashSet uses LinkedHashMap\n\nCan you explain what do you mean?\nIn my OpenJDK 11 HashSet uses HashMap under the hood, and I believe this is what most implementations do.", "author": "rkhachatryan", "createdAt": "2020-06-16T10:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc3MjA3OQ==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440772079", "bodyText": "Never mind, I misread the code. It's only used while calling LinkedHashSet -> super(HashSet).\nAnyways, the current way is used to avoid dynamic reallocations. I can also write a small wrapper Set implementation (similar to EnumSet) if it's too hard to read right now.\nPerformance-wise there is no gain on a HashSet#containsKey on an empty set to a HashMap#get on a filled set with same capacity. However, I'd we avoid object creations and deletions if we just update the nodes on write access.", "author": "AHeise", "createdAt": "2020-06-16T11:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxOTQ0Nw==", "url": "https://github.com/apache/flink/pull/12575#discussion_r440819447", "bodyText": "I'm not sure if it's not a premature optimization (I think contains is faster for set but put/remove slower; and it all may not be visible).\nBut I'm also fine with the current approach.", "author": "rkhachatryan", "createdAt": "2020-06-16T12:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzNDAzMg==", "url": "https://github.com/apache/flink/pull/12575#discussion_r441334032", "bodyText": "HashSet#contains uses HashMap#containsKey, which fetches the node of the key. Without hash collisions and overflow lists, that is exactly the same. The question is how many collisions we have. It may also depend on whether the respective Set is mostly filled or empty (e.g., blockedChannels should be mostly empty). We might want to potentially invert the current semantics to keep them empty as long as possible.\nMy main motivation was to avoid adding anything to GC pressure and using mostly a constant data structure as before to not change too much. I think I'd leave it as is for now. We can revise it when we adjust the threading model of Unaligner, which will be a major change on the code anyways.", "author": "AHeise", "createdAt": "2020-06-17T07:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MzUyOQ=="}], "type": "inlineReview", "revised_code": null}]}