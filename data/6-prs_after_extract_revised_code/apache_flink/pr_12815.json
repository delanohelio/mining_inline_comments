{"pr_number": 12815, "pr_title": "[FLINK-17075][coordination] Reconcile deployed Executions", "pr_createdAt": "2020-07-03T08:15:10Z", "pr_url": "https://github.com/apache/flink/pull/12815", "timeline": [{"oid": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "url": "https://github.com/apache/flink/commit/c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "message": "[FLINK-17075][coordination] Reconcile deployed Executions", "committedDate": "2020-07-03T08:13:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NjE2NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449576164", "bodyText": "I think we can move this to ExecutionGraph.notifyExecutionChange. That way we will only react to signals coming from a valid Execution.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:11:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -1601,6 +1604,8 @@ private boolean transitionState(ExecutionState currentState, ExecutionState targ\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tgetExecutionGraph().getExecutionStateUpdateListener().onStateUpdate(attemptId, state);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxODEyNw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449618127", "bodyText": "Yes, that should work.", "author": "zentol", "createdAt": "2020-07-03T14:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NjE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "55e325143fefcfaf116109ee14e8c2ef2c551b91", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex 195e55fccee..a4a708638ce 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n\n@@ -1604,8 +1604,6 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tgetExecutionGraph().getExecutionStateUpdateListener().onStateUpdate(attemptId, state);\n-\n \t\t\tif (targetState.isTerminal()) {\n \t\t\t\t// complete the terminal state future\n \t\t\t\tterminalStateFuture.complete(targetState);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Njg0Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449576842", "bodyText": "What happens if this Execution is no longer valid (e.g. it has failed in the meantime?). Shouldn't we guard against this situation similar to what we do in ExecutionVertex.notifyStateTransition by checking what the currentExecution is?", "author": "tillrohrmann", "createdAt": "2020-07-03T13:12:40Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -753,8 +753,11 @@ public void deploy() throws JobException {\n \t\t\t\t.thenCompose(Function.identity())\n \t\t\t\t.whenCompleteAsync(\n \t\t\t\t\t(ack, failure) -> {\n-\t\t\t\t\t\t// only respond to the failure case\n-\t\t\t\t\t\tif (failure != null) {\n+\t\t\t\t\t\tif (failure == null) {\n+\t\t\t\t\t\t\tgetExecutionGraph()\n+\t\t\t\t\t\t\t\t.getExecutionDeploymentListener()\n+\t\t\t\t\t\t\t\t.onCompletedDeployment(attemptId, getAssignedResourceLocation().getResourceID());", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNzk5NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449617994", "bodyText": "So just guard the call with if (this == vertex.getCurrentExecutionAttempt())?", "author": "zentol", "createdAt": "2020-07-03T14:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Njg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMTM0Nw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449621347", "bodyText": "Maybe follow a similar pattern as what we do in ExecutionVertex.notifyStateTransition. We could introduce a ExecutionVertex.completeDeployment(this) which does the check whether this is still the currentExecution.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Njg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex 195e55fccee..734d0bc9e61 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n\n@@ -754,9 +754,7 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution\n \t\t\t\t.whenCompleteAsync(\n \t\t\t\t\t(ack, failure) -> {\n \t\t\t\t\t\tif (failure == null) {\n-\t\t\t\t\t\t\tgetExecutionGraph()\n-\t\t\t\t\t\t\t\t.getExecutionDeploymentListener()\n-\t\t\t\t\t\t\t\t.onCompletedDeployment(attemptId, getAssignedResourceLocation().getResourceID());\n+\t\t\t\t\t\t\tvertex.notifyDeployment(this);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tif (failure instanceof TimeoutException) {\n \t\t\t\t\t\t\t\tString taskname = vertex.getTaskNameWithSubtaskIndex() + \" (\" + attemptId + ')';\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449578166", "bodyText": "This call effectively is getVertex().getExecutionGraph().getExecutionDeploymentListener() which is violating the law of Demeter. It effectively couples the implementation of where the ExecutionDeploymentListener lives.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:15:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -753,8 +753,11 @@ public void deploy() throws JobException {\n \t\t\t\t.thenCompose(Function.identity())\n \t\t\t\t.whenCompleteAsync(\n \t\t\t\t\t(ack, failure) -> {\n-\t\t\t\t\t\t// only respond to the failure case\n-\t\t\t\t\t\tif (failure != null) {\n+\t\t\t\t\t\tif (failure == null) {\n+\t\t\t\t\t\t\tgetExecutionGraph()\n+\t\t\t\t\t\t\t\t.getExecutionDeploymentListener()", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzNDU0OA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449634548", "bodyText": "Well yes, but that's rather common in the ExecutionGraph?\nThe alternative I suppose would be to pass the listener through the constructor, ideally behind some kind of service interface which could evolve into a set covering all the other stuff we access the vertex/graph for.", "author": "zentol", "createdAt": "2020-07-03T15:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzODE2Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449638162", "bodyText": "Do you still want me to change anything with the listener call being moved into the ExecutionVertex?", "author": "zentol", "createdAt": "2020-07-03T15:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0MTQ0MA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449641440", "bodyText": "Well, maybe we can introduce a ExecutionVertex.onDeploymentCompleted which then forwards the call to the ExecutionGraph.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\nindex 195e55fccee..734d0bc9e61 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java\n\n@@ -754,9 +754,7 @@ public class Execution implements AccessExecution, Archiveable<ArchivedExecution\n \t\t\t\t.whenCompleteAsync(\n \t\t\t\t\t(ack, failure) -> {\n \t\t\t\t\t\tif (failure == null) {\n-\t\t\t\t\t\t\tgetExecutionGraph()\n-\t\t\t\t\t\t\t\t.getExecutionDeploymentListener()\n-\t\t\t\t\t\t\t\t.onCompletedDeployment(attemptId, getAssignedResourceLocation().getResourceID());\n+\t\t\t\t\t\t\tvertex.notifyDeployment(this);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tif (failure instanceof TimeoutException) {\n \t\t\t\t\t\t\t\tString taskname = vertex.getTaskNameWithSubtaskIndex() + \" (\" + attemptId + ')';\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTA3Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449579073", "bodyText": "Maybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n          \n          \n            \n            \t\tExecutionDeploymentReconciler create(ExecutionDeploymentReconciliationHandler reconciliationHandler);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:17:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.Set;\n+\n+/**\n+ * Component for reconciling the deployment state of executions.\n+ */\n+public interface ExecutionDeploymentReconciler {\n+\n+\t/**\n+\t * Factory for {@link ExecutionDeploymentReconciler}.\n+\t */\n+\tinterface Factory {\n+\t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java\nindex 4128f880146..4372fb8b810 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java\n\n@@ -32,13 +32,13 @@ public interface ExecutionDeploymentReconciler {\n \t * Factory for {@link ExecutionDeploymentReconciler}.\n \t */\n \tinterface Factory {\n-\t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n+\t\tExecutionDeploymentReconciler create(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n \t}\n \n \t/**\n \t * Reconciles the deployment states between all reported/expected executions for the given task executor.\n \t *\n-\t * @param taskExecutorHost\n+\t * @param taskExecutorHost hosting task executor\n \t * @param executionDeploymentReport task executor report for deployed executions\n \t * @param expectedDeployedExecutionIds set of expected deployed executions\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTI2MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449579261", "bodyText": "Description is missing", "author": "tillrohrmann", "createdAt": "2020-07-03T13:18:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.Set;\n+\n+/**\n+ * Component for reconciling the deployment state of executions.\n+ */\n+public interface ExecutionDeploymentReconciler {\n+\n+\t/**\n+\t * Factory for {@link ExecutionDeploymentReconciler}.\n+\t */\n+\tinterface Factory {\n+\t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n+\t}\n+\n+\t/**\n+\t * Reconciles the deployment states between all reported/expected executions for the given task executor.\n+\t *\n+\t * @param taskExecutorHost", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java\nindex 4128f880146..4372fb8b810 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java\n\n@@ -32,13 +32,13 @@ public interface ExecutionDeploymentReconciler {\n \t * Factory for {@link ExecutionDeploymentReconciler}.\n \t */\n \tinterface Factory {\n-\t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n+\t\tExecutionDeploymentReconciler create(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n \t}\n \n \t/**\n \t * Reconciles the deployment states between all reported/expected executions for the given task executor.\n \t *\n-\t * @param taskExecutorHost\n+\t * @param taskExecutorHost hosting task executor\n \t * @param executionDeploymentReport task executor report for deployed executions\n \t * @param expectedDeployedExecutionIds set of expected deployed executions\n \t */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTczMw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449579733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n          \n          \n            \n            public class DefaultExecutionDeploymentReconciler implements ExecutionDeploymentReconciler {\n          \n      \n    \n    \n  \n\nIt is not a lot more specific than XYZImpl but a bit since it says that this is the default implementation.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:19:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNDEzNA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449614134", "bodyText": "I prefer *Impl purely because in an alphabetical file listing it is closer to the interface.", "author": "zentol", "createdAt": "2020-07-03T14:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMzAyMg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449623022", "bodyText": "Hmm, I think it would be slightly better to give implementations a meaningful/expressive name. In the future we might add special implementations which do things a bit differently and if we have a ExecutionDeploymentReconcilerImpl and a FatallyFailingExecutionDeploymentReconciler, then it might not be super obvious what the former does. But admittedly, DefaultXYZ is also not the best of all names. Ideally one has a name which describes the implementation.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTczMw=="}], "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nsimilarity index 78%\nrename from flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\nrename to flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nindex a5a9c69e289..7db5987b687 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\n\n@@ -28,11 +28,11 @@ import java.util.Set;\n  * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n  * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n  */\n-public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+public class DefaultExecutionDeploymentReconciler implements ExecutionDeploymentReconciler {\n \n \tprivate final ExecutionDeploymentReconciliationHandler handler;\n \n-\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\tpublic DefaultExecutionDeploymentReconciler(ExecutionDeploymentReconciliationHandler handler) {\n \t\tthis.handler = handler;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4MDE1Nw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449580157", "bodyText": "I prefer the KISS principle and would simply use the for-each loop here.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:20:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+\n+\tprivate final ExecutionDeploymentReconciliationHandler handler;\n+\n+\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\t\tthis.handler = handler;\n+\t}\n+\n+\t@Override\n+\tpublic void reconcileExecutionDeployments(ResourceID taskExecutorHost, ExecutionDeploymentReport executionDeploymentReport, Set<ExecutionAttemptID> expectedDeployedExecutions) {\n+\t\tfinal Set<ExecutionAttemptID> executions = new HashSet<>(expectedDeployedExecutions);\n+\n+\t\texecutionDeploymentReport.getExecutions().forEach(executionAttemptID -> {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nsimilarity index 78%\nrename from flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\nrename to flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nindex a5a9c69e289..7db5987b687 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\n\n@@ -28,11 +28,11 @@ import java.util.Set;\n  * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n  * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n  */\n-public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+public class DefaultExecutionDeploymentReconciler implements ExecutionDeploymentReconciler {\n \n \tprivate final ExecutionDeploymentReconciliationHandler handler;\n \n-\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\tpublic DefaultExecutionDeploymentReconciler(ExecutionDeploymentReconciliationHandler handler) {\n \t\tthis.handler = handler;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4MTE5MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449581191", "bodyText": "The JavaDocs are not complete. For interfaces I think we should provide complete JavaDocs.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:22:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+/**\n+ * Interface for triggering actions in case of state mismatches.\n+ */\n+public interface ExecutionDeploymentReconciliationHandler {\n+\t/**\n+\t * Called if an execution is expected to be hosted on a task executor, but isn't.\n+\t */", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java\nindex 941a104c155..22c3e07d79d 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java\n\n@@ -26,11 +26,17 @@ import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n public interface ExecutionDeploymentReconciliationHandler {\n \t/**\n \t * Called if an execution is expected to be hosted on a task executor, but isn't.\n+\t *\n+\t * @param executionAttemptId id of te missing deployment\n+\t * @param hostingTaskExecutor expected hosting task executor\n \t */\n-\tvoid onMissingDeployment(ExecutionAttemptID deployment);\n+\tvoid onMissingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID hostingTaskExecutor);\n \n \t/**\n \t * Called if an execution is hosted on a task executor, but we don't expect it.\n+\t *\n+\t * @param executionAttemptId id of the unknown execution\n+\t * @param hostingTaskExecutor hosting task executor\n \t */\n-\tvoid onUnknownDeployment(ExecutionAttemptID deployment, ResourceID hostingTaskExecutor);\n+\tvoid onUnknownDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID hostingTaskExecutor);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTI0NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585244", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid onMissingDeployment(ExecutionAttemptID deployment);\n          \n          \n            \n            \tvoid onMissingDeployment(ExecutionAttemptID executionAttemptId);\n          \n      \n    \n    \n  \n\nnot sure whether the parameter should really be named deployment.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:31:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+/**\n+ * Interface for triggering actions in case of state mismatches.\n+ */\n+public interface ExecutionDeploymentReconciliationHandler {\n+\t/**\n+\t * Called if an execution is expected to be hosted on a task executor, but isn't.\n+\t */\n+\tvoid onMissingDeployment(ExecutionAttemptID deployment);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java\nindex 941a104c155..22c3e07d79d 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java\n\n@@ -26,11 +26,17 @@ import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n public interface ExecutionDeploymentReconciliationHandler {\n \t/**\n \t * Called if an execution is expected to be hosted on a task executor, but isn't.\n+\t *\n+\t * @param executionAttemptId id of te missing deployment\n+\t * @param hostingTaskExecutor expected hosting task executor\n \t */\n-\tvoid onMissingDeployment(ExecutionAttemptID deployment);\n+\tvoid onMissingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID hostingTaskExecutor);\n \n \t/**\n \t * Called if an execution is hosted on a task executor, but we don't expect it.\n+\t *\n+\t * @param executionAttemptId id of the unknown execution\n+\t * @param hostingTaskExecutor hosting task executor\n \t */\n-\tvoid onUnknownDeployment(ExecutionAttemptID deployment, ResourceID hostingTaskExecutor);\n+\tvoid onUnknownDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID hostingTaskExecutor);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTU0MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n          \n          \n            \n            \tvoid startTrackingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:31:54Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A tracker for deployed executions.\n+ */\n+public interface ExecutionDeploymentTracker {\n+\n+\t/**\n+\t * Starts tracking the given execution that was deployed on the given host.\n+\t *\n+\t * @param deployment deployment to start tracking\n+\t * @param host hosting task executor\n+\t */\n+\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\nindex 51b6a3d39a4..5cadf010a2f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\n\n@@ -30,17 +30,17 @@ public interface ExecutionDeploymentTracker {\n \t/**\n \t * Starts tracking the given execution that was deployed on the given host.\n \t *\n-\t * @param deployment deployment to start tracking\n+\t * @param executionAttemptId execution to start tracking\n \t * @param host hosting task executor\n \t */\n-\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\tvoid startTrackingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host);\n \n \t/**\n \t * Stops tracking the given execution.\n \t *\n-\t * @param deployment deployment to stop tracking\n+\t * @param executionAttemptId execution to stop tracking\n \t */\n-\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n+\tvoid stopTrackingDeploymentOf(ExecutionAttemptID executionAttemptId);\n \n \t/**\n \t * Returns all tracked executions for the given host.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTY0Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n          \n          \n            \n            \tvoid stopTrackingDeploymentOf(ExecutionAttemptID executionAttemptId);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:32:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A tracker for deployed executions.\n+ */\n+public interface ExecutionDeploymentTracker {\n+\n+\t/**\n+\t * Starts tracking the given execution that was deployed on the given host.\n+\t *\n+\t * @param deployment deployment to start tracking\n+\t * @param host hosting task executor\n+\t */\n+\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\n+\t/**\n+\t * Stops tracking the given execution.\n+\t *\n+\t * @param deployment deployment to stop tracking\n+\t */\n+\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\nindex 51b6a3d39a4..5cadf010a2f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\n\n@@ -30,17 +30,17 @@ public interface ExecutionDeploymentTracker {\n \t/**\n \t * Starts tracking the given execution that was deployed on the given host.\n \t *\n-\t * @param deployment deployment to start tracking\n+\t * @param executionAttemptId execution to start tracking\n \t * @param host hosting task executor\n \t */\n-\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\tvoid startTrackingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host);\n \n \t/**\n \t * Stops tracking the given execution.\n \t *\n-\t * @param deployment deployment to stop tracking\n+\t * @param executionAttemptId execution to stop tracking\n \t */\n-\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n+\tvoid stopTrackingDeploymentOf(ExecutionAttemptID executionAttemptId);\n \n \t/**\n \t * Returns all tracked executions for the given host.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTg4Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585883", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tSet<ExecutionAttemptID> getExecutions(ResourceID host);\n          \n          \n            \n            \tSet<ExecutionAttemptID> getExecutionsOn(ResourceID host);\n          \n      \n    \n    \n  \n\nor maybe getExecutionsOnHost", "author": "tillrohrmann", "createdAt": "2020-07-03T13:32:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A tracker for deployed executions.\n+ */\n+public interface ExecutionDeploymentTracker {\n+\n+\t/**\n+\t * Starts tracking the given execution that was deployed on the given host.\n+\t *\n+\t * @param deployment deployment to start tracking\n+\t * @param host hosting task executor\n+\t */\n+\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\n+\t/**\n+\t * Stops tracking the given execution.\n+\t *\n+\t * @param deployment deployment to stop tracking\n+\t */\n+\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n+\n+\t/**\n+\t * Returns all tracked executions for the given host.\n+\t *\n+\t * @param host hosting task executor\n+\t * @return tracked executions\n+\t */\n+\tSet<ExecutionAttemptID> getExecutions(ResourceID host);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\nindex 51b6a3d39a4..5cadf010a2f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java\n\n@@ -30,17 +30,17 @@ public interface ExecutionDeploymentTracker {\n \t/**\n \t * Starts tracking the given execution that was deployed on the given host.\n \t *\n-\t * @param deployment deployment to start tracking\n+\t * @param executionAttemptId execution to start tracking\n \t * @param host hosting task executor\n \t */\n-\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\tvoid startTrackingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host);\n \n \t/**\n \t * Stops tracking the given execution.\n \t *\n-\t * @param deployment deployment to stop tracking\n+\t * @param executionAttemptId execution to stop tracking\n \t */\n-\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n+\tvoid stopTrackingDeploymentOf(ExecutionAttemptID executionAttemptId);\n \n \t/**\n \t * Returns all tracked executions for the given host.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTk3Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionDeploymentTrackerImpl implements ExecutionDeploymentTracker, ExecutionDeploymentListener {\n          \n          \n            \n            public class DefaultExecutionDeploymentTracker implements ExecutionDeploymentTracker, ExecutionDeploymentListener {", "author": "tillrohrmann", "createdAt": "2020-07-03T13:32:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.executiongraph.ExecutionDeploymentListener;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentTracker} implementation.\n+ */\n+public class ExecutionDeploymentTrackerImpl implements ExecutionDeploymentTracker, ExecutionDeploymentListener {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMTE5OQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449601199", "bodyText": "Why does this class implement ExecutionDeploymentListener? I think it is nowhere used.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMDgyNQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449620825", "bodyText": "Artifact of an earlier iteration where the tracker was passed into the ExecutionGraph as the listener.", "author": "zentol", "createdAt": "2020-07-03T14:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTk3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTracker.java\nsimilarity index 64%\nrename from flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java\nrename to flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTracker.java\nindex 53d557111a9..c985316b2c9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTracker.java\n\n@@ -19,7 +19,6 @@ package org.apache.flink.runtime.jobmaster;\n \n import org.apache.flink.runtime.clusterframework.types.ResourceID;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n-import org.apache.flink.runtime.executiongraph.ExecutionDeploymentListener;\n \n import java.util.Collections;\n import java.util.HashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4ODA5Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449588093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\texecutionsByHost.compute(host, (resourceID, executionAttemptIds) -> {\n          \n          \n            \n            \t\t\tif (executionAttemptIds == null) {\n          \n          \n            \n            \t\t\t\texecutionAttemptIds = new HashSet<>();\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\texecutionAttemptIds.add(execution);\n          \n          \n            \n            \t\t\treturn executionAttemptIds;\n          \n          \n            \n            \t\t});\n          \n          \n            \n            \t\texecutionsByHost.computeIfAbsent(host, ignored -> new HashSet<>()).add(execution);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:37:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.executiongraph.ExecutionDeploymentListener;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentTracker} implementation.\n+ */\n+public class ExecutionDeploymentTrackerImpl implements ExecutionDeploymentTracker, ExecutionDeploymentListener {\n+\n+\tprivate final Map<ResourceID, Set<ExecutionAttemptID>> executionsByHost = new HashMap<>();\n+\tprivate final Map<ExecutionAttemptID, ResourceID> hostByExecution = new HashMap<>();\n+\n+\t@Override\n+\tpublic void startTrackingDeployment(ExecutionAttemptID execution, ResourceID host) {\n+\t\thostByExecution.put(execution, host);\n+\t\texecutionsByHost.compute(host, (resourceID, executionAttemptIds) -> {\n+\t\t\tif (executionAttemptIds == null) {\n+\t\t\t\texecutionAttemptIds = new HashSet<>();\n+\t\t\t}\n+\t\t\texecutionAttemptIds.add(execution);\n+\t\t\treturn executionAttemptIds;\n+\t\t});", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTracker.java\nsimilarity index 64%\nrename from flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java\nrename to flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTracker.java\nindex 53d557111a9..c985316b2c9 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTracker.java\n\n@@ -19,7 +19,6 @@ package org.apache.flink.runtime.jobmaster;\n \n import org.apache.flink.runtime.clusterframework.types.ResourceID;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n-import org.apache.flink.runtime.executiongraph.ExecutionDeploymentListener;\n \n import java.util.Collections;\n import java.util.HashMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MDU1NQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449590555", "bodyText": "Maybe add a bit more specific exception message.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:43:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java", "diffHunk": "@@ -224,10 +227,34 @@ public JobMaster(\n \t\t\tClassLoader userCodeLoader,\n \t\t\tSchedulerNGFactory schedulerNGFactory,\n \t\t\tShuffleMaster<?> shuffleMaster,\n-\t\t\tPartitionTrackerFactory partitionTrackerFactory) throws Exception {\n+\t\t\tPartitionTrackerFactory partitionTrackerFactory,\n+\t\t\tExecutionDeploymentTracker executionDeploymentTracker,\n+\t\t\tExecutionDeploymentReconciler.Factory executionDeploymentReconcilerFactory) throws Exception {\n \n \t\tsuper(rpcService, AkkaRpcServiceUtils.createRandomName(JOB_MANAGER_NAME), null);\n \n+\t\tfinal ExecutionDeploymentReconciliationHandler executionStateReconciliationHandler = new ExecutionDeploymentReconciliationHandler() {\n+\t\t\t@Override\n+\t\t\tpublic void onMissingDeployment(ExecutionAttemptID deployment) {\n+\t\t\t\tlog.debug(\"Failing deployment {} due to no longer being deployed.\", deployment);\n+\t\t\t\tschedulerNG.updateTaskExecutionState(new TaskExecutionState(\n+\t\t\t\t\tjobGraph.getJobID(), deployment, ExecutionState.FAILED, new FlinkException(\"State de-sync\")", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java\nindex 7e4f4ac6144..e00a688e51e 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java\n\n@@ -235,25 +235,28 @@ public class JobMaster extends FencedRpcEndpoint<JobMasterId> implements JobMast\n \n \t\tfinal ExecutionDeploymentReconciliationHandler executionStateReconciliationHandler = new ExecutionDeploymentReconciliationHandler() {\n \t\t\t@Override\n-\t\t\tpublic void onMissingDeployment(ExecutionAttemptID deployment) {\n-\t\t\t\tlog.debug(\"Failing deployment {} due to no longer being deployed.\", deployment);\n+\t\t\tpublic void onMissingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host) {\n+\t\t\t\tlog.debug(\"Failing deployment {} due to no longer being deployed.\", executionAttemptId);\n \t\t\t\tschedulerNG.updateTaskExecutionState(new TaskExecutionState(\n-\t\t\t\t\tjobGraph.getJobID(), deployment, ExecutionState.FAILED, new FlinkException(\"State de-sync\")\n+\t\t\t\t\tjobGraph.getJobID(),\n+\t\t\t\t\texecutionAttemptId,\n+\t\t\t\t\tExecutionState.FAILED,\n+\t\t\t\t\tnew FlinkException(String.format(\"Execution %s is unexpectedly no longer running on task executor %s.\", executionAttemptId, host))\n \t\t\t\t));\n \t\t\t}\n \n \t\t\t@Override\n-\t\t\tpublic void onUnknownDeployment(ExecutionAttemptID deployment, ResourceID host) {\n-\t\t\t\tlog.debug(\"Canceling left-over deployment {} on task executor {}.\", deployment, host);\n+\t\t\tpublic void onUnknownDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host) {\n+\t\t\t\tlog.debug(\"Canceling left-over deployment {} on task executor {}.\", executionAttemptId, host);\n \t\t\t\tTuple2<TaskManagerLocation, TaskExecutorGateway> taskManagerInfo = registeredTaskManagers.get(host);\n \t\t\t\tif (taskManagerInfo != null) {\n-\t\t\t\t\ttaskManagerInfo.f1.cancelTask(deployment, rpcTimeout);\n+\t\t\t\t\ttaskManagerInfo.f1.cancelTask(executionAttemptId, rpcTimeout);\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \n \t\tthis.executionDeploymentTracker = executionDeploymentTracker;\n-\t\tthis.executionDeploymentReconciler = executionDeploymentReconcilerFactory.get(executionStateReconciliationHandler);\n+\t\tthis.executionDeploymentReconciler = executionDeploymentReconcilerFactory.create(executionStateReconciliationHandler);\n \n \t\tthis.jobMasterConfiguration = checkNotNull(jobMasterConfiguration);\n \t\tthis.resourceId = checkNotNull(resourceId);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTQ0OQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449591449", "bodyText": "Does it make sense to batch the executions which are unknown? That way we would not have to make a lookup for every unknown Execution.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:45:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+\n+\tprivate final ExecutionDeploymentReconciliationHandler handler;\n+\n+\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\t\tthis.handler = handler;\n+\t}\n+\n+\t@Override\n+\tpublic void reconcileExecutionDeployments(ResourceID taskExecutorHost, ExecutionDeploymentReport executionDeploymentReport, Set<ExecutionAttemptID> expectedDeployedExecutions) {\n+\t\tfinal Set<ExecutionAttemptID> executions = new HashSet<>(expectedDeployedExecutions);\n+\n+\t\texecutionDeploymentReport.getExecutions().forEach(executionAttemptID -> {\n+\t\t\tboolean isTracked = executions.remove(executionAttemptID);\n+\t\t\tif (!isTracked) {\n+\t\t\t\thandler.onUnknownDeployment(executionAttemptID, taskExecutorHost);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDkzMw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449624933", "bodyText": "hmm, yes, but then we maybe should also batch the cancel calls?", "author": "zentol", "createdAt": "2020-07-03T15:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0MTg2Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449641862", "bodyText": "This is an orthogonal discussion. The question here is whether the interface should enforce a single deployment lookup/cancellation call or be flexible enough to support batched calls.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTQ0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nsimilarity index 78%\nrename from flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\nrename to flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nindex a5a9c69e289..7db5987b687 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\n\n@@ -28,11 +28,11 @@ import java.util.Set;\n  * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n  * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n  */\n-public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+public class DefaultExecutionDeploymentReconciler implements ExecutionDeploymentReconciler {\n \n \tprivate final ExecutionDeploymentReconciliationHandler handler;\n \n-\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\tpublic DefaultExecutionDeploymentReconciler(ExecutionDeploymentReconciliationHandler handler) {\n \t\tthis.handler = handler;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTY1Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449591656", "bodyText": "Same here. If handler.onMissingDeployments takes a collection of Execution we only would have to call it once.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:45:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+\n+\tprivate final ExecutionDeploymentReconciliationHandler handler;\n+\n+\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\t\tthis.handler = handler;\n+\t}\n+\n+\t@Override\n+\tpublic void reconcileExecutionDeployments(ResourceID taskExecutorHost, ExecutionDeploymentReport executionDeploymentReport, Set<ExecutionAttemptID> expectedDeployedExecutions) {\n+\t\tfinal Set<ExecutionAttemptID> executions = new HashSet<>(expectedDeployedExecutions);\n+\n+\t\texecutionDeploymentReport.getExecutions().forEach(executionAttemptID -> {\n+\t\t\tboolean isTracked = executions.remove(executionAttemptID);\n+\t\t\tif (!isTracked) {\n+\t\t\t\thandler.onUnknownDeployment(executionAttemptID, taskExecutorHost);\n+\t\t\t}\n+\t\t});\n+\t\texecutions.forEach(handler::onMissingDeployment);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nsimilarity index 78%\nrename from flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\nrename to flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\nindex a5a9c69e289..7db5987b687 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconciler.java\n\n@@ -28,11 +28,11 @@ import java.util.Set;\n  * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n  * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n  */\n-public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+public class DefaultExecutionDeploymentReconciler implements ExecutionDeploymentReconciler {\n \n \tprivate final ExecutionDeploymentReconciliationHandler handler;\n \n-\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\tpublic DefaultExecutionDeploymentReconciler(ExecutionDeploymentReconciliationHandler handler) {\n \t\tthis.handler = handler;\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDE4Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449594186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class TaskExecutorToJobManagerHeartbeatPayload {\n          \n          \n            \n            public class TaskExecutorToJobManagerHeartbeatPayload implements Serializable {\n          \n          \n            \n            \n          \n          \n            \n            private static final long serialVersionUID = ....", "author": "tillrohrmann", "createdAt": "2020-07-03T13:51:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToJobManagerHeartbeatPayload.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import java.util.Collections;\n+\n+/**\n+ * Payload for heartbeats sent from the TaskExecutor to the JobManager.\n+ */\n+public class TaskExecutorToJobManagerHeartbeatPayload {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDMxOQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449594319", "bodyText": "the AkkaRpcService requires that all messages are serializable.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDE4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToJobManagerHeartbeatPayload.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToJobManagerHeartbeatPayload.java\nindex 6d4b0afb78e..dc2bae498e8 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToJobManagerHeartbeatPayload.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToJobManagerHeartbeatPayload.java\n\n@@ -17,12 +17,15 @@\n \n package org.apache.flink.runtime.taskexecutor;\n \n+import java.io.Serializable;\n import java.util.Collections;\n \n /**\n  * Payload for heartbeats sent from the TaskExecutor to the JobManager.\n  */\n-public class TaskExecutorToJobManagerHeartbeatPayload {\n+public class TaskExecutorToJobManagerHeartbeatPayload implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 525146950563585444L;\n \n \tprivate final AccumulatorReport accumulatorReport;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDU1Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449594556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionDeploymentReport {\n          \n          \n            \n            public class ExecutionDeploymentReport implements Serializable {", "author": "tillrohrmann", "createdAt": "2020-07-03T13:52:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/ExecutionDeploymentReport.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A report about the currently deployed executions of a TaskExecutor.\n+ */\n+public class ExecutionDeploymentReport {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/ExecutionDeploymentReport.java b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/ExecutionDeploymentReport.java\nindex c1285457e7f..2fa5c00abfa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/ExecutionDeploymentReport.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/ExecutionDeploymentReport.java\n\n@@ -19,12 +19,16 @@ package org.apache.flink.runtime.taskexecutor;\n \n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n \n+import java.io.Serializable;\n import java.util.Set;\n \n /**\n  * A report about the currently deployed executions of a TaskExecutor.\n  */\n-public class ExecutionDeploymentReport {\n+public class ExecutionDeploymentReport implements Serializable {\n+\n+\tprivate static final long serialVersionUID = -2731996813330298044L;\n+\n \tprivate final Set<ExecutionAttemptID> executions;\n \n \tpublic ExecutionDeploymentReport(Set<ExecutionAttemptID> executions) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5OTc2MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449599761", "bodyText": "It's mainly a personal preference but I think tests are easier to understand if one know what's going on. With runTest a lot of details are being hidden. For example, the below suggestion makes it a bit easier to understand what missingFuture and unknownFuture actually are.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t@Test\n          \n          \n            \n            \tpublic void testMatchingDeployments() throws Exception {\n          \n          \n            \n            \t\trunTest((reconciler, missingFuture, unknownFuture) -> {\n          \n          \n            \n            \t\t\tResourceID resourceId = ResourceID.generate();\n          \n          \n            \n            \t\t\tExecutionAttemptID attemptId = new ExecutionAttemptID();\n          \n          \n            \n            \n          \n          \n            \n            \t\t\treconciler.reconcileExecutionDeployments(\n          \n          \n            \n            \t\t\t\tresourceId,\n          \n          \n            \n            \t\t\t\tnew ExecutionDeploymentReport(Collections.singleton(attemptId)),\n          \n          \n            \n            \t\t\t\tCollections.singleton(attemptId));\n          \n          \n            \n            \n          \n          \n            \n            \t\t\tassertFalse(missingFuture.isDone());\n          \n          \n            \n            \t\t\tassertFalse(unknownFuture.isDone());\n          \n          \n            \n            \t\t});\n          \n          \n            \n            \t}\n          \n          \n            \n                   @Test\n          \n          \n            \n            \tpublic void test() {\n          \n          \n            \n            \t\tfinal TestingExecutionDeploymentReconciliationHandler handler = new TestingExecutionDeploymentReconciliationHandler();\n          \n          \n            \n            \t\tfinal ExecutionDeploymentReconciler reconciler = new ExecutionDeploymentReconcilerImpl(handler);\n          \n          \n            \n            \t\tResourceID resourceId = ResourceID.generate();\n          \n          \n            \n            \t\tExecutionAttemptID attemptId = new ExecutionAttemptID();\n          \n          \n            \n            \n          \n          \n            \n            \t\treconciler.reconcileExecutionDeployments(\n          \n          \n            \n            \t\t\tresourceId,\n          \n          \n            \n            \t\t\tnew ExecutionDeploymentReport(Collections.singleton(attemptId)),\n          \n          \n            \n            \t\t\tCollections.singleton(attemptId));\n          \n          \n            \n            \n          \n          \n            \n            \t\tassertThat(handler.getMissingDeployments(), is(empty()));\n          \n          \n            \n            \t\tassertFalse(handler.getUnknownDeployments(), is(empty()));\n          \n          \n            \n            \t}", "author": "tillrohrmann", "createdAt": "2020-07-03T14:03:50Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImplTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link ExecutionDeploymentReconcilerImpl}.\n+ */\n+public class ExecutionDeploymentReconcilerImplTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testMatchingDeployments() throws Exception {\n+\t\trunTest((reconciler, missingFuture, unknownFuture) -> {\n+\t\t\tResourceID resourceId = ResourceID.generate();\n+\t\t\tExecutionAttemptID attemptId = new ExecutionAttemptID();\n+\n+\t\t\treconciler.reconcileExecutionDeployments(\n+\t\t\t\tresourceId,\n+\t\t\t\tnew ExecutionDeploymentReport(Collections.singleton(attemptId)),\n+\t\t\t\tCollections.singleton(attemptId));\n+\n+\t\t\tassertFalse(missingFuture.isDone());\n+\t\t\tassertFalse(unknownFuture.isDone());\n+\t\t});\n+\t}", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconcilerTest.java\nsimilarity index 81%\nrename from flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImplTest.java\nrename to flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconcilerTest.java\nindex 80a81d619f0..15225a8eab2 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImplTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentReconcilerTest.java\n\n@@ -35,9 +35,9 @@ import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertThat;\n \n /**\n- * Tests for {@link ExecutionDeploymentReconcilerImpl}.\n+ * Tests for {@link DefaultExecutionDeploymentReconciler}.\n  */\n-public class ExecutionDeploymentReconcilerImplTest extends TestLogger {\n+public class DefaultExecutionDeploymentReconcilerTest extends TestLogger {\n \n \t@Test\n \tpublic void testMatchingDeployments() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMTU4NQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449601585", "bodyText": "Should we also assert that the returned Collection is empty?", "author": "tillrohrmann", "createdAt": "2020-07-03T14:07:52Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImplTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.core.IsCollectionContaining.hasItems;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link ExecutionDeploymentTrackerImpl}.\n+ */\n+public class ExecutionDeploymentTrackerImplTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStartTracking() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t}\n+\n+\t@Test\n+\tpublic void testOnCompleteEquivalentToStartTracking() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.onCompletedDeployment(attemptId1, resourceId1);\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t}\n+\n+\t@Test\n+\tpublic void testStopTracking() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\n+\t\ttracker.stopTrackingDeployment(attemptId1);\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testStopTrackingDoesNotAffectOtherIds() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\n+\t\ttracker.stopTrackingDeployment(new ExecutionAttemptID());\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t}\n+\n+\t@Test\n+\tpublic void testStopTrackingUnknownExecutionDoesNotThrowException() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId2 = new ExecutionAttemptID();\n+\t\ttracker.stopTrackingDeployment(attemptId2);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetExecutionsReturnsEmptySetForUnknownHost() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tassertThat(tracker.getExecutions(ResourceID.generate()), notNullValue());", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImplTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTrackerTest.java\nsimilarity index 56%\nrename from flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImplTest.java\nrename to flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTrackerTest.java\nindex 9a96b62db12..17243777f37 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImplTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/DefaultExecutionDeploymentTrackerTest.java\n\n@@ -23,76 +23,66 @@ import org.apache.flink.util.TestLogger;\n \n import org.junit.Test;\n \n+import static org.hamcrest.Matchers.allOf;\n import static org.hamcrest.Matchers.empty;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.core.IsCollectionContaining.hasItems;\n import static org.junit.Assert.assertThat;\n \n /**\n- * Tests for {@link ExecutionDeploymentTrackerImpl}.\n+ * Tests for {@link DefaultExecutionDeploymentTracker}.\n  */\n-public class ExecutionDeploymentTrackerImplTest extends TestLogger {\n+public class DefaultExecutionDeploymentTrackerTest extends TestLogger {\n \n \t@Test\n \tpublic void testStartTracking() {\n-\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\t\tfinal DefaultExecutionDeploymentTracker tracker = new DefaultExecutionDeploymentTracker();\n \n \t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n \t\tfinal ResourceID resourceId1 = ResourceID.generate();\n-\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\t\ttracker.startTrackingDeploymentOf(attemptId1, resourceId1);\n \n-\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n-\t}\n-\n-\t@Test\n-\tpublic void testOnCompleteEquivalentToStartTracking() {\n-\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n-\n-\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n-\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n-\t\ttracker.onCompletedDeployment(attemptId1, resourceId1);\n-\n-\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t\tassertThat(tracker.getExecutionsOn(resourceId1), hasItems(attemptId1));\n \t}\n \n \t@Test\n \tpublic void testStopTracking() {\n-\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\t\tfinal DefaultExecutionDeploymentTracker tracker = new DefaultExecutionDeploymentTracker();\n \n \t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n \t\tfinal ResourceID resourceId1 = ResourceID.generate();\n-\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\t\ttracker.startTrackingDeploymentOf(attemptId1, resourceId1);\n \n-\t\ttracker.stopTrackingDeployment(attemptId1);\n+\t\ttracker.stopTrackingDeploymentOf(attemptId1);\n \n-\t\tassertThat(tracker.getExecutions(resourceId1), empty());\n+\t\tassertThat(tracker.getExecutionsOn(resourceId1), empty());\n \t}\n \n \t@Test\n \tpublic void testStopTrackingDoesNotAffectOtherIds() {\n-\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\t\tfinal DefaultExecutionDeploymentTracker tracker = new DefaultExecutionDeploymentTracker();\n \n \t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n \t\tfinal ResourceID resourceId1 = ResourceID.generate();\n-\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\t\ttracker.startTrackingDeploymentOf(attemptId1, resourceId1);\n \n-\t\ttracker.stopTrackingDeployment(new ExecutionAttemptID());\n+\t\ttracker.stopTrackingDeploymentOf(new ExecutionAttemptID());\n \n-\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t\tassertThat(tracker.getExecutionsOn(resourceId1), hasItems(attemptId1));\n \t}\n \n \t@Test\n \tpublic void testStopTrackingUnknownExecutionDoesNotThrowException() {\n-\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\t\tfinal DefaultExecutionDeploymentTracker tracker = new DefaultExecutionDeploymentTracker();\n \n \t\tfinal ExecutionAttemptID attemptId2 = new ExecutionAttemptID();\n-\t\ttracker.stopTrackingDeployment(attemptId2);\n+\t\ttracker.stopTrackingDeploymentOf(attemptId2);\n \t}\n \n \t@Test\n \tpublic void testGetExecutionsReturnsEmptySetForUnknownHost() {\n-\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\t\tfinal DefaultExecutionDeploymentTracker tracker = new DefaultExecutionDeploymentTracker();\n \n-\t\tassertThat(tracker.getExecutions(ResourceID.generate()), notNullValue());\n+\t\tassertThat(tracker.getExecutionsOn(ResourceID.generate()), allOf(notNullValue(), empty()));\n \t}\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMjIwNQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449602205", "bodyText": "You could also use TestingRpcServiceResource here.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:09:16Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.jobgraph.utils.JobGraphTestUtils;\n+import org.apache.flink.runtime.jobmanager.OnCompletionActions;\n+import org.apache.flink.runtime.jobmaster.utils.JobMasterBuilder;\n+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.AccumulatorReport;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorToJobManagerHeartbeatPayload;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link JobMaster}.\n+ */\n+public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time testingTimeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpcService;", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\nindex 3fa82d69cce..04d5ce5b3d8 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n\n@@ -21,6 +21,7 @@ import org.apache.flink.api.common.JobStatus;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMzc4Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449603782", "bodyText": "One could make AllocationIdsResourceManagerGateway a top level class.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:12:35Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.jobgraph.utils.JobGraphTestUtils;\n+import org.apache.flink.runtime.jobmanager.OnCompletionActions;\n+import org.apache.flink.runtime.jobmaster.utils.JobMasterBuilder;\n+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.AccumulatorReport;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorToJobManagerHeartbeatPayload;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link JobMaster}.\n+ */\n+public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time testingTimeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpcService;\n+\n+\tprivate final HeartbeatServices heartbeatServices = new HeartbeatServices(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final TestingLeaderElectionService resourceManagerLeaderElectionService = new TestingLeaderElectionService();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setResourceManagerLeaderElectionService(resourceManagerLeaderElectionService);\n+\t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpcService.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpcService = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpcService.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testExecutionDeploymentReconciliation() throws Exception {\n+\t\tJobMasterBuilder.TestingOnCompletionActions onCompletionActions = new JobMasterBuilder.TestingOnCompletionActions();\n+\t\tJobMaster jobMaster = createAndStartJobMaster(onCompletionActions);\n+\t\tJobMasterGateway jobMasterGateway = jobMaster.getSelfGateway(JobMasterGateway.class);\n+\t\trpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);\n+\n+\t\tfinal JobMasterPartitionReleaseTest.AllocationIdsResourceManagerGateway resourceManagerGateway = createResourceManagerGateway();", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\nindex 3fa82d69cce..04d5ce5b3d8 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n\n@@ -21,6 +21,7 @@ import org.apache.flink.api.common.JobStatus;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNzAzMA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449607030", "bodyText": "I think this test is unstable because the completion of this future does not guarantee that we are tracking the respective task. If you add a Thread.sleep() in line 161, then you can reproduce it. The reason is that we use a whenCompleteAsync when deploying an Execution.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:20:07Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.jobgraph.utils.JobGraphTestUtils;\n+import org.apache.flink.runtime.jobmanager.OnCompletionActions;\n+import org.apache.flink.runtime.jobmaster.utils.JobMasterBuilder;\n+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.AccumulatorReport;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorToJobManagerHeartbeatPayload;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link JobMaster}.\n+ */\n+public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time testingTimeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpcService;\n+\n+\tprivate final HeartbeatServices heartbeatServices = new HeartbeatServices(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final TestingLeaderElectionService resourceManagerLeaderElectionService = new TestingLeaderElectionService();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setResourceManagerLeaderElectionService(resourceManagerLeaderElectionService);\n+\t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpcService.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpcService = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpcService.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testExecutionDeploymentReconciliation() throws Exception {\n+\t\tJobMasterBuilder.TestingOnCompletionActions onCompletionActions = new JobMasterBuilder.TestingOnCompletionActions();\n+\t\tJobMaster jobMaster = createAndStartJobMaster(onCompletionActions);\n+\t\tJobMasterGateway jobMasterGateway = jobMaster.getSelfGateway(JobMasterGateway.class);\n+\t\trpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);\n+\n+\t\tfinal JobMasterPartitionReleaseTest.AllocationIdsResourceManagerGateway resourceManagerGateway = createResourceManagerGateway();\n+\n+\t\tfinal CompletableFuture<Void> taskSubmissionFuture = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<ExecutionAttemptID> taskCancellationFuture = new CompletableFuture<>();\n+\t\tTaskExecutorGateway taskExecutorGateway = createTaskExecutorGateway(taskSubmissionFuture, taskCancellationFuture);\n+\t\tLocalUnresolvedTaskManagerLocation localUnresolvedTaskManagerLocation = new LocalUnresolvedTaskManagerLocation();\n+\n+\t\tregisterTaskExecutorAndOfferSlots(resourceManagerGateway, jobMasterGateway, taskExecutorGateway, localUnresolvedTaskManagerLocation);\n+\n+\t\ttaskSubmissionFuture.get();", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\nindex 3fa82d69cce..04d5ce5b3d8 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n\n@@ -21,6 +21,7 @@ import org.apache.flink.api.common.JobStatus;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNzUzNw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449607537", "bodyText": "Maybe make this a top level class.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:21:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterPartitionReleaseTest.java", "diffHunk": "@@ -162,10 +162,10 @@ private void testPartitionReleaseOrPromotionOnJobTermination(Function<TestSetup,\n \t\t}\n \t}\n \n-\tprivate static final class AllocationIdsResourceManagerGateway extends TestingResourceManagerGateway {\n+\tpublic static final class AllocationIdsResourceManagerGateway extends TestingResourceManagerGateway {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterPartitionReleaseTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterPartitionReleaseTest.java\nindex 2df4cbc3ecb..aa02627c524 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterPartitionReleaseTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterPartitionReleaseTest.java\n\n@@ -162,26 +159,6 @@ public class JobMasterPartitionReleaseTest extends TestLogger {\n \t\t}\n \t}\n \n-\tpublic static final class AllocationIdsResourceManagerGateway extends TestingResourceManagerGateway {\n-\t\tprivate final BlockingQueue<AllocationID> allocationIds;\n-\n-\t\tpublic AllocationIdsResourceManagerGateway() {\n-\t\t\tthis.allocationIds = new ArrayBlockingQueue<>(10);\n-\t\t\tsetRequestSlotConsumer(\n-\t\t\t\tslotRequest -> allocationIds.offer(slotRequest.getAllocationId())\n-\t\t\t);\n-\t\t}\n-\n-\t\tAllocationID takeAllocationId() {\n-\t\t\ttry {\n-\t\t\t\treturn allocationIds.take();\n-\t\t\t} catch (InterruptedException e) {\n-\t\t\t\tExceptionUtils.rethrow(e);\n-\t\t\t\treturn null;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \tprivate static class TestSetup implements AutoCloseable {\n \n \t\tprivate final TemporaryFolder temporaryFolder = new TemporaryFolder();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNzkxOQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449607919", "bodyText": "Maybe use TestingRpcServiceResource.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:22:17Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\nindex d0162d2b715..b877a23e55a 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n\n@@ -17,7 +17,6 @@\n \n package org.apache.flink.runtime.taskexecutor;\n \n-import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.JobID;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.Configuration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwOTM1OQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449609359", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);\n          \n          \n            \n            \t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsQueue = new ArrayBlockingQueue<>(3);", "author": "tillrohrmann", "createdAt": "2020-07-03T14:25:36Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpc.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpc = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpc.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\nindex d0162d2b715..b877a23e55a 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n\n@@ -17,7 +17,6 @@\n \n package org.apache.flink.runtime.taskexecutor;\n \n-import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.JobID;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.Configuration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxMDczNA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449610734", "bodyText": "Can we use TaskDeploymentDescriptorBuilder here?", "author": "tillrohrmann", "createdAt": "2020-07-03T14:28:44Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpc.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpc = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpc.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);\n+\t\tfinal CompletableFuture<Void> taskFinishedFuture = new CompletableFuture<>();\n+\t\tfinal ResourceID jobManagerResourceId = ResourceID.generate();\n+\t\tfinal TestingJobMasterGateway jobMasterGateway = setupJobManagerGateway(slotOfferLatch, deployedExecutionsFuture, taskFinishedFuture, jobManagerResourceId);\n+\n+\t\tfinal CompletableFuture<SlotReport> initialSlotReportFuture = new CompletableFuture<>();\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = setupResourceManagerGateway(initialSlotReportFuture);\n+\n+\t\tfinal TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()\n+\t\t\t.setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1, timeout))\n+\t\t\t.setShuffleEnvironment(new NettyShuffleEnvironmentBuilder().build())\n+\t\t\t.build();\n+\n+\t\tfinal TestingTaskExecutor taskExecutor = createTestingTaskExecutor(taskManagerServices);\n+\n+\t\ttry {\n+\t\t\ttaskExecutor.start();\n+\t\t\ttaskExecutor.waitUntilStarted();\n+\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);\n+\n+\t\t\tfinal TaskDeploymentDescriptor taskDeploymentDescriptor = createTaskDeploymentDescriptor(jobId);\n+\n+\t\t\tconnectComponentsAndRequestSlot(jobMasterGateway, testingResourceManagerGateway, taskExecutorGateway, taskManagerServices.getJobLeaderService(), initialSlotReportFuture, taskDeploymentDescriptor.getAllocationId());\n+\n+\t\t\tTestingInvokable.sync = new BlockerSync();\n+\n+\t\t\t// This ensures TM has been successfully registered to JM.\n+\t\t\tslotOfferLatch.await();\n+\n+\t\t\tAllocatedSlotReport slotAllocationReport = new AllocatedSlotReport(jobId, Collections.singleton(new AllocatedSlotInfo(0, taskDeploymentDescriptor.getAllocationId())));\n+\n+\t\t\t// nothing as deployed, so the deployment report should be empty\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\n+\t\t\ttaskExecutorGateway.submitTask(taskDeploymentDescriptor, jobMasterGateway.getFencingToken(), timeout)\n+\t\t\t\t.get();\n+\n+\t\t\tTestingInvokable.sync.awaitBlocker();\n+\n+\t\t\t// task is deployed, so the deployment report should contain it\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasItem(taskDeploymentDescriptor.getExecutionAttemptId()));\n+\n+\t\t\tTestingInvokable.sync.releaseBlocker();\n+\n+\t\t\t// task is finished ans was cleaned up, so the deployment report should be empty\n+\t\t\ttaskFinishedFuture.get();\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\t\t} finally {\n+\t\t\tRpcUtils.terminateRpcEndpoint(taskExecutor, timeout);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Test invokable which completes the given future when executed.\n+\t */\n+\tpublic static class TestingInvokable extends AbstractInvokable {\n+\n+\t\tstatic BlockerSync sync;\n+\n+\t\tpublic TestingInvokable(Environment environment) {\n+\t\t\tsuper(environment);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void invoke() throws Exception {\n+\t\t\tsync.block();\n+\t\t}\n+\t}\n+\n+\tprivate TestingTaskExecutor createTestingTaskExecutor(TaskManagerServices taskManagerServices) throws IOException {\n+\t\tfinal Configuration configuration = new Configuration();\n+\t\treturn new TestingTaskExecutor(\n+\t\t\trpc,\n+\t\t\tTaskManagerConfiguration.fromConfiguration(\n+\t\t\t\tconfiguration,\n+\t\t\t\tTaskExecutorResourceUtils.resourceSpecFromConfigForLocalExecution(configuration),\n+\t\t\t\tInetAddress.getLoopbackAddress().getHostAddress()),\n+\t\t\thaServices,\n+\t\t\ttaskManagerServices,\n+\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n+\t\t\tnew HeartbeatServices(1_000L, 30_000L),\n+\t\t\tUnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),\n+\t\t\tnull,\n+\t\t\tnew BlobCacheService(\n+\t\t\t\tconfiguration,\n+\t\t\t\tnew VoidBlobStore(),\n+\t\t\t\tnull),\n+\t\t\ttestingFatalErrorHandlerResource.getFatalErrorHandler(),\n+\t\t\tnew TestingTaskExecutorPartitionTracker(),\n+\t\t\tTaskManagerRunner.createBackPressureSampleService(configuration, rpc.getScheduledExecutor()));\n+\t}\n+\n+\tprivate static TaskDeploymentDescriptor createTaskDeploymentDescriptor(JobID jobId) throws IOException {\n+\t\tfinal ResultPartitionDeploymentDescriptor taskResultPartitionDescriptor =\n+\t\t\tPartitionTestUtils.createPartitionDeploymentDescriptor(ResultPartitionType.BLOCKING);\n+\n+\t\treturn TaskExecutorSubmissionTest.createTaskDeploymentDescriptor(\n+\t\t\tjobId,\n+\t\t\t\"job\",\n+\t\t\ttaskResultPartitionDescriptor.getShuffleDescriptor().getResultPartitionID().getProducerId(),\n+\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n+\t\t\t\"Sender\",\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\tnew Configuration(),\n+\t\t\tnew Configuration(),\n+\t\t\tTestingInvokable.class.getName(),\n+\t\t\tCollections.singletonList(taskResultPartitionDescriptor),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\t0);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\nindex d0162d2b715..b877a23e55a 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n\n@@ -17,7 +17,6 @@\n \n package org.apache.flink.runtime.taskexecutor;\n \n-import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.JobID;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.Configuration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxMTgwMw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449611803", "bodyText": "If you want to wait that the TaskExecutor has established the connection to the ResourceManager, then one can wait for the ResourceManagerGateway.sendSlotReport call.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:31:19Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpc.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpc = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpc.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);\n+\t\tfinal CompletableFuture<Void> taskFinishedFuture = new CompletableFuture<>();\n+\t\tfinal ResourceID jobManagerResourceId = ResourceID.generate();\n+\t\tfinal TestingJobMasterGateway jobMasterGateway = setupJobManagerGateway(slotOfferLatch, deployedExecutionsFuture, taskFinishedFuture, jobManagerResourceId);\n+\n+\t\tfinal CompletableFuture<SlotReport> initialSlotReportFuture = new CompletableFuture<>();\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = setupResourceManagerGateway(initialSlotReportFuture);\n+\n+\t\tfinal TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()\n+\t\t\t.setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1, timeout))\n+\t\t\t.setShuffleEnvironment(new NettyShuffleEnvironmentBuilder().build())\n+\t\t\t.build();\n+\n+\t\tfinal TestingTaskExecutor taskExecutor = createTestingTaskExecutor(taskManagerServices);\n+\n+\t\ttry {\n+\t\t\ttaskExecutor.start();\n+\t\t\ttaskExecutor.waitUntilStarted();\n+\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);\n+\n+\t\t\tfinal TaskDeploymentDescriptor taskDeploymentDescriptor = createTaskDeploymentDescriptor(jobId);\n+\n+\t\t\tconnectComponentsAndRequestSlot(jobMasterGateway, testingResourceManagerGateway, taskExecutorGateway, taskManagerServices.getJobLeaderService(), initialSlotReportFuture, taskDeploymentDescriptor.getAllocationId());\n+\n+\t\t\tTestingInvokable.sync = new BlockerSync();\n+\n+\t\t\t// This ensures TM has been successfully registered to JM.\n+\t\t\tslotOfferLatch.await();\n+\n+\t\t\tAllocatedSlotReport slotAllocationReport = new AllocatedSlotReport(jobId, Collections.singleton(new AllocatedSlotInfo(0, taskDeploymentDescriptor.getAllocationId())));\n+\n+\t\t\t// nothing as deployed, so the deployment report should be empty\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\n+\t\t\ttaskExecutorGateway.submitTask(taskDeploymentDescriptor, jobMasterGateway.getFencingToken(), timeout)\n+\t\t\t\t.get();\n+\n+\t\t\tTestingInvokable.sync.awaitBlocker();\n+\n+\t\t\t// task is deployed, so the deployment report should contain it\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasItem(taskDeploymentDescriptor.getExecutionAttemptId()));\n+\n+\t\t\tTestingInvokable.sync.releaseBlocker();\n+\n+\t\t\t// task is finished ans was cleaned up, so the deployment report should be empty\n+\t\t\ttaskFinishedFuture.get();\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\t\t} finally {\n+\t\t\tRpcUtils.terminateRpcEndpoint(taskExecutor, timeout);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Test invokable which completes the given future when executed.\n+\t */\n+\tpublic static class TestingInvokable extends AbstractInvokable {\n+\n+\t\tstatic BlockerSync sync;\n+\n+\t\tpublic TestingInvokable(Environment environment) {\n+\t\t\tsuper(environment);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void invoke() throws Exception {\n+\t\t\tsync.block();\n+\t\t}\n+\t}\n+\n+\tprivate TestingTaskExecutor createTestingTaskExecutor(TaskManagerServices taskManagerServices) throws IOException {\n+\t\tfinal Configuration configuration = new Configuration();\n+\t\treturn new TestingTaskExecutor(\n+\t\t\trpc,\n+\t\t\tTaskManagerConfiguration.fromConfiguration(\n+\t\t\t\tconfiguration,\n+\t\t\t\tTaskExecutorResourceUtils.resourceSpecFromConfigForLocalExecution(configuration),\n+\t\t\t\tInetAddress.getLoopbackAddress().getHostAddress()),\n+\t\t\thaServices,\n+\t\t\ttaskManagerServices,\n+\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n+\t\t\tnew HeartbeatServices(1_000L, 30_000L),\n+\t\t\tUnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),\n+\t\t\tnull,\n+\t\t\tnew BlobCacheService(\n+\t\t\t\tconfiguration,\n+\t\t\t\tnew VoidBlobStore(),\n+\t\t\t\tnull),\n+\t\t\ttestingFatalErrorHandlerResource.getFatalErrorHandler(),\n+\t\t\tnew TestingTaskExecutorPartitionTracker(),\n+\t\t\tTaskManagerRunner.createBackPressureSampleService(configuration, rpc.getScheduledExecutor()));\n+\t}\n+\n+\tprivate static TaskDeploymentDescriptor createTaskDeploymentDescriptor(JobID jobId) throws IOException {\n+\t\tfinal ResultPartitionDeploymentDescriptor taskResultPartitionDescriptor =\n+\t\t\tPartitionTestUtils.createPartitionDeploymentDescriptor(ResultPartitionType.BLOCKING);\n+\n+\t\treturn TaskExecutorSubmissionTest.createTaskDeploymentDescriptor(\n+\t\t\tjobId,\n+\t\t\t\"job\",\n+\t\t\ttaskResultPartitionDescriptor.getShuffleDescriptor().getResultPartitionID().getProducerId(),\n+\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n+\t\t\t\"Sender\",\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\tnew Configuration(),\n+\t\t\tnew Configuration(),\n+\t\t\tTestingInvokable.class.getName(),\n+\t\t\tCollections.singletonList(taskResultPartitionDescriptor),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\t0);\n+\t}\n+\n+\tprivate static TestingJobMasterGateway setupJobManagerGateway(OneShotLatch slotOfferLatch, BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture, CompletableFuture<Void> taskFinishedFuture, ResourceID jobManagerResourceId) {\n+\t\treturn new TestingJobMasterGatewayBuilder()\n+\t\t\t.setRegisterTaskManagerFunction((s, location) -> CompletableFuture.completedFuture(new JMTMRegistrationSuccess(jobManagerResourceId)))\n+\t\t\t.setOfferSlotsFunction((resourceID, slotOffers) -> {\n+\t\t\t\tslotOfferLatch.trigger();\n+\t\t\t\treturn CompletableFuture.completedFuture(slotOffers);\n+\t\t\t})\n+\t\t\t.setTaskManagerHeartbeatConsumer((resourceID, taskExecutorToJobManagerHeartbeatPayload) -> {\n+\t\t\t\tExecutionDeploymentReport executionDeploymentReport = taskExecutorToJobManagerHeartbeatPayload.getExecutionDeploymentReport();\n+\t\t\t\tdeployedExecutionsFuture.add(executionDeploymentReport.getExecutions());\n+\t\t\t})\n+\t\t\t.setUpdateTaskExecutionStateFunction(taskExecutionState -> {\n+\t\t\t\tif (taskExecutionState.getExecutionState() == ExecutionState.FINISHED) {\n+\t\t\t\t\ttaskFinishedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.build();\n+\t}\n+\n+\tprivate static TestingResourceManagerGateway setupResourceManagerGateway(CompletableFuture<SlotReport> initialSlotReportFuture) {\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = new TestingResourceManagerGateway();\n+\t\ttestingResourceManagerGateway.setSendSlotReportFunction(resourceIDInstanceIDSlotReportTuple3 -> {\n+\t\t\tinitialSlotReportFuture.complete(resourceIDInstanceIDSlotReportTuple3.f2);\n+\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t});\n+\t\ttestingResourceManagerGateway.setRegisterTaskExecutorFunction(input -> CompletableFuture.completedFuture(\n+\t\t\tnew TaskExecutorRegistrationSuccess(\n+\t\t\t\tnew InstanceID(),\n+\t\t\t\ttestingResourceManagerGateway.getOwnResourceId(),\n+\t\t\t\tnew ClusterInformation(\"blobServerHost\", 55555))));\n+\t\treturn testingResourceManagerGateway;\n+\t}\n+\n+\tprivate void connectComponentsAndRequestSlot(\n+\t\t\tJobMasterGateway jobMasterGateway,\n+\t\t\tResourceManagerGateway resourceManagerGateway,\n+\t\t\tTaskExecutorGateway taskExecutorGateway,\n+\t\t\tJobLeaderService jobLeaderService,\n+\t\t\tCompletableFuture<SlotReport> initialSlotReportFuture,\n+\t\t\tAllocationID allocationId) throws Exception {\n+\t\tfinal String jobMasterAddress = \"jm\";\n+\t\trpc.registerGateway(jobMasterAddress, jobMasterGateway);\n+\t\trpc.registerGateway(resourceManagerGateway.getAddress(), resourceManagerGateway);\n+\n+\t\t// inform the task manager about the job leader\n+\t\tjobLeaderService.addJob(jobId, jobMasterAddress);\n+\t\tjobManagerLeaderRetriever.notifyListener(jobMasterAddress, UUID.randomUUID());\n+\t\tresourceManagerLeaderRetriever.notifyListener(resourceManagerGateway.getAddress(), resourceManagerGateway.getFencingToken().toUUID());\n+\n+\t\tfinal Optional<SlotStatus> slotStatusOptional = StreamSupport.stream(initialSlotReportFuture.get().spliterator(), false)\n+\t\t\t.findAny();\n+\n+\t\tassertTrue(slotStatusOptional.isPresent());\n+\n+\t\twhile (true) {\n+\t\t\ttry {\n+\t\t\t\ttaskExecutorGateway.requestSlot(\n+\t\t\t\t\tslotStatusOptional.get().getSlotID(),\n+\t\t\t\t\tjobId,\n+\t\t\t\t\tallocationId,\n+\t\t\t\t\tResourceProfile.ZERO,\n+\t\t\t\t\tjobMasterAddress,\n+\t\t\t\t\tresourceManagerGateway.getFencingToken(),\n+\t\t\t\t\ttimeout\n+\t\t\t\t).get();\n+\t\t\t\tbreak;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// the proper establishment of the RM connection is tracked\n+\t\t\t\t// asynchronously, so we have to poll here until it went through\n+\t\t\t\t// until then, slot requests will fail with an exception\n+\t\t\t\tThread.sleep(50);\n+\t\t\t}\n+\t\t}", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\nindex d0162d2b715..b877a23e55a 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n\n@@ -17,7 +17,6 @@\n \n package org.apache.flink.runtime.taskexecutor;\n \n-import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.JobID;\n import org.apache.flink.api.common.time.Time;\n import org.apache.flink.configuration.Configuration;\n"}}, {"oid": "55e325143fefcfaf116109ee14e8c2ef2c551b91", "url": "https://github.com/apache/flink/commit/55e325143fefcfaf116109ee14e8c2ef2c551b91", "message": "Move state update listeners calls into EG", "committedDate": "2020-07-03T14:43:56Z", "type": "commit"}, {"oid": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "url": "https://github.com/apache/flink/commit/0260110c2b7464c4daeab3e4803f4a67540f25c1", "message": "address comments", "committedDate": "2020-07-03T15:38:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0Mjc4NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449642784", "bodyText": "I think the resource will take care of shutting the service down.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:52:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -86,38 +88,29 @@ public void setup() {\n \t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n \t}\n \n-\t@After\n-\tpublic void shutdown() {\n-\t\trpcService.clearGateways();\n-\t}\n-\n-\t@BeforeClass\n-\tpublic static void setupClass() {\n-\t\trpcService = new TestingRpcService();\n-\t}\n-\n \t@AfterClass\n \tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n-\t\trpcService.stopService().get();\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().stopService().get();", "originalCommit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2209c8b21fb3120252b58e35debb9f715b3c237", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\nindex 04d5ce5b3d8..36f07d90694 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java\n\n@@ -88,11 +87,6 @@ public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n \t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n \t}\n \n-\t@AfterClass\n-\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n-\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().stopService().get();\n-\t}\n-\n \t@Test\n \tpublic void testExecutionDeploymentReconciliation() throws Exception {\n \t\tJobMasterBuilder.TestingOnCompletionActions onCompletionActions = new JobMasterBuilder.TestingOnCompletionActions();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NDg3Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449644873", "bodyText": "Why exactly do we need this while loop here? I think by waiting on initialSlotReportFuture it is not needed.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:59:08Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptorBuilder;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcServiceResource;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@ClassRule\n+\tpublic static final TestingRpcServiceResource RPC_SERVICE_RESOURCE = new TestingRpcServiceResource();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().clearGateways();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsQueue = new ArrayBlockingQueue<>(3);\n+\t\tfinal CompletableFuture<Void> taskFinishedFuture = new CompletableFuture<>();\n+\t\tfinal ResourceID jobManagerResourceId = ResourceID.generate();\n+\t\tfinal TestingJobMasterGateway jobMasterGateway = setupJobManagerGateway(slotOfferLatch, deployedExecutionsQueue, taskFinishedFuture, jobManagerResourceId);\n+\n+\t\tfinal CompletableFuture<SlotReport> initialSlotReportFuture = new CompletableFuture<>();\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = setupResourceManagerGateway(initialSlotReportFuture);\n+\n+\t\tfinal TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()\n+\t\t\t.setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1, timeout))\n+\t\t\t.setShuffleEnvironment(new NettyShuffleEnvironmentBuilder().build())\n+\t\t\t.build();\n+\n+\t\tfinal TestingTaskExecutor taskExecutor = createTestingTaskExecutor(taskManagerServices);\n+\n+\t\ttry {\n+\t\t\ttaskExecutor.start();\n+\t\t\ttaskExecutor.waitUntilStarted();\n+\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);\n+\n+\t\t\tfinal TaskDeploymentDescriptor taskDeploymentDescriptor = createTaskDeploymentDescriptor(jobId);\n+\n+\t\t\tconnectComponentsAndRequestSlot(jobMasterGateway, testingResourceManagerGateway, taskExecutorGateway, taskManagerServices.getJobLeaderService(), initialSlotReportFuture, taskDeploymentDescriptor.getAllocationId());\n+\n+\t\t\tTestingInvokable.sync = new BlockerSync();\n+\n+\t\t\t// This ensures TM has been successfully registered to JM.\n+\t\t\tslotOfferLatch.await();\n+\n+\t\t\tAllocatedSlotReport slotAllocationReport = new AllocatedSlotReport(jobId, Collections.singleton(new AllocatedSlotInfo(0, taskDeploymentDescriptor.getAllocationId())));\n+\n+\t\t\t// nothing as deployed, so the deployment report should be empty\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsQueue.take(), hasSize(0));\n+\n+\t\t\ttaskExecutorGateway.submitTask(taskDeploymentDescriptor, jobMasterGateway.getFencingToken(), timeout)\n+\t\t\t\t.get();\n+\n+\t\t\tTestingInvokable.sync.awaitBlocker();\n+\n+\t\t\t// task is deployed, so the deployment report should contain it\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsQueue.take(), hasItem(taskDeploymentDescriptor.getExecutionAttemptId()));\n+\n+\t\t\tTestingInvokable.sync.releaseBlocker();\n+\n+\t\t\t// task is finished ans was cleaned up, so the deployment report should be empty\n+\t\t\ttaskFinishedFuture.get();\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsQueue.take(), hasSize(0));\n+\t\t} finally {\n+\t\t\tRpcUtils.terminateRpcEndpoint(taskExecutor, timeout);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Test invokable which completes the given future when executed.\n+\t */\n+\tpublic static class TestingInvokable extends AbstractInvokable {\n+\n+\t\tstatic BlockerSync sync;\n+\n+\t\tpublic TestingInvokable(Environment environment) {\n+\t\t\tsuper(environment);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void invoke() throws Exception {\n+\t\t\tsync.block();\n+\t\t}\n+\t}\n+\n+\tprivate TestingTaskExecutor createTestingTaskExecutor(TaskManagerServices taskManagerServices) throws IOException {\n+\t\tfinal Configuration configuration = new Configuration();\n+\t\treturn new TestingTaskExecutor(\n+\t\t\tRPC_SERVICE_RESOURCE.getTestingRpcService(),\n+\t\t\tTaskManagerConfiguration.fromConfiguration(\n+\t\t\t\tconfiguration,\n+\t\t\t\tTaskExecutorResourceUtils.resourceSpecFromConfigForLocalExecution(configuration),\n+\t\t\t\tInetAddress.getLoopbackAddress().getHostAddress()),\n+\t\t\thaServices,\n+\t\t\ttaskManagerServices,\n+\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n+\t\t\tnew HeartbeatServices(1_000L, 30_000L),\n+\t\t\tUnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),\n+\t\t\tnull,\n+\t\t\tnew BlobCacheService(\n+\t\t\t\tconfiguration,\n+\t\t\t\tnew VoidBlobStore(),\n+\t\t\t\tnull),\n+\t\t\ttestingFatalErrorHandlerResource.getFatalErrorHandler(),\n+\t\t\tnew TestingTaskExecutorPartitionTracker(),\n+\t\t\tTaskManagerRunner.createBackPressureSampleService(configuration, RPC_SERVICE_RESOURCE.getTestingRpcService().getScheduledExecutor()));\n+\t}\n+\n+\tprivate static TaskDeploymentDescriptor createTaskDeploymentDescriptor(JobID jobId) throws IOException {\n+\t\treturn TaskDeploymentDescriptorBuilder.newBuilder(jobId, TestingInvokable.class).build();\n+\t}\n+\n+\tprivate static TestingJobMasterGateway setupJobManagerGateway(OneShotLatch slotOfferLatch, BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture, CompletableFuture<Void> taskFinishedFuture, ResourceID jobManagerResourceId) {\n+\t\treturn new TestingJobMasterGatewayBuilder()\n+\t\t\t.setRegisterTaskManagerFunction((s, location) -> CompletableFuture.completedFuture(new JMTMRegistrationSuccess(jobManagerResourceId)))\n+\t\t\t.setOfferSlotsFunction((resourceID, slotOffers) -> {\n+\t\t\t\tslotOfferLatch.trigger();\n+\t\t\t\treturn CompletableFuture.completedFuture(slotOffers);\n+\t\t\t})\n+\t\t\t.setTaskManagerHeartbeatConsumer((resourceID, taskExecutorToJobManagerHeartbeatPayload) -> {\n+\t\t\t\tExecutionDeploymentReport executionDeploymentReport = taskExecutorToJobManagerHeartbeatPayload.getExecutionDeploymentReport();\n+\t\t\t\tdeployedExecutionsFuture.add(executionDeploymentReport.getExecutions());\n+\t\t\t})\n+\t\t\t.setUpdateTaskExecutionStateFunction(taskExecutionState -> {\n+\t\t\t\tif (taskExecutionState.getExecutionState() == ExecutionState.FINISHED) {\n+\t\t\t\t\ttaskFinishedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.build();\n+\t}\n+\n+\tprivate static TestingResourceManagerGateway setupResourceManagerGateway(CompletableFuture<SlotReport> initialSlotReportFuture) {\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = new TestingResourceManagerGateway();\n+\t\ttestingResourceManagerGateway.setSendSlotReportFunction(resourceIDInstanceIDSlotReportTuple3 -> {\n+\t\t\tinitialSlotReportFuture.complete(resourceIDInstanceIDSlotReportTuple3.f2);\n+\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t});\n+\t\ttestingResourceManagerGateway.setRegisterTaskExecutorFunction(input -> CompletableFuture.completedFuture(\n+\t\t\tnew TaskExecutorRegistrationSuccess(\n+\t\t\t\tnew InstanceID(),\n+\t\t\t\ttestingResourceManagerGateway.getOwnResourceId(),\n+\t\t\t\tnew ClusterInformation(\"blobServerHost\", 55555))));\n+\t\treturn testingResourceManagerGateway;\n+\t}\n+\n+\tprivate void connectComponentsAndRequestSlot(\n+\t\t\tJobMasterGateway jobMasterGateway,\n+\t\t\tResourceManagerGateway resourceManagerGateway,\n+\t\t\tTaskExecutorGateway taskExecutorGateway,\n+\t\t\tJobLeaderService jobLeaderService,\n+\t\t\tCompletableFuture<SlotReport> initialSlotReportFuture,\n+\t\t\tAllocationID allocationId) throws Exception {\n+\t\tfinal String jobMasterAddress = \"jm\";\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().registerGateway(jobMasterAddress, jobMasterGateway);\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().registerGateway(resourceManagerGateway.getAddress(), resourceManagerGateway);\n+\n+\t\t// inform the task manager about the job leader\n+\t\tjobLeaderService.addJob(jobId, jobMasterAddress);\n+\t\tjobManagerLeaderRetriever.notifyListener(jobMasterAddress, UUID.randomUUID());\n+\t\tresourceManagerLeaderRetriever.notifyListener(resourceManagerGateway.getAddress(), resourceManagerGateway.getFencingToken().toUUID());\n+\n+\t\tfinal Optional<SlotStatus> slotStatusOptional = StreamSupport.stream(initialSlotReportFuture.get().spliterator(), false)\n+\t\t\t.findAny();\n+\n+\t\tassertTrue(slotStatusOptional.isPresent());\n+\n+\t\twhile (true) {", "originalCommit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f2209c8b21fb3120252b58e35debb9f715b3c237", "chunk": "diff --git a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\nindex b877a23e55a..6ce1b675457 100644\n--- a/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n+++ b/flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java\n\n@@ -266,24 +266,14 @@ public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogge\n \n \t\tassertTrue(slotStatusOptional.isPresent());\n \n-\t\twhile (true) {\n-\t\t\ttry {\n-\t\t\t\ttaskExecutorGateway.requestSlot(\n-\t\t\t\t\tslotStatusOptional.get().getSlotID(),\n-\t\t\t\t\tjobId,\n-\t\t\t\t\tallocationId,\n-\t\t\t\t\tResourceProfile.ZERO,\n-\t\t\t\t\tjobMasterAddress,\n-\t\t\t\t\tresourceManagerGateway.getFencingToken(),\n-\t\t\t\t\ttimeout\n-\t\t\t\t).get();\n-\t\t\t\tbreak;\n-\t\t\t} catch (Exception e) {\n-\t\t\t\t// the proper establishment of the RM connection is tracked\n-\t\t\t\t// asynchronously, so we have to poll here until it went through\n-\t\t\t\t// until then, slot requests will fail with an exception\n-\t\t\t\tThread.sleep(50);\n-\t\t\t}\n-\t\t}\n+\t\ttaskExecutorGateway.requestSlot(\n+\t\t\tslotStatusOptional.get().getSlotID(),\n+\t\t\tjobId,\n+\t\t\tallocationId,\n+\t\t\tResourceProfile.ZERO,\n+\t\t\tjobMasterAddress,\n+\t\t\tresourceManagerGateway.getFencingToken(),\n+\t\t\ttimeout\n+\t\t).get();\n \t}\n }\n"}}, {"oid": "f2209c8b21fb3120252b58e35debb9f715b3c237", "url": "https://github.com/apache/flink/commit/f2209c8b21fb3120252b58e35debb9f715b3c237", "message": "batch #2", "committedDate": "2020-07-07T09:19:53Z", "type": "commit"}]}