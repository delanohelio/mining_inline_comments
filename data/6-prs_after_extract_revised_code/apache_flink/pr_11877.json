{"pr_number": 11877, "pr_title": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "pr_createdAt": "2020-04-23T08:37:09Z", "pr_url": "https://github.com/apache/flink/pull/11877", "timeline": [{"oid": "929403a9ae1b734c4e72a4585862f994d8c1f5e9", "url": "https://github.com/apache/flink/commit/929403a9ae1b734c4e72a4585862f994d8c1f5e9", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-04-23T10:40:36Z", "type": "forcePushed"}, {"oid": "ca6f75c37da358874cc38d7998bce5c4445feff5", "url": "https://github.com/apache/flink/commit/ca6f75c37da358874cc38d7998bce5c4445feff5", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-04-27T06:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422466188", "bodyText": "Make the following condition out of synchronized part, then we do not need to touch the lock for most of the cases.\nCheckpointOptions options = barrier.getCheckpointOptions();\nif (!(initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()))  {\n     return;\n}", "author": "zhijiangW", "createdAt": "2020-05-09T07:54:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -428,6 +423,23 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3MDcyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422970729", "bodyText": "It might be better to trigger this action by netty thread when received this barrier immediately. Otherwise the task processing might delay much time to better reuse the floating buffers for other channels.", "author": "zhijiangW", "createdAt": "2020-05-11T11:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3MjYyMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422972620", "bodyText": "Considering the race condition between this operation and canceler task, it might involve in potential conflicts and deadlock case if removeBufferListener and adjust isWaitingForFloatingBuffers here. Let me think whether we can lazy remove the listener and adjust isWaitingForFloatingBuffers by reusing the existing process RemoteInputChannel#notifyBufferAvailable.", "author": "zhijiangW", "createdAt": "2020-05-11T11:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ff2103389d6..86a8977f8ee 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -369,75 +299,30 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \t\treturn receivedBuffers.poll();\n \t}\n \n-\t/**\n-\t * The Buffer pool notifies this channel of an available floating buffer. If the channel is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt> and the unannounced credit is increased\n-\t * by one.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t *  \tmore floating buffers.\n-\t */\n-\t@Override\n-\tpublic NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tNotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tcheckState(isWaitingForFloatingBuffers,\n-\t\t\t\t\t\"This channel should be waiting for floating buffers.\");\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllResources() already released buffers inside bufferQueue\n-\t\t\t\t// -> then isReleased is set correctly\n-\t\t\t\t// 2) releaseAllResources() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (isReleased.get() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n+\t@VisibleForTesting\n+\tBufferManager getBufferManager() {\n+\t\treturn bufferManager;\n+\t}\n \n-\t\t\tif (unannouncedCredit.getAndAdd(1) == 0) {\n-\t\t\t\tnotifyCreditAvailable();\n-\t\t\t}\n-\t\t} catch (Throwable t) {\n-\t\t\tsetError(t);\n-\t\t}\n-\t\treturn notificationResult;\n+\t@VisibleForTesting\n+\tPartitionRequestClient getPartitionRequestClient() {\n+\t\treturn partitionRequestClient;\n \t}\n \n+\t/**\n+\t * The unannounced credit is increased by the given amount and might notify\n+\t * increased credit to the producer.\n+\t */\n \t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n+\tpublic void notifyBufferAvailable(int numAvailableBuffers) {\n+\t\tif (numAvailableBuffers > 0 && unannouncedCredit.getAndAdd(numAvailableBuffers) == 0) {\n+\t\t\tnotifyCreditAvailable();\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tCheckpointOptions options = barrier.getCheckpointOptions();\n-\t\t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n-\t\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\t\tboolean removed = inputGate.getBufferProvider().removeBufferListener(this);\n-\t\t\t\t\tcheckState(removed, \"Listener should be removed.\");\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t}\n-\n-\t\t\t\tint bufferReleased = bufferQueue.releaseAllFloatingBuffers();\n-\t\t\t\tnumRequiredBuffers += bufferReleased;\n-\t\t\t}\n-\t\t}\n+\t\tbufferManager.onCheckpointBarrier(barrier, initialCredit);\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NzQyMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422847423", "bodyText": "The different message path is distinguished in both PartitionRequestQueue and CreditBasedSequenceNumberingViewReader now. We can improve it to judge only in one place instead.\n\nIntroduce ServerOutboundMessage class to extend NettyMessage and make AddBacklog and BufferResponse both extend ServerOutboundMessage.\nIntroduce NetworkSequenceViewReader#getNextMessage instead of existing NetworkSequenceViewReader#getNextBuffer. And inside CreditBasedSequenceNumberingViewReader implementation, we can judge the condition for distinguish.\n\npublic NettyMessage.ServerOutboundMessage getNextMessage() throws IOException {\n\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(numCreditsAvailable)) {\n\t\t\treturn getBacklogMessage();\n\t\t} else {\n\t\t\treturn getNextBufferResponse();\n\t\t}\n\t}\n\nTo do so we can also reduce the necessary transformation between BufferAndAvailability and BufferResponse.", "author": "zhijiangW", "createdAt": "2020-05-11T07:47:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -234,11 +236,16 @@ private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IO\n \t\t\t\t\t\tregisterAvailableReader(reader);\n \t\t\t\t\t}\n \n-\t\t\t\t\tBufferResponse msg = new BufferResponse(\n-\t\t\t\t\t\tnext.buffer(),\n-\t\t\t\t\t\treader.getSequenceNumber(),\n-\t\t\t\t\t\treader.getReceiverId(),\n-\t\t\t\t\t\tnext.buffersInBacklog());\n+\t\t\t\t\tObject msg;\n+\t\t\t\t\tif (next.buffer() != null) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 3d3da181b2b..41faef88125 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -232,31 +234,20 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t\t\t\t} else {\n \t\t\t\t\t// This channel was now removed from the available reader queue.\n \t\t\t\t\t// We re-add it into the queue if it is still available\n-\t\t\t\t\tif (next.moreAvailable()) {\n+\t\t\t\t\tif (next.isMoreAvailable()) {\n \t\t\t\t\t\tregisterAvailableReader(reader);\n \t\t\t\t\t}\n \n-\t\t\t\t\tObject msg;\n-\t\t\t\t\tif (next.buffer() != null) {\n-\t\t\t\t\t\tmsg = new BufferResponse(\n-\t\t\t\t\t\t\tnext.buffer(),\n-\t\t\t\t\t\t\treader.getSequenceNumber(),\n-\t\t\t\t\t\t\treader.getReceiverId(),\n-\t\t\t\t\t\t\tnext.backlog());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tmsg = new NettyMessage.AddBacklog(next.backlog(), reader.getReceiverId());\n-\t\t\t\t\t}\n-\n \t\t\t\t\t// Write and flush and wait until this is done before\n \t\t\t\t\t// trying to continue with the next buffer.\n-\t\t\t\t\tchannel.writeAndFlush(msg).addListener(writeListener);\n+\t\t\t\t\tchannel.writeAndFlush(next.build()).addListener(writeListener);\n \n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \t\t} catch (Throwable t) {\n \t\t\tif (next != null) {\n-\t\t\t\tnext.buffer().recycleBuffer();\n+\t\t\t\tnext.recycleBufferIfNeeded();\n \t\t\t}\n \n \t\t\tthrow new IOException(t.getMessage(), t);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MzY5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422863695", "bodyText": "The previous buffersInBacklog variable should be replaced by this new variable, to avoid maintaining two variables.", "author": "zhijiangW", "createdAt": "2020-05-11T08:16:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -70,6 +70,10 @@\n \t@GuardedBy(\"buffers\")\n \tprivate int buffersInBacklog;\n \n+\t/** The number of non-event buffers to be announced to the downstream. */\n+\t@GuardedBy(\"buffers\")\n+\tprivate int unannouncedBacklog;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 840cfb80b5a..6d24a58afc5 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -66,10 +65,6 @@ public class PipelinedSubpartition extends ResultSubpartition {\n \t/** All buffers of this subpartition. Access to the buffers is synchronized on this object. */\n \tprivate final ArrayDeque<BufferConsumer> buffers = new ArrayDeque<>();\n \n-\t/** The number of non-event buffers currently in this subpartition. */\n-\t@GuardedBy(\"buffers\")\n-\tprivate int buffersInBacklog;\n-\n \t/** The number of non-event buffers to be announced to the downstream. */\n \t@GuardedBy(\"buffers\")\n \tprivate int unannouncedBacklog;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDk4MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422864980", "bodyText": "buffersInBacklog and unannouncedBacklog should be retained only one finally.", "author": "zhijiangW", "createdAt": "2020-05-11T08:18:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java", "diffHunk": "@@ -158,11 +158,18 @@ public boolean add(BufferConsumer bufferConsumer) throws IOException {\n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isDataAvailable;\n \t\tprivate final int buffersInBacklog;\n+\t\tprivate final int unannouncedBacklog;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\nindex 95eaee362d3..8d9a66e67b3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java\n\n@@ -150,25 +144,18 @@ public abstract class ResultSubpartition {\n \t// ------------------------------------------------------------------------\n \n \t/**\n-\t * A combination of a {@link Buffer} and the backlog length indicating\n-\t * how many non-event buffers are available in the subpartition.\n+\t * A combination of a {@link Buffer} and the unannounced backlog in the subpartition to\n+\t * be announced to the consumer.\n \t */\n \tpublic static final class BufferAndBacklog {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isDataAvailable;\n-\t\tprivate final int buffersInBacklog;\n \t\tprivate final int unannouncedBacklog;\n \t\tprivate final boolean isEventAvailable;\n \n-\t\tpublic BufferAndBacklog(\n-\t\t\t\tBuffer buffer,\n-\t\t\t\tboolean isDataAvailable,\n-\t\t\t\tint buffersInBacklog,\n-\t\t\t\tint unannouncedBacklog,\n-\t\t\t\tboolean isEventAvailable) {\n+\t\tpublic BufferAndBacklog(Buffer buffer, boolean isDataAvailable, int unannouncedBacklog, boolean isEventAvailable) {\n \t\t\tthis.buffer = checkNotNull(buffer);\n-\t\t\tthis.buffersInBacklog = buffersInBacklog;\n \t\t\tthis.unannouncedBacklog = unannouncedBacklog;\n \t\t\tthis.isDataAvailable = isDataAvailable;\n \t\t\tthis.isEventAvailable = isEventAvailable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2ODk4Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422868983", "bodyText": "why we need to trigger announce backlog while adding credit?\nI assume since the added creditDeltas is always more than zero, then we have the chance to announce the backlog later via sending BufferResponse.", "author": "zhijiangW", "createdAt": "2020-05-11T08:25:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,27 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\treturn shouldAnnounceBacklog();", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDQyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r423500427", "bodyText": "You are right shouldAnnounceBacklog always return false, I will replace the function call with return false. The reason why we need to change return type of addCredit is that we can't identify whether we are calling addCredit or resumeConsumption in PartitionRequestQueue.", "author": "wsry", "createdAt": "2020-05-12T06:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2ODk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 191e5471df4..cc9cadaa37a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -101,7 +102,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t@Override\n \tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn shouldAnnounceBacklog();\n+\t\treturn false;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4NDU1MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422884550", "bodyText": "We can also avoid introducing nullable buffer by this comment https://github.com/apache/flink/pull/11877/files#r422847423", "author": "zhijiangW", "createdAt": "2020-05-11T08:51:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -305,19 +311,18 @@ protected CheckpointBarrier parseCheckpointBarrierOrNull(Buffer buffer) throws I\n \n \t/**\n \t * A combination of a {@link Buffer} and a flag indicating availability of further buffers,\n-\t * and the backlog length indicating how many non-event buffers are available in the\n-\t * subpartition.\n+\t * and the backlog length indicating how many credits the subpartition.\n \t */\n \tpublic static final class BufferAndAvailability {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean moreAvailable;\n-\t\tprivate final int buffersInBacklog;\n+\t\tprivate final int backlog;\n \n-\t\tpublic BufferAndAvailability(Buffer buffer, boolean moreAvailable, int buffersInBacklog) {\n-\t\t\tthis.buffer = checkNotNull(buffer);\n+\t\tpublic BufferAndAvailability(@Nullable Buffer buffer, boolean moreAvailable, int backlog) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\nindex 05d2f546f4e..ef701809bd8 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java\n\n@@ -310,19 +311,16 @@ public abstract class InputChannel {\n \t}\n \n \t/**\n-\t * A combination of a {@link Buffer} and a flag indicating availability of further buffers,\n-\t * and the backlog length indicating how many credits the subpartition.\n+\t * A combination of a {@link Buffer} and a flag indicating availability of further buffers.\n \t */\n \tpublic static final class BufferAndAvailability {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean moreAvailable;\n-\t\tprivate final int backlog;\n \n-\t\tpublic BufferAndAvailability(@Nullable Buffer buffer, boolean moreAvailable, int backlog) {\n-\t\t\tthis.buffer = buffer;\n+\t\tpublic BufferAndAvailability(Buffer buffer, boolean moreAvailable) {\n+\t\t\tthis.buffer = checkNotNull(buffer);\n \t\t\tthis.moreAvailable = moreAvailable;\n-\t\t\tthis.backlog = backlog;\n \t\t}\n \n \t\tpublic Buffer buffer() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4OTAyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422889022", "bodyText": "I guess this check is not necessary or invalid.", "author": "zhijiangW", "createdAt": "2020-05-11T08:57:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,27 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\treturn shouldAnnounceBacklog();\n+\t}\n+\n+\t@Override\n+\tpublic boolean shouldAnnounceBacklog() {\n+\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n+\t\tif (initialCredit > 0) {\n+\t\t\tcheckState(numCreditsAvailable == availableCredit, \"Illegal number of available credit.\");", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 191e5471df4..cc9cadaa37a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -101,7 +102,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t@Override\n \tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n-\t\treturn shouldAnnounceBacklog();\n+\t\treturn false;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1MDcxMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422950710", "bodyText": "nit: might rename to numRequiredFloatingBuffers for better reflecting the current semantic.", "author": "zhijiangW", "createdAt": "2020-05-11T10:44:35Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -99,7 +100,7 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/** The number of required buffers that equals to sender's backlog plus initial credit. */\n+\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n \t@GuardedBy(\"bufferQueue\")\n \tprivate int numRequiredBuffers;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ff2103389d6..86a8977f8ee 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -92,33 +83,23 @@ public class RemoteInputChannel extends InputChannel implements BufferRecycler,\n \tprivate int expectedSequenceNumber = 0;\n \n \t/** The initial number of exclusive buffers assigned to this channel. */\n-\tprivate int initialCredit;\n-\n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\tprivate final int initialCredit;\n \n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\t/** The tag indicates whether this channel is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** Global memory segment provider to request and recycle exclusive buffers (only for credit-based). */\n-\t@Nonnull\n-\tprivate final MemorySegmentProvider memorySegmentProvider;\n-\n-\t/** The latest already triggered checkpoint id which would be updated during {@link #requestInflightBuffers(long)}.*/\n+\t/**\n+\t * The latest already triggered checkpoint id which would be updated during\n+\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n+\t */\n \t@GuardedBy(\"receivedBuffers\")\n \tprivate long lastRequestedCheckpointId = -1;\n \n \t/** The current received checkpoint id from the network. */\n \tprivate long receivedCheckpointId = -1;\n \n+\tprivate final BufferManager bufferManager;\n+\n \tpublic RemoteInputChannel(\n \t\tSingleInputGate inputGate,\n \t\tint channelIndex,\n"}}, {"oid": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "url": "https://github.com/apache/flink/commit/3046802f6bfcf476af447fffbc9af3f20a96ed61", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-12T13:04:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1NjQyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424156429", "bodyText": "fix the javadoc accordingly.", "author": "zhijiangW", "createdAt": "2020-05-13T03:46:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -127,7 +127,7 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \t/**\n \t * Requests exclusive buffers from the provider and returns the number of requested amount.", "originalCommit": "8a9dba521dd41e70cb5c4be10669372b1c674d22", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fc3e9f5b7933d0b74b53946e6f506916f73aba14", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7207cad4bcf..37e357b2ea0 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -129,7 +132,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n \n \t\tsynchronized (bufferQueue) {\n \t\t\tfor (MemorySegment segment : segments) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1NzE1Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424157153", "bodyText": "It is better to supplement the similar check to avoid this action is called multiple times in practice.\nMaybe we can check the available exclusive buffers should be 0 in BufferManager instead?", "author": "zhijiangW", "createdAt": "2020-05-13T03:49:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -122,10 +124,7 @@ public RemoteInputChannel(\n \t * after this input channel is created.\n \t */\n \tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(initialCredit == 0, \"Bug in input channel setup logic: exclusive buffers have \" +", "originalCommit": "8a9dba521dd41e70cb5c4be10669372b1c674d22", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex c58fdffa5fc..861d407262c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -124,6 +126,9 @@ public class RemoteInputChannel extends InputChannel {\n \t * after this input channel is created.\n \t */\n \tvoid assignExclusiveSegments() throws IOException {\n+\t\tcheckState(bufferManager.unsynchronizedGetExclusiveBuffers() == 0, \"Bug in input channel setup logic: \" +\n+\t\t\t\"exclusive buffers have already been set for this input channel.\");\n+\n \t\tbufferManager.requestExclusiveBuffers();\n \t}\n \n"}}, {"oid": "fc3e9f5b7933d0b74b53946e6f506916f73aba14", "url": "https://github.com/apache/flink/commit/fc3e9f5b7933d0b74b53946e6f506916f73aba14", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T03:57:50Z", "type": "forcePushed"}, {"oid": "708b2ceb97564084900c555d6f38e6ba1174d735", "url": "https://github.com/apache/flink/commit/708b2ceb97564084900c555d6f38e6ba1174d735", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T04:00:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2MzEyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424163129", "bodyText": "numberOfSegmentsToRequest  should never be negative because we already check this argument in constructor.\nif (numberOfSegmentsToRequest == 0) instead?", "author": "zhijiangW", "createdAt": "2020-05-13T04:16:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java", "diffHunk": "@@ -162,6 +162,10 @@ public void recycle(MemorySegment segment) {\n \n \t@Override\n \tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n+\t\tif (numberOfSegmentsToRequest <= 0) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\nindex 102d16381fa..4b187db7a96 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java\n\n@@ -162,7 +162,7 @@ public class NetworkBufferPool implements BufferPoolFactory, MemorySegmentProvid\n \n \t@Override\n \tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n-\t\tif (numberOfSegmentsToRequest <= 0) {\n+\t\tif (numberOfSegmentsToRequest == 0) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2MzQyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424163429", "bodyText": "nit: import NettyMessage.AddBacklog because it occurs many times in this part.", "author": "zhijiangW", "createdAt": "2020-05-13T04:17:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -291,6 +290,11 @@ private void decodeMsg(Object msg) throws Throwable {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t} else if (msgClazz == NettyMessage.AddBacklog.class) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex aa34a03e96b..6a41febf423 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -290,8 +291,8 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t} else if (msgClazz == NettyMessage.AddBacklog.class) {\n-\t\t\tNettyMessage.AddBacklog addBacklog = (NettyMessage.AddBacklog) msg;\n+\t\t} else if (msgClazz == AddBacklog.class) {\n+\t\t\tAddBacklog addBacklog = (AddBacklog) msg;\n \n \t\t\tRemoteInputChannel inputChannel = inputChannels.get(addBacklog.receiverId);\n \t\t\tinputChannel.onSenderBacklog(addBacklog.backlog);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424164395", "bodyText": "this change should be together with the previous hotfix commit \" making initialCredit as final\"", "author": "zhijiangW", "createdAt": "2020-05-13T04:22:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -129,7 +132,6 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4NDM4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424284387", "bodyText": "Before the last commit, we can't set numExclusive buffers to 0, so the check should be reserved before the last commit.", "author": "wsry", "createdAt": "2020-05-13T09:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkxMTkwMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424911901", "bodyText": "Got it. So do you think we add the if (initialCredit > 0) before calling this method inside RemoteInputChannel#assignExclusiveSegments?  Just for not necessary to synchronized below for empty segments.", "author": "zhijiangW", "createdAt": "2020-05-14T07:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -128,7 +125,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t}\n \n \t/**\n-\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t * Requests exclusive buffers from the provider.\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NTEwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424165102", "bodyText": "This renaming is not necessary.\nBufferManager is abstracted as a general purpose, not coupled with credit-based process, so it is better to not define a argument strongly related to credit-based purpose. numRequired seems more general to describe the semantic.", "author": "zhijiangW", "createdAt": "2020-05-13T04:25:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -139,10 +141,10 @@ void requestExclusiveBuffers() throws IOException {\n \t}\n \n \t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n \t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n \t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\tint requestFloatingBuffers(int backlog) throws IOException {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -141,10 +138,10 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t}\n \n \t/**\n-\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n \t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n \t */\n-\tint requestFloatingBuffers(int backlog) throws IOException {\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n \t\tint numRequestedBuffers = 0;\n \t\tsynchronized (bufferQueue) {\n \t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NzY5OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424167698", "bodyText": "Keep in mind that BufferManager is only for buffer request/release related operations, so it should not understand the other specific logics which should be done inside the respective InputChannel. Otherwise we would dirty this component and have ambiguous definition what is the role of this component.\nIn detail, the following should be done inside RemoteInputChannel\nCheckpointOptions options = barrier.getCheckpointOptions();\nif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) \n\nAnd rename  the method onCheckpointBarrier to distinguish with existing releaseFloatingBuffers(). From the perspective of outside caller, we should give a clear semantic method naming in order to be reused future.", "author": "zhijiangW", "createdAt": "2020-05-13T04:37:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +153,63 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n+\t\t\tInputChannelID channelID,\n+\t\t\tint initialCredit) throws IOException {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n+\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n+\n+\t\t\tif (initialCredit > 0) {\n+\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n+\t\t\t}\n+\n+\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numCredit;\n+\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n+\t\t}\n+\t}\n+\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -153,7 +150,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequiredBuffers += numRequired;\n \t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n \t\t\tnumRequiredBuffers -= numRequestedBuffers;\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2ODI2NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424168264", "bodyText": "As mentioned in 708b2ce#r424167698, this logic should be done inside RemoteInputChannel, because the BufferManager should not understand the specific logics unless buffer request/release.", "author": "zhijiangW", "createdAt": "2020-05-13T04:39:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +153,63 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 37e357b2ea0..7fb7cf9358b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -153,7 +150,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequiredBuffers += numRequired;\n \t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n \t\t\tnumRequiredBuffers -= numRequestedBuffers;\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjkwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424182902", "bodyText": "resumeAndGetResumptionMessage() -> getResumeConsumptionMessage()", "author": "zhijiangW", "createdAt": "2020-05-13T05:36:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -334,6 +335,15 @@ public void resumeConsumption() {\n \t\tpartitionRequestClient.resumeConsumption(this);\n \t}\n \n+\t/**\n+\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n+\t */\n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 2cbd3801b56..861d407262c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -336,12 +343,19 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t/**\n-\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n+\t * Called by netty thread to request buffers and generate {@link ResumeConsumption} message.\n \t */\n-\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {\n+\tpublic ResumeConsumption getResumeConsumptionMessage() throws IOException {\n \t\tcheckState(unannouncedCredit.get() == 0, \"Unannounced credit should be 0.\");\n+\t\tcheckState(bufferManager.getNumberOfAvailableBuffers() == initialCredit, \"Illegal number of available buffers.\");\n+\t\tcheckState(!bufferManager.isWaitingForFloatingBuffers(), \"Should not be waiting for floating buffers.\");\n+\n+\t\tif (initialCredit > 0) {\n+\t\t\treturn new ResumeConsumption(id, initialCredit, bufferManager.getNumberOfRequiredBuffers());\n+\t\t}\n \n-\t\treturn bufferManager.resumeAndGetResumptionMessage(id, initialCredit);\n+\t\tint availableCredit = bufferManager.requestFloatingBuffers(0);\n+\t\treturn new ResumeConsumption(id, availableCredit, bufferManager.getNumberOfRequiredBuffers());\n \t}\n \n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NjMwOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424186308", "bodyText": "Make this change a separate hotfix?", "author": "zhijiangW", "createdAt": "2020-05-13T05:48:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -415,11 +425,8 @@ public Buffer requestBuffer() {\n \t *\n \t * @param backlog The number of unsent buffers in the producer's sub partition.\n \t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = bufferManager.requestFloatingBuffers(backlog + initialCredit);\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n+\tpublic void onSenderBacklog(int backlog) throws IOException {\n+\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 2cbd3801b56..0c4f32d2f89 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -419,11 +431,11 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n+\t * Receives the backlog from the producer's buffer response. Floating buffers will\n+\t * be requested from the {@link BufferManager} according to the announced backlog,\n+\t * and then it will notify unannounced credits to the producer.\n \t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n+\t * @param backlog Number of the announced backlog from producer.\n \t */\n \tpublic void onSenderBacklog(int backlog) throws IOException {\n \t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n"}}, {"oid": "59b651c070adcca2b7e4e4a78e6b10411429c589", "url": "https://github.com/apache/flink/commit/59b651c070adcca2b7e4e4a78e6b10411429c589", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T10:25:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1MzQzOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424353439", "bodyText": "Actually the logic for adding credit does not need needAnnounceBacklog, so it might bring trouble to understand the logic of addCredit by reusing the common codes here.\nOne possible solution is to call enqueueAvailableReader in reader stack while applying the function, then the NetworkSequenceViewReader#addCredit and NetworkSequenceViewReader#resumeConsumption can judge the separate conditions before calling enqueueAvailableReader.", "author": "zhijiangW", "createdAt": "2020-05-13T11:04:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -145,20 +148,20 @@ public void close() throws IOException {\n \t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n \t *\n \t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n+\t * @param function The operation to be performed (add credit or resume data consumption).\n \t */\n \tvoid addCreditOrResumeConsumption(\n \t\t\tInputChannelID receiverId,\n-\t\t\tConsumer<NetworkSequenceViewReader> operation) throws Exception {\n+\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n \t\tif (fatalError) {\n \t\t\treturn;\n \t\t}\n \n \t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n \t\tif (reader != null) {\n-\t\t\toperation.accept(reader);\n+\t\t\tboolean needAnnounceBacklog = function.apply(reader);", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1Mzk0Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424353946", "bodyText": "To do so we can also avoid adjusting to return unnecessary boolean value for NetworkSequenceViewReader#addCredit", "author": "zhijiangW", "createdAt": "2020-05-13T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1MzQzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 8cfbd108656..70ec735057f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -148,20 +149,18 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n \t *\n \t * @param receiverId The input channel id to identify the consumer.\n-\t * @param function The operation to be performed (add credit or resume data consumption).\n+\t * @param operation The operation to be performed (add credit or resume data consumption).\n \t */\n \tvoid addCreditOrResumeConsumption(\n \t\t\tInputChannelID receiverId,\n-\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n+\t\t\tFutureConsumerWithException<NetworkSequenceViewReader, Exception> operation) throws Exception {\n \t\tif (fatalError) {\n \t\t\treturn;\n \t\t}\n \n \t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n \t\tif (reader != null) {\n-\t\t\tboolean needAnnounceBacklog = function.apply(reader);\n-\n-\t\t\tenqueueAvailableReader(reader, needAnnounceBacklog);\n+\t\t\toperation.acceptWithException(reader);\n \t\t} else {\n \t\t\tthrow new IllegalStateException(\"No reader for receiverId = \" + receiverId + \" exists.\");\n \t\t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NDY4Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424354683", "bodyText": "Based on this comment, we might not need to bring announceBacklog argument in this method, to understand all the related processes together.", "author": "zhijiangW", "createdAt": "2020-05-13T11:07:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -94,10 +96,11 @@ void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n+\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 8cfbd108656..70ec735057f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -96,8 +97,8 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {\n+\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {\n+\t\tif (reader.isRegisteredAsAvailable() || !condition.getAsBoolean()) {\n \t\t\treturn;\n \t\t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NDk3NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424374975", "bodyText": "Renaming it to a boolean type withoutExclusiveCredits seems more direct to understand", "author": "zhijiangW", "createdAt": "2020-05-13T11:48:34Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -45,6 +47,8 @@\n \n \tprivate final PartitionRequestQueue requestQueue;\n \n+\tprivate final int initialCredit;", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 401550a55d3..09ce436d1ec 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -47,7 +47,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \n \tprivate final PartitionRequestQueue requestQueue;\n \n-\tprivate final int initialCredit;\n+\tprivate final boolean withoutExclusiveCredits;\n \n \tprivate volatile ResultSubpartitionView subpartitionView;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDk0MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424860940", "bodyText": "nit: bufferReleased  -> numReleasedBuffers", "author": "zhijiangW", "createdAt": "2020-05-14T04:14:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +150,43 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += numRequired;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tif (isWaitingForFloatingBuffers) {\n+\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n+\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t}\n+\n+\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 7fb7cf9358b..78c34783461 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -182,8 +182,7 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\t\t\tisWaitingForFloatingBuffers = false;\n \t\t\t}\n \n-\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();\n-\t\t\tnumRequiredBuffers += bufferReleased;\n+\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n \t\t}\n \t}\n \n"}}, {"oid": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "url": "https://github.com/apache/flink/commit/b0bc4fc762c88de29509bb7ffb16c71203327fa8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T04:17:19Z", "type": "forcePushed"}, {"oid": "e033307ba22ee660cd6c39063896500075b60671", "url": "https://github.com/apache/flink/commit/e033307ba22ee660cd6c39063896500075b60671", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T04:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MzUyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424863522", "bodyText": "This method should be placed into the below section Buffer recycle.\nI think it is better to integrate this method with existing #releaseFloatingBuffers to provide a general one, otherwise it might bring confusing to understand the difference among them, especially for the different handle of numRequiredBuffers, to make them seem customized logic.\nThe integration is as below\nvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n\t\tsynchronized (bufferQueue) {\n\t\t\tif (isWaitingForFloatingBuffers) {\n\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n\t\t\t\tisWaitingForFloatingBuffers = false;\n\t\t\t}\n\n\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n\t\t\tif (isTemporaryRelease) {\n\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n\t\t\t} else {\n\t\t\t\tnumRequiredBuffers = 0;\n\t\t\t}\n\t\t}\n\t}", "author": "zhijiangW", "createdAt": "2020-05-14T04:25:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +149,42 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += numRequired;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {", "originalCommit": "e033307ba22ee660cd6c39063896500075b60671", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 6074cef11af..0f216cae4d1 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -174,17 +174,6 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t\treturn numRequestedBuffers;\n \t}\n \n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n \t// ------------------------------------------------------------------------\n \t// Buffer recycle\n \t// ------------------------------------------------------------------------\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NjA3Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424866076", "bodyText": "It should not be changed here. If the numRequiredBuffers is 0, getAvailableBufferSize() must be more than it. If numRequiredBuffers is 1 or something else, as long as the getAvailableBufferSize() is more than it, we also need to release a floating buffer.", "author": "zhijiangW", "createdAt": "2020-05-14T04:36:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -349,7 +373,7 @@ int unsynchronizedGetFloatingBuffersAvailable() {\n \t\t */\n \t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n \t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (getAvailableBufferSize() > numRequiredBuffers) {\n+\t\t\tif (numRequiredBuffers == 0) {", "originalCommit": "e033307ba22ee660cd6c39063896500075b60671", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 6074cef11af..ba6e75d3a43 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -41,395 +41,402 @@ import java.util.List;\n \n import static org.apache.flink.util.Preconditions.checkArgument;\n import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n- * The general buffer manager used by {@link InputChannel} to request/recycle\n- * exclusive or floating buffers.\n+ * The general buffer manager used by {@link InputChannel} to request/recycle exclusive or floating\n+ * buffers.\n  */\n public class BufferManager implements BufferListener, BufferRecycler {\n \n-\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n-\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n-\n-\t/** The buffer provider for requesting exclusive buffers. */\n-\tprivate final MemorySegmentProvider globalPool;\n-\n-\t/** The input channel to own this buffer manager. */\n-\tprivate final InputChannel inputChannel;\n-\n-\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate boolean isWaitingForFloatingBuffers;\n-\n-\t/** The total number of floating buffers to request for the respective input channel. */\n-\t@GuardedBy(\"bufferQueue\")\n-\tprivate int numRequiredBuffers;\n-\n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n-\t\tcheckArgument(numRequiredBuffers >= 0);\n-\t\tthis.numRequiredBuffers = numRequiredBuffers;\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer request\n-\t// ------------------------------------------------------------------------\n-\n-\t@Nullable\n-\tBuffer requestBuffer() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.takeBuffer();\n-\t\t}\n-\t}\n-\n-\tBuffer requestBufferBlocking() throws IOException, InterruptedException {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = bufferQueue.takeBuffer()) == null) {\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tthrow new CancelTaskException(\"Input channel [\" + inputChannel.channelInfo + \"] has already been released.\");\n-\t\t\t\t}\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\t\tbuffer = bufferPool.requestBuffer();\n-\t\t\t\t\tif (buffer == null && shouldContinueRequest(bufferPool)) {\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\treturn buffer;\n-\t\t\t\t}\n-\t\t\t\tbufferQueue.wait();\n-\t\t\t}\n-\t\t\treturn buffer;\n-\t\t}\n-\t}\n-\n-\tprivate boolean shouldContinueRequest(BufferPool bufferPool) {\n-\t\tif (bufferPool.addBufferListener(this)) {\n-\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\tnumRequiredBuffers++;\n-\t\t\treturn false;\n-\t\t} else if (bufferPool.isDestroyed()) {\n-\t\t\tthrow new CancelTaskException(\"Local buffer pool has already been released.\");\n-\t\t} else {\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests exclusive buffers from the provider.\n-\t */\n-\tvoid requestExclusiveBuffers() throws IOException {\n-\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tfor (MemorySegment segment : segments) {\n-\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n-\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n-\t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n-\t\tint numRequestedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n-\t\t\t// released all buffers via releaseAllResources().\n-\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\treturn numRequestedBuffers;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += numRequired;\n-\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n-\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n-\t\tassert Thread.holdsLock(bufferQueue);\n-\n-\t\tint numRequestedBuffers = 0;\n-\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n-\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\tif (buffer != null) {\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tnumRequestedBuffers++;\n-\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\treturn numRequestedBuffers;\n-\t}\n-\n-\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tif (isWaitingForFloatingBuffers) {\n-\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n-\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t}\n-\n-\t\t\tnumRequiredBuffers += bufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer recycle\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n-\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers = 0;\n-\t\tsynchronized (bufferQueue) {\n-\t\t\ttry {\n-\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t\t// after channel released all buffers via releaseAllResources().\n-\t\t\t\tif (inputChannel.isReleased()) {\n-\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t} else {\n-\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t\t\t\tnumRequiredBuffers -= numAddedBuffers;\n-\t\t\t\t}\n-\t\t\t} catch (Throwable t) {\n-\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t} finally {\n-\t\t\t\tbufferQueue.notifyAll();\n-\t\t\t}\n-\t\t}\n-\n-\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n-\t}\n-\n-\tvoid releaseFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tnumRequiredBuffers = 0;\n-\t\t\tbufferQueue.releaseFloatingBuffers();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n-\t */\n-\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n-\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n-\t\t// we do not want to trigger redistribution of buffers after each recycle.\n-\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n-\n-\t\tBuffer buffer;\n-\t\twhile ((buffer = buffers.poll()) != null) {\n-\t\t\tif (buffer.getRecycler() == this) {\n-\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n-\t\t\t} else {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t}\n-\t\tsynchronized (bufferQueue) {\n-\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n-\t\t\tbufferQueue.notifyAll();\n-\t\t}\n-\n-\t\tif (exclusiveRecyclingSegments.size() > 0) {\n-\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n-\t\t}\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Buffer listener notification\n-\t// ------------------------------------------------------------------------\n-\n-\t/**\n-\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n-\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n-\t * the buffer will be added into the <tt>bufferQueue</tt>.\n-\t *\n-\t * @param buffer Buffer that becomes available in buffer pool.\n-\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n-\t * more floating buffers.\n-\t */\n-\t@Override\n-\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n-\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n-\t\ttry {\n-\t\t\tsynchronized (bufferQueue) {\n-\t\t\t\tif (!isWaitingForFloatingBuffers) {\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n-\t\t\t\t// released all buffers. Following scenarios exist:\n-\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n-\t\t\t\t// -> while isReleased is set correctly in InputChannel\n-\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n-\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n-\t\t\t\t// lock on bufferQueue to release buffers\n-\t\t\t\tif (inputChannel.isReleased() || numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\treturn notificationResult;\n-\t\t\t\t}\n-\n-\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\tbufferQueue.notifyAll();\n-\n-\t\t\t\tif (--numRequiredBuffers == 0) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = false;\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n-\t\t\t\t} else {\n-\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tinputChannel.notifyBufferAvailable(1);\n-\t\t} catch (Throwable t) {\n-\t\t\tinputChannel.setError(t);\n-\t\t}\n-\n-\t\treturn notificationResult;\n-\t}\n-\n-\t@Override\n-\tpublic void notifyBufferDestroyed() {\n-\t\t// Nothing to do actually.\n-\t}\n-\n-\t// ------------------------------------------------------------------------\n-\t// Getter properties\n-\t// ------------------------------------------------------------------------\n-\n-\t@VisibleForTesting\n-\tint getNumberOfRequiredBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn numRequiredBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tboolean isWaitingForFloatingBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn isWaitingForFloatingBuffers;\n-\t\t}\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n-\t}\n-\n-\tint unsynchronizedGetExclusiveBuffers() {\n-\t\treturn bufferQueue.exclusiveBuffers.size();\n-\t}\n-\n-\tint unsynchronizedGetFloatingBuffersAvailable() {\n-\t\treturn bufferQueue.floatingBuffers.size();\n-\t}\n-\n-\t/**\n-\t * Manages the exclusive and floating buffers of this channel, and handles the\n-\t * internal buffer related logic.\n-\t */\n-\tstatic final class AvailableBufferQueue {\n-\n-\t\t/**\n-\t\t * The current available floating buffers from the fixed buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> floatingBuffers;\n-\n-\t\t/**\n-\t\t * The current available exclusive buffers from the global buffer pool.\n-\t\t */\n-\t\tfinal ArrayDeque<Buffer> exclusiveBuffers;\n-\n-\t\tAvailableBufferQueue() {\n-\t\t\tthis.exclusiveBuffers = new ArrayDeque<>();\n-\t\t\tthis.floatingBuffers = new ArrayDeque<>();\n-\t\t}\n-\n-\t\t/**\n-\t\t * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n-\t\t * number of available buffers in queue is more than the required amount.\n-\t\t *\n-\t\t * @param buffer             The exclusive buffer to add\n-\t\t * @param numRequiredBuffers The number of required buffers\n-\t\t * @return How many buffers were added to the queue\n-\t\t */\n-\t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n-\t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (numRequiredBuffers == 0) {\n-\t\t\t\tBuffer floatingBuffer = floatingBuffers.poll();\n-\t\t\t\tif (floatingBuffer != null) {\n-\t\t\t\t\tfloatingBuffer.recycleBuffer();\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn 1;\n-\t\t}\n-\n-\t\tvoid addFloatingBuffer(Buffer buffer) {\n-\t\t\tfloatingBuffers.add(buffer);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Takes the floating buffer first in order to make full use of floating\n-\t\t * buffers reasonably.\n-\t\t *\n-\t\t * @return An available floating or exclusive buffer, may be null\n-\t\t * if the channel is released.\n-\t\t */\n-\t\t@Nullable\n-\t\tBuffer takeBuffer() {\n-\t\t\tif (floatingBuffers.size() > 0) {\n-\t\t\t\treturn floatingBuffers.poll();\n-\t\t\t} else {\n-\t\t\t\treturn exclusiveBuffers.poll();\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * The floating buffer is recycled to local buffer pool directly, and the\n-\t\t * exclusive buffer will be gathered to return to global buffer pool later.\n-\t\t *\n-\t\t * @param exclusiveSegments The list that we will add exclusive segments into.\n-\t\t */\n-\t\tvoid releaseAll(List<MemorySegment> exclusiveSegments) {\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\twhile ((buffer = exclusiveBuffers.poll()) != null) {\n-\t\t\t\texclusiveSegments.add(buffer.getMemorySegment());\n-\t\t\t}\n-\t\t}\n-\n-\t\tint releaseFloatingBuffers() {\n-\t\t\tint numBufferReleased = floatingBuffers.size();\n-\t\t\tBuffer buffer;\n-\t\t\twhile ((buffer = floatingBuffers.poll()) != null) {\n-\t\t\t\tbuffer.recycleBuffer();\n-\t\t\t}\n-\t\t\treturn numBufferReleased;\n-\t\t}\n-\n-\t\tint getAvailableBufferSize() {\n-\t\t\treturn floatingBuffers.size() + exclusiveBuffers.size();\n-\t\t}\n-\t}\n+    /** The available buffer queue wraps both exclusive and requested floating buffers. */\n+    private final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+    /** The buffer provider for requesting exclusive buffers. */\n+    private final MemorySegmentProvider globalPool;\n+\n+    /** The input channel to own this buffer manager. */\n+    private final InputChannel inputChannel;\n+\n+    /**\n+     * The tag indicates whether it is waiting for additional floating buffers from the buffer pool.\n+     */\n+    @GuardedBy(\"bufferQueue\")\n+    private boolean isWaitingForFloatingBuffers;\n+\n+    /** The total number of required buffers for the respective input channel. */\n+    @GuardedBy(\"bufferQueue\")\n+    private int numRequiredBuffers;\n+\n+    public BufferManager(\n+            MemorySegmentProvider globalPool, InputChannel inputChannel, int numRequiredBuffers) {\n+\n+        this.globalPool = checkNotNull(globalPool);\n+        this.inputChannel = checkNotNull(inputChannel);\n+        checkArgument(numRequiredBuffers >= 0);\n+        this.numRequiredBuffers = numRequiredBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer request\n+    // ------------------------------------------------------------------------\n+\n+    @Nullable\n+    Buffer requestBuffer(int initialCredit) {\n+        synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                checkState(\n+                        bufferQueue.getAvailableBufferSize() <= numRequiredBuffers,\n+                        \"Too many buffers allocated.\");\n+                --numRequiredBuffers;\n+            }\n+            return bufferQueue.takeBuffer();\n+        }\n+    }\n+\n+    Buffer requestBufferBlocking() throws InterruptedException {\n+        synchronized (bufferQueue) {\n+            Buffer buffer;\n+            while ((buffer = bufferQueue.takeBuffer()) == null) {\n+                if (inputChannel.isReleased()) {\n+                    throw new CancelTaskException(\n+                            \"Input channel [\"\n+                                    + inputChannel.channelInfo\n+                                    + \"] has already been released.\");\n+                }\n+                if (!isWaitingForFloatingBuffers) {\n+                    BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                    buffer = bufferPool.requestBuffer();\n+                    if (buffer == null && shouldContinueRequest(bufferPool)) {\n+                        continue;\n+                    }\n+                }\n+\n+                if (buffer != null) {\n+                    return buffer;\n+                }\n+                bufferQueue.wait();\n+            }\n+            return buffer;\n+        }\n+    }\n+\n+    private boolean shouldContinueRequest(BufferPool bufferPool) {\n+        if (bufferPool.addBufferListener(this)) {\n+            isWaitingForFloatingBuffers = true;\n+            numRequiredBuffers = 1;\n+            return false;\n+        } else if (bufferPool.isDestroyed()) {\n+            throw new CancelTaskException(\"Local buffer pool has already been released.\");\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    /** Requests exclusive buffers from the provider. */\n+    void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n+        if (numExclusiveBuffers <= 0) {\n+            return;\n+        }\n+\n+        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n+        synchronized (bufferQueue) {\n+            for (MemorySegment segment : segments) {\n+                bufferQueue.addExclusiveBuffer(\n+                        new NetworkBuffer(segment, this), numRequiredBuffers);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Requests floating buffers from the buffer pool based on the given required amount, and\n+     * returns the actual requested amount. If the required amount is not fully satisfied, it will\n+     * register as a listener.\n+     */\n+    int requestFloatingBuffers(int numRequired) {\n+        int numRequestedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            // Similar to notifyBufferAvailable(), make sure that we never add a buffer after\n+            // channel\n+            // released all buffers via releaseAllResources().\n+            if (inputChannel.isReleased()) {\n+                return numRequestedBuffers;\n+            }\n+\n+            numRequiredBuffers = numRequired;\n+\n+            while (bufferQueue.getAvailableBufferSize() < numRequiredBuffers\n+                    && !isWaitingForFloatingBuffers) {\n+                BufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+                Buffer buffer = bufferPool.requestBuffer();\n+                if (buffer != null) {\n+                    bufferQueue.addFloatingBuffer(buffer);\n+                    numRequestedBuffers++;\n+                } else if (bufferPool.addBufferListener(this)) {\n+                    isWaitingForFloatingBuffers = true;\n+                    break;\n+                }\n+            }\n+        }\n+        return numRequestedBuffers;\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer recycle\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+     * floating buffer based on <tt>numRequiredBuffers</tt>.\n+     *\n+     * @param segment The exclusive segment of this channel.\n+     */\n+    @Override\n+    public void recycle(MemorySegment segment) {\n+        int numAddedBuffers = 0;\n+        synchronized (bufferQueue) {\n+            try {\n+                // Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+                // after channel released all buffers via releaseAllResources().\n+                if (inputChannel.isReleased()) {\n+                    globalPool.recycleMemorySegments(Collections.singletonList(segment));\n+                } else {\n+                    numAddedBuffers =\n+                            bufferQueue.addExclusiveBuffer(\n+                                    new NetworkBuffer(segment, this), numRequiredBuffers);\n+                }\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            } finally {\n+                bufferQueue.notifyAll();\n+            }\n+        }\n+\n+        try {\n+            inputChannel.notifyBufferAvailable(numAddedBuffers);\n+        } catch (Throwable t) {\n+            ExceptionUtils.rethrow(t);\n+        }\n+    }\n+\n+    void releaseFloatingBuffers() {\n+        synchronized (bufferQueue) {\n+            numRequiredBuffers = 0;\n+            bufferQueue.releaseFloatingBuffers();\n+        }\n+    }\n+\n+    /** Recycles all the exclusive and floating buffers from the given buffer queue. */\n+    void releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+        // Gather all exclusive buffers and recycle them to global pool in batch, because\n+        // we do not want to trigger redistribution of buffers after each recycle.\n+        final List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+        Buffer buffer;\n+        while ((buffer = buffers.poll()) != null) {\n+            if (buffer.getRecycler() == this) {\n+                exclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+            } else {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+        synchronized (bufferQueue) {\n+            bufferQueue.releaseAll(exclusiveRecyclingSegments);\n+            bufferQueue.notifyAll();\n+        }\n+\n+        if (exclusiveRecyclingSegments.size() > 0) {\n+            globalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+        }\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Buffer listener notification\n+    // ------------------------------------------------------------------------\n+\n+    /**\n+     * The buffer pool notifies this listener of an available floating buffer. If the listener is\n+     * released or currently does not need extra buffers, the buffer should be returned to the\n+     * buffer pool. Otherwise, the buffer will be added into the <tt>bufferQueue</tt>.\n+     *\n+     * @param buffer Buffer that becomes available in buffer pool.\n+     * @return NotificationResult indicates whether this channel accepts the buffer and is waiting\n+     *     for more floating buffers.\n+     */\n+    @Override\n+    public BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+        BufferListener.NotificationResult notificationResult =\n+                BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\n+        // Assuming two remote channels with respective buffer managers as listeners inside\n+        // LocalBufferPool.\n+        // While canceler thread calling ch1#releaseAllResources, it might trigger\n+        // bm2#notifyBufferAvaialble.\n+        // Concurrently if task thread is recycling exclusive buffer, it might trigger\n+        // bm1#notifyBufferAvailable.\n+        // Then these two threads will both occupy the respective bufferQueue lock and wait for\n+        // other side's\n+        // bufferQueue lock to cause deadlock. So we check the isReleased state out of synchronized\n+        // to resolve it.\n+        if (inputChannel.isReleased()) {\n+            return notificationResult;\n+        }\n+\n+        try {\n+            synchronized (bufferQueue) {\n+                checkState(\n+                        isWaitingForFloatingBuffers,\n+                        \"This channel should be waiting for floating buffers.\");\n+\n+                // Important: make sure that we never add a buffer after releaseAllResources()\n+                // released all buffers. Following scenarios exist:\n+                // 1) releaseAllBuffers() already released buffers inside bufferQueue\n+                // -> while isReleased is set correctly in InputChannel\n+                // 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+                // -> we may or may not have set isReleased yet but will always wait for the\n+                // lock on bufferQueue to release buffers\n+                if (inputChannel.isReleased()\n+                        || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    return notificationResult;\n+                }\n+\n+                bufferQueue.addFloatingBuffer(buffer);\n+                bufferQueue.notifyAll();\n+\n+                if (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+                    isWaitingForFloatingBuffers = false;\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+                } else {\n+                    notificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+                }\n+            }\n+\n+            inputChannel.notifyBufferAvailable(1);\n+        } catch (Throwable t) {\n+            inputChannel.setError(t);\n+        }\n+\n+        return notificationResult;\n+    }\n+\n+    @Override\n+    public void notifyBufferDestroyed() {\n+        // Nothing to do actually.\n+    }\n+\n+    // ------------------------------------------------------------------------\n+    // Getter properties\n+    // ------------------------------------------------------------------------\n+\n+    @VisibleForTesting\n+    int unsynchronizedGetNumberOfRequiredBuffers() {\n+        return numRequiredBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    boolean unsynchronizedIsWaitingForFloatingBuffers() {\n+        return isWaitingForFloatingBuffers;\n+    }\n+\n+    @VisibleForTesting\n+    int getNumberOfAvailableBuffers() {\n+        synchronized (bufferQueue) {\n+            return bufferQueue.getAvailableBufferSize();\n+        }\n+    }\n+\n+    int unsynchronizedGetAvailableExclusiveBuffers() {\n+        return bufferQueue.exclusiveBuffers.size();\n+    }\n+\n+    int unsynchronizedGetFloatingBuffersAvailable() {\n+        return bufferQueue.floatingBuffers.size();\n+    }\n+\n+    /**\n+     * Manages the exclusive and floating buffers of this channel, and handles the internal buffer\n+     * related logic.\n+     */\n+    static final class AvailableBufferQueue {\n+\n+        /** The current available floating buffers from the fixed buffer pool. */\n+        final ArrayDeque<Buffer> floatingBuffers;\n+\n+        /** The current available exclusive buffers from the global buffer pool. */\n+        final ArrayDeque<Buffer> exclusiveBuffers;\n+\n+        AvailableBufferQueue() {\n+            this.exclusiveBuffers = new ArrayDeque<>();\n+            this.floatingBuffers = new ArrayDeque<>();\n+        }\n+\n+        /**\n+         * Adds an exclusive buffer (back) into the queue and recycles one floating buffer if the\n+         * number of available buffers in queue is more than the required amount.\n+         *\n+         * @param buffer The exclusive buffer to add\n+         * @param numRequiredBuffers The number of required buffers\n+         * @return How many buffers were added to the queue\n+         */\n+        int addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n+            exclusiveBuffers.add(buffer);\n+            if (getAvailableBufferSize() > numRequiredBuffers) {\n+                Buffer floatingBuffer = floatingBuffers.poll();\n+                if (floatingBuffer != null) {\n+                    floatingBuffer.recycleBuffer();\n+                    return 0;\n+                }\n+            }\n+            return 1;\n+        }\n+\n+        void addFloatingBuffer(Buffer buffer) {\n+            floatingBuffers.add(buffer);\n+        }\n+\n+        /**\n+         * Takes the floating buffer first in order to make full use of floating buffers reasonably.\n+         *\n+         * @return An available floating or exclusive buffer, may be null if the channel is\n+         *     released.\n+         */\n+        @Nullable\n+        Buffer takeBuffer() {\n+            if (floatingBuffers.size() > 0) {\n+                return floatingBuffers.poll();\n+            } else {\n+                return exclusiveBuffers.poll();\n+            }\n+        }\n+\n+        /**\n+         * The floating buffer is recycled to local buffer pool directly, and the exclusive buffer\n+         * will be gathered to return to global buffer pool later.\n+         *\n+         * @param exclusiveSegments The list that we will add exclusive segments into.\n+         */\n+        void releaseAll(List<MemorySegment> exclusiveSegments) {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+            while ((buffer = exclusiveBuffers.poll()) != null) {\n+                exclusiveSegments.add(buffer.getMemorySegment());\n+            }\n+        }\n+\n+        void releaseFloatingBuffers() {\n+            Buffer buffer;\n+            while ((buffer = floatingBuffers.poll()) != null) {\n+                buffer.recycleBuffer();\n+            }\n+        }\n+\n+        int getAvailableBufferSize() {\n+            return floatingBuffers.size() + exclusiveBuffers.size();\n+        }\n+    }\n }\n"}}, {"oid": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "url": "https://github.com/apache/flink/commit/10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T06:16:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5OTUxNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424899517", "bodyText": "make it only private method inside RemoteInputChannel, because it is never used outside.", "author": "zhijiangW", "createdAt": "2020-05-14T06:32:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -327,6 +322,14 @@ public void notifyBufferAvailable(int numAvailableBuffers) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {", "originalCommit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a933d700d53457d7743252c2a3c735a04fbd87f8", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..82a1243aa5c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -322,8 +322,7 @@ public class RemoteInputChannel extends InputChannel {\n \t\t}\n \t}\n \n-\t@Override\n-\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {\n+\tprivate void onCheckpointBarrier(CheckpointBarrier barrier) {\n \t\tCheckpointOptions options = barrier.getCheckpointOptions();\n \t\tif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) {\n \t\t\tbufferManager.releaseFloatingBuffers(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkwMjAyNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424902024", "bodyText": "nit: also adjust the javadoc of this method accordingly.", "author": "zhijiangW", "createdAt": "2020-05-14T06:38:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -418,8 +437,8 @@ public Buffer requestBuffer() {\n \t *\n \t * @param backlog The number of unsent buffers in the producer's sub partition.\n \t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+\tpublic void onSenderBacklog(int backlog) throws IOException {", "originalCommit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 5e125aef0d0..0c4f32d2f89 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -431,11 +431,11 @@ public class RemoteInputChannel extends InputChannel {\n \t}\n \n \t/**\n-\t * Receives the backlog from the producer's buffer response. If the number of available\n-\t * buffers is less than backlog + initialCredit, it will request floating buffers from\n-\t * the buffer manager, and then notify unannounced credits to the producer.\n+\t * Receives the backlog from the producer's buffer response. Floating buffers will\n+\t * be requested from the {@link BufferManager} according to the announced backlog,\n+\t * and then it will notify unannounced credits to the producer.\n \t *\n-\t * @param backlog The number of unsent buffers in the producer's sub partition.\n+\t * @param backlog Number of the announced backlog from producer.\n \t */\n \tpublic void onSenderBacklog(int backlog) throws IOException {\n \t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkwNjk3Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424906972", "bodyText": "unsynchronizedGetAvailableExclusiveBuffers?", "author": "zhijiangW", "createdAt": "2020-05-14T06:49:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -313,7 +313,7 @@ int getNumberOfAvailableBuffers() {\n \t\t}\n \t}\n \n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n+\tint unsynchronizedGetExclusiveBuffers() {", "originalCommit": "2ea543cf392fb1f2d8d7691fa358a93b6765d195", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex a2c531e35cb..54995d605aa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -297,23 +312,25 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \t// ------------------------------------------------------------------------\n \n \t@VisibleForTesting\n-\tint unsynchronizedGetNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n+\tint getNumberOfRequiredBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn numRequiredBuffers;\n+\t\t}\n \t}\n \n-\t@VisibleForTesting\n-\tboolean unsynchronizedIsWaitingForFloatingBuffers() {\n-\t\treturn isWaitingForFloatingBuffers;\n+\tboolean isWaitingForFloatingBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn isWaitingForFloatingBuffers;\n+\t\t}\n \t}\n \n-\t@VisibleForTesting\n \tint getNumberOfAvailableBuffers() {\n \t\tsynchronized (bufferQueue) {\n \t\t\treturn bufferQueue.getAvailableBufferSize();\n \t\t}\n \t}\n \n-\tint unsynchronizedGetExclusiveBuffers() {\n+\tint unsynchronizedGetAvailableExclusiveBuffers() {\n \t\treturn bufferQueue.exclusiveBuffers.size();\n \t}\n \n"}}, {"oid": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "url": "https://github.com/apache/flink/commit/2cb05ba959c5ac264eb8fa85d711f499301ed767", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:43:23Z", "type": "forcePushed"}, {"oid": "a933d700d53457d7743252c2a3c735a04fbd87f8", "url": "https://github.com/apache/flink/commit/a933d700d53457d7743252c2a3c735a04fbd87f8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:47:15Z", "type": "forcePushed"}, {"oid": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "url": "https://github.com/apache/flink/commit/ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:52:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425072084", "bodyText": "remove moreAvailable argument from the constructor, because it seems strange for AddBacklogMessage, then we can give false in below super instead.", "author": "zhijiangW", "createdAt": "2020-05-14T11:41:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -328,4 +325,67 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t/**\n+\t * Outbound message to be sent to the client.\n+\t */\n+\tpublic static abstract class ServerOutboundMessage {\n+\t\tprotected final InputChannelID receiverId;\n+\t\tprotected final int backlog;\n+\t\tprivate final boolean moreAvailable;\n+\n+\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n+\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n+\t\t\tthis.receiverId = checkNotNull(receiverId);\n+\t\t\tthis.backlog = backlog;\n+\t\t\tthis.moreAvailable = moreAvailable;\n+\t\t}\n+\n+\t\tabstract Object build();\n+\n+\t\tpublic boolean isMoreAvailable() {\n+\t\t\treturn moreAvailable;\n+\t\t}\n+\n+\t\tvoid recycleBufferIfNeeded() {\n+\t\t}\n+\t}\n+\n+\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n+\t\tprivate final Buffer buffer;\n+\t\tprivate final int sequenceNumber;\n+\n+\t\tBufferResponseMessage(\n+\t\t\t\tBuffer buffer,\n+\t\t\t\tInputChannelID receiverId,\n+\t\t\t\tint sequenceNumber,\n+\t\t\t\tint backlog,\n+\t\t\t\tboolean moreAvailable) {\n+\t\t\tsuper(receiverId, backlog, moreAvailable);\n+\t\t\tthis.buffer = checkNotNull(buffer);\n+\t\t\tthis.sequenceNumber = sequenceNumber;\n+\t\t}\n+\n+\t\t@Override\n+\t\tObject build() {\n+\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid recycleBufferIfNeeded() {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n+\n+\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..65a7c1d5595 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -379,8 +379,8 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \n \tstatic class AddBacklogMessage extends ServerOutboundMessage {\n \n-\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n-\t\t\tsuper(receiverId, backlog, moreAvailable);\n+\t\tAddBacklogMessage(InputChannelID receiverId, int backlog) {\n+\t\t\tsuper(receiverId, backlog, false);\n \t\t}\n \n \t\t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MzA2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425073066", "bodyText": "Adjust the javadoc accordingly", "author": "zhijiangW", "createdAt": "2020-05-14T11:43:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -94,10 +97,11 @@ void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 70ec735057f..65a7c1d5595 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -91,8 +91,8 @@ public class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n \t}\n \n \t/**\n-\t * Try to enqueue the reader once receiving credit notification from the consumer or receiving\n-\t * non-empty reader notification from the producer.\n+\t * Try to enqueue the reader once receiving credit or resume consumption notification from\n+\t * the consumer or receiving non-empty reader notification from the producer.\n \t *\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425078522", "bodyText": "I guess we should not expect null return here. As long as the code path enters getAddBacklogMessage, then we should guarantee that the respective backlog should be more than 0.\nMaybe add assert backlog instead?", "author": "zhijiangW", "createdAt": "2020-05-14T11:53:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -163,8 +172,15 @@ boolean hasBuffersAvailable() {\n \t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n-\t@Override\n-\tpublic BufferAndAvailability getNextBuffer() throws IOException {\n+\tprivate AddBacklogMessage getAddBacklogMessage() {\n+\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n+\t\tif (backlog > 0) {\n+\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n+\t\t}\n+\t\treturn null;", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzEzNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425117136", "bodyText": "It can be null because of redundant data available notification.", "author": "wsry", "createdAt": "2020-05-14T13:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -175,7 +175,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \tprivate AddBacklogMessage getAddBacklogMessage() {\n \t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n \t\tif (backlog > 0) {\n-\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n+\t\t\treturn new AddBacklogMessage(receiverId, backlog);\n \t\t}\n \t\treturn null;\n \t}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODcwNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425078707", "bodyText": "initialCredit  == 0", "author": "zhijiangW", "createdAt": "2020-05-14T11:54:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -69,6 +73,7 @@\n \t\tthis.receiverId = receiverId;\n \t\tthis.numCreditsAvailable = initialCredit;\n \t\tthis.requestQueue = requestQueue;\n+\t\tthis.withoutExclusiveCredits = initialCredit > 0;", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -73,7 +73,7 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t\tthis.receiverId = receiverId;\n \t\tthis.numCreditsAvailable = initialCredit;\n \t\tthis.requestQueue = requestQueue;\n-\t\tthis.withoutExclusiveCredits = initialCredit > 0;\n+\t\tthis.withoutExclusiveCredits = initialCredit == 0;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTMzOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425079339", "bodyText": "nit: availableCredit -> availableCredits", "author": "zhijiangW", "createdAt": "2020-05-14T11:55:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,22 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic void addCredit(int creditDeltas) throws Exception {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n+\t}\n+\n+\t@Override\n+\tpublic boolean shouldAnnounceBacklog() {\n+\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb4c607a5c4780729143d458b1c7633adcba59bf", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 09ce436d1ec..0c03c332422 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -105,16 +105,16 @@ class CreditBasedSequenceNumberingViewReader implements BufferAvailabilityListen\n \t}\n \n \t@Override\n-\tpublic boolean shouldAnnounceBacklog() {\n-\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n+\tpublic boolean shouldAnnounceBacklog(boolean hasUnfulfilledBacklog) {\n+\t\treturn !hasUnfulfilledBacklog && withoutExclusiveCredits && numCreditsAvailable == 0;\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {\n+\tpublic void resumeConsumption(int availableCredits, boolean hasUnfulfilledBacklog) throws Exception {\n \t\t// reset the available credit\n-\t\tnumCreditsAvailable = availableCredit;\n+\t\tnumCreditsAvailable = availableCredits;\n \t\tsubpartitionView.resumeConsumption();\n-\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || !hasUnfulfilledBacklog && shouldAnnounceBacklog()));\n+\t\trequestQueue.enqueueAvailableReader(this, () -> (isAvailable() || shouldAnnounceBacklog(hasUnfulfilledBacklog)));\n \t}\n \n \t@Override\n"}}, {"oid": "fb4c607a5c4780729143d458b1c7633adcba59bf", "url": "https://github.com/apache/flink/commit/fb4c607a5c4780729143d458b1c7633adcba59bf", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T13:08:16Z", "type": "forcePushed"}, {"oid": "a51d7760c34c0652321427daa153070874c54a61", "url": "https://github.com/apache/flink/commit/a51d7760c34c0652321427daa153070874c54a61", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-15T18:27:12Z", "type": "forcePushed"}, {"oid": "0ed54d10e01403ccbe4478ad086d4859f6f511cf", "url": "https://github.com/apache/flink/commit/0ed54d10e01403ccbe4478ad086d4859f6f511cf", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-15T18:44:42Z", "type": "forcePushed"}, {"oid": "edabda8971fb299b278a0bd0b42c2dca82c8a6a4", "url": "https://github.com/apache/flink/commit/edabda8971fb299b278a0bd0b42c2dca82c8a6a4", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-16T03:03:56Z", "type": "forcePushed"}, {"oid": "d8b233f483d45b8901cc28770be9da71a39929ef", "url": "https://github.com/apache/flink/commit/d8b233f483d45b8901cc28770be9da71a39929ef", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-16T04:52:00Z", "type": "forcePushed"}, {"oid": "ab13e8a7dff7dcf53ed919196908437c30e78158", "url": "https://github.com/apache/flink/commit/ab13e8a7dff7dcf53ed919196908437c30e78158", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-18T03:56:00Z", "type": "forcePushed"}, {"oid": "3f89d29a4cee4917ff8087e16ab35c5d1274220c", "url": "https://github.com/apache/flink/commit/3f89d29a4cee4917ff8087e16ab35c5d1274220c", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-18T04:05:48Z", "type": "forcePushed"}, {"oid": "7dfdb8bfa05b783479697bd3aa3de3fac2628482", "url": "https://github.com/apache/flink/commit/7dfdb8bfa05b783479697bd3aa3de3fac2628482", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-06-28T05:30:04Z", "type": "forcePushed"}, {"oid": "66de3ded5740c19aab5984c8650b5d6a355ed6e8", "url": "https://github.com/apache/flink/commit/66de3ded5740c19aab5984c8650b5d6a355ed6e8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-06-28T08:14:19Z", "type": "forcePushed"}, {"oid": "9963994d6a37e8c1721d31519ac7346e25922248", "url": "https://github.com/apache/flink/commit/9963994d6a37e8c1721d31519ac7346e25922248", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-07-01T16:03:05Z", "type": "forcePushed"}, {"oid": "5682e0256634e2ce1a38ca132cdaaddc79ee71c0", "url": "https://github.com/apache/flink/commit/5682e0256634e2ce1a38ca132cdaaddc79ee71c0", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-07-02T03:27:27Z", "type": "forcePushed"}, {"oid": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "url": "https://github.com/apache/flink/commit/1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.", "committedDate": "2021-03-07T13:57:47Z", "type": "forcePushed"}, {"oid": "57cd88378e64e7c534d592d4538b2aa8222a2b00", "url": "https://github.com/apache/flink/commit/57cd88378e64e7c534d592d4538b2aa8222a2b00", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-07T15:25:00Z", "type": "forcePushed"}, {"oid": "379905b396355d37f565230cbcbee323dc626dce", "url": "https://github.com/apache/flink/commit/379905b396355d37f565230cbcbee323dc626dce", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T03:36:48Z", "type": "forcePushed"}, {"oid": "522dfaaf4295b903fa0c2d88e79db6d267086730", "url": "https://github.com/apache/flink/commit/522dfaaf4295b903fa0c2d88e79db6d267086730", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T05:48:19Z", "type": "forcePushed"}, {"oid": "8006bdc42eddf90eaaf8b1a426e3ee3c9b635e3c", "url": "https://github.com/apache/flink/commit/8006bdc42eddf90eaaf8b1a426e3ee3c9b635e3c", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T12:38:46Z", "type": "forcePushed"}, {"oid": "4b4b098f5eb40c7caf885c30b8c12aced99bbe05", "url": "https://github.com/apache/flink/commit/4b4b098f5eb40c7caf885c30b8c12aced99bbe05", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T13:58:14Z", "type": "forcePushed"}, {"oid": "87c4d9e67b205d7ca2fedf25a5a59402500de2ce", "url": "https://github.com/apache/flink/commit/87c4d9e67b205d7ca2fedf25a5a59402500de2ce", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-28T12:53:34Z", "type": "forcePushed"}, {"oid": "86af5b748a70ba9bb997d654b6f76c0f3a343bc0", "url": "https://github.com/apache/flink/commit/86af5b748a70ba9bb997d654b6f76c0f3a343bc0", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-05-08T07:29:43Z", "type": "forcePushed"}, {"oid": "ae312385b57ca67cdb73ee96be38c4edbe56478d", "url": "https://github.com/apache/flink/commit/ae312385b57ca67cdb73ee96be38c4edbe56478d", "message": "Commit for test", "committedDate": "2021-05-10T06:49:44Z", "type": "forcePushed"}, {"oid": "4f4ce33b815167b23c8ee3dc8d65e1e97cc0cd07", "url": "https://github.com/apache/flink/commit/4f4ce33b815167b23c8ee3dc8d65e1e97cc0cd07", "message": "Commit for test", "committedDate": "2021-05-10T10:06:29Z", "type": "forcePushed"}, {"oid": "8550965d808fe7b4d6ff2d48034612878937a579", "url": "https://github.com/apache/flink/commit/8550965d808fe7b4d6ff2d48034612878937a579", "message": "Fix commit", "committedDate": "2021-05-11T08:33:04Z", "type": "forcePushed"}, {"oid": "7b6eb661923f59967a116e9074cf790fd694c578", "url": "https://github.com/apache/flink/commit/7b6eb661923f59967a116e9074cf790fd694c578", "message": "Commit for test", "committedDate": "2021-05-11T12:15:11Z", "type": "forcePushed"}, {"oid": "2c49d1a8cee6485e8f367190f152e58960c901ff", "url": "https://github.com/apache/flink/commit/2c49d1a8cee6485e8f367190f152e58960c901ff", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-05-11T12:14:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661546940", "bodyText": "Before these changes where this buffer was recycled? or was it the bug?", "author": "akalash", "createdAt": "2021-06-30T14:46:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -340,7 +355,15 @@ private void decodeBufferOrEvent(\n             RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n             throws Throwable {\n         if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            try {\n+                inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            } finally {\n+                // recycle the empty buffer directly\n+                Buffer buffer = bufferOrEvent.getBuffer();\n+                if (buffer != null) {\n+                    buffer.recycleBuffer();", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk4NjgxMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661986812", "bodyText": "It is not a bug. The empty buffer will not be sent to the downstream before. However, after this change, the empty buffer will be sent to the downstream task to release the credit already allocated for it. If we do not send the empty buffer to the downstream, the corresponding downstream channel will occupy more credits than needed.", "author": "wsry", "createdAt": "2021-07-01T05:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDUwMzUyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664503527", "bodyText": "What do you mean by that @wsry ? That previously bufferOrEevnt.getBuffer() was always null?\nIf so why do we need to keep suport for sending both empty buffers or null buffer?", "author": "pnowojski", "createdAt": "2021-07-06T12:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5NzIxOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664997218", "bodyText": "Yes, you are right. Previously, bufferOrEevnt.getBuffer() was always null. And currently, it should be never null. So we do not need to support null buffer now.", "author": "wsry", "createdAt": "2021-07-07T02:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5OTc2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664999767", "bodyText": "I think I can keep this logic unchanged and release the buffer in decoder", "author": "wsry", "createdAt": "2021-07-07T02:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex 92425db4f8e..41d91430e70 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -355,15 +369,7 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n             RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n             throws Throwable {\n         if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-            try {\n-                inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n-            } finally {\n-                // recycle the empty buffer directly\n-                Buffer buffer = bufferOrEvent.getBuffer();\n-                if (buffer != null) {\n-                    buffer.recycleBuffer();\n-                }\n-            }\n+            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n         } else if (bufferOrEvent.getBuffer() != null) {\n             inputChannel.onBuffer(\n                     bufferOrEvent.getBuffer(), bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661554029", "bodyText": "as I understand, the backlog can not be less or equal to 0 here. So maybe convert it to checkArgument? Or I missed something?", "author": "akalash", "createdAt": "2021-06-30T14:53:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -164,6 +168,27 @@ void addCreditOrResumeConsumption(\n         }\n     }\n \n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader) {\n+        int backlog = reader.getRemainingBacklog();\n+        if (backlog > 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MDgyNQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661990825", "bodyText": "The backlog can be 0. For example, after resumption from checkpoint, if there is no pending data in the subpartition.", "author": "wsry", "createdAt": "2021-07-01T05:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0ODA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664648084", "bodyText": "Have you tested this @wsry ? After all it seems like if reader is available, it should have backlog > 0, shouldn't it?", "author": "pnowojski", "createdAt": "2021-07-06T15:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2OTg1NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664669854", "bodyText": "Secondly, getRemainingBacklog() is a very costly operation (additional synchronisation) that I think could have been avoided:\n\nBacklog can go up only as a result of org.apache.flink.runtime.io.network.netty.PartitionRequestQueue#notifyReaderNonEmpty(reader).\nBacklog can go down, only as a result of polling the data from the reader.\nSo instead of using thread safe reader.getRemainingBacklog(), we could re-use existing synchronisation in 1. and 2., to maintain remainingBacklog in the netty thread (in the PartitionRequestQueue.\n\nBut it would be even better to completely avoid this check (my comment above).", "author": "pnowojski", "createdAt": "2021-07-06T15:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTAxMjQ0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665012443", "bodyText": "You are right, we can do some optimization here.", "author": "wsry", "createdAt": "2021-07-07T03:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA3MzQ2Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665073463", "bodyText": "I think there is one thing blocking us from reusing the backlog from PartitionRequestQueue#notifyReaderNonEmpty(reader): we have duplicated availability notifications. We may get outdated backlog.", "author": "wsry", "createdAt": "2021-07-07T06:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTIyNTkzMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665225932", "bodyText": "Maybe we can reuse the return value of is available. Instead of just return a bool flag, we may also return the backlog. I will give it a try.", "author": "wsry", "createdAt": "2021-07-07T09:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTkwMDUxNQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665900515", "bodyText": "NetworkSequenceViewReader#isAvailable() has the same problem of synchronisation costs.\n\nI think there is one thing blocking us from reusing the backlog from PartitionRequestQueue#notifyReaderNonEmpty(reader): we have duplicated availability notifications. We may get outdated backlog.\n\nWhat is the problem?  Keep in mind that spurious notifications shouldn't be that big of a problem. If we sometimes wake up too many times, and we rarely send incorrect backlog information that should be fine, as long as we always over estimate the backlog.\nAfter all even in your version I think there can be a race condition where PartitionRequestQueue is notified reader is non empty, you check the getRemainingBacklog() and send the BacklogAnnouncement message, while before it gets processed by the receiver, some buffer is polled from this reader and backlog goes down to 0. And as a result, receiver assigns as a credit to a sender that doesn't have any data anymore?", "author": "pnowojski", "createdAt": "2021-07-08T06:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTkzMzA2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665933067", "bodyText": "NetworkSequenceViewReader#isAvailable() has already been called by PartitionRequestQueue#enqueueAvailableReader:\nprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\nif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\nreturn;\n}\n......\n}\n\nI think we can change it to:\n    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n        if (reader.isRegisteredAsAvailable()) {\n            return;\n        }\n\n        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n                reader.getAvailabilityAndBacklog();\n        if (!availabilityWithBacklog.isAvailable()) {\n            int backlog = availabilityWithBacklog.getBacklog();\n            if (backlog > 0 && reader.needAnnounceBacklog()) {\n                announceBacklog(reader, backlog);\n            }\n            return;\n        }\n......\n}\n\nWhat do you think?\n\nAfter all even in your version I think there can be a race condition where PartitionRequestQueue is notified reader is non empty, you check the getRemainingBacklog() and send the BacklogAnnouncement message, while before it gets processed by the receiver, some buffer is polled from this reader and backlog goes down to 0. And as a result, receiver assigns as a credit to a sender that doesn't have any data anymore?\n\nI think there is no such problem. One reason is that getRemainingBacklog() is in netty thread and we can guarantee the order, the downstream will always process the BacklogAnnouncement before the buffer. The other reason is that we only announce credit when there is no credit available which means if there is credit available, only buffer with backlog will be sent, if there is no credit available, only BacklogAnnouncement will be send, buffer will be always wait for credit. It is also not a problem if we announce the same credit twice because we can guarantee the process order.", "author": "wsry", "createdAt": "2021-07-08T07:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjI4NjM5Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666286396", "bodyText": "Yes you are right. reader.isAvailable() is already being called. I'm not sure why I've missed that.\nreader.getAvailabilityAndBacklog(); should work fine :)", "author": "pnowojski", "createdAt": "2021-07-08T15:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\nindex 3d3a36d3006..4395a06e5d3 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java\n\n@@ -168,6 +168,20 @@ class PartitionRequestQueue extends ChannelInboundHandlerAdapter {\n         }\n     }\n \n+    void acknowledgeAllRecordsProcessed(InputChannelID receiverId) {\n+        if (fatalError) {\n+            return;\n+        }\n+\n+        NetworkSequenceViewReader reader = allReaders.get(receiverId);\n+        if (reader != null) {\n+            reader.acknowledgeAllRecordsProcessed();\n+        } else {\n+            throw new IllegalStateException(\n+                    \"No reader for receiverId = \" + receiverId + \" exists.\");\n+        }\n+    }\n+\n     /**\n      * Announces remaining backlog to the consumer after the available data notification or data\n      * consumption resumption.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661557618", "bodyText": "Is it also a bug? Or why do we distinguish EVENT_BUFFER and DATA_BUFFER now?", "author": "akalash", "createdAt": "2021-06-30T14:57:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java", "diffHunk": "@@ -91,10 +91,14 @@ public BufferAndBacklog getNextBuffer() throws IOException {\n \n         updateStatistics(current);\n \n-        // We simply assume all the data are non-events for batch jobs to avoid pre-fetching the\n-        // next header\n-        Buffer.DataType nextDataType =\n-                numDataAndEventBuffers > 0 ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.NONE;\n+        // We simply assume all the data except for the last one (EndOfPartitionEvent)\n+        // are non-events for batch jobs to avoid pre-fetching the next header\n+        Buffer.DataType nextDataType = Buffer.DataType.NONE;\n+        if (numDataBuffers > 0) {\n+            nextDataType = Buffer.DataType.DATA_BUFFER;\n+        } else if (numDataAndEventBuffers > 0) {\n+            nextDataType = Buffer.DataType.EVENT_BUFFER;\n+        }", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MjQ1OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661992459", "bodyText": "An EVENT_BUFFER does not need any credit to be sent. The BoundedBlockingSubpartitionDirectTransferReader Implementation does not distinguish EVENT_BUFFER and DATA_BUFFER for simplicity. However, after this change, we need to distinguish EVENT_BUFFER and DATA_BUFFER because we do not want to allocate any credit at downstream for an EVENT_BUFFER.", "author": "wsry", "createdAt": "2021-07-01T05:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1NDk0OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664654949", "bodyText": "But what would be a problem with requesting for a credit for the EndOfPartitionEvent? In other words, what's wrong with doing it as it was done previously: always returning DATA_BUFFER or NONE?", "author": "pnowojski", "createdAt": "2021-07-06T15:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA1OTAyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665059027", "bodyText": "I think this is just an optimization. Without this change, the backlog announced to the downstream does not include the event and EVENT_BUFFER and DATA_BUFFER are not distinguished, this means the event buffer also need a credit to send. If there is no exclusive buffer, no enough buffer will be allocated for the event, because we only announce the data buffer backlog to the downstream. As a result, some tests will hang for there is no credit for the event buffer. To solve this dead lock, there are two simple ways:\n\nAnnounce both data buffer and event buffer backlog to the downstream, this lead to allocate more buffers than needed, these buffers will be released when the EOF is received at the downstream task.\nDistinguish EVENT_BUFFER and DATA_BUFFER just like what is doing now.\n\nThese choices are both acceptable to me. I chose the second one because EVENT_BUFFER and DATA_BUFFER are distinguished at the downstream task and we can allocate one less buffer.\nBoth of the choices need to do some change to BoundedBlockingSubpartitionDirectTransferReader. Which one do you prefer? I think both are acceptable for me.", "author": "wsry", "createdAt": "2021-07-07T05:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgzMDY5MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665830690", "bodyText": "After rethink about it, the first choice can support more events type in the future and the second choice make the assumption that we only have one event at the end of the data. Maybe the first choice is better?", "author": "wsry", "createdAt": "2021-07-08T02:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTg5NTUwNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665895504", "bodyText": "Let's stay with the option 2 (as you have currently implemented)", "author": "pnowojski", "createdAt": "2021-07-08T06:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex ec784393e9a..f8472c05b63 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n\n@@ -91,14 +91,10 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n \n         updateStatistics(current);\n \n-        // We simply assume all the data except for the last one (EndOfPartitionEvent)\n-        // are non-events for batch jobs to avoid pre-fetching the next header\n-        Buffer.DataType nextDataType = Buffer.DataType.NONE;\n-        if (numDataBuffers > 0) {\n-            nextDataType = Buffer.DataType.DATA_BUFFER;\n-        } else if (numDataAndEventBuffers > 0) {\n-            nextDataType = Buffer.DataType.EVENT_BUFFER;\n-        }\n+        // We simply assume all the data are non-events for batch jobs to avoid pre-fetching the\n+        // next header\n+        Buffer.DataType nextDataType =\n+                numDataAndEventBuffers > 0 ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.NONE;\n         return BufferAndBacklog.fromBufferAndLookahead(\n                 current, nextDataType, numDataBuffers, sequenceNumber++);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU2MzMwNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661563304", "bodyText": "Does this mean that we don't need the credit for sending the event?", "author": "akalash", "createdAt": "2021-06-30T15:04:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java", "diffHunk": "@@ -110,7 +114,12 @@ private void updateStatistics(Buffer buffer) {\n     public boolean isAvailable(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return numCreditsAvailable > 0 && numDataAndEventBuffers > 0;\n+        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MzY0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661993643", "bodyText": "Yes, you are right. At the downstream task, no credit is needed when decoding an event.", "author": "wsry", "createdAt": "2021-07-01T05:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU2MzMwNA=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\nindex ec784393e9a..d9034287be9 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java\n\n@@ -111,15 +111,12 @@ public class BoundedBlockingSubpartitionDirectTransferReader implements ResultSu\n     }\n \n     @Override\n-    public boolean isAvailable(int numCreditsAvailable) {\n+    public AvailabilityWithBacklog getAvailabilityAndBacklog(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;\n-    }\n-\n-    @Override\n-    public int getRemainingBacklog() {\n-        return numDataBuffers;\n+        return new AvailabilityWithBacklog(\n+                (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0,\n+                numDataBuffers);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661589690", "bodyText": "I don't really get the idea of these changes.\nLet's suppose PipelindedSubpartition#buffers contain several but the first one is empty and finished already.\nHow it was before the changes:\n\nPartitionRequestQueue requests the buffer.\nin any case, PipelindedSubpartition#pollBuffer returns a buffer(it skip the first one because it is empty and finished but it returns the buffer from the next consumer)\nPartitionRequestQueue continues to request from this Reader until PipelindedSubpartition#buffers is not empty.\n\nAfter the changes:\n\nPartitionRequestQueue requests the buffer.\nPipelindedSubpartition#pollBuffer returns null.\nPartitionRequestQueue remove this reader from the available readers\nOther buffers from PipelindedSubpartition#buffers will be sent only when timeout happens and this reader is added to the available list again.\n\nWhat the point to delay the sending if we already have credit for it and we have the buffer ready to be sent?", "author": "akalash", "createdAt": "2021-06-30T15:33:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -288,9 +288,7 @@ BufferAndBacklog pollBuffer() {\n \n             if (buffers.isEmpty()) {\n                 flushRequested = false;\n-            }\n-\n-            while (!buffers.isEmpty()) {\n+            } else {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5ODg4NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661998885", "bodyText": "After the changes, if the first buffer is finished and empty. The empty buffer will be sent to the downstream to release the allocated credit for it instead of recycled directly.", "author": "wsry", "createdAt": "2021-07-01T05:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIxNzkxNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662217914", "bodyText": "Ok, I think I understand it now. Please, tell me I indeed understand the scenario right:\n\nSuppose the buffers contain one unfinished Buffer.\nThe flush was requested\nWhen pollBuffer() was called it collects all readable bytes from this unfinished buffer and getBuffersInBacklog returns 1(because flushRequested set to true)\nOne more credit is requested from downstream because getBuffersInBacklog equal to 1.\nWhen pollBuffer() was called again it reads nothing because all data was read last time. But it already has one credit that should be released(it is exactly what you told about?).", "author": "akalash", "createdAt": "2021-07-01T11:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjY4ODEyMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662688120", "bodyText": "If there is only one buffer in the buffer queue, after all data is read, the flushRequested flag will be turned off. Consider the following scenario (correct me if I am wrong):\n\nThere is an unfinished buffer in the queue and all data is read.\nThen the buffer is finished but no new data is appended. Note appending data and finish buffer is not an atomic operation.\nNew buffer or event is added to the buffer queue.\nWhen polling buffer, an empty buffer is at the head of the queue and we already allocate a credit for it.", "author": "wsry", "createdAt": "2021-07-02T02:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjc3ODA1NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662778055", "bodyText": "appending data and finish buffer is not an atomic operation.\n\nIt is exactly what I want to emphasize. As I understand, we need the empty buffer only because appending data and finish buffer is not an atomic operation. which happens because BufferBuilder has a gap between commit and finish. So I propose to rewrite BufferBuilder in such a way that if it commits the current state and size == capacity it finishes it immediately(so there is no explicit finish call needed). These changes allow us to avoid all logic with an empty buffer which I think pretty untransparent.\nOne more time, my proposal:\n\nRewriting the BufferBuilder in such a way that it will be impossible to have the empty finished buffer(it just requires removing the gap between the last commit and finish).\nDon't send the empty buffer(after changes described above there won't be any empty buffers)\n\n@wsry WDYT?\n@pnowojski What is your opinion, is it safe to finish BufferBuilder immediately when it becomes full? I mean not to wait for call explicit finish but finish in the commit if it is full?", "author": "akalash", "createdAt": "2021-07-02T06:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjgxNjg1OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662816858", "bodyText": "Does that mean that the BufferBuilder can not finish a partial buffer, for example the last piece of data of the batch execution mode? Besides, there is another case which may lead to the empty buffer: in PipelinedApproximateSubpartition, if a partial record takes more than one buffer in the queue, those partial data will be dropped when recovering.", "author": "wsry", "createdAt": "2021-07-02T07:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg0MTM3NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662841374", "bodyText": "Yes, the batch execution mode still requires the manual calling of finish which brokes my idea.  The same about PipelinedApproximateSubpartition. As I understand, it is impossible to know that a partial record will be sent or not before the request the credit.\nSo I still believe that it would be better to avoid sending the empty buffer if it is possible. But perhaps you right and it will be not so easy to do so in the current implementation, especially because of the scenarios which you described.", "author": "akalash", "createdAt": "2021-07-02T08:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzExOTk1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r663119956", "bodyText": "How common is that case? Can we measure how many those empty buffers are being sent? Is this an issue of 0.1% more messages or 50%? If it's hard to say or can vary, would it be difficult/would it complicate the code to send the empty buffers only if #exclusiveBuffers == 0 to make sure that there is no performance regression?", "author": "pnowojski", "createdAt": "2021-07-02T16:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzU5MTI4NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r663591285", "bodyText": "It is pretty simple to send empty buffer only when  #exclusiveBuffers == 0.", "author": "wsry", "createdAt": "2021-07-05T01:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "ae5a618edba91af4656de9bab058e4a372a01331", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..dd48214990a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -288,7 +299,9 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n             if (buffers.isEmpty()) {\n                 flushRequested = false;\n-            } else {\n+            }\n+\n+            while (!buffers.isEmpty()) {\n                 BufferConsumerWithPartialRecordLength bufferConsumerWithPartialRecordLength =\n                         buffers.peek();\n                 BufferConsumer bufferConsumer =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5MjQ2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661592466", "bodyText": "So dangerous, why you so sure that buffers contain at least one object?", "author": "akalash", "createdAt": "2021-06-30T15:36:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -513,19 +514,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {\n+                return 0;\n+            }\n+\n+            if (flushRequested\n+                    || isFinished\n+                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5OTc0MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661999741", "bodyText": "In the previous if block in this method, we have already filtered the case when the buffer queue is empty.", "author": "wsry", "createdAt": "2021-07-01T06:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5MjQ2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..fef1387485a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -515,19 +540,24 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {\n         synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+            return getBuffersInBacklogUnsafe();\n+        }\n+    }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+    private int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5NzQ4Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661597482", "bodyText": "It seems that it is the wrong place for such condition. Logically, even if the subpartition is blocked it still has the buffers. But as I understand, specifically for the case where 'initialCredit == 0' it should return 0. So it needs to think how does it do better.", "author": "akalash", "createdAt": "2021-06-30T15:42:05Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -513,19 +514,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwMzA1OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662003058", "bodyText": "After the channel is blocked, we do not need to allocated any credit at the downstream, because no buffer will be sent. As mentioned in your comment, if the initialCredit is 0, it should return 0. If the initialCredit is not 0, we always have exclusive credits, we still do not need allocate any floating credit. Maybe returning the actual value instead of 0 is a small improvement.", "author": "wsry", "createdAt": "2021-07-01T06:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5NzQ4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 44ecb62b410..fef1387485a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -515,19 +540,24 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {\n         synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+            return getBuffersInBacklogUnsafe();\n+        }\n+    }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+    private int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5OTQ1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661599456", "bodyText": "As I understand, initialCredit is an unchangeable value, and BufferManager and AvailableBufferQueue know this value so maybe it is better to avoid this parameter?", "author": "akalash", "createdAt": "2021-06-30T15:44:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -83,8 +84,13 @@ public BufferManager(\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer() {\n+    Buffer requestBuffer(int initialCredit) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwMzQ3Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662003477", "bodyText": "You are right, we can avoid this parameter.", "author": "wsry", "createdAt": "2021-07-01T06:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5OTQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -84,13 +84,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer(int initialCredit) {\n+    Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n             // decrease the number of buffers require to avoid the possibility of\n             // allocating more than required buffers after the buffer is taken\n-            if (initialCredit == 0) {\n-                --numRequiredBuffers;\n-            }\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMjExMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661602113", "bodyText": "I don't understand why initialCredit == 0 should be handled differently here. Even if initialCredit == 1 and the Buffer is requested we should decrease this value, or am I wrong?", "author": "akalash", "createdAt": "2021-06-30T15:47:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -83,8 +84,13 @@ public BufferManager(\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer() {\n+    Buffer requestBuffer(int initialCredit) {\n         synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                --numRequiredBuffers;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwNDMxMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662004311", "bodyText": "You are right, we should always decrease this value.", "author": "wsry", "createdAt": "2021-07-01T06:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMjExMw=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -84,13 +84,11 @@ public class BufferManager implements BufferListener, BufferRecycler {\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer(int initialCredit) {\n+    Buffer requestBuffer() {\n         synchronized (bufferQueue) {\n             // decrease the number of buffers require to avoid the possibility of\n             // allocating more than required buffers after the buffer is taken\n-            if (initialCredit == 0) {\n-                --numRequiredBuffers;\n-            }\n+            --numRequiredBuffers;\n             return bufferQueue.takeBuffer();\n         }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMzY2MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661603660", "bodyText": "As I understand, the negative number is still illegal. So maybe it makes sense to add checkArgument for numExclusiveBuffers < 0?", "author": "akalash", "createdAt": "2021-06-30T15:49:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -130,11 +136,11 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \n     /** Requests exclusive buffers from the provider. */\n     void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n-        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n-        checkArgument(\n-                !segments.isEmpty(),\n-                \"The number of exclusive buffers per channel should be larger than 0.\");\n+        if (numExclusiveBuffers <= 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwNTUzMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662005533", "bodyText": "You are right, I will add a checkArgument.", "author": "wsry", "createdAt": "2021-07-01T06:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMzY2MA=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -136,12 +134,20 @@ public class BufferManager implements BufferListener, BufferRecycler {\n \n     /** Requests exclusive buffers from the provider. */\n     void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n-        if (numExclusiveBuffers <= 0) {\n+        checkArgument(numExclusiveBuffers >= 0, \"Num exclusive buffers must be non-negative.\");\n+        if (numExclusiveBuffers == 0) {\n             return;\n         }\n \n         Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n         synchronized (bufferQueue) {\n+            // AvailableBufferQueue::addExclusiveBuffer may release the previously allocated\n+            // floating buffer, which requires the caller to recycle these released floating\n+            // buffers. There should be no floating buffers that have been allocated before the\n+            // exclusive buffers are initialized, so here only a simple assertion is required\n+            checkState(\n+                    unsynchronizedGetFloatingBuffersAvailable() == 0,\n+                    \"Bug in buffer allocation logic: floating buffer is allocated before exclusive buffers are initialized.\");\n             for (MemorySegment segment : segments) {\n                 bufferQueue.addExclusiveBuffer(\n                         new NetworkBuffer(segment, this), numRequiredBuffers);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661605173", "bodyText": "Can you explain what kind of deadlock can happen? Between LocalBufferPool and BufferManager?", "author": "akalash", "createdAt": "2021-06-30T15:50:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -215,9 +221,15 @@ public void recycle(MemorySegment segment) {\n     }\n \n     void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n         synchronized (bufferQueue) {\n             numRequiredBuffers = 0;\n-            bufferQueue.releaseFloatingBuffers();\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMDQ0NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662010444", "bodyText": "Each RemoteInputChannel has its own BufferManager and bufferQueue, floating buffers recycled by one RemoteInputChannel can be assigned to other RemoteInputChannels directly and the buffer assignment also need to sync the bufferQueue object. Besides, different RemoteInputChannels may recycle buffers simultaneously, which means we may need to lock two bufferQueue objects of different RemoteInputChannels simultaneously in the reverse order. I already encountered this dead lock when running test.", "author": "wsry", "createdAt": "2021-07-01T06:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIzOTA2Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662239062", "bodyText": "As I understand from your explanation, it relates to this BufferManager#notifyBufferAvailable. But I still don't get which threads can call the releaseFloatingBuffers simultaneously. It is not so important, but just for curiosity if you have the stacktrace of this deadlock can you share it with me(or just tell me which test)?\nAnyway, your changes look correct here.", "author": "akalash", "createdAt": "2021-07-01T12:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjY4OTEwMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662689103", "bodyText": "It is the new logic added by this PR causes the problem. RemoteInputChannel#onBlockingUpstream will call BufferManager#releaseFloatingBuffers in netty thread and different RemoteInputChannels can have different netty thread.", "author": "wsry", "createdAt": "2021-07-02T02:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c161aff32e5aed483ca0722e0504ec8493348947", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\nindex 8031f6b5d3c..f417f2dee4b 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java\n\n@@ -213,10 +220,14 @@ public class BufferManager implements BufferListener, BufferRecycler {\n             }\n         }\n \n-        try {\n-            inputChannel.notifyBufferAvailable(numAddedBuffers);\n-        } catch (Throwable t) {\n-            ExceptionUtils.rethrow(t);\n+        if (releasedFloatingBuffer != null) {\n+            releasedFloatingBuffer.recycleBuffer();\n+        } else {\n+            try {\n+                inputChannel.notifyBufferAvailable(1);\n+            } catch (Throwable t) {\n+                ExceptionUtils.rethrow(t);\n+            }\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNjUwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661606502", "bodyText": "The same question that earlier - is this bug? or where did we recycle the buffer before this changes?", "author": "akalash", "createdAt": "2021-06-30T15:52:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -265,6 +265,13 @@ public void run() {\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n+\n+        // ignore the empty buffer directly\n+        if (buffer.readableBytes() == 0) {\n+            buffer.recycleBuffer();", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMTY2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662011666", "bodyText": "Before this change, the buffer is recycled in the pollBuffer method of Subpartition because no empty buffer is sent.", "author": "wsry", "createdAt": "2021-07-01T06:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNjUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex bba98cc9e60..15121b2f78f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n\n@@ -265,13 +249,6 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n-\n-        // ignore the empty buffer directly\n-        if (buffer.readableBytes() == 0) {\n-            buffer.recycleBuffer();\n-            return getNextBuffer();\n-        }\n-\n         return Optional.of(\n                 new BufferAndAvailability(\n                         buffer,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMDY0Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661610647", "bodyText": "How is it even possible to get an empty buffer? Who is sending it?", "author": "akalash", "createdAt": "2021-06-30T15:57:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -265,6 +265,13 @@ public void run() {\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n+\n+        // ignore the empty buffer directly\n+        if (buffer.readableBytes() == 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMjY2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662012667", "bodyText": "After this change, we can poll an empty buffer from the Subpartition of the upstream task.", "author": "wsry", "createdAt": "2021-07-01T06:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMDY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\nindex bba98cc9e60..15121b2f78f 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java\n\n@@ -265,13 +249,6 @@ public class LocalInputChannel extends InputChannel implements BufferAvailabilit\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n-\n-        // ignore the empty buffer directly\n-        if (buffer.readableBytes() == 0) {\n-            buffer.recycleBuffer();\n-            return getNextBuffer();\n-        }\n-\n         return Optional.of(\n                 new BufferAndAvailability(\n                         buffer,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMzIwMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661613201", "bodyText": "Why can not we do the same thing for any number of credits not only for initialCredit == 0? Or does it slow down the load after resuming?", "author": "akalash", "createdAt": "2021-06-30T16:00:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -357,11 +359,26 @@ public void resumeConsumption() throws IOException {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+\n         // notifies the producer that this channel is ready to\n         // unblock from checkpoint and resume data consumption\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxNjE1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662016156", "bodyText": "I think it does not slow down the load after resuming. It is just for the simplicity of handling unannounced credit. Maybe we have already announced the credits to the producer.", "author": "wsry", "createdAt": "2021-07-01T06:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMzIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ec5281cb0db..4be0669defa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -368,6 +368,14 @@ public class RemoteInputChannel extends InputChannel {\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n     private void onBlockingUpstream() {\n         if (initialCredit == 0) {\n             // release the allocated floating buffers so that they can be used by other channels if\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661614767", "bodyText": "Do we need to do so because we released all buffers in onBlockingUpstream? If so can we hold this code in one place, ex. to move it into onBlockingUpstream?", "author": "akalash", "createdAt": "2021-06-30T16:02:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -357,11 +359,26 @@ public void resumeConsumption() throws IOException {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAyMDQ3Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662020472", "bodyText": "Doing this in the onBlockingUpstream method can guarantee that after resumeConsumption the unannouncedCredit is in a clean state. Because the unannouncedCredit may get increased after that if there is any new available floating credit.", "author": "wsry", "createdAt": "2021-07-01T06:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY4Mjk4OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664682988", "bodyText": "But how can this floating credit be assigned to this blocked RemoteInputChannel? Wouldn't it cause the same deadlock, when floating buffers are assigned to blocked channels and job/task can not make any progress?\nIt sounds like maybe this should have been handled sooner when trying to increase unannouncedCredit?", "author": "pnowojski", "createdAt": "2021-07-06T15:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA2ODA0OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665068048", "bodyText": "This because RemoteInputChannel#notifyBufferAvailable which increases unannouncedCredit and floating buffer assignment is not an atomic operation. There is a possibility:\n\nthe floating buffer is assigned;\nthe floating buffer is released because of receiving an event which blocks the channel;\nthe notifyBufferAvailable is called and the unannouncedCredit is increased.\n\nDo you mean we should make RemoteInputChannel#notifyBufferAvailable and floating buffer assignment an atomic operation?", "author": "wsry", "createdAt": "2021-07-07T06:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTM5NDU1MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665394550", "bodyText": "Something sounds wrong here. The race condition that you described above, does it mean that unannouncedCredit can be out of sync? That we in reality have released all floating buffers, channel is blocked, but actually unannouncedCredit > 0? And it's only fixed after calling resumeConsumption()?\nAnd as I understand it, without your change, this problem doesn't exist, as floating buffers are kept assigned to the blocked channel and the unannouncedCredit (or maybe even assigned AddCredit that might have been sent to the upstream node)  are consistent with the reality. Also those assigned floating buffers are not used because channel is blocked, but that is not a big issue, because thanks to the exclusive buffers, other channels can make a progress?", "author": "pnowojski", "createdAt": "2021-07-07T13:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgxNDMzNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665814336", "bodyText": "Something sounds wrong here. The race condition that you described above, does it mean that unannouncedCredit can be out of sync? That we in reality have released all floating buffers, channel is blocked, but actually unannouncedCredit > 0? And it's only fixed after calling resumeConsumption()?\n\nYes, exactly.\n\nAnd as I understand it, without your change, this problem doesn't exist, as floating buffers are kept assigned to the blocked channel and the unannouncedCredit (or maybe even assigned AddCredit that might have been sent to the upstream node) are consistent with the reality. Also those assigned floating buffers are not used because channel is blocked, but that is not a big issue, because thanks to the exclusive buffers, other channels can make a progress?\n\nThat only happens when the exclusive credit is 0. If the exclusive credit is not 0, the allocated floating buffers will not be released and if the exclusive credit is 0, we release the floating buffers allocated to let other channel use them to avoid deadlock, an extreme case is that we only have 1 floating buffer and no exclusive buffer. At downstream, the unannounced credit will be reset, at the upstream, the available credit is also reset to 0 when resume consumption.", "author": "wsry", "createdAt": "2021-07-08T01:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjMzNDUwNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666334506", "bodyText": "Ok, can you at least add a comment explaining why this is set to 0 here?", "author": "pnowojski", "createdAt": "2021-07-08T16:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex ec5281cb0db..4be0669defa 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -368,6 +368,14 @@ public class RemoteInputChannel extends InputChannel {\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() throws IOException {\n+        checkState(!isReleased.get(), \"Channel released.\");\n+        checkPartitionRequestQueueInitialized();\n+\n+        partitionRequestClient.acknowledgeAllRecordsProcessed(this);\n+    }\n+\n     private void onBlockingUpstream() {\n         if (initialCredit == 0) {\n             // release the allocated floating buffers so that they can be used by other channels if\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNzUyNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661617526", "bodyText": "Do we do it because we know that all floating buffers would be released before the checkpoint when initialCredit == 0?", "author": "akalash", "createdAt": "2021-06-30T16:05:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -100,8 +106,19 @@ public void addCredit(int creditDeltas) {\n         numCreditsAvailable += creditDeltas;\n     }\n \n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n     @Override\n     public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAyMDc1OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662020759", "bodyText": "Yes, you are right.", "author": "wsry", "createdAt": "2021-07-01T06:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNzUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "1814aee57851711782cc2d922c4ef8f118a74c13", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\nindex 803ab4a3d3b..9d8d30387ae 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java\n\n@@ -122,6 +122,11 @@ class CreditBasedSequenceNumberingViewReader\n         subpartitionView.resumeConsumption();\n     }\n \n+    @Override\n+    public void acknowledgeAllRecordsProcessed() {\n+        subpartitionView.acknowledgeAllRecordsProcessed();\n+    }\n+\n     @Override\n     public void setRegisteredAsAvailable(boolean isRegisteredAvailable) {\n         this.isRegisteredAsAvailable = isRegisteredAvailable;\n"}}, {"oid": "c161aff32e5aed483ca0722e0504ec8493348947", "url": "https://github.com/apache/flink/commit/c161aff32e5aed483ca0722e0504ec8493348947", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-01T07:53:09Z", "type": "forcePushed"}, {"oid": "159596e8f11586211a5f54e6aaae2c9fdee532a2", "url": "https://github.com/apache/flink/commit/159596e8f11586211a5f54e6aaae2c9fdee532a2", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-02T02:08:29Z", "type": "forcePushed"}, {"oid": "1814aee57851711782cc2d922c4ef8f118a74c13", "url": "https://github.com/apache/flink/commit/1814aee57851711782cc2d922c4ef8f118a74c13", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T01:55:10Z", "type": "forcePushed"}, {"oid": "f28812c2d19b7109e851d4cce6cdb9df82868117", "url": "https://github.com/apache/flink/commit/f28812c2d19b7109e851d4cce6cdb9df82868117", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T07:02:25Z", "type": "forcePushed"}, {"oid": "048818bd8e4548d20febf9308b83e42146806b6e", "url": "https://github.com/apache/flink/commit/048818bd8e4548d20febf9308b83e42146806b6e", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T07:13:41Z", "type": "forcePushed"}, {"oid": "ae5a618edba91af4656de9bab058e4a372a01331", "url": "https://github.com/apache/flink/commit/ae5a618edba91af4656de9bab058e4a372a01331", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T08:17:11Z", "type": "forcePushed"}, {"oid": "109e1d36469b537f997a7c844e57e23729a1af21", "url": "https://github.com/apache/flink/commit/109e1d36469b537f997a7c844e57e23729a1af21", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T08:39:29Z", "type": "forcePushed"}, {"oid": "028f2185c0bb15c542006065550d04f69b0b06bd", "url": "https://github.com/apache/flink/commit/028f2185c0bb15c542006065550d04f69b0b06bd", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-06T04:02:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664644076", "bodyText": "Why is this an issue? Is this an independent optimisation or is it relate with the other parts of the PR?", "author": "pnowojski", "createdAt": "2021-07-06T15:08:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -433,8 +459,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \n         @Override\n         public Object buildMessage() {\n-            return new AddCredit(\n-                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+            int credits = inputChannel.getAndResetUnannouncedCredit();\n+            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MDU4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664650587", "bodyText": "Secondly, return type of the buildMessage() is not annotated @Nullable, so if we need this code for correctness we need to add this annotation (but it would be better to avoid null here)", "author": "pnowojski", "createdAt": "2021-07-06T15:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MDE2NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665080164", "bodyText": "It is relevant to this PR, it is because we add the reset logic in RemoteInputChannel#resumeConsumption method.\n        if (initialCredit == 0) {\n            unannouncedCredit.set(0);\n        }", "author": "wsry", "createdAt": "2021-07-07T06:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MDQ5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665080497", "bodyText": "I will add a @nullable annotation.", "author": "wsry", "createdAt": "2021-07-07T06:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\nindex bb83e4aa2ec..c9a36959395 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java\n\n@@ -459,8 +433,8 @@ class CreditBasedPartitionRequestClientHandler extends ChannelInboundHandlerAdap\n \n         @Override\n         public Object buildMessage() {\n-            int credits = inputChannel.getAndResetUnannouncedCredit();\n-            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;\n+            return new AddCredit(\n+                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MTgwOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664651808", "bodyText": "@Nullable\nDo we really need to support null here? Can not we return empty Buffer?", "author": "pnowojski", "createdAt": "2021-07-06T15:17:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java", "diffHunk": "@@ -69,6 +69,9 @@ Buffer allocatePooledNetworkBuffer(InputChannelID receiverId) {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n+        if (size <= 0) {\n+            return null;\n+        }", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MjY3OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665082678", "bodyText": "This method is used to allocate unpooled buffer for event, the size must be positive. I will replace it with a argument check.", "author": "wsry", "createdAt": "2021-07-07T06:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MTgwOA=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\nindex 9c950b1fe9f..7011c1cbcbc 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java\n\n@@ -69,9 +70,7 @@ class NetworkBufferAllocator {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n-        if (size <= 0) {\n-            return null;\n-        }\n+        checkArgument(size > 0, \"Illegal buffer size, must be positive.\");\n         byte[] byteArray = new byte[size];\n         MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664659995", "bodyText": "Instead of this check here, can not we add similar check outside of the while (...) loop? For example replace:\nif (buffer == null) {\n    return null;\n}\n\nwith something like:\nif (buffer == null) {\n   if (buffersPerChannel == 0) {\n       return EMPTY_BUFFER;\n    }\n    else {\n       return null;\n    }\n}\n\n?\nThat way, we would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued?", "author": "pnowojski", "createdAt": "2021-07-06T15:27:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -315,6 +326,17 @@ BufferAndBacklog pollBuffer() {\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n+\n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4NDYyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665084629", "bodyText": "I am afraid we can not skip the empty buffer is the exclusive credit is 0, because we may already allocate the floating credit for it and we can not just release the floating credit because we may already announce the credit to the upstream.", "author": "wsry", "createdAt": "2021-07-07T06:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA5MjA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665092084", "bodyText": "I was not suggesting that. I was suggesting to:\n\nwe would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued", "author": "pnowojski", "createdAt": "2021-07-07T06:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTIyMjQ5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665222497", "bodyText": "I guess I did not fully understand the comment, could you please explain a bit more? From my understand, even there are multiple buffers in the queue and the first is empty, if we do not send the first empty buffer out, how could we guarantee the downstream tasks are not allocating too many buffers if the exclusive credit is 0? For example, if there is two buffers, the first one is empty and the second one is an event, we may already announce 1 backlog to the downstream task and if we send the event directly, dose that mean we can not release the credit already allocated? Correct me if I am wrong.", "author": "wsry", "createdAt": "2021-07-07T09:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTM0MjA3NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665342075", "bodyText": "If there are two buffers, first is empty the second one can be:\n\nnon empty buffer\nempty buffer\nevent\n\nIn all cases, instead of sending this first empty buffer with the backlog information, as far as I understand, it should be possible to just send any of the above instead with the updated backlog information. From the downstream node perspective, it should make no difference if we hide this empty buffer. If this is 2nd or 3rd case, we should be able to release the floating buffer regardless of that, shouldn't we?", "author": "pnowojski", "createdAt": "2021-07-07T12:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgyOTM4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665829387", "bodyText": "Let's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\n\nThere are only one data buffer in the queue.\nFlush triggered.\nAll data of the first buffer is committed but the buffer is still not finished.\nAll data of the buffer is consumed by pollBuffer and the available credit becomes 0.\nThe first buffer is finished, the second event is added and the data available notification is triggered.\nThe upstream announces backlog to the downstream to request a credit.\nThe upstream receives available credit and start to pollBuffer.\nSkip the first empty buffer and send the second event.\nThe downstream receive the event but the event does not consume any credit.\n\nDo you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)? If there are multiple empty buffers, should we just skip the first one or should we skip all?", "author": "wsry", "createdAt": "2021-07-08T02:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex dd48214990a..bc1e5beb89c 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -323,10 +323,6 @@ public class PipelinedSubpartition extends ResultSubpartition\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n-                if (buffer.readableBytes() > 0) {\n-                    break;\n-                }\n-\n                 // if we have an empty finished buffer and the exclusive credit is 0, we just return\n                 // the empty buffer so that the downstream task can release the allocated credit for\n                 // this empty buffer, this happens in two main scenarios currently:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2MjE1Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664662153", "bodyText": "pollBuffer() would be acquiring the lock twice, wouldn't it? If you really need to make this method public you should keep private int getBuffersInBacklogUnsafe() without any synchronisation.", "author": "pnowojski", "createdAt": "2021-07-06T15:29:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -517,19 +539,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4NDg3Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665084877", "bodyText": "I will add a private int getBuffersInBacklogUnsafe() method", "author": "wsry", "createdAt": "2021-07-07T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2MjE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex dd48214990a..fef1387485a 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -540,19 +540,24 @@ public class PipelinedSubpartition extends ResultSubpartition\n     }\n \n     /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {\n         synchronized (buffers) {\n-            if (isBlocked || buffers.isEmpty()) {\n-                return 0;\n-            }\n+            return getBuffersInBacklogUnsafe();\n+        }\n+    }\n \n-            if (flushRequested\n-                    || isFinished\n-                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n-                return buffersInBacklog;\n-            } else {\n-                return Math.max(buffersInBacklog - 1, 0);\n-            }\n+    private int getBuffersInBacklogUnsafe() {\n+        if (isBlocked || buffers.isEmpty()) {\n+            return 0;\n+        }\n+\n+        if (flushRequested\n+                || isFinished\n+                || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {\n+            return buffersInBacklog;\n+        } else {\n+            return Math.max(buffersInBacklog - 1, 0);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY3NTg2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664675867", "bodyText": "add the backlog value to the error message?", "author": "pnowojski", "createdAt": "2021-07-06T15:46:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -468,6 +485,11 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n                 return;\n             }\n \n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog.\");", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\nindex 4be0669defa..9e8e1d3cbcd 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java\n\n@@ -487,7 +487,7 @@ public class RemoteInputChannel extends InputChannel {\n \n             if (buffer.getDataType().isBlockingUpstream()) {\n                 onBlockingUpstream();\n-                checkArgument(backlog == 0, \"Illegal number of backlog.\");\n+                checkArgument(backlog == 0, \"Illegal number of backlog: %s, should be 0.\", backlog);\n             }\n \n             final boolean wasEmpty;\n"}}, {"oid": "fb631b77700e2f05dcfdd50cd50cdea35e7cfb13", "url": "https://github.com/apache/flink/commit/fb631b77700e2f05dcfdd50cd50cdea35e7cfb13", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-07T02:10:53Z", "type": "forcePushed"}, {"oid": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "url": "https://github.com/apache/flink/commit/826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-07T08:46:21Z", "type": "forcePushed"}, {"oid": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "url": "https://github.com/apache/flink/commit/01b2bc58b30a2a3730895f7c50ff59099bd273d2", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-08T12:39:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjMwMjY4MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666302680", "bodyText": "nit: Rename to getBuffersInBacklogUnsafe() (previously it was a private method just made @VisibleForTesting)", "author": "pnowojski", "createdAt": "2021-07-08T15:31:22Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -517,16 +520,16 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {", "originalCommit": "c9956bc098175364585e5661d5d4ca097b2fe876", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2792e1a43d72ffc013bb60bdea52a577316d933a", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex 93e58ba27ec..bc588a1519d 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -522,7 +543,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     /** Gets the number of non-event buffers in this subpartition. */\n     @Override\n-    public int getBuffersInBacklog() {\n+    public int getBuffersInBacklogUnsafe() {\n         if (isBlocked || buffers.isEmpty()) {\n             return 0;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666340771", "bodyText": "I can not seem to respond in the previous thread, so I need to start a new one.\n\nLet's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\n\nThere are only one data buffer in the queue.\nFlush triggered.\nAll data of the first buffer is committed but the buffer is still not finished.\nAll data of the buffer is consumed by pollBuffer and the available credit becomes 0.\nThe first buffer is finished, the second event is added and the data available notification is triggered.\nThe upstream announces backlog to the downstream to request a credit.\nThe upstream receives available credit and start to pollBuffer.\nSkip the first empty buffer and send the second event.\nThe downstream receive the event but the event does not consume any credit.\n\nDo you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)?\n\nNo, but I think we could send this regardless if any is credit available or not as we are doing right now. I think we are also already attaching information about the backlog to such event. One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\n\nIf there are multiple empty buffers, should we just skip the first one or should we skip all?\n\nWe could skip all of them, until we reach one of the three options:\n\nnon empty data buffer\nevent (check above)\nlast empty buffer, without any events after it - here we would indeed need to send that empty buffer", "author": "pnowojski", "createdAt": "2021-07-08T16:19:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -312,6 +323,16 @@ BufferAndBacklog pollBuffer() {\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+", "originalCommit": "faee760500feb1a2f793a6d691a1d061b1d17917", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjYyNjg4Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666626886", "bodyText": "One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\n\nCurrently, we are not doing that. Actually, I think it is a little complicated to do so. Because we need to keep consistency between the sender side available credit and the receiver side floating buffers. If we just release the floating buffers at the receiver side, if the sender side available credit is not reset, then there is may data sent out without buffers at receiver side to receive them. If we also reset the available credit at the sender side when the backlog is 0, there is a possibility that some AddCredit messages are on the way and we are not resetting this part. Maybe one way is to not sending any data out after sending a buffer with 0 backlog at sender side, then the receivers clear all floating credits and send a reset message to the senders. Then the senders reset all available credits. This process is similar to the channel blocking and resumption. I think this is a little complicated and can incur extra overhead.\nWhat do you think? Or is there any simple way?", "author": "wsry", "createdAt": "2021-07-09T02:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjY3Nzk5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666677997", "bodyText": "Yes, you are right. It wouldn't be that simple. In that case, how complicated would it be to optimise the code to skip the all of the empty buffers until:\n\nnon empty data buffer\nevent (then send empty buffer first)\nlast empty buffer, without any events after it - here we would indeed need to send that empty buffer\n\n?", "author": "pnowojski", "createdAt": "2021-07-09T05:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjcyMzU0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666723543", "bodyText": "Currently, I can only come up with the following way, which depends on the downstream to reset the available credit of the upstream. This at least needs to add a special network message and propagating this message can incur extra overhead. If you think this is really important, I will spend some time to rethink about it and see if I can find a better way to solve it.\n\nMaybe one way is to not sending any data out after sending a buffer with 0 backlog at sender side, then the receivers clear all floating credits and send a reset message to the senders. Then the senders reset all available credits. This process is similar to the channel blocking and resumption.", "author": "wsry", "createdAt": "2021-07-09T07:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1MjExMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666752113", "bodyText": "Ok, let's go with the current way for now, as with buffersPerChannel == 0 check it's not that critical. But it would be nice if you could spend a little time thinking if we can improve this.", "author": "pnowojski", "createdAt": "2021-07-09T07:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc2MTQzOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666761438", "bodyText": "OK, thanks a lot. I will spend some time thinking if we can improve it.", "author": "wsry", "createdAt": "2021-07-09T08:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -329,7 +331,7 @@ public class PipelinedSubpartition extends ResultSubpartition\n                 // 1. all data of a buffer builder has been read and after that the buffer builder\n                 // is finished\n                 // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n-                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                if (receiverExclusiveBuffersPerChannel == 0 && bufferConsumer.isFinished()) {\n                     break;\n                 }\n \n"}}, {"oid": "2792e1a43d72ffc013bb60bdea52a577316d933a", "url": "https://github.com/apache/flink/commit/2792e1a43d72ffc013bb60bdea52a577316d933a", "message": "Fixup", "committedDate": "2021-07-09T03:57:07Z", "type": "forcePushed"}, {"oid": "d4b35b61d395564b24dd98896b785e22c6e3ab30", "url": "https://github.com/apache/flink/commit/d4b35b61d395564b24dd98896b785e22c6e3ab30", "message": "Fixup", "committedDate": "2021-07-09T03:59:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1NjI0MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666756241", "bodyText": "rename networkBuffersPerChannel -> configuredNetworkBuffersPerChannel to better reflect that we are actually overriding this value for the output?", "author": "pnowojski", "createdAt": "2021-07-09T08:05:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java", "diffHunk": "@@ -156,15 +155,16 @@ public ResultPartition create(\n                             bufferCompressor,\n                             bufferPoolFactory);\n \n-            BiFunction<Integer, PipelinedResultPartition, PipelinedSubpartition> factory;\n-            if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n-                factory = PipelinedApproximateSubpartition::new;\n-            } else {\n-                factory = PipelinedSubpartition::new;\n-            }\n-\n             for (int i = 0; i < subpartitions.length; i++) {\n-                subpartitions[i] = factory.apply(i, pipelinedPartition);\n+                if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n+                    subpartitions[i] =\n+                            new PipelinedApproximateSubpartition(\n+                                    i, networkBuffersPerChannel, pipelinedPartition);", "originalCommit": "a3f6a9f67fcb3429ce0b086c3384f14ff4a31b29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\nindex 4336c9dbd30..aad174e22e4 100755\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java\n\n@@ -159,11 +159,11 @@ public class ResultPartitionFactory {\n                 if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n                     subpartitions[i] =\n                             new PipelinedApproximateSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 } else {\n                     subpartitions[i] =\n                             new PipelinedSubpartition(\n-                                    i, networkBuffersPerChannel, pipelinedPartition);\n+                                    i, configuredNetworkBuffersPerChannel, pipelinedPartition);\n                 }\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1Njk5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666756995", "bodyText": "Can we rename this property to something like receiverExclusiveBuffersPerChannel?  Because actually this is not the number of buffersPerChannel for the sender.", "author": "pnowojski", "createdAt": "2021-07-09T08:06:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -112,8 +120,11 @@\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, ResultPartition parent) {\n+    PipelinedSubpartition(int index, int buffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n+\n+        checkArgument(buffersPerChannel >= 0, \"Buffers per channel must be non-negative.\");\n+        this.buffersPerChannel = buffersPerChannel;", "originalCommit": "a3f6a9f67fcb3429ce0b086c3384f14ff4a31b29", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "chunk": "diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\nindex bc1e5beb89c..38d8cf93158 100644\n--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java\n\n@@ -120,11 +119,14 @@ public class PipelinedSubpartition extends ResultSubpartition\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, int buffersPerChannel, ResultPartition parent) {\n+    PipelinedSubpartition(\n+            int index, int receiverExclusiveBuffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n \n-        checkArgument(buffersPerChannel >= 0, \"Buffers per channel must be non-negative.\");\n-        this.buffersPerChannel = buffersPerChannel;\n+        checkArgument(\n+                receiverExclusiveBuffersPerChannel >= 0,\n+                \"Buffers per channel must be non-negative.\");\n+        this.receiverExclusiveBuffersPerChannel = receiverExclusiveBuffersPerChannel;\n     }\n \n     @Override\n"}}, {"oid": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "url": "https://github.com/apache/flink/commit/da81fde5fc9e110075cff4982048b7f7ee3a0d61", "message": "Fixup", "committedDate": "2021-07-10T10:18:42Z", "type": "forcePushed"}, {"oid": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "url": "https://github.com/apache/flink/commit/dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "message": "[hotfix] Remove redundant if condition in BufferManager\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "29d20e309908eea85d077c9f96f9c337217ee89b", "url": "https://github.com/apache/flink/commit/29d20e309908eea85d077c9f96f9c337217ee89b", "message": "[hotfix] Remove outdated comments in UnionInputGate\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "c3428a92d528b20b61d030429b9099347144256d", "url": "https://github.com/apache/flink/commit/c3428a92d528b20b61d030429b9099347144256d", "message": "[hotfix] Simplify RemoteInputChannel#onSenderBacklog and call the existing method directly\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "b23c8f4778af071cb16b0f80b8357db4477ff812", "url": "https://github.com/apache/flink/commit/b23c8f4778af071cb16b0f80b8357db4477ff812", "message": "[hotfix] Fix typos in NettyShuffleUtils\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "bede6d39163df06f22a1d64df440d1067408b2ec", "url": "https://github.com/apache/flink/commit/bede6d39163df06f22a1d64df440d1067408b2ec", "message": "[FLINK-16641][network] (Part#1) Introduce a new network message BacklogAnnouncement which can bring the upstream buffer backlog to the downstream", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "url": "https://github.com/apache/flink/commit/0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "message": "[FLINK-16641][network] (Part#2) Distinguish data buffer and event buffer for BoundedBlockingSubpartitionDirectTransferReader\n\nCurrently, the BoundedBlockingSubpartitionDirectTransferReader does not distinguish data buffer and event buffer but it does not allocate floating credits for events, which means it relies on at least one exclusive credit to send the events. This patch changes the logic and distinguishes data buffer and event buffer for BoundedBlockingSubpartitionDirectTransferReader, after which the BoundedBlockingSubpartitionDirectTransferReader does not rely on the exclusive credits any more and we can set the exclusive credit to 0 after we finish FLINK-16641.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "url": "https://github.com/apache/flink/commit/639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "message": "[FLINK-16641][network] (Part#3) Support to announce the upstream backlog to the downstream tasks\n\nThis batch introduce the ability of announcing upstream backlog to the downstream tasks through the BacklogAnnouncement message when the exclusive credit is 0. This gives the upstream tasks the ability to actively allocate credits from the downstream tasks, which is needed by FLINK-16641.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "url": "https://github.com/apache/flink/commit/412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "message": "[FLINK-16641][network] (Part#4) Release all allocated floating buffers of RemoteInputChannel on receiving any channel blocking event if the exclusive credit is 0\n\nThis patch tries to release all allocated floating buffers of RemoteInputChannel on receiving any channel blocking event if the exclusive credit is 0 because a blocked channel does not need any credit and after that, these released credits can be used by other active channels. This can avoid the deadlock where credits are assigned to channels which do need them and those channels who need credits can not get any when the exclusive credit is 0.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "url": "https://github.com/apache/flink/commit/941de53b0ae20ae40a820a1bb0e35c6d189a7221", "message": "[FLINK-16641][network] (Part#5) Send empty buffers to the downstream tasks to release the allocated credits if the exclusive credit is 0\n\nCurrently,the empty buffers are not sent to the downstream tasks. This patch changes the logic and sends empty buffers to the downstream tasks when the exclusive credit is 0 release the allocated floating credits. If we do not do that, the downstream task may allocate more credits than needed which may lead to dead lock without exclusive credits.", "committedDate": "2021-07-12T10:45:01Z", "type": "commit"}, {"oid": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "url": "https://github.com/apache/flink/commit/4609625eac16247f2d70d8c36c42b3e2dfec8768", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-12T11:16:21Z", "type": "commit"}, {"oid": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "url": "https://github.com/apache/flink/commit/4609625eac16247f2d70d8c36c42b3e2dfec8768", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-12T11:16:21Z", "type": "forcePushed"}]}