{"pr_number": 17142, "pr_title": "Check replicas by dividing partitions into smaller batches", "pr_createdAt": "2020-06-30T07:57:41Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17142", "timeline": [{"oid": "a6e17e17de4a54b1e9d1e4abe181cdcc0c6dd708", "url": "https://github.com/hazelcast/hazelcast/commit/a6e17e17de4a54b1e9d1e4abe181cdcc0c6dd708", "message": "Check replicas by dividing partitions into smaller batches.", "committedDate": "2020-07-01T16:15:08Z", "type": "forcePushed"}, {"oid": "f3061c7f2cce51d5a8dc8504dfb4db1fb317e278", "url": "https://github.com/hazelcast/hazelcast/commit/f3061c7f2cce51d5a8dc8504dfb4db1fb317e278", "message": "Check replicas by dividing partitions into smaller batches", "committedDate": "2020-07-01T19:18:17Z", "type": "forcePushed"}, {"oid": "3947a684cd3bc43fa071a291bac18d96a78af0fd", "url": "https://github.com/hazelcast/hazelcast/commit/3947a684cd3bc43fa071a291bac18d96a78af0fd", "message": "Check replicas by dividing partitions into smaller batches", "committedDate": "2020-07-02T13:49:09Z", "type": "forcePushed"}, {"oid": "6fe93a65286ea1d1ea076e47b3deae38bc227bfd", "url": "https://github.com/hazelcast/hazelcast/commit/6fe93a65286ea1d1ea076e47b3deae38bc227bfd", "message": "Check replicas by dividing partitions into smaller batches", "committedDate": "2020-07-03T08:00:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc1ODU1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r450758558", "bodyText": "Was this change for testing? I'm asking since some issues does not appear with very low partition counts.", "author": "mdogan", "createdAt": "2020-07-07T10:15:37Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java", "diffHunk": "@@ -76,7 +76,7 @@\n     @Parameterized.Parameter(1)\n     public int nodeCount;\n \n-    protected int partitionCount = 111;\n+    protected int partitionCount = 11;", "originalCommit": "6fe93a65286ea1d1ea076e47b3deae38bc227bfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc3NDA2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r450774063", "bodyText": "removed leftover", "author": "ahmetmircik", "createdAt": "2020-07-07T10:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDc1ODU1OA=="}], "type": "inlineReview", "revised_code": {"commit": "5409e4b82b56c9c879a2565f34bf90b90baf362f", "chunk": "diff --git a/hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java b/hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java\nindex 01dfdf86d18..776fc30958f 100644\n--- a/hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java\n+++ b/hazelcast/src/test/java/com/hazelcast/internal/partition/PartitionCorrectnessTestSupport.java\n\n@@ -76,7 +76,7 @@ public abstract class PartitionCorrectnessTestSupport extends HazelcastTestSuppo\n     @Parameterized.Parameter(1)\n     public int nodeCount;\n \n-    protected int partitionCount = 11;\n+    protected int partitionCount = 111;\n \n     @Before\n     public void setup() {\n"}}, {"oid": "5409e4b82b56c9c879a2565f34bf90b90baf362f", "url": "https://github.com/hazelcast/hazelcast/commit/5409e4b82b56c9c879a2565f34bf90b90baf362f", "message": "remove leftover", "committedDate": "2020-07-07T10:45:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg5NzU2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r457897560", "bodyText": "minor: you can probably use PartitionIdSet instead of BitSet here. It is backed by a BitSet while providing a Set<Integer> interface as well as methods with primitive int arguments to avoid unnecessary boxing/unboxing.", "author": "vbekiaris", "createdAt": "2020-07-21T07:38:15Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "diffHunk": "@@ -516,31 +517,116 @@ public void process(EntryTaskScheduler<ReplicaFragmentSyncInfo, Void> scheduler,\n     }\n \n     private class AntiEntropyTask implements Runnable {\n+\n+        private static final int UNSET = -1;\n+\n+        private final long firstRunNanos;\n+        private final long backupSyncCheckIntervalSeconds;\n+        private final Semaphore semaphore = new Semaphore(0);\n+\n+        private int numInOneGo;\n+        private Queue<Integer> localPartitionIds;\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds) {\n+            this(backupSyncCheckIntervalSeconds, null, UNSET, UNSET);\n+        }\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds, Queue<Integer> localPartitionIds,\n+                        long firstRunNanos, int numInOneGo) {\n+            this.backupSyncCheckIntervalSeconds = backupSyncCheckIntervalSeconds;\n+            this.localPartitionIds = localPartitionIds;\n+            this.firstRunNanos = firstRunNanos;\n+            this.numInOneGo = numInOneGo;\n+        }\n+\n         @Override\n         public void run() {\n+            long initialStartTimeInNanos = firstRunNanos == UNSET ? System.nanoTime() : firstRunNanos;\n+\n             if (!node.isRunning() || !node.getNodeExtension().isStartCompleted()\n                     || !partitionService.areMigrationTasksAllowed()) {\n                 return;\n             }\n-            nodeEngine.getOperationService().executeOnPartitions(new PartitionAntiEntropyTaskFactory(), getLocalPartitions());\n+\n+            initLocalPartitionsIfNull();\n+\n+            BitSet partitionsBitSet = convertLocalPartitionsToBitSet();", "originalCommit": "5409e4b82b56c9c879a2565f34bf90b90baf362f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyMjE5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r459322195", "bodyText": "BitSet is given to nodeEngine.getOperationService().executeOnPartitions. This is the reason i kept it as is.", "author": "ahmetmircik", "createdAt": "2020-07-23T09:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg5NzU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "9f39c33f3266fba15253390d95d2abf4cb52ffc5", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java b/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java\nindex a000a246aa8..db164485747 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java\n\n@@ -606,13 +606,13 @@ public class PartitionReplicaManager implements PartitionReplicaVersionManager {\n \n             do {\n                 Integer partitionId = localPartitionIds.poll();\n-                if (partitionId == null || bitSet.cardinality() == numInOneGo) {\n+                if (partitionId == null) {\n                     break;\n                 }\n \n                 bitSet.set(partitionId);\n \n-            } while (true);\n+            } while (bitSet.cardinality() == numInOneGo);\n \n             return bitSet;\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwNTEyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r458605124", "bodyText": "Here if partitionId is not null and we reach numInOneGo, then that partitionId is lost from this batch because it was already removed from the queue.", "author": "vbekiaris", "createdAt": "2020-07-22T07:55:31Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java", "diffHunk": "@@ -516,31 +517,116 @@ public void process(EntryTaskScheduler<ReplicaFragmentSyncInfo, Void> scheduler,\n     }\n \n     private class AntiEntropyTask implements Runnable {\n+\n+        private static final int UNSET = -1;\n+\n+        private final long firstRunNanos;\n+        private final long backupSyncCheckIntervalSeconds;\n+        private final Semaphore semaphore = new Semaphore(0);\n+\n+        private int numInOneGo;\n+        private Queue<Integer> localPartitionIds;\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds) {\n+            this(backupSyncCheckIntervalSeconds, null, UNSET, UNSET);\n+        }\n+\n+        AntiEntropyTask(long backupSyncCheckIntervalSeconds, Queue<Integer> localPartitionIds,\n+                        long firstRunNanos, int numInOneGo) {\n+            this.backupSyncCheckIntervalSeconds = backupSyncCheckIntervalSeconds;\n+            this.localPartitionIds = localPartitionIds;\n+            this.firstRunNanos = firstRunNanos;\n+            this.numInOneGo = numInOneGo;\n+        }\n+\n         @Override\n         public void run() {\n+            long initialStartTimeInNanos = firstRunNanos == UNSET ? System.nanoTime() : firstRunNanos;\n+\n             if (!node.isRunning() || !node.getNodeExtension().isStartCompleted()\n                     || !partitionService.areMigrationTasksAllowed()) {\n                 return;\n             }\n-            nodeEngine.getOperationService().executeOnPartitions(new PartitionAntiEntropyTaskFactory(), getLocalPartitions());\n+\n+            initLocalPartitionsIfNull();\n+\n+            BitSet partitionsBitSet = convertLocalPartitionsToBitSet();\n+\n+            runAntiEntropyTask(partitionsBitSet);\n+\n+            waitAntiEntropyTaskEnd(partitionsBitSet.cardinality());\n+\n+            scheduleNextRun(initialStartTimeInNanos);\n         }\n \n-        private BitSet getLocalPartitions() {\n-            BitSet localPartitions = new BitSet(partitionService.getPartitionCount());\n+        private void scheduleNextRun(long initialStartTimeInNanos) {\n+            ExecutionService executionService = nodeEngine.getExecutionService();\n+\n+            if (!localPartitionIds.isEmpty()) {\n+                // we still have local partitions to check\n+                executionService.schedule(new AntiEntropyTask(backupSyncCheckIntervalSeconds,\n+                        localPartitionIds, initialStartTimeInNanos, numInOneGo), 1, TimeUnit.SECONDS);\n+            } else {\n+                // we have finished checking of all local partitions, time to decide when to commence next run.\n+                long elapsedSeconds = TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - initialStartTimeInNanos);\n+                long delayBeforeNextRunSeconds = Math.max(1, backupSyncCheckIntervalSeconds - elapsedSeconds);\n+                executionService.schedule(new AntiEntropyTask(backupSyncCheckIntervalSeconds),\n+                        delayBeforeNextRunSeconds, TimeUnit.SECONDS);\n+            }\n+        }\n+\n+        private void runAntiEntropyTask(BitSet partitionsBitSet) {\n+            nodeEngine.getOperationService().executeOnPartitions(partitionId -> {\n+                semaphore.release();\n+                return new PartitionPrimaryReplicaAntiEntropyTask(nodeEngine, partitionId);\n+            }, partitionsBitSet);\n+        }\n+\n+        private void waitAntiEntropyTaskEnd(int partitionCount) {\n+            try {\n+                semaphore.acquire(partitionCount);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                throw ExceptionUtil.rethrow(e);\n+            }\n+        }\n+\n+        private void initLocalPartitionsIfNull() {\n+            if (localPartitionIds != null) {\n+                return;\n+            }\n+\n+            localPartitionIds = getLocalPartitionIds();\n+            numInOneGo = Math.max(1, (int) Math.ceil(1D * localPartitionIds.size() / backupSyncCheckIntervalSeconds));\n+        }\n+\n+        @Nonnull\n+        private BitSet convertLocalPartitionsToBitSet() {\n+            BitSet bitSet = new BitSet(partitionService.getPartitionCount());\n+\n+            do {\n+                Integer partitionId = localPartitionIds.poll();\n+                if (partitionId == null || bitSet.cardinality() == numInOneGo) {\n+                    break;", "originalCommit": "5409e4b82b56c9c879a2565f34bf90b90baf362f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyMjMzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17142#discussion_r459322330", "bodyText": "Good catch, now it should be fixed.", "author": "ahmetmircik", "createdAt": "2020-07-23T09:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYwNTEyNA=="}], "type": "inlineReview", "revised_code": {"commit": "9f39c33f3266fba15253390d95d2abf4cb52ffc5", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java b/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java\nindex a000a246aa8..db164485747 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionReplicaManager.java\n\n@@ -606,13 +606,13 @@ public class PartitionReplicaManager implements PartitionReplicaVersionManager {\n \n             do {\n                 Integer partitionId = localPartitionIds.poll();\n-                if (partitionId == null || bitSet.cardinality() == numInOneGo) {\n+                if (partitionId == null) {\n                     break;\n                 }\n \n                 bitSet.set(partitionId);\n \n-            } while (true);\n+            } while (bitSet.cardinality() == numInOneGo);\n \n             return bitSet;\n         }\n"}}, {"oid": "9f39c33f3266fba15253390d95d2abf4cb52ffc5", "url": "https://github.com/hazelcast/hazelcast/commit/9f39c33f3266fba15253390d95d2abf4cb52ffc5", "message": "Vassilis reviews", "committedDate": "2020-07-22T22:34:13Z", "type": "forcePushed"}, {"oid": "b518ac7dcd6197d3fef21f9c9a59fe83e340b29c", "url": "https://github.com/hazelcast/hazelcast/commit/b518ac7dcd6197d3fef21f9c9a59fe83e340b29c", "message": "Vassilis reviews", "committedDate": "2020-07-23T07:56:24Z", "type": "forcePushed"}, {"oid": "831c3703784e4335bc4502e017aeb3b37baf9d46", "url": "https://github.com/hazelcast/hazelcast/commit/831c3703784e4335bc4502e017aeb3b37baf9d46", "message": "Vassilis reviews", "committedDate": "2020-07-23T08:01:35Z", "type": "forcePushed"}, {"oid": "f87f3a08f0ba5adae36a58040264f0114a0226fa", "url": "https://github.com/hazelcast/hazelcast/commit/f87f3a08f0ba5adae36a58040264f0114a0226fa", "message": "Check replicas by dividing partitions into smaller batches", "committedDate": "2020-07-23T09:38:06Z", "type": "commit"}, {"oid": "ddd459d1c205a0be692e1ae9bb2b14e6d7854fcf", "url": "https://github.com/hazelcast/hazelcast/commit/ddd459d1c205a0be692e1ae9bb2b14e6d7854fcf", "message": "remove leftover", "committedDate": "2020-07-23T09:38:06Z", "type": "commit"}, {"oid": "04e83c99cdd496cec12a2cb486f2443e789bd5b7", "url": "https://github.com/hazelcast/hazelcast/commit/04e83c99cdd496cec12a2cb486f2443e789bd5b7", "message": "Vassilis reviews", "committedDate": "2020-07-23T09:38:06Z", "type": "commit"}, {"oid": "04e83c99cdd496cec12a2cb486f2443e789bd5b7", "url": "https://github.com/hazelcast/hazelcast/commit/04e83c99cdd496cec12a2cb486f2443e789bd5b7", "message": "Vassilis reviews", "committedDate": "2020-07-23T09:38:06Z", "type": "forcePushed"}]}