{"pr_number": 16452, "pr_title": "Fix client listener registry leaks", "pr_createdAt": "2020-01-09T12:49:14Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16452", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA5NjQ1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16452#discussion_r365096459", "bodyText": "I think the following would also fix the leak and will not call the removeAction twice in any code path\n    @Override\n    public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) {\n        synchronized (removeListenerActions) {\n            if (destroyed) {\n                callRemoveAction(removeAction);\n            } else {\n                removeListenerActions.put(registrationId, removeAction);\n            }\n        }\n    }", "author": "mdumandag", "createdAt": "2020-01-10T07:06:22Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/ClientEndpointImpl.java", "diffHunk": "@@ -198,6 +202,10 @@ public void addListenerDestroyAction(final String service, final String topic, f\n     @Override\n     public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) {\n         removeListenerActions.put(registrationId, removeAction);\n+        if (destroyed) {", "originalCommit": "600502cd5ed258ca4f44a9a7a796e2ebe806990f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwODg5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16452#discussion_r365108891", "bodyText": "Calling the remove action is doing an invocation and waits for the results. We don't want to create a potential deadlock. Since registration id's are unique, calling the remove action twice looks ok to me.", "author": "sancar", "createdAt": "2020-01-10T07:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA5NjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEyMzY4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16452#discussion_r365123689", "bodyText": "What about the following then ?\n    @Override\n    public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) {\n        synchronized (removeListenerActions) {\n            if (!destroyed) {\n                removeListenerActions.put(registrationId, removeAction);\n                return;\n            }\n        }\n        callRemoveAction(removeAction);\n    }", "author": "mdumandag", "createdAt": "2020-01-10T08:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA5NjQ1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c18990509373b68c0276be9bf52526607eb8b991", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/ClientEndpointImpl.java b/hazelcast/src/main/java/com/hazelcast/client/impl/ClientEndpointImpl.java\nindex 4c5b4d52ad2..3b6ce6444fc 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/ClientEndpointImpl.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/ClientEndpointImpl.java\n\n@@ -203,8 +204,8 @@ public final class ClientEndpointImpl implements ClientEndpoint {\n     public void addDestroyAction(UUID registrationId, Callable<Boolean> removeAction) {\n         removeListenerActions.put(registrationId, removeAction);\n         if (destroyed) {\n-            callRemoveAction(removeAction);\n             removeDestroyAction(registrationId);\n+            callRemoveAction(removeAction);\n         }\n     }\n \n"}}, {"oid": "c18990509373b68c0276be9bf52526607eb8b991", "url": "https://github.com/hazelcast/hazelcast/commit/c18990509373b68c0276be9bf52526607eb8b991", "message": "Fix client listener registry leaks\n\nBackground:\nWhen a listener is added from an endpoint, we also register a\ndestroyAction. A destroyAction is a function to deregister the listener.\nIt is used when endpoint is removed. When endpoint is removed, we call\n all the registered destroy actions.\n\nRacy scenario is as follows:\n1. A listener is added, but not registered the destroy action.\n2. Endpoint is removed because the client is disconnected.\nAll the destroy actions currently registered are called.\n3. DestroyAction is registered to endpoint after it is destroyed.\n4. After this point, there is no one to call the last destroyAction,\nhence the leak.\n\nAs fix, we have added a second check if endpoint is destroyed after\na destroy action is put.\n\nfixes https://github.com/hazelcast/hazelcast/issues/16429", "committedDate": "2020-01-10T08:17:57Z", "type": "forcePushed"}, {"oid": "922a7b17f758450424d592eb9a11a3e9748eaa6d", "url": "https://github.com/hazelcast/hazelcast/commit/922a7b17f758450424d592eb9a11a3e9748eaa6d", "message": "Fix client listener registry leaks\n\nBackground:\nWhen a listener is added from an endpoint, we also register a\ndestroyAction. A destroyAction is a function to deregister the listener.\nIt is used when endpoint is removed. When endpoint is removed, we call\n all the registered destroy actions.\n\nRacy scenario is as follows:\n1. A listener is added, but not registered the destroy action.\n2. Endpoint is removed because the client is disconnected.\nAll the destroy actions currently registered are called.\n3. DestroyAction is registered to endpoint after it is destroyed.\n4. After this point, there is no one to call the last destroyAction,\nhence the leak.\n\nAs fix, we have added a second check if endpoint is destroyed after\na destroy action is put.\n\nfixes https://github.com/hazelcast/hazelcast/issues/16429", "committedDate": "2020-01-10T08:35:47Z", "type": "commit"}, {"oid": "922a7b17f758450424d592eb9a11a3e9748eaa6d", "url": "https://github.com/hazelcast/hazelcast/commit/922a7b17f758450424d592eb9a11a3e9748eaa6d", "message": "Fix client listener registry leaks\n\nBackground:\nWhen a listener is added from an endpoint, we also register a\ndestroyAction. A destroyAction is a function to deregister the listener.\nIt is used when endpoint is removed. When endpoint is removed, we call\n all the registered destroy actions.\n\nRacy scenario is as follows:\n1. A listener is added, but not registered the destroy action.\n2. Endpoint is removed because the client is disconnected.\nAll the destroy actions currently registered are called.\n3. DestroyAction is registered to endpoint after it is destroyed.\n4. After this point, there is no one to call the last destroyAction,\nhence the leak.\n\nAs fix, we have added a second check if endpoint is destroyed after\na destroy action is put.\n\nfixes https://github.com/hazelcast/hazelcast/issues/16429", "committedDate": "2020-01-10T08:35:47Z", "type": "forcePushed"}]}