{"pr_number": 16614, "pr_title": "Allow blocking Raft invocations to op-timeout after wait timeout", "pr_createdAt": "2020-02-05T14:50:13Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16614", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NDY2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16614#discussion_r375674663", "bodyText": "What if Clock.currentTimeMillis() + timeoutMs overflows?", "author": "mdogan", "createdAt": "2020-02-06T07:28:22Z", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java", "diffHunk": "@@ -110,12 +116,12 @@ private void checkNotDestroyed(String name) {\n     }\n \n     protected final void addWaitKey(String name, W key, long timeoutMs) {\n+        long deadline = timeoutMs > 0 ? Clock.currentTimeMillis() + timeoutMs : NO_WAIT_KEY_DEADLINE;", "originalCommit": "2dead3b0b7af55dfca34818f98b523998697c4b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bd7bb10b09461f0a1ddf068545c0824fa4c0cc1", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\nindex a5d0c75a7f4..e2835e7a4f3 100644\n--- a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n+++ b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n\n@@ -116,10 +116,15 @@ public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingReso\n     }\n \n     protected final void addWaitKey(String name, W key, long timeoutMs) {\n-        long deadline = timeoutMs > 0 ? Clock.currentTimeMillis() + timeoutMs : NO_WAIT_KEY_DEADLINE;\n+        long deadline;\n         if (timeoutMs > 0) {\n+            long now = Clock.currentTimeMillis();\n+            deadline = Long.MAX_VALUE - now >= timeoutMs ? now + timeoutMs : Long.MAX_VALUE;\n             waitTimeouts.putIfAbsent(BiTuple.of(name, key.invocationUid), BiTuple.of(timeoutMs, deadline));\n+        } else {\n+            deadline = NO_WAIT_KEY_DEADLINE;\n         }\n+\n         if (timeoutMs != 0) {\n             addLiveOperation(key, deadline);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY3NTAzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16614#discussion_r375675033", "bodyText": "I think it's better to use Long.MAX as NO_WAIT_KEY_DEADLINE. That way, there'll be no need to check deadline == NO_WAIT_KEY_DEADLINE equality.", "author": "mdogan", "createdAt": "2020-02-06T07:29:36Z", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java", "diffHunk": "@@ -57,7 +57,10 @@\n  * @param <R> concrete type of the resource\n  */\n public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingResource<W>>\n-        implements LiveOperationsTracker, DataSerializable {\n+        implements DataSerializable {\n+\n+    private static final long OPERATION_TIMEOUT_EXTENSION_MS = TimeUnit.SECONDS.toMillis(5);\n+    private static final long NO_WAIT_KEY_DEADLINE = -1;", "originalCommit": "2dead3b0b7af55dfca34818f98b523998697c4b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4bd7bb10b09461f0a1ddf068545c0824fa4c0cc1", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\nindex a5d0c75a7f4..e2835e7a4f3 100644\n--- a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n+++ b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n\n@@ -60,7 +60,7 @@ public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingReso\n         implements DataSerializable {\n \n     private static final long OPERATION_TIMEOUT_EXTENSION_MS = TimeUnit.SECONDS.toMillis(5);\n-    private static final long NO_WAIT_KEY_DEADLINE = -1;\n+    private static final long NO_WAIT_KEY_DEADLINE = Long.MAX_VALUE;\n \n     protected CPGroupId groupId;\n     protected final Map<String, R> resources = new ConcurrentHashMap<>();\n"}}, {"oid": "4bd7bb10b09461f0a1ddf068545c0824fa4c0cc1", "url": "https://github.com/hazelcast/hazelcast/commit/4bd7bb10b09461f0a1ddf068545c0824fa4c0cc1", "message": "Allow blocking Raft invocations to op-timeout after wait timeout\n\nIf the wait key of a blocking call times out, it is still reported\nas a live operation. This cloud lead to hang the caller side when\nthe majority is lost because the Raft invocation does not fail with\noperation timeout.\n\nTo prevent this problem, we don't report a wait key as a live operation\nif it is not expired on the CP group after its wait timeout occurs.", "committedDate": "2020-02-06T09:07:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NDUyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16614#discussion_r375764522", "bodyText": "Can we add a comment why we need this extension?", "author": "petrpleshachkov", "createdAt": "2020-02-06T10:49:51Z", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java", "diffHunk": "@@ -57,7 +57,10 @@\n  * @param <R> concrete type of the resource\n  */\n public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingResource<W>>\n-        implements LiveOperationsTracker, DataSerializable {\n+        implements DataSerializable {\n+\n+    private static final long OPERATION_TIMEOUT_EXTENSION_MS = TimeUnit.SECONDS.toMillis(5);", "originalCommit": "4bd7bb10b09461f0a1ddf068545c0824fa4c0cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5da2d660df976201ae6fcc556545a6b2bc80a9ec", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\nindex e2835e7a4f3..0b22a99762a 100644\n--- a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n+++ b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n\n@@ -59,12 +59,29 @@ import static java.util.Collections.unmodifiableMap;\n public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingResource<W>>\n         implements DataSerializable {\n \n+    // If the wait key of a blocking call times out, it is still reported\n+    // as a live operation. This cloud lead to hang the caller side when\n+    // the majority is lost because the Raft invocation does not fail with\n+    // operation timeout. To prevent this problem, we don't report a wait\n+    // key as a live operation if it is not expired on the CP group after\n+    // its wait timeout occurs. However, if we stop reporting a wait key\n+    // immediately after its timeout, then the caller might receive\n+    // an operation timeout prematurely, even though the majority is alive\n+    // and the wait key is expired on the CP group gracefully. In order to\n+    // prevent this problem, we extend the wait key timeout a few more seconds\n+    // so that the expiration logic could kick in and expire the key gracefully\n+    // when the CP group majority is healthy.\n     private static final long OPERATION_TIMEOUT_EXTENSION_MS = TimeUnit.SECONDS.toMillis(5);\n+\n+    // If no timeout is given for a blocking call, then we will use\n+    // this constant to not to expire its wait key\n     private static final long NO_WAIT_KEY_DEADLINE = Long.MAX_VALUE;\n \n+\n     protected CPGroupId groupId;\n     protected final Map<String, R> resources = new ConcurrentHashMap<>();\n     protected final Set<String> destroyedNames = new HashSet<>();\n+\n     // key.element1: name, key.element2: invocation uid\n     // value.element1: timeout duration (persisted in the snapshot), value.element2: deadline timestamp (transient)\n     protected final ConcurrentMap<BiTuple<String, UUID>, BiTuple<Long, Long>> waitTimeouts = new ConcurrentHashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc2NjIxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16614#discussion_r375766219", "bodyText": "else deadline = Long.MAX_VALUE ?", "author": "petrpleshachkov", "createdAt": "2020-02-06T10:53:23Z", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java", "diffHunk": "@@ -217,29 +228,42 @@ public final CPGroupId getGroupId() {\n         return indices;\n     }\n \n-    @Override\n-    public void populate(LiveOperations liveOperations) {\n-        for (BiTuple<Address, Long> t : liveOperationsSet) {\n-            liveOperations.add(t.element1, t.element2);\n+    public void populate(LiveOperations liveOperations, long now) {\n+        Iterator<Entry<BiTuple<Address, Long>, Long>> it = liveOperationMap.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Entry<BiTuple<Address, Long>, Long> e = it.next();\n+            long deadline = e.getValue();\n+            if (deadline >= now) {\n+                BiTuple<Address, Long> t = e.getKey();\n+                liveOperations.add(t.element1, t.element2);\n+            } else {\n+                it.remove();\n+            }\n         }\n     }\n \n-    private void addLiveOperation(W key) {\n-        liveOperationsSet.add(BiTuple.of(key.callerAddress(), key.callId()));\n+    private void addLiveOperation(W key, long deadline) {\n+        if (Long.MAX_VALUE - deadline >= OPERATION_TIMEOUT_EXTENSION_MS) {\n+            deadline += OPERATION_TIMEOUT_EXTENSION_MS;\n+        }", "originalCommit": "4bd7bb10b09461f0a1ddf068545c0824fa4c0cc1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5da2d660df976201ae6fcc556545a6b2bc80a9ec", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\nindex e2835e7a4f3..0b22a99762a 100644\n--- a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n+++ b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n\n@@ -243,6 +260,8 @@ public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingReso\n     }\n \n     private void addLiveOperation(W key, long deadline) {\n+        // if deadline is NO_WAIT_KEY_DEADLINE, it is already Long.MAX_VALUE\n+        // and no need to extend it further.\n         if (Long.MAX_VALUE - deadline >= OPERATION_TIMEOUT_EXTENSION_MS) {\n             deadline += OPERATION_TIMEOUT_EXTENSION_MS;\n         }\n"}}, {"oid": "5da2d660df976201ae6fcc556545a6b2bc80a9ec", "url": "https://github.com/hazelcast/hazelcast/commit/5da2d660df976201ae6fcc556545a6b2bc80a9ec", "message": "Allow blocking Raft invocations to op-timeout after wait timeout\n\nIf the wait key of a blocking call times out, it is still reported\nas a live operation. This cloud lead to hang the caller side when\nthe majority is lost because the Raft invocation does not fail with\noperation timeout.\n\nTo prevent this problem, we don't report a wait key as a live operation\nif it is not expired on the CP group after its wait timeout occurs.", "committedDate": "2020-02-06T14:39:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3NDc4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16614#discussion_r375874785", "bodyText": "typo cloud -> could", "author": "petrpleshachkov", "createdAt": "2020-02-06T14:45:19Z", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java", "diffHunk": "@@ -57,11 +57,31 @@\n  * @param <R> concrete type of the resource\n  */\n public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingResource<W>>\n-        implements LiveOperationsTracker, DataSerializable {\n+        implements DataSerializable {\n+\n+    // If the wait key of a blocking call times out, it is still reported\n+    // as a live operation. This cloud lead to hang the caller side when", "originalCommit": "5da2d660df976201ae6fcc556545a6b2bc80a9ec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3a971db8b95e5f594394aae2e58364bc4362d3bf", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\nindex 0b22a99762a..591a32ababa 100644\n--- a/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n+++ b/hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/spi/blocking/ResourceRegistry.java\n\n@@ -60,7 +60,7 @@ public abstract class ResourceRegistry<W extends WaitKey, R extends BlockingReso\n         implements DataSerializable {\n \n     // If the wait key of a blocking call times out, it is still reported\n-    // as a live operation. This cloud lead to hang the caller side when\n+    // as a live operation. This could lead to hang the caller side when\n     // the majority is lost because the Raft invocation does not fail with\n     // operation timeout. To prevent this problem, we don't report a wait\n     // key as a live operation if it is not expired on the CP group after\n"}}, {"oid": "3a971db8b95e5f594394aae2e58364bc4362d3bf", "url": "https://github.com/hazelcast/hazelcast/commit/3a971db8b95e5f594394aae2e58364bc4362d3bf", "message": "Allow blocking Raft invocations to op-timeout after wait timeout\n\nIf the wait key of a blocking call times out, it is still reported\nas a live operation. This cloud lead to hang the caller side when\nthe majority is lost because the Raft invocation does not fail with\noperation timeout.\n\nTo prevent this problem, we don't report a wait key as a live operation\nif it is not expired on the CP group after its wait timeout occurs.", "committedDate": "2020-02-06T14:55:01Z", "type": "forcePushed"}, {"oid": "8c1b916c833668782fad2791060debdf21f40bd3", "url": "https://github.com/hazelcast/hazelcast/commit/8c1b916c833668782fad2791060debdf21f40bd3", "message": "Allow blocking Raft invocations to op-timeout after wait timeout\n\nIf the wait key of a blocking call times out, it is still reported\nas a live operation. This could lead to hang the caller side when\nthe majority is lost because the Raft invocation does not fail with\noperation timeout.\n\nTo prevent this problem, we don't report a wait key as a live operation\nif it is not expired on the CP group after its wait timeout occurs.", "committedDate": "2020-02-06T14:55:49Z", "type": "commit"}, {"oid": "8c1b916c833668782fad2791060debdf21f40bd3", "url": "https://github.com/hazelcast/hazelcast/commit/8c1b916c833668782fad2791060debdf21f40bd3", "message": "Allow blocking Raft invocations to op-timeout after wait timeout\n\nIf the wait key of a blocking call times out, it is still reported\nas a live operation. This could lead to hang the caller side when\nthe majority is lost because the Raft invocation does not fail with\noperation timeout.\n\nTo prevent this problem, we don't report a wait key as a live operation\nif it is not expired on the CP group after its wait timeout occurs.", "committedDate": "2020-02-06T14:55:49Z", "type": "forcePushed"}]}