{"pr_number": 17340, "pr_title": "SQL math expressions (#17339)", "pr_createdAt": "2020-08-12T15:32:37Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17340", "timeline": [{"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf", "url": "https://github.com/hazelcast/hazelcast/commit/977c38cd535043f2127d900b5cab6a69656cf3cf", "message": "SQL math expressions (#17339)", "committedDate": "2020-08-12T15:23:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NDU5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469754596", "bodyText": "I'm not really sure about the difference, but shouldn't we use writer.keyword here?", "author": "viliam-durina", "createdAt": "2020-08-13T07:35:15Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlFloorFunction.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperatorBinding;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.fun.SqlMonotonicUnaryFunction;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n+public class HazelcastSqlFloorFunction extends SqlMonotonicUnaryFunction {\n+    public HazelcastSqlFloorFunction(SqlKind kind) {\n+        super(\n+            kind.name(),\n+            kind,\n+            ReturnTypes.ARG0_OR_EXACT_NO_SCALE,\n+            HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+            notAny(OperandTypes.NUMERIC),\n+            SqlFunctionCategory.NUMERIC\n+        );\n+    }\n+\n+    @Override public SqlMonotonicity getMonotonicity(SqlOperatorBinding call) {\n+        return call.getOperandMonotonicity(0).unstrict();\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:MagicNumber\")\n+    @Override public void unparse(SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {\n+        SqlWriter.Frame frame = writer.startFunCall(getName());\n+\n+        if (call.operandCount() == 2) {\n+            call.operand(0).unparse(writer, 0, 100);\n+            writer.sep(\"TO\");", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNzI5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470437296", "bodyText": "This is a copy-paste from Calcite. We had to copy the code from Calcite's SqlFloorFunction, because it doesn't have suitable constructors.", "author": "devozerov", "createdAt": "2020-08-14T06:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc1NDU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d466387bbc40ac2977bf76730cb827e30455df61", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlFloorFunction.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlFloorFunction.java\nindex c0e790de584..a7313b5bb48 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlFloorFunction.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlFloorFunction.java\n\n@@ -16,7 +16,7 @@\n \n package com.hazelcast.sql.impl.calcite.validate.operators;\n \n-import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n import org.apache.calcite.sql.SqlCall;\n import org.apache.calcite.sql.SqlFunctionCategory;\n import org.apache.calcite.sql.SqlKind;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNTY0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469935642", "bodyText": "We test infinities and NAN, we should also test -0.0f. Also in all other tests.", "author": "viliam-durina", "createdAt": "2020-08-13T13:05:14Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class AbsFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testColumn() {\n+        checkColumn((byte) 0, SqlColumnType.SMALLINT, (short) 0);\n+        checkColumn((byte) 1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn((byte) -1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn(Byte.MAX_VALUE, SqlColumnType.SMALLINT, (short) Byte.MAX_VALUE);\n+        checkColumn(Byte.MIN_VALUE, SqlColumnType.SMALLINT, (short) (Byte.MAX_VALUE + 1));\n+\n+        checkColumn((short) 0, SqlColumnType.INTEGER, 0);\n+        checkColumn((short) 1, SqlColumnType.INTEGER, 1);\n+        checkColumn((short) -1, SqlColumnType.INTEGER, 1);\n+        checkColumn(Short.MAX_VALUE, SqlColumnType.INTEGER, (int) Short.MAX_VALUE);\n+        checkColumn(Short.MIN_VALUE, SqlColumnType.INTEGER, Short.MAX_VALUE + 1);\n+\n+        checkColumn(0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn(1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(-1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Integer.MAX_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE);\n+        checkColumn(Integer.MIN_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE + 1);\n+\n+        checkColumn((long) 0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn((long) 1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn((long) -1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Long.MAX_VALUE, SqlColumnType.BIGINT, Long.MAX_VALUE);\n+        checkColumnFailure(Long.MIN_VALUE, SqlErrorCode.DATA_EXCEPTION, \"BIGINT overflow in ABS function (consider adding an explicit CAST to DECIMAL)\");\n+\n+        checkColumn(BigInteger.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigInteger.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigInteger.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(BigDecimal.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigDecimal.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigDecimal.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn((float) 0, SqlColumnType.REAL, (float) 0);\n+        checkColumn((float) 1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn((float) -1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn(Float.MAX_VALUE, SqlColumnType.REAL, Float.MAX_VALUE);\n+        checkColumn(Float.MIN_VALUE, SqlColumnType.REAL, Math.abs(Float.MIN_VALUE));\n+        checkColumn(Float.POSITIVE_INFINITY, SqlColumnType.REAL, Float.POSITIVE_INFINITY);\n+        checkColumn(Float.NEGATIVE_INFINITY, SqlColumnType.REAL, Float.POSITIVE_INFINITY);\n+        checkColumn(Float.NaN, SqlColumnType.REAL, Float.NaN);", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzODc1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470438756", "bodyText": "Added missing tests", "author": "devozerov", "createdAt": "2020-08-14T06:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNTY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ5OTE1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470499155", "bodyText": "Also all other tests need it I think, maybe all subclasses of SqlExpressionIntegrationTestSupport", "author": "viliam-durina", "createdAt": "2020-08-14T08:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNTY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwMjI2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470502262", "bodyText": "-0.0f and -0.0d produces interesting results only in the case of ABS. Note that the test coverage is not meant to be exhaustive, because it will take too much time to tests all possible permutations and special values. Instead, these tests aimed to cover interesting scenarios that are specific for the given operator.", "author": "devozerov", "createdAt": "2020-08-14T09:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNTY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "474282c2fda86b821e4666ea6ada8bff548f4f89", "chunk": "diff --git a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java\nindex bc385fc5961..389bcd577a8 100644\n--- a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java\n+++ b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java\n\n@@ -16,54 +16,23 @@\n \n package com.hazelcast.sql.impl.expression.math;\n \n-import com.hazelcast.core.HazelcastInstance;\n-import com.hazelcast.map.IMap;\n import com.hazelcast.sql.SqlColumnType;\n import com.hazelcast.sql.SqlErrorCode;\n-import com.hazelcast.sql.SqlException;\n-import com.hazelcast.sql.SqlRow;\n-import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n import com.hazelcast.sql.support.expressions.ExpressionValue;\n import com.hazelcast.test.HazelcastParallelClassRunner;\n-import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n-import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.List;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class AbsFunctionIntegrationTest extends SqlTestSupport {\n-\n-    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n-    private HazelcastInstance member;\n-    private IMap map;\n-\n-    @Before\n-    public void before() {\n-        member = factory.newHazelcastInstance();\n-\n-        map = member.getMap(\"map\");\n-    }\n-\n-    @After\n-    public void after() {\n-        factory.shutdownAll();\n-    }\n-\n+public class AbsFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n     @Test\n     public void testColumn() {\n         checkColumn((byte) 0, SqlColumnType.SMALLINT, (short) 0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNjA2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469936063", "bodyText": "Float.MIN_VALUE is a positive number actually...", "author": "viliam-durina", "createdAt": "2020-08-13T13:05:58Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class AbsFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testColumn() {\n+        checkColumn((byte) 0, SqlColumnType.SMALLINT, (short) 0);\n+        checkColumn((byte) 1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn((byte) -1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn(Byte.MAX_VALUE, SqlColumnType.SMALLINT, (short) Byte.MAX_VALUE);\n+        checkColumn(Byte.MIN_VALUE, SqlColumnType.SMALLINT, (short) (Byte.MAX_VALUE + 1));\n+\n+        checkColumn((short) 0, SqlColumnType.INTEGER, 0);\n+        checkColumn((short) 1, SqlColumnType.INTEGER, 1);\n+        checkColumn((short) -1, SqlColumnType.INTEGER, 1);\n+        checkColumn(Short.MAX_VALUE, SqlColumnType.INTEGER, (int) Short.MAX_VALUE);\n+        checkColumn(Short.MIN_VALUE, SqlColumnType.INTEGER, Short.MAX_VALUE + 1);\n+\n+        checkColumn(0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn(1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(-1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Integer.MAX_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE);\n+        checkColumn(Integer.MIN_VALUE, SqlColumnType.BIGINT, (long) Integer.MAX_VALUE + 1);\n+\n+        checkColumn((long) 0, SqlColumnType.BIGINT, (long) 0);\n+        checkColumn((long) 1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn((long) -1, SqlColumnType.BIGINT, (long) 1);\n+        checkColumn(Long.MAX_VALUE, SqlColumnType.BIGINT, Long.MAX_VALUE);\n+        checkColumnFailure(Long.MIN_VALUE, SqlErrorCode.DATA_EXCEPTION, \"BIGINT overflow in ABS function (consider adding an explicit CAST to DECIMAL)\");\n+\n+        checkColumn(BigInteger.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigInteger.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigInteger.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(BigDecimal.ZERO, SqlColumnType.DECIMAL, BigDecimal.ZERO);\n+        checkColumn(BigDecimal.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(BigDecimal.ONE.negate(), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn((float) 0, SqlColumnType.REAL, (float) 0);\n+        checkColumn((float) 1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn((float) -1.1, SqlColumnType.REAL, (float) 1.1);\n+        checkColumn(Float.MAX_VALUE, SqlColumnType.REAL, Float.MAX_VALUE);\n+        checkColumn(Float.MIN_VALUE, SqlColumnType.REAL, Math.abs(Float.MIN_VALUE));", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzOTQwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470439403", "bodyText": "Removed these tests", "author": "devozerov", "createdAt": "2020-08-14T06:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNjA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "474282c2fda86b821e4666ea6ada8bff548f4f89", "chunk": "diff --git a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java\nindex bc385fc5961..389bcd577a8 100644\n--- a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java\n+++ b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java\n\n@@ -16,54 +16,23 @@\n \n package com.hazelcast.sql.impl.expression.math;\n \n-import com.hazelcast.core.HazelcastInstance;\n-import com.hazelcast.map.IMap;\n import com.hazelcast.sql.SqlColumnType;\n import com.hazelcast.sql.SqlErrorCode;\n-import com.hazelcast.sql.SqlException;\n-import com.hazelcast.sql.SqlRow;\n-import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n import com.hazelcast.sql.support.expressions.ExpressionValue;\n import com.hazelcast.test.HazelcastParallelClassRunner;\n-import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n-import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.List;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class AbsFunctionIntegrationTest extends SqlTestSupport {\n-\n-    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n-    private HazelcastInstance member;\n-    private IMap map;\n-\n-    @Before\n-    public void before() {\n-        member = factory.newHazelcastInstance();\n-\n-        map = member.getMap(\"map\");\n-    }\n-\n-    @After\n-    public void after() {\n-        factory.shutdownAll();\n-    }\n-\n+public class AbsFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n     @Test\n     public void testColumn() {\n         checkColumn((byte) 0, SqlColumnType.SMALLINT, (short) 0);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzODMzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469938336", "bodyText": "We should test a good string literal too.", "author": "viliam-durina", "createdAt": "2020-08-13T13:09:39Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/CeilFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class CeilFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testColumn() {\n+        checkColumn((byte) 1, SqlColumnType.TINYINT, (byte) 1);\n+        checkColumn((short) 1, SqlColumnType.SMALLINT, (short) 1);\n+        checkColumn(1, SqlColumnType.INTEGER, 1);\n+        checkColumn(1L, SqlColumnType.BIGINT, 1L);\n+        checkColumn(0.9f, SqlColumnType.REAL, 1f);\n+        checkColumn(0.9d, SqlColumnType.DOUBLE, 1d);\n+        checkColumn(BigInteger.ONE, SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn(new BigDecimal(\"0.9\"), SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(\"0.9\", SqlColumnType.DECIMAL, BigDecimal.ONE);\n+        checkColumn('1', SqlColumnType.DECIMAL, BigDecimal.ONE);\n+\n+        checkColumn(Float.POSITIVE_INFINITY, SqlColumnType.REAL, Float.POSITIVE_INFINITY);\n+        checkColumn(Float.NEGATIVE_INFINITY, SqlColumnType.REAL, Float.NEGATIVE_INFINITY);\n+        checkColumn(Float.NaN, SqlColumnType.REAL, Float.NaN);\n+\n+        checkColumn(Double.POSITIVE_INFINITY, SqlColumnType.DOUBLE, Double.POSITIVE_INFINITY);\n+        checkColumn(Double.NEGATIVE_INFINITY, SqlColumnType.DOUBLE, Double.NEGATIVE_INFINITY);\n+        checkColumn(Double.NaN, SqlColumnType.DOUBLE, Double.NaN);\n+\n+        map.clear();\n+        map.put(0, new ExpressionValue.IntegerVal());\n+        assertNull(execute(\"field1\", SqlColumnType.INTEGER));\n+\n+        checkColumnFailure(\"bad\", SqlErrorCode.DATA_EXCEPTION, \"Cannot convert VARCHAR to DECIMAL\");\n+        checkColumnFailure('b', SqlErrorCode.DATA_EXCEPTION, \"Cannot convert VARCHAR to DECIMAL\");\n+        checkColumnFailure(new ExpressionValue.ObjectVal(), SqlErrorCode.PARSING, \"Cannot apply 'CEIL' to arguments of type 'CEIL(<OBJECT>)'\");\n+    }\n+\n+    private void checkColumn(Object value, SqlColumnType expectedType, Object expectedResult) {\n+        map.clear();\n+        map.put(0, value);\n+\n+        Object res = execute(\"this\", expectedType);\n+        assertEquals(expectedResult, res);\n+    }\n+\n+    private void checkColumnFailure(Object value, int expectedErrorCode, String expectedErrorMessage) {\n+        map.clear();\n+        map.put(0, value);\n+\n+        checkFailure(\"this\", expectedErrorCode, expectedErrorMessage);\n+    }\n+\n+    @Test\n+    public void testParameter() {\n+        map.put(0, 0);\n+\n+        checkParameter((byte) 1, BigDecimal.ONE);\n+        checkParameter((short) 1, BigDecimal.ONE);\n+        checkParameter(1, BigDecimal.ONE);\n+        checkParameter(1L, BigDecimal.ONE);\n+        checkParameter(0.9f, BigDecimal.ONE);\n+        checkParameter(0.9d, BigDecimal.ONE);\n+        checkParameter(BigInteger.ONE, BigDecimal.ONE);\n+        checkParameter(new BigDecimal(\"0.9\"), BigDecimal.ONE);\n+\n+        checkParameter(\"0.9\", BigDecimal.ONE);\n+        checkParameter('1', BigDecimal.ONE);\n+\n+        assertNull(execute(\"?\", SqlColumnType.DECIMAL, new Object[] { null }));\n+\n+        checkFailure(\"?\", SqlErrorCode.DATA_EXCEPTION, \"Failed to convert parameter at position 0 from VARCHAR to DECIMAL\", \"bad\");\n+        checkFailure(\"?\", SqlErrorCode.DATA_EXCEPTION, \"Failed to convert parameter at position 0 from VARCHAR to DECIMAL\", 'b');\n+        checkFailure(\"?\", SqlErrorCode.DATA_EXCEPTION, \"Failed to convert parameter at position 0 from OBJECT to DECIMAL\", new ExpressionValue.ObjectVal());\n+    }\n+\n+    private void checkParameter(Object param, Object expectedResult) {\n+        Object res = execute(\"?\", SqlColumnType.DECIMAL, param);\n+        assertEquals(res, expectedResult);\n+    }\n+\n+    @Test\n+    public void testLiteral() {\n+        map.put(0, 0);\n+\n+        checkLiteral(1, SqlColumnType.TINYINT, (byte) 1);\n+\n+        checkLiteral(\"null\", SqlColumnType.DECIMAL, null);\n+        checkLiteral(\"1.1\", SqlColumnType.DECIMAL, new BigDecimal(\"2\"));\n+        checkLiteral(\"1.1E0\", SqlColumnType.DOUBLE, 2d);\n+\n+        checkFailure(\"'bad'\", SqlErrorCode.PARSING, \"Literal ''bad'' can not be parsed to type 'DECIMAL'\");", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MDI1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470440252", "bodyText": "Added missing tests to CEIL/FLOOR test classes", "author": "devozerov", "createdAt": "2020-08-14T06:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzODMzNg=="}], "type": "inlineReview", "revised_code": {"commit": "474282c2fda86b821e4666ea6ada8bff548f4f89", "chunk": "diff --git a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/CeilFunctionIntegrationTest.java b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/CeilFunctionIntegrationTest.java\nindex 95894177d31..9fdd973657c 100644\n--- a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/CeilFunctionIntegrationTest.java\n+++ b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/CeilFunctionIntegrationTest.java\n\n@@ -16,55 +16,23 @@\n \n package com.hazelcast.sql.impl.expression.math;\n \n-import com.hazelcast.core.HazelcastInstance;\n-import com.hazelcast.map.IMap;\n import com.hazelcast.sql.SqlColumnType;\n import com.hazelcast.sql.SqlErrorCode;\n-import com.hazelcast.sql.SqlException;\n-import com.hazelcast.sql.SqlRow;\n-import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n import com.hazelcast.sql.support.expressions.ExpressionValue;\n import com.hazelcast.test.HazelcastParallelClassRunner;\n-import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n-import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.List;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class CeilFunctionIntegrationTest extends SqlTestSupport {\n-\n-    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n-    private HazelcastInstance member;\n-    private IMap map;\n-\n-    @Before\n-    public void before() {\n-        member = factory.newHazelcastInstance();\n-\n-        map = member.getMap(\"map\");\n-    }\n-\n-    @After\n-    public void after() {\n-        factory.shutdownAll();\n-    }\n-\n+public class CeilFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n     @Test\n     public void testColumn() {\n         checkColumn((byte) 1, SqlColumnType.TINYINT, (byte) 1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469965320", "bodyText": "We miss a test that two invocations of rand() in a single query return different value. It can be in a single row or in two rows or in the where clause: to sample 10% of rows one would use WHERE rand()<0.1", "author": "viliam-durina", "createdAt": "2020-08-13T13:49:36Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/RandFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.SqlException;\n+import com.hazelcast.sql.SqlRow;\n+import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class RandFunctionIntegrationTest extends SqlTestSupport {\n+\n+    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n+    private HazelcastInstance member;\n+    private IMap map;\n+\n+    @Before\n+    public void before() {\n+        member = factory.newHazelcastInstance();\n+\n+        map = member.getMap(\"map\");\n+    }\n+\n+    @After\n+    public void after() {\n+        factory.shutdownAll();\n+    }\n+\n+    @Test\n+    public void testNoArg() {\n+        map.put(0, 0);\n+\n+        double res1 = execute(\"\");\n+        double res2 = execute(\"\");\n+\n+        assertNotEquals(res1, res2);", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MjM1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470442355", "bodyText": "Added a test", "author": "devozerov", "createdAt": "2020-08-14T06:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwMDIyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470500220", "bodyText": "Shouldn't we also test SELECT rand(), rand() FROM map? Maybe also in the WHERE clause.", "author": "viliam-durina", "createdAt": "2020-08-14T08:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwMDc3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470500775", "bodyText": "I do not think we need it. The function doesn't depend on the context of a row or specific placement in the query.", "author": "devozerov", "createdAt": "2020-08-14T08:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwNTY3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470505675", "bodyText": "I know it will work now, but the purpose of the test is to document the behavior so that it doesn't change in the future due to some optimization. It's easy to write such a test.", "author": "viliam-durina", "createdAt": "2020-08-14T09:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3MjczNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470572736", "bodyText": "Extended the test to invoke the function several times for a row", "author": "devozerov", "createdAt": "2020-08-14T11:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2NTMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "474282c2fda86b821e4666ea6ada8bff548f4f89", "chunk": "diff --git a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/RandFunctionIntegrationTest.java b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/RandFunctionIntegrationTest.java\nindex 61c256a5cf2..2aff8899d95 100644\n--- a/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/RandFunctionIntegrationTest.java\n+++ b/hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/RandFunctionIntegrationTest.java\n\n@@ -16,62 +16,32 @@\n \n package com.hazelcast.sql.impl.expression.math;\n \n-import com.hazelcast.core.HazelcastInstance;\n-import com.hazelcast.map.IMap;\n import com.hazelcast.sql.SqlColumnType;\n import com.hazelcast.sql.SqlErrorCode;\n-import com.hazelcast.sql.SqlException;\n-import com.hazelcast.sql.SqlRow;\n-import com.hazelcast.sql.impl.SqlTestSupport;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n import com.hazelcast.sql.support.expressions.ExpressionValue;\n import com.hazelcast.test.HazelcastParallelClassRunner;\n-import com.hazelcast.test.TestHazelcastInstanceFactory;\n import com.hazelcast.test.annotation.ParallelJVMTest;\n import com.hazelcast.test.annotation.QuickTest;\n-import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.junit.experimental.categories.Category;\n import org.junit.runner.RunWith;\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.List;\n import java.util.Random;\n \n-import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n-@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n @RunWith(HazelcastParallelClassRunner.class)\n @Category({QuickTest.class, ParallelJVMTest.class})\n-public class RandFunctionIntegrationTest extends SqlTestSupport {\n-\n-    private final TestHazelcastInstanceFactory factory = new TestHazelcastInstanceFactory(1);\n-    private HazelcastInstance member;\n-    private IMap map;\n-\n-    @Before\n-    public void before() {\n-        member = factory.newHazelcastInstance();\n-\n-        map = member.getMap(\"map\");\n-    }\n-\n-    @After\n-    public void after() {\n-        factory.shutdownAll();\n-    }\n-\n+public class RandFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n     @Test\n     public void testNoArg() {\n-        map.put(0, 0);\n+        put(0);\n \n-        double res1 = execute(\"\");\n-        double res2 = execute(\"\");\n+        double res1 = checkValue(\"\", SKIP_VALUE_CHECK);\n+        double res2 = checkValue(\"\", SKIP_VALUE_CHECK);\n \n         assertNotEquals(res1, res2);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NTEzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469975131", "bodyText": "We can also do this if operand2 is a constant expression that is >=0", "author": "viliam-durina", "createdAt": "2020-08-13T14:03:09Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+\n+/**\n+ * Implementation of ROUND/TRUNCATE functions.\n+ */\n+public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    private boolean truncate;\n+\n+    public RoundTruncateFunction() {\n+        // No-op.\n+    }\n+\n+    private RoundTruncateFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType, boolean truncate) {\n+        super(operand1, operand2, resultType);\n+\n+        this.truncate = truncate;\n+    }\n+\n+    public static Expression<?> create(\n+        Expression<?> operand1,\n+        Expression<?> operand2,\n+        QueryDataType resultType,\n+        boolean truncate\n+    ) {\n+        if (operand2 == null) {\n+            QueryDataType operand1Type = operand1.getType();\n+\n+            // No conversion is expected for non-fractional types when the length operand is not defined.\n+            if (MathFunctionUtils.notFractional(operand1Type) && operand1Type == resultType) {\n+                return operand1;", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MjkzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470442936", "bodyText": "This is not trivial to implement, because the constant is often wrapped into a CAST operator due to type coercion.", "author": "devozerov", "createdAt": "2020-08-14T06:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NTEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3NTY5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470575695", "bodyText": "Could you please give some examples of queries producing such literals wrapped into CAST? Usually, a literal cast should be either unnecessary or evaluated statically. If we are frequently producing such casts at runtime, that should be considered as a potential performance issue.", "author": "taburet", "createdAt": "2020-08-14T11:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk3NTEzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "71084cebcb6c919e0639a367f33369499f968d0d", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\nindex 0df280f604f..260b6e5b3eb 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\n\n@@ -59,7 +59,9 @@ public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements\n             QueryDataType operand1Type = operand1.getType();\n \n             // No conversion is expected for non-fractional types when the length operand is not defined.\n-            if (MathFunctionUtils.notFractional(operand1Type) && operand1Type == resultType) {\n+            if (MathFunctionUtils.notFractional(operand1Type)) {\n+                assert operand1Type == resultType;\n+\n                 return operand1;\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk4ODY3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469988674", "bodyText": "These methods are unused.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Class<? extends ExpressionBiValue> createBiClass(ExpressionType<?> type1, ExpressionType<?> type2) {\n          \n          \n            \n                    return createBiClass(type1.typeName(), type2.typeName());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static Class<? extends ExpressionBiValue> createBiClass(String type1, String type2) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        String className = ExpressionBiValue.class.getName() + \"$\" + type1 + type2 + \"Val\";\n          \n          \n            \n            \n          \n          \n            \n                        return (Class<? extends ExpressionBiValue>) Class.forName(className);\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Cannot create \" + ExpressionBiValue.class.getSimpleName() + \" for types \\\"\"\n          \n          \n            \n                            + type1 + \"\\\" and \\\"\" + type2 + \"\\\"\", e);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                public static <T extends ExpressionBiValue> T createBiValue(Class<? extends ExpressionBiValue> clazz) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        return (T) clazz.newInstance();\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static <T extends ExpressionBiValue> T createBiValue(\n          \n          \n            \n                    Class<? extends ExpressionBiValue> clazz,\n          \n          \n            \n                    int key,\n          \n          \n            \n                    Object field1,\n          \n          \n            \n                    Object field2\n          \n          \n            \n                ) {\n          \n          \n            \n                    T res = create(clazz);\n          \n          \n            \n            \n          \n          \n            \n                    res.key = key;\n          \n          \n            \n                    res.field1(field1);\n          \n          \n            \n                    res.field2(field2);\n          \n          \n            \n            \n          \n          \n            \n                    return res;\n          \n          \n            \n                }", "author": "viliam-durina", "createdAt": "2020-08-13T14:21:25Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionBiValue.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@SuppressWarnings({\"unused\", \"unchecked\", \"checkstyle:MultipleVariableDeclarations\"})\n+public abstract class ExpressionBiValue extends ExpressionValue {\n+    public static Class<? extends ExpressionBiValue> createBiClass(ExpressionType<?> type1, ExpressionType<?> type2) {\n+        return createBiClass(type1.typeName(), type2.typeName());\n+    }\n+\n+    public static Class<? extends ExpressionBiValue> createBiClass(String type1, String type2) {\n+        try {\n+            String className = ExpressionBiValue.class.getName() + \"$\" + type1 + type2 + \"Val\";\n+\n+            return (Class<? extends ExpressionBiValue>) Class.forName(className);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Cannot create \" + ExpressionBiValue.class.getSimpleName() + \" for types \\\"\"\n+                + type1 + \"\\\" and \\\"\" + type2 + \"\\\"\", e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends ExpressionBiValue> T createBiValue(Class<? extends ExpressionBiValue> clazz) {\n+        try {\n+            return (T) clazz.newInstance();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n+        }\n+    }\n+\n+    public static <T extends ExpressionBiValue> T createBiValue(\n+        Class<? extends ExpressionBiValue> clazz,\n+        int key,\n+        Object field1,\n+        Object field2\n+    ) {\n+        T res = create(clazz);\n+\n+        res.key = key;\n+        res.field1(field1);\n+        res.field2(field2);\n+\n+        return res;\n+    }", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0MzMxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470443314", "bodyText": "These classes form a tiny framework for expression testing. In this specific PR, they are not used, but more usages will be added in the subsequent PRs with predicates and other expressions.", "author": "devozerov", "createdAt": "2020-08-14T06:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk4ODY3NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTI3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995278", "bodyText": "Whole class unused.", "author": "viliam-durina", "createdAt": "2020-08-13T14:29:50Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionPredicates.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import java.util.function.Predicate;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public final class ExpressionPredicates {", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTQ4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995487", "bodyText": "Whole class unused.", "author": "viliam-durina", "createdAt": "2020-08-13T14:30:06Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionType.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public abstract class ExpressionType<T> {", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTY2Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995667", "bodyText": "Whole class unused.", "author": "viliam-durina", "createdAt": "2020-08-13T14:30:21Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionTypes.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+public final class ExpressionTypes {", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NTk5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469995993", "bodyText": "Methods and field unused.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public int key;\n          \n          \n            \n            \n          \n          \n            \n                public static Class<? extends ExpressionValue> createClass(ExpressionType<?> type) {\n          \n          \n            \n                    return createClass(type.typeName());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static Class<? extends ExpressionValue> createClass(String type) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        String className = ExpressionValue.class.getName() + \"$\" + type + \"Val\";\n          \n          \n            \n            \n          \n          \n            \n                        return (Class<? extends ExpressionValue>) Class.forName(className);\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Cannot create \" + ExpressionValue.class.getSimpleName() + \" for type \\\"\"\n          \n          \n            \n                            + type + \"\\\"\", e);\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz) {\n          \n          \n            \n                    try {\n          \n          \n            \n                        return (T) clazz.newInstance();\n          \n          \n            \n                    } catch (ReflectiveOperationException e) {\n          \n          \n            \n                        throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz, int key, Object field) {\n          \n          \n            \n                    T res = create(clazz);\n          \n          \n            \n            \n          \n          \n            \n                    res.key = key;\n          \n          \n            \n                    res.field1(field);\n          \n          \n            \n            \n          \n          \n            \n                    return res;\n          \n          \n            \n                }", "author": "viliam-durina", "createdAt": "2020-08-13T14:30:45Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/support/expressions/ExpressionValue.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.support.expressions;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@SuppressWarnings({\"unused\", \"unchecked, checkstyle:MultipleVariableDeclarations\"})\n+public abstract class ExpressionValue implements Serializable {\n+\n+    public int key;\n+\n+    public static Class<? extends ExpressionValue> createClass(ExpressionType<?> type) {\n+        return createClass(type.typeName());\n+    }\n+\n+    public static Class<? extends ExpressionValue> createClass(String type) {\n+        try {\n+            String className = ExpressionValue.class.getName() + \"$\" + type + \"Val\";\n+\n+            return (Class<? extends ExpressionValue>) Class.forName(className);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Cannot create \" + ExpressionValue.class.getSimpleName() + \" for type \\\"\"\n+                + type + \"\\\"\", e);\n+        }\n+    }\n+\n+    public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz) {\n+        try {\n+            return (T) clazz.newInstance();\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"Failed to create an instance of \" + clazz.getSimpleName());\n+        }\n+    }\n+\n+    public static <T extends ExpressionValue> T create(Class<? extends ExpressionValue> clazz, int key, Object field) {\n+        T res = create(clazz);\n+\n+        res.key = key;\n+        res.field1(field);\n+\n+        return res;\n+    }", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NzIxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r469997217", "bodyText": "Might be better to name these FUNCTION_x", "author": "viliam-durina", "createdAt": "2020-08-13T14:32:30Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java", "diffHunk": "@@ -123,7 +129,14 @@\n     public static final int EXPRESSION_IS_NOT_FALSE = 39;\n     public static final int EXPRESSION_IS_NOT_NULL = 40;\n \n-    public static final int LEN = EXPRESSION_IS_NOT_NULL + 1;\n+    public static final int EXPRESSION_ABS = 41;\n+    public static final int EXPRESSION_SIGN = 42;\n+    public static final int EXPRESSION_RAND = 43;\n+    public static final int EXPRESSION_DOUBLE = 44;\n+    public static final int EXPRESSION_FLOOR_CEIL = 45;\n+    public static final int EXPRESSION_ROUND_TRUNCATE = 46;", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0Mzc5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470443792", "bodyText": "We name them this way because the relevant classes all extend com.hazelcast.sql.impl.expression.Expression class. I.e. they are all expressions in a sense, that they accept one or more argument, and produce the result. There is no principal difference between, say, functions, predicates, or special operators such as CAST, CASE, etc.", "author": "devozerov", "createdAt": "2020-08-14T06:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NzIxNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTA5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470405095", "bodyText": "notAny?", "author": "taburet", "createdAt": "2020-08-14T04:35:10Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -263,6 +267,71 @@\n \n     //#endregion\n \n+    //#region Math functions.\n+\n+    public static final SqlFunction ABS = new SqlFunction(\n+        \"ABS\",\n+        SqlKind.OTHER_FUNCTION,\n+        HazelcastReturnTypes.UNARY_MINUS,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC_OR_INTERVAL),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction SIGN = new SqlFunction(\n+        \"SIGN\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction RAND = new SqlFunction(\n+        \"RAND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.DOUBLE,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        OperandTypes.or(OperandTypes.NILADIC, notAny(OperandTypes.NUMERIC)),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction COS = new HazelcastDoubleFunction(\"COS\");\n+    public static final SqlFunction SIN = new HazelcastDoubleFunction(\"SIN\");\n+    public static final SqlFunction TAN = new HazelcastDoubleFunction(\"TAN\");\n+    public static final SqlFunction COT = new HazelcastDoubleFunction(\"COT\");\n+    public static final SqlFunction ACOS = new HazelcastDoubleFunction(\"ACOS\");\n+    public static final SqlFunction ASIN = new HazelcastDoubleFunction(\"ASIN\");\n+    public static final SqlFunction ATAN = new HazelcastDoubleFunction(\"ATAN\");\n+    public static final SqlFunction EXP = new HazelcastDoubleFunction(\"EXP\");\n+    public static final SqlFunction LN = new HazelcastDoubleFunction(\"LN\");\n+    public static final SqlFunction LOG10 = new HazelcastDoubleFunction(\"LOG10\");\n+    public static final SqlFunction DEGREES = new HazelcastDoubleFunction(\"DEGREES\");\n+    public static final SqlFunction RADIANS = new HazelcastDoubleFunction(\"RADIANS\");\n+\n+    public static final SqlFunction FLOOR = new HazelcastSqlFloorFunction(SqlKind.FLOOR);\n+    public static final SqlFunction CEIL = new HazelcastSqlFloorFunction(SqlKind.CEIL);\n+\n+    public static final SqlFunction ROUND = new SqlFunction(\n+        \"ROUND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0_NULLABLE,\n+        HazelcastInferTypes.ROUND,\n+        OperandTypes.NUMERIC_OPTIONAL_INTEGER,", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0NjA0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470446046", "bodyText": "Fixed in 95442d9", "author": "devozerov", "createdAt": "2020-08-14T07:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "95442d9b91abe7324b404b3fee044505319410ce", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\nindex 8fabdc73907..b340740c1e0 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n\n@@ -317,7 +317,7 @@ public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable\n         SqlKind.OTHER_FUNCTION,\n         ReturnTypes.ARG0_NULLABLE,\n         HazelcastInferTypes.ROUND,\n-        OperandTypes.NUMERIC_OPTIONAL_INTEGER,\n+        notAny(OperandTypes.NUMERIC_OPTIONAL_INTEGER),\n         SqlFunctionCategory.NUMERIC\n     );\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTE1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470405153", "bodyText": "notAny?", "author": "taburet", "createdAt": "2020-08-14T04:35:25Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -263,6 +267,71 @@\n \n     //#endregion\n \n+    //#region Math functions.\n+\n+    public static final SqlFunction ABS = new SqlFunction(\n+        \"ABS\",\n+        SqlKind.OTHER_FUNCTION,\n+        HazelcastReturnTypes.UNARY_MINUS,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC_OR_INTERVAL),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction SIGN = new SqlFunction(\n+        \"SIGN\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        notAny(OperandTypes.NUMERIC),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction RAND = new SqlFunction(\n+        \"RAND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.DOUBLE,\n+        HazelcastInferTypes.DECIMAL_IF_UNKNOWN,\n+        OperandTypes.or(OperandTypes.NILADIC, notAny(OperandTypes.NUMERIC)),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction COS = new HazelcastDoubleFunction(\"COS\");\n+    public static final SqlFunction SIN = new HazelcastDoubleFunction(\"SIN\");\n+    public static final SqlFunction TAN = new HazelcastDoubleFunction(\"TAN\");\n+    public static final SqlFunction COT = new HazelcastDoubleFunction(\"COT\");\n+    public static final SqlFunction ACOS = new HazelcastDoubleFunction(\"ACOS\");\n+    public static final SqlFunction ASIN = new HazelcastDoubleFunction(\"ASIN\");\n+    public static final SqlFunction ATAN = new HazelcastDoubleFunction(\"ATAN\");\n+    public static final SqlFunction EXP = new HazelcastDoubleFunction(\"EXP\");\n+    public static final SqlFunction LN = new HazelcastDoubleFunction(\"LN\");\n+    public static final SqlFunction LOG10 = new HazelcastDoubleFunction(\"LOG10\");\n+    public static final SqlFunction DEGREES = new HazelcastDoubleFunction(\"DEGREES\");\n+    public static final SqlFunction RADIANS = new HazelcastDoubleFunction(\"RADIANS\");\n+\n+    public static final SqlFunction FLOOR = new HazelcastSqlFloorFunction(SqlKind.FLOOR);\n+    public static final SqlFunction CEIL = new HazelcastSqlFloorFunction(SqlKind.CEIL);\n+\n+    public static final SqlFunction ROUND = new SqlFunction(\n+        \"ROUND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0_NULLABLE,\n+        HazelcastInferTypes.ROUND,\n+        OperandTypes.NUMERIC_OPTIONAL_INTEGER,\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction TRUNCATE = new SqlFunction(\n+        \"TRUNCATE\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0_NULLABLE,\n+        HazelcastInferTypes.ROUND,\n+        OperandTypes.NUMERIC_OPTIONAL_INTEGER,", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0NjAxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470446013", "bodyText": "Fixed in 95442d9", "author": "devozerov", "createdAt": "2020-08-14T07:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwNTE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "95442d9b91abe7324b404b3fee044505319410ce", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\nindex 8fabdc73907..b340740c1e0 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n\n@@ -317,7 +317,7 @@ public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable\n         SqlKind.OTHER_FUNCTION,\n         ReturnTypes.ARG0_NULLABLE,\n         HazelcastInferTypes.ROUND,\n-        OperandTypes.NUMERIC_OPTIONAL_INTEGER,\n+        notAny(OperandTypes.NUMERIC_OPTIONAL_INTEGER),\n         SqlFunctionCategory.NUMERIC\n     );\n \n"}}, {"oid": "298a55b287a0d68f302eb17d2189e10cb7aa10cc", "url": "https://github.com/hazelcast/hazelcast/commit/298a55b287a0d68f302eb17d2189e10cb7aa10cc", "message": "Merge branch 'master' into issues/17339\n\n# Conflicts:\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java", "committedDate": "2020-08-14T06:01:45Z", "type": "commit"}, {"oid": "474282c2fda86b821e4666ea6ada8bff548f4f89", "url": "https://github.com/hazelcast/hazelcast/commit/474282c2fda86b821e4666ea6ada8bff548f4f89", "message": "Refactored tests", "committedDate": "2020-08-14T06:35:15Z", "type": "commit"}, {"oid": "e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "url": "https://github.com/hazelcast/hazelcast/commit/e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "message": "ABS tests for negative zero", "committedDate": "2020-08-14T06:40:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzOTA1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470439056", "bodyText": "Kind of strange to infer it as a decimal for a function accepting only double.", "author": "taburet", "createdAt": "2020-08-14T06:41:51Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n+/**\n+ * Function that accepts a DOUBLE argument and produces a DOUBLE result.\n+ */\n+public class HazelcastDoubleFunction extends SqlFunction {\n+    public HazelcastDoubleFunction(String name) {\n+        super(\n+            name,\n+            SqlKind.OTHER_FUNCTION,\n+            ReturnTypes.DOUBLE_NULLABLE,\n+            HazelcastInferTypes.DECIMAL_IF_UNKNOWN,", "originalCommit": "977c38cd535043f2127d900b5cab6a69656cf3cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ0OTY5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470449696", "bodyText": "Fixed in 95442d9\nThe same problem was for RAND - we inferred DECIMAL, while the function expected BIGINT.", "author": "devozerov", "createdAt": "2020-08-14T07:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzOTA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d466387bbc40ac2977bf76730cb827e30455df61", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java\nindex 2e2a8da0908..4a88032dac6 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java\n\n@@ -16,12 +16,13 @@\n \n package com.hazelcast.sql.impl.calcite.validate.operators;\n \n-import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n import org.apache.calcite.sql.SqlFunction;\n import org.apache.calcite.sql.SqlFunctionCategory;\n import org.apache.calcite.sql.SqlKind;\n import org.apache.calcite.sql.type.OperandTypes;\n import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlTypeName;\n \n import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n \n"}}, {"oid": "932c75f84fdec229b719bda8067b0db573bebfda", "url": "https://github.com/hazelcast/hazelcast/commit/932c75f84fdec229b719bda8067b0db573bebfda", "message": "Removed unnecessary tests for Float.MIN_VALUE and Double.MIN_VALUE", "committedDate": "2020-08-14T06:42:31Z", "type": "commit"}, {"oid": "5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "url": "https://github.com/hazelcast/hazelcast/commit/5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "message": "Added missing test for numeric literals in single quotes for CEIL/FLOOR tests", "committedDate": "2020-08-14T06:45:08Z", "type": "commit"}, {"oid": "20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "url": "https://github.com/hazelcast/hazelcast/commit/20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "message": "Test for several rows for RAND", "committedDate": "2020-08-14T06:51:12Z", "type": "commit"}, {"oid": "95442d9b91abe7324b404b3fee044505319410ce", "url": "https://github.com/hazelcast/hazelcast/commit/95442d9b91abe7324b404b3fee044505319410ce", "message": "Added \"notAny\" to ROUND/TRUNCATE", "committedDate": "2020-08-14T07:00:40Z", "type": "commit"}, {"oid": "d466387bbc40ac2977bf76730cb827e30455df61", "url": "https://github.com/hazelcast/hazelcast/commit/d466387bbc40ac2977bf76730cb827e30455df61", "message": "Fixed inference for double functions (DECIMAL -> DOUBLE) and RAND (DECIMAL -> BIGINT)", "committedDate": "2020-08-14T07:10:09Z", "type": "commit"}, {"oid": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "url": "https://github.com/hazelcast/hazelcast/commit/cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "message": "Fixed SpotBugs problem", "committedDate": "2020-08-14T07:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ3OTE2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470479166", "bodyText": "Looks like a proper way of doing this is:\nInferTypes.explicit(singletonList(HazelcastTypeFactory.INSTANCE.createSqlType(SqlTypeName.DOUBLE)))\n\nThis basically tells Calcite that the function accepts only doubles, also there would be no need in the conversion performed in DoubleFunction.eval, something like ((Number) value).doubleValue() should do the trick, plain (double) value would not work since conversion between numeric types is not necessarily leading to CAST insertion in Calcite.", "author": "taburet", "createdAt": "2020-08-14T08:17:51Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n+\n+/**\n+ * Function that accepts a DOUBLE argument and produces a DOUBLE result.\n+ */\n+public class HazelcastDoubleFunction extends SqlFunction {\n+    public HazelcastDoubleFunction(String name) {\n+        super(\n+            name,\n+            SqlKind.OTHER_FUNCTION,\n+            ReturnTypes.DOUBLE_NULLABLE,\n+            new ReplaceUnknownOperandTypeInference(SqlTypeName.DOUBLE),", "originalCommit": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ5NDYzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470494637", "bodyText": "Applied the suggested fix", "author": "devozerov", "createdAt": "2020-08-14T08:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ3OTE2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "493b6d471f6c1fa75b02a2de74eb800763df1d97", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java\nindex 4a88032dac6..259303e52d6 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastDoubleFunction.java\n\n@@ -16,14 +16,17 @@\n \n package com.hazelcast.sql.impl.calcite.validate.operators;\n \n-import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastTypeFactory;\n import org.apache.calcite.sql.SqlFunction;\n import org.apache.calcite.sql.SqlFunctionCategory;\n import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.InferTypes;\n import org.apache.calcite.sql.type.OperandTypes;\n import org.apache.calcite.sql.type.ReturnTypes;\n import org.apache.calcite.sql.type.SqlTypeName;\n \n+import java.util.Collections;\n+\n import static com.hazelcast.sql.impl.calcite.validate.types.HazelcastOperandTypes.notAny;\n \n /**\n"}}, {"oid": "493b6d471f6c1fa75b02a2de74eb800763df1d97", "url": "https://github.com/hazelcast/hazelcast/commit/493b6d471f6c1fa75b02a2de74eb800763df1d97", "message": "Changed operand type inference for double functions", "committedDate": "2020-08-14T08:45:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ5ODMwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470498305", "bodyText": "SQRT is missing in the actual code, are there some complications with it?", "author": "taburet", "createdAt": "2020-08-14T08:53:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/DoubleFunction.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.UniExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Family of functions which accept a single double operand and return double result:\n+ *     COS, SIN, TAN, COT, ACOS, ASIN, ATAN, SQRT, EXP, LN, LOG10, DEGREES, RADIANS", "originalCommit": "493b6d471f6c1fa75b02a2de74eb800763df1d97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUwMzMzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470503333", "bodyText": "SQRT is out of scope, as mentioned in the PR description. Calcite converts SQRT to POWER. The latter is not very easy to implement and test, because it requires advanced inference rules, similar to multiply.\nFixed JavaDoc.", "author": "devozerov", "createdAt": "2020-08-14T09:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ5ODMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "883ec348410adabed42e705bc43486fd47910e34", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/DoubleFunction.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/DoubleFunction.java\nindex 200b696c95a..a8a812fdc69 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/DoubleFunction.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/DoubleFunction.java\n\n@@ -30,8 +30,7 @@ import com.hazelcast.sql.impl.type.QueryDataType;\n import java.io.IOException;\n \n /**\n- * Family of functions which accept a single double operand and return double result:\n- *     COS, SIN, TAN, COT, ACOS, ASIN, ATAN, SQRT, EXP, LN, LOG10, DEGREES, RADIANS\n+ * Family of functions which accept a single double operand and return double result.\n  */\n public class DoubleFunction extends UniExpression<Double> implements IdentifiedDataSerializable {\n \n"}}, {"oid": "883ec348410adabed42e705bc43486fd47910e34", "url": "https://github.com/hazelcast/hazelcast/commit/883ec348410adabed42e705bc43486fd47910e34", "message": "DoubleFunction: removed concrete functions from JavaDoc.", "committedDate": "2020-08-14T09:02:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUxMDYzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470510634", "bodyText": "Shouldn't it be done the same way as for DoubleFunction?", "author": "taburet", "createdAt": "2020-08-14T09:18:41Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -263,6 +272,71 @@\n \n     //#endregion\n \n+    //#region Math functions.\n+\n+    public static final SqlFunction ABS = new SqlFunction(\n+        \"ABS\",\n+        SqlKind.OTHER_FUNCTION,\n+        HazelcastReturnTypes.UNARY_MINUS,\n+        new ReplaceUnknownOperandTypeInference(DECIMAL),\n+        notAny(OperandTypes.NUMERIC_OR_INTERVAL),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction SIGN = new SqlFunction(\n+        \"SIGN\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.ARG0,\n+        new ReplaceUnknownOperandTypeInference(DECIMAL),\n+        notAny(OperandTypes.NUMERIC),\n+        SqlFunctionCategory.NUMERIC\n+    );\n+\n+    public static final SqlFunction RAND = new SqlFunction(\n+        \"RAND\",\n+        SqlKind.OTHER_FUNCTION,\n+        ReturnTypes.DOUBLE,\n+        new ReplaceUnknownOperandTypeInference(BIGINT),", "originalCommit": "883ec348410adabed42e705bc43486fd47910e34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NzY5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470567695", "bodyText": "Changed to explicit inference", "author": "devozerov", "createdAt": "2020-08-14T11:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUxMDYzNA=="}], "type": "inlineReview", "revised_code": {"commit": "f3111ee9c98418fbbe9a62cf6382f033755058d5", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\nindex 1403765e742..b7ed7e9f520 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n\n@@ -296,7 +296,7 @@ public final class HazelcastSqlOperatorTable extends ReflectiveSqlOperatorTable\n         \"RAND\",\n         SqlKind.OTHER_FUNCTION,\n         ReturnTypes.DOUBLE,\n-        new ReplaceUnknownOperandTypeInference(BIGINT),\n+        HazelcastInferTypes.explicit(BIGINT),\n         OperandTypes.or(OperandTypes.NILADIC, notAny(OperandTypes.NUMERIC)),\n         SqlFunctionCategory.NUMERIC\n     );\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU1ODg1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470558854", "bodyText": "Are conversions necessary here, if all the types are already should be inferred statically by Calcite?", "author": "taburet", "createdAt": "2020-08-14T11:04:03Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/AbsFunction.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.UniExpressionWithType;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.converter.Converter;\n+\n+import static com.hazelcast.sql.impl.expression.math.ExpressionMath.DECIMAL_MATH_CONTEXT;\n+\n+public class AbsFunction<T> extends UniExpressionWithType<T> implements IdentifiedDataSerializable {\n+    @SuppressWarnings(\"unused\")\n+    public AbsFunction() {\n+        // No-op.\n+    }\n+\n+    private AbsFunction(Expression<?> operand, QueryDataType resultType) {\n+        super(operand, resultType);\n+    }\n+\n+    public static AbsFunction<?> create(Expression<?> operand, QueryDataType resultType) {\n+        return new AbsFunction<>(operand, resultType);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        Object operandValue = operand.eval(row, context);\n+\n+        if (operandValue == null) {\n+            return null;\n+        }\n+\n+        return (T) abs(operandValue, operand.getType(), resultType);\n+    }\n+\n+    private static Object abs(Object operand, QueryDataType operandType, QueryDataType resultType) {\n+        Converter operandConverter = operandType.getConverter();\n+\n+        switch (resultType.getTypeFamily()) {\n+            case TINYINT:\n+                return (byte) Math.abs(operandConverter.asTinyint(operand));", "originalCommit": "883ec348410adabed42e705bc43486fd47910e34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2OTU4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470569589", "bodyText": "IMO there is no much difference. Converters are safer than relying on Calcite. In most cases, the return type will be the same, so the converter will not do anything except for cast from Object to a concrete type.", "author": "devozerov", "createdAt": "2020-08-14T11:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU1ODg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM1NzUzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471357536", "bodyText": "The whole idea of switching to static typing was to assign valid types statically and avoid runtime conversions as much as possible. Defensive usage of converters at runtime doesn't make it safer, it makes it more uncertain. If there are some bugs with type inference and/or implicit casts behavior for parameters of math functions, usage of converters will hide them, since converters are readily converting everything. And there are no tests similar to UnaryMinusTest verifying the actual types assigned to parameters of math functions to give confidence.", "author": "taburet", "createdAt": "2020-08-17T09:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU1ODg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTA3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471361075", "bodyText": "There were no idea to avoid runtime conversions. This specific expression works in a way that it can tolerate different inputs for so long, as values are convertible. It is not concerned with Calcite integration.", "author": "devozerov", "createdAt": "2020-08-17T09:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU1ODg1NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NTI3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470565277", "bodyText": "operandType == resultType should be always true since the return type inference is defined as ReturnTypes.ARG0_NULLABLE for ROUND and TRUNCATE, it might make sense to convert it into a general assert for this method.", "author": "taburet", "createdAt": "2020-08-14T11:20:34Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+\n+/**\n+ * Implementation of ROUND/TRUNCATE functions.\n+ */\n+public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    private boolean truncate;\n+\n+    public RoundTruncateFunction() {\n+        // No-op.\n+    }\n+\n+    private RoundTruncateFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType, boolean truncate) {\n+        super(operand1, operand2, resultType);\n+\n+        this.truncate = truncate;\n+    }\n+\n+    public static Expression<?> create(\n+        Expression<?> operand1,\n+        Expression<?> operand2,\n+        QueryDataType resultType,\n+        boolean truncate\n+    ) {\n+        if (operand2 == null) {\n+            QueryDataType operand1Type = operand1.getType();\n+\n+            // No conversion is expected for non-fractional types when the length operand is not defined.\n+            if (MathFunctionUtils.notFractional(operand1Type) && operand1Type == resultType) {", "originalCommit": "883ec348410adabed42e705bc43486fd47910e34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU3MTQyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470571424", "bodyText": "Changed to assert", "author": "devozerov", "createdAt": "2020-08-14T11:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU2NTI3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "71084cebcb6c919e0639a367f33369499f968d0d", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\nindex 0df280f604f..260b6e5b3eb 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\n\n@@ -59,7 +59,9 @@ public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements\n             QueryDataType operand1Type = operand1.getType();\n \n             // No conversion is expected for non-fractional types when the length operand is not defined.\n-            if (MathFunctionUtils.notFractional(operand1Type) && operand1Type == resultType) {\n+            if (MathFunctionUtils.notFractional(operand1Type)) {\n+                assert operand1Type == resultType;\n+\n                 return operand1;\n             }\n         }\n"}}, {"oid": "f3111ee9c98418fbbe9a62cf6382f033755058d5", "url": "https://github.com/hazelcast/hazelcast/commit/f3111ee9c98418fbbe9a62cf6382f033755058d5", "message": "Explicit inference for RAND", "committedDate": "2020-08-14T11:26:26Z", "type": "commit"}, {"oid": "71084cebcb6c919e0639a367f33369499f968d0d", "url": "https://github.com/hazelcast/hazelcast/commit/71084cebcb6c919e0639a367f33369499f968d0d", "message": "Assert types in RoundTruncateFunction", "committedDate": "2020-08-14T11:35:24Z", "type": "commit"}, {"oid": "9c400000d1523948822545362cc863d509afeabc", "url": "https://github.com/hazelcast/hazelcast/commit/9c400000d1523948822545362cc863d509afeabc", "message": "Extended tests for RAND", "committedDate": "2020-08-14T11:38:25Z", "type": "commit"}, {"oid": "63b76e16d69d95177d08f87bb4efef4f949b83c3", "url": "https://github.com/hazelcast/hazelcast/commit/63b76e16d69d95177d08f87bb4efef4f949b83c3", "message": "Checkstyle", "committedDate": "2020-08-14T11:40:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU4MzY2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470583664", "bodyText": "This line may produce a cryptic conversion error since operand type checker for ROUND and TRUNCATE is defined as NUMERIC_OPTIONAL_INTEGER. That last INTEGER is referring to SqlTypeFamily.INTEGER (not to SqlTypeName.INTEGER) and that family refers to all integer types including BIGINT. Either the type checker should allow only the compatible types or some meaningful error message should be provided.", "author": "taburet", "createdAt": "2020-08-14T12:05:36Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.BiExpressionWithType;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeFamily;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+\n+/**\n+ * Implementation of ROUND/TRUNCATE functions.\n+ */\n+public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements IdentifiedDataSerializable {\n+\n+    private boolean truncate;\n+\n+    public RoundTruncateFunction() {\n+        // No-op.\n+    }\n+\n+    private RoundTruncateFunction(Expression<?> operand1, Expression<?> operand2, QueryDataType resultType, boolean truncate) {\n+        super(operand1, operand2, resultType);\n+\n+        this.truncate = truncate;\n+    }\n+\n+    public static Expression<?> create(\n+        Expression<?> operand1,\n+        Expression<?> operand2,\n+        QueryDataType resultType,\n+        boolean truncate\n+    ) {\n+        if (operand2 == null) {\n+            QueryDataType operand1Type = operand1.getType();\n+\n+            // No conversion is expected for non-fractional types when the length operand is not defined.\n+            if (MathFunctionUtils.notFractional(operand1Type)) {\n+                assert operand1Type == resultType;\n+\n+                return operand1;\n+            }\n+        }\n+\n+        return new RoundTruncateFunction<>(operand1, operand2, resultType, truncate);\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\"})\n+    @Override\n+    public T eval(Row row, ExpressionEvalContext context) {\n+        // Get base operand.\n+        Object operand1Value = operand1.eval(row, context);\n+\n+        // NULL always yields NULL\n+        if (operand1Value == null) {\n+            return null;\n+        }\n+\n+        // Get length.\n+        Integer operand2Value = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;", "originalCommit": "63b76e16d69d95177d08f87bb4efef4f949b83c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU4ODQzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r470588438", "bodyText": "Fixed and tested in 5ce9f81", "author": "devozerov", "createdAt": "2020-08-14T12:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU4MzY2NA=="}], "type": "inlineReview", "revised_code": {"commit": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\nindex 260b6e5b3eb..9d784076413 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RoundTruncateFunction.java\n\n@@ -72,20 +72,14 @@ public class RoundTruncateFunction<T> extends BiExpressionWithType<T> implements\n     @SuppressWarnings({\"unchecked\", \"checkstyle:CyclomaticComplexity\", \"checkstyle:ReturnCount\"})\n     @Override\n     public T eval(Row row, ExpressionEvalContext context) {\n-        // Get base operand.\n         Object operand1Value = operand1.eval(row, context);\n \n-        // NULL always yields NULL\n         if (operand1Value == null) {\n             return null;\n         }\n \n-        // Get length.\n-        Integer operand2Value = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;\n+        int len = getLength(row, context);\n \n-        int len = operand2Value != null ? operand2Value : 0;\n-\n-        // Cast to expected type.\n         switch (resultType.getTypeFamily()) {\n             case TINYINT:\n                 try {\n"}}, {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "url": "https://github.com/hazelcast/hazelcast/commit/5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "message": "Added lenght overflow handling to ROUND/TRUNCATE", "committedDate": "2020-08-14T12:16:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471273772", "bodyText": "It might make sense to create Random once if seed is provided and use setSeed in eval instead of allocating a new Random on every invocation.\nWhat it the semantics of seed? Calcite's SqlRandFunction and RandomFunction define it as \"initializing the random number generator with seed on first call\".\nBTW, what thread safety level is expected for expressions? As far as I remember, Exec is not required to be thread safe and expressions belong to its state.", "author": "taburet", "createdAt": "2020-08-17T07:04:07Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/math/RandFunction.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.UniExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * Random function implementation.\n+ */\n+public class RandFunction extends UniExpression<Double> implements IdentifiedDataSerializable {\n+    public RandFunction() {\n+        // No-op.\n+    }\n+\n+    public RandFunction(Expression<?> seedExp) {\n+        super(seedExp);\n+    }\n+\n+    public static RandFunction create(Expression<?> seedExp) {\n+        return new RandFunction(seedExp);\n+    }\n+\n+    @Override\n+    public Double eval(Row row, ExpressionEvalContext context) {\n+        Long seed = operand != null ? MathFunctionUtils.asBigint(operand, row, context) : null;\n+\n+        Random random = seed != null ? new Random(seed) : ThreadLocalRandom.current();", "originalCommit": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3OTAwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471279001", "bodyText": "Naive question: why Random instead of SecureRandom?", "author": "nfrankel", "createdAt": "2020-08-17T07:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4NDg3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471284876", "bodyText": "@taburet seed could change from invocation to invocation. We do not know whether it should be used or not before the actual operand is processed. I would not complicate things, this is a micro-optimization for a function, which is mainly used for testing.\nThe state is not shared between expression instances. They are not thread-safe.", "author": "devozerov", "createdAt": "2020-08-17T07:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4NTc4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471285781", "bodyText": "@nfrankel This function doesn't have a requirement to be cryptographically strong, therefore we use the more performant implementation.", "author": "devozerov", "createdAt": "2020-08-17T07:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI4OTE3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471289172", "bodyText": "@devozerov what about semantics of seed and implied thread safety for expressions?", "author": "taburet", "createdAt": "2020-08-17T07:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI5MTg4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471291880", "bodyText": "Expressions do not have a shared state - does this answer the question?", "author": "devozerov", "createdAt": "2020-08-17T07:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI5NDYwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471294607", "bodyText": "Does that mean there should be no state to share or the state is not shared between threads?", "author": "taburet", "createdAt": "2020-08-17T07:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI5NTQ3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471295475", "bodyText": "One expression instance is not meant to have any semantical influence on the results of other expressions. Expressions are not concerned with threading at all.", "author": "devozerov", "createdAt": "2020-08-17T07:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMwMjI4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471302284", "bodyText": "To put it simple, can eval be invoked by the query execution engine from more than one thread simultaneously on the same expression instance?", "author": "taburet", "createdAt": "2020-08-17T07:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMwMjk2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471302969", "bodyText": "No. Expressions are not thread-safe. A single instance is not meant to be executed by multiple threads simultaneously.", "author": "devozerov", "createdAt": "2020-08-17T07:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI3Mzc3Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471349619", "bodyText": "Looks like there are no tests for boolean columns and parameters here and for other expressions as well.", "author": "taburet", "createdAt": "2020-08-17T09:18:22Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/math/AbsFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.math;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class AbsFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {", "originalCommit": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM1NjA1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471356050", "bodyText": "Let's collect the list of missing test cases and add them separately. Subsequent PRs fixe more problems with conversions, so it would be a waste of time adding these tests in this PR.", "author": "devozerov", "createdAt": "2020-08-17T09:30:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3MDI0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471370245", "bodyText": "Ticket: #17360", "author": "devozerov", "createdAt": "2020-08-17T09:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3MzA5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471373092", "bodyText": "Not sure how it does relate to problematic conversions, boolean-to-numeric conversion is prohibited currently and there are no plans I'm aware of to change that, it's just the tests missing, that should be easy to add them.", "author": "taburet", "createdAt": "2020-08-17T10:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3NDQ1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471374456", "bodyText": "In this specific branch parameter conversions do not work properly - it allows conversions that are otherwise explicit only. Subsequent PRs fixes that.", "author": "devozerov", "createdAt": "2020-08-17T10:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3NjEyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471376127", "bodyText": "Moreover, we have broken type inference - it also allows conversions that are otherwise explicit (e.g. INT to VARCHAR). We do not have a solution for this at the moment, neither we know the exact error messages that we will have in the future.\nThat said, these corner cases should not be critical for beta IMO", "author": "devozerov", "createdAt": "2020-08-17T10:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3NjMzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471376335", "bodyText": "Does that mean boolean can be converted to numeric for ABS in this PR?", "author": "taburet", "createdAt": "2020-08-17T10:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3NzI1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471377250", "bodyText": "No, it can't. But the error message that appears in this branch is different, from what we will have after the next PR is ready.", "author": "devozerov", "createdAt": "2020-08-17T10:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NTQzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471385436", "bodyText": "In which next PR the message would change? It shouldn't be hard to add the tests in this PR and fix a couple of error message strings here and there later. The actual error messages are not important, the fact that we are failing while converting boolean to numeric is important.", "author": "taburet", "createdAt": "2020-08-17T10:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4ODE2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471388163", "bodyText": "In the next PR with predicates. Why should we spend time on writing tests only to rewrite them later? There is no BOOLEAN-specific logic in this PR, all expressions work the same way and rely on the existing expressions code base.\nThe more expressions I implement, the more bugs I found. This requires to me rewrite tests and spend precious time that we have before code freeze. We will easily add more tests after the code freeze.\nPlease do not follow the formal approach here. Our goal is to implement as many expressions as possible before the code freeze with sensible quality. In this specific case, we know for sure that there is no BOOLEAN-specific code, so the risk is minimal; and that the tests we write now will have to be rewritten afterwards, so it is definitely a waste of time.", "author": "devozerov", "createdAt": "2020-08-17T10:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM0OTYxOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTgyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471361820", "bodyText": "It might make sense to create a test for it in HazelcastInferTypesTest.", "author": "taburet", "createdAt": "2020-08-17T09:40:38Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastInferTypes.java", "diffHunk": "@@ -80,6 +82,10 @@\n     };\n \n     private HazelcastInferTypes() {\n+        // No-op.\n     }\n \n+    public static SqlOperandTypeInference explicit(SqlTypeName typeName) {", "originalCommit": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3MDAwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471370009", "bodyText": "Created a ticket for that: #17360\nThere is a high level of confidence that it works as expected because there are integration tests that cover this", "author": "devozerov", "createdAt": "2020-08-17T09:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2MTgyMA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2NDYwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471364605", "bodyText": "Missing test in HazelcastInferTypesTest.", "author": "taburet", "createdAt": "2020-08-17T09:45:50Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/ReplaceUnknownOperandTypeInference.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.types;\n+\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.type.SqlOperandTypeInference;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+/**\n+ * Type inference, that replaces unknown operands with the given types.\n+ */\n+public class ReplaceUnknownOperandTypeInference implements SqlOperandTypeInference {", "originalCommit": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM3MDA2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17340#discussion_r471370068", "bodyText": "Created a ticket for that: #17360\nThere is a high level of confidence that it works as expected because there are integration tests that cover this", "author": "devozerov", "createdAt": "2020-08-17T09:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM2NDYwNQ=="}], "type": "inlineReview", "revised_code": null}]}