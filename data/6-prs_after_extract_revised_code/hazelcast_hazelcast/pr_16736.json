{"pr_number": 16736, "pr_title": "Disable COR on certain IMap operations", "pr_createdAt": "2020-03-10T16:57:37Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16736", "timeline": [{"oid": "fc898a101e01de3e596505d092b501317f40fe40", "url": "https://github.com/hazelcast/hazelcast/commit/fc898a101e01de3e596505d092b501317f40fe40", "message": "Disable COR on certain IMap operations", "committedDate": "2020-03-10T16:55:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzMzk2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391033968", "bodyText": "Needs javadoc. You can check out this PR for inspiration - #11479", "author": "mmedenjak", "createdAt": "2020-03-11T14:58:48Z", "path": "hazelcast/src/main/java/com/hazelcast/map/Immutable.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package com.hazelcast.map;\n+\n+public interface Immutable {", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/Immutable.java b/hazelcast/src/main/java/com/hazelcast/map/Immutable.java\nindex da306235d0d..752cde1b593 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/Immutable.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/Immutable.java\n\n@@ -1,4 +1,23 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package com.hazelcast.map;\n \n+/**\n+ * This is just a marker interface for Adobe Entities so that we can disable Copy on Read for this type\n+ */\n public interface Immutable {\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNjY1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391036659", "bodyText": "Why do you need to cast here?", "author": "mmedenjak", "createdAt": "2020-03-11T15:02:20Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "diffHunk": "@@ -170,11 +170,14 @@ public MapKeysWithCursor fetchKeys(int tableIndex, int size) {\n     public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {\n         List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n-        List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());\n+        List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = entry.getValue();\n-            Data dataValue = serializationService.toData(record.getValue());\n-            entriesData.add(new AbstractMap.SimpleEntry<Data, Data>(entry.getKey(), dataValue));\n+            R record = (R)(Record)entry.getValue();", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\nindex c73567b4a50..a9ce0ccaebb 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\n\n@@ -172,12 +173,10 @@ public class StorageImpl<R extends Record> implements Storage<Data, R> {\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n         List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = (R)(Record)entry.getValue();\n+            R record = entry.getValue();\n             Object value = record.getValue();\n-            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?\n-                    value :\n-                    serializationService.toData(value);\n-            entriesData.add(new AbstractMap.SimpleEntry((Data)entry.getKey(), dataValue));\n+            Object resultValue = (value instanceof Immutable) ? value : serializationService.toData(value);\n+            entriesData.add(new AbstractMap.SimpleEntry<Data, Object>(entry.getKey(), resultValue));\n         }\n         return new MapEntriesWithCursor(entriesData, newTableIndex);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNzM3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391037379", "bodyText": "No need to cast to Data. Also, add generics to remove the type warning - new AbstractMap.SimpleEntry<Data, Object>.", "author": "mmedenjak", "createdAt": "2020-03-11T15:03:17Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "diffHunk": "@@ -170,11 +170,14 @@ public MapKeysWithCursor fetchKeys(int tableIndex, int size) {\n     public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {\n         List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n-        List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());\n+        List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = entry.getValue();\n-            Data dataValue = serializationService.toData(record.getValue());\n-            entriesData.add(new AbstractMap.SimpleEntry<Data, Data>(entry.getKey(), dataValue));\n+            R record = (R)(Record)entry.getValue();\n+            Object value = record.getValue();\n+            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?\n+                    value :\n+                    serializationService.toData(value);\n+            entriesData.add(new AbstractMap.SimpleEntry((Data)entry.getKey(), dataValue));", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\nindex c73567b4a50..a9ce0ccaebb 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\n\n@@ -172,12 +173,10 @@ public class StorageImpl<R extends Record> implements Storage<Data, R> {\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n         List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = (R)(Record)entry.getValue();\n+            R record = entry.getValue();\n             Object value = record.getValue();\n-            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?\n-                    value :\n-                    serializationService.toData(value);\n-            entriesData.add(new AbstractMap.SimpleEntry((Data)entry.getKey(), dataValue));\n+            Object resultValue = (value instanceof Immutable) ? value : serializationService.toData(value);\n+            entriesData.add(new AbstractMap.SimpleEntry<Data, Object>(entry.getKey(), resultValue));\n         }\n         return new MapEntriesWithCursor(entriesData, newTableIndex);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzNzc0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391037748", "bodyText": "You can import this to avoid the fully-qualified class name. You can also change the variable name since this is no longer dataValue.", "author": "mmedenjak", "createdAt": "2020-03-11T15:03:45Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java", "diffHunk": "@@ -170,11 +170,14 @@ public MapKeysWithCursor fetchKeys(int tableIndex, int size) {\n     public MapEntriesWithCursor fetchEntries(int tableIndex, int size, SerializationService serializationService) {\n         List<Map.Entry<Data, R>> entries = new ArrayList<Map.Entry<Data, R>>(size);\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n-        List<Map.Entry<Data, Data>> entriesData = new ArrayList<Map.Entry<Data, Data>>(entries.size());\n+        List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = entry.getValue();\n-            Data dataValue = serializationService.toData(record.getValue());\n-            entriesData.add(new AbstractMap.SimpleEntry<Data, Data>(entry.getKey(), dataValue));\n+            R record = (R)(Record)entry.getValue();\n+            Object value = record.getValue();\n+            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\nindex c73567b4a50..a9ce0ccaebb 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/StorageImpl.java\n\n@@ -172,12 +173,10 @@ public class StorageImpl<R extends Record> implements Storage<Data, R> {\n         int newTableIndex = records.fetchEntries(tableIndex, size, entries);\n         List<Map.Entry<Data, Object>> entriesData = new ArrayList<Map.Entry<Data, Object>>(entries.size());\n         for (Map.Entry<Data, R> entry : entries) {\n-            R record = (R)(Record)entry.getValue();\n+            R record = entry.getValue();\n             Object value = record.getValue();\n-            Object dataValue = (value instanceof com.hazelcast.map.Immutable) ?\n-                    value :\n-                    serializationService.toData(value);\n-            entriesData.add(new AbstractMap.SimpleEntry((Data)entry.getKey(), dataValue));\n+            Object resultValue = (value instanceof Immutable) ? value : serializationService.toData(value);\n+            entriesData.add(new AbstractMap.SimpleEntry<Data, Object>(entry.getKey(), resultValue));\n         }\n         return new MapEntriesWithCursor(entriesData, newTableIndex);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0MjYxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391042611", "bodyText": "No need to cast here.", "author": "mmedenjak", "createdAt": "2020-03-11T15:10:25Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java", "diffHunk": "@@ -33,26 +33,31 @@\n  *\n  * @see com.hazelcast.map.impl.proxy.MapProxyImpl#iterator\n  */\n-public class MapEntriesWithCursor extends AbstractCursor<Map.Entry<Data, Data>> {\n+public class MapEntriesWithCursor extends AbstractCursor<Map.Entry<Data, Object>> {\n \n     public MapEntriesWithCursor() {\n     }\n \n-    public MapEntriesWithCursor(List<Map.Entry<Data, Data>> entries, int nextTableIndexToReadFrom) {\n+    public MapEntriesWithCursor(List<Map.Entry<Data, Object>> entries, int nextTableIndexToReadFrom) {\n         super(entries, nextTableIndexToReadFrom);\n     }\n \n     @Override\n-    void writeElement(ObjectDataOutput out, Entry<Data, Data> entry) throws IOException {\n-        out.writeData(entry.getKey());\n-        out.writeData(entry.getValue());\n+    void writeElement(ObjectDataOutput out, Entry<Data, Object> entry) throws IOException {\n+        out.writeData((Data)entry.getKey());", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java b/hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java\nindex a4c94e034c8..cd7a91b8bb4 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/iterator/MapEntriesWithCursor.java\n\n@@ -44,10 +44,10 @@ public class MapEntriesWithCursor extends AbstractCursor<Map.Entry<Data, Object>\n \n     @Override\n     void writeElement(ObjectDataOutput out, Entry<Data, Object> entry) throws IOException {\n-        out.writeData((Data)entry.getKey());\n+        out.writeData(entry.getKey());\n         Object value = entry.getValue();\n         if (value instanceof Data) {\n-            out.writeData((Data)value);\n+            out.writeData((Data) value);\n         } else {\n             out.writeObject(value);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0Mzc5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391043794", "bodyText": "You can replace the full class name with an import.", "author": "mmedenjak", "createdAt": "2020-03-11T15:12:02Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -25,20 +25,20 @@\n \n public final class GetOperation extends ReadonlyKeyBasedMapOperation implements BlockingOperation {\n \n-    private Data result;\n+    private Object result;\n \n     public GetOperation() {\n     }\n \n     public GetOperation(String name, Data dataKey) {\n         super(name, dataKey);\n-\n         this.dataKey = dataKey;\n     }\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object value = this.recordStore.get(this.dataKey, false, getCallerAddress());\n+        this.result = (value instanceof com.hazelcast.map.Immutable) ? value : this.mapServiceContext.toData(value);", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java b/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java\nindex 3835350d794..816e1df96a0 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java\n\n@@ -18,6 +18,7 @@ package com.hazelcast.map.impl.operation;\n \n import com.hazelcast.concurrent.lock.LockWaitNotifyKey;\n import com.hazelcast.core.OperationTimeoutException;\n+import com.hazelcast.map.Immutable;\n import com.hazelcast.map.impl.MapDataSerializerHook;\n import com.hazelcast.nio.serialization.Data;\n import com.hazelcast.spi.BlockingOperation;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0NDIyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391044226", "bodyText": "No need for this. prefixes here and in line below.", "author": "mmedenjak", "createdAt": "2020-03-11T15:12:38Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -25,20 +25,20 @@\n \n public final class GetOperation extends ReadonlyKeyBasedMapOperation implements BlockingOperation {\n \n-    private Data result;\n+    private Object result;\n \n     public GetOperation() {\n     }\n \n     public GetOperation(String name, Data dataKey) {\n         super(name, dataKey);\n-\n         this.dataKey = dataKey;\n     }\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object value = this.recordStore.get(this.dataKey, false, getCallerAddress());", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java b/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java\nindex 3835350d794..816e1df96a0 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java\n\n@@ -18,6 +18,7 @@ package com.hazelcast.map.impl.operation;\n \n import com.hazelcast.concurrent.lock.LockWaitNotifyKey;\n import com.hazelcast.core.OperationTimeoutException;\n+import com.hazelcast.map.Immutable;\n import com.hazelcast.map.impl.MapDataSerializerHook;\n import com.hazelcast.nio.serialization.Data;\n import com.hazelcast.spi.BlockingOperation;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391048678", "bodyText": "I believe this will create a class cast exception when being used from the client. We're going to have to release this changed - https://github.com/hazelcast/hazelcast-client-protocol/blob/1.8.z/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/template/ResponseTemplate.java#L219-L225.\ncc @asimarslan @sancar", "author": "mmedenjak", "createdAt": "2020-03-11T15:18:40Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java", "diffHunk": "@@ -53,7 +54,7 @@ protected ClientMessage encodeResponse(Object response) {\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());", "originalCommit": "fc898a101e01de3e596505d092b501317f40fe40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ1MDA4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391450086", "bodyText": "The casting here looks confusing but it will not cause any cast exception. So no need for any protocol change.\ngetBatch  methods always returns List<Map.Entry<Data, Data>> , it is just not clear from the method signature.\nI think the problem arises from usage of the generics on AbstractCursor. We are using the generic for both the stored object on construction, and also for the object that we read. Their types are actually different. I also don't see a strong reason for AbstractConstructor to know the type. Child classes can keep the reference themselves and override read,write methods so that AbstractConstructor does not know the type.", "author": "sancar", "createdAt": "2020-03-12T07:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2NTE2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391665164", "bodyText": "I've modified the AbstractMapPartitionIteratorTest#test_HasNext_Returns_True_On_NonEmptyPartition test to use OBJECT in-memory format and to add Immutable objects as values to the map. This forces the issue and I've been able to get the exception:\njava.lang.ClassCastException: com.hazelcast.client.map.AbstractMapPartitionIteratorTest$Lala cannot be cast to com.hazelcast.nio.serialization.Data\n\n\tat com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec$ResponseParameters.calculateDataSize(MapFetchEntriesCodec.java:107)\n\tat com.hazelcast.client.impl.protocol.codec.MapFetchEntriesCodec.encodeResponse(MapFetchEntriesCodec.java:119)\n\tat com.hazelcast.client.impl.protocol.task.map.MapFetchEntriesMessageTask.encodeResponse(MapFetchEntriesMessageTask.java:56)\n\tat com.hazelcast.client.impl.protocol.task.AbstractMessageTask.sendResponse(AbstractMessageTask.java:195)\n\tat com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.onResponse(AbstractPartitionMessageTask.java:89)\n\tat com.hazelcast.spi.impl.AbstractInvocationFuture$1.run(AbstractInvocationFuture.java:256)\n\tat com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.execute(AbstractPartitionMessageTask.java:78)\n\tat com.hazelcast.spi.impl.AbstractInvocationFuture.unblock(AbstractInvocationFuture.java:247)\n\tat com.hazelcast.spi.impl.AbstractInvocationFuture.andThen(AbstractInvocationFuture.java:223)\n\tat com.hazelcast.client.impl.protocol.task.AbstractPartitionMessageTask.processMessage(AbstractPartitionMessageTask.java:69)\n\tat com.hazelcast.client.impl.protocol.task.AbstractMessageTask.initializeAndProcessMessage(AbstractMessageTask.java:129)\n\tat com.hazelcast.client.impl.protocol.task.AbstractMessageTask.run(AbstractMessageTask.java:109)\n\tat com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl.run(OperationRunnerImpl.java:163)\n\tat com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:159)\n\tat com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.process(OperationThread.java:127)\n\tat com.hazelcast.spi.impl.operationexecutor.impl.OperationThread.run(OperationThread.java:110)\n\nThis is because previously, MapEntriesWithCursor could only contain a list of serialized keys and values. The MapFetchEntriesCodec#encodeResponse method expects these to be Data to be able to calculate the data size and prepare the response. But now, due to the fact that we want to avoid having extra copies on reads, the MapEntriesWithCursor can also contain references to actual user objects in some cases, which is why it contains a list of Map.Entry<Data, Object>. In some cases, the value will be Data and in other cases it will be the user object. But now MapFetchEntriesCodec#encodeResponse fails to prepare the response in cases where the value is not serialised. The same issue is in the EE repo.", "author": "mmedenjak", "createdAt": "2020-03-12T14:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5MTY1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391691659", "bodyText": "I don't  know why but I was thinking that AbstractCursor will always come from remote.\nIn that case, we need to convert to proper type before passing to encodeResponse.\nProbably in MapFetchEntriesMessageTask.encodeResponse  code.", "author": "sancar", "createdAt": "2020-03-12T15:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5Njg3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r391796872", "bodyText": "Hi mmedanjak,\nThis is Rajeev from Adobe. I was the original author of these changes. A little bit of context around this patch:\n\n\nThis patch is intended and tailor made for our use case(s) and in no way meant to be a general purpose, comprehensive all-encompassing feature covering all use cases and apis. At one point, I did try to address this holistically but quickly realized that it would be a much larger effort and outside of our concern.\n\n\nAs described in the design doc, we are addressing a very narrow subset of our use cases. The whole intent was to minimize redundant copy on read and thus minimizing memory usage.\n\n\nYou are right about the classcastexception that would happen when the iterator api is accessed from the clientproxy. I had realized this side effect of the patch. That would mean not being able to use the ClientMapProxy::iterator api (with object format on) which is anyways not exposed on the IMap interface (and we dont use direct Apis on the proxy).\n\n\nSo overall, yes the patch breaks an api (with object format) which we dont use. (even if we were to use that api, in that topology we would use the binary format) as a trade off against optimization of memory usage. We would like to accept and work within these caveats and proceed with the patch after addressing the other feedback.\n\n\nRe: benchmark\nWe havent done any benchmark. We did add test to confirm the patch functionality works and COR is disabled for local access of immutable types. Intuitively & naively, the performance should improve for the targeted use case and remain the same otherwise.", "author": "rajivgandhi1", "createdAt": "2020-03-12T17:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NTMyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r392075320", "bodyText": "The fix is quite simple actually here as @sancar pointed out. The collection will need to be serialised either way as we're transmitting it from the member back to the client. So, you can simply fix this by going over the collection and serialising the values.", "author": "mmedenjak", "createdAt": "2020-03-13T07:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2ODk2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r392368960", "bodyText": "Thanks @mmedenjak @sancar Yes we will fix this issue.", "author": "rajivgandhi1", "createdAt": "2020-03-13T17:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU3ODYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r393578610", "bodyText": "Looks good, thanks!", "author": "mmedenjak", "createdAt": "2020-03-17T10:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA0ODY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java\nindex 5d3d21a09c4..baed7e88a14 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/map/MapFetchEntriesMessageTask.java\n\n@@ -54,7 +54,7 @@ public class MapFetchEntriesMessageTask extends AbstractMapPartitionMessageTask<\n         }\n         MapEntriesWithCursor mapEntriesWithCursor = (MapEntriesWithCursor) response;\n         return MapFetchEntriesCodec.encodeResponse(mapEntriesWithCursor.getNextTableIndexToReadFrom(),\n-                                                   (List<Map.Entry<Data, Data>>)(Object)mapEntriesWithCursor.getBatch());\n+                                                   (List<Map.Entry<Data, Data>>) (Object) mapEntriesWithCursor.getBatch());\n     }\n \n     @Override\n"}}, {"oid": "b89b8a93367020c8e819de4c299b8fb3d80195be", "url": "https://github.com/hazelcast/hazelcast/commit/b89b8a93367020c8e819de4c299b8fb3d80195be", "message": "Addressing comments", "committedDate": "2020-03-12T18:40:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NTgxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r392075813", "bodyText": "Can you remove mentioning of Adobe and simply say that it is a hint that this object is effectively immutable and can be shared safely between threads?", "author": "mmedenjak", "createdAt": "2020-03-13T07:55:51Z", "path": "hazelcast/src/main/java/com/hazelcast/map/Immutable.java", "diffHunk": "@@ -1,4 +1,23 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n package com.hazelcast.map;\n \n+/**\n+ * This is just a marker interface for Adobe Entities so that we can disable Copy on Read for this type", "originalCommit": "b89b8a93367020c8e819de4c299b8fb3d80195be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9da93576e5dd677a2e52c1888602fe84991d38a8", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/Immutable.java b/hazelcast/src/main/java/com/hazelcast/map/Immutable.java\nindex 752cde1b593..a9b30823642 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/Immutable.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/Immutable.java\n\n@@ -16,8 +16,24 @@\n \n package com.hazelcast.map;\n \n+import com.hazelcast.spi.annotation.Beta;\n+\n /**\n- * This is just a marker interface for Adobe Entities so that we can disable Copy on Read for this type\n+ * Allows notifying Hazelcast code that the object implementing this interface\n+ * is effectively immutable.\n+ * This may mean that it either does not have any state (e.g. pure function)\n+ * or the state is not mutated at any point.\n+ * This interface allows for performance optimisations where applicable such\n+ * as avoiding cloning user supplied objects or cloning hazelcast internal\n+ * objects supplied to the user.\n+ * It is important that the user follows the rules:\n+ * <ul>\n+ * <li>the object must not have any state which is changed by cloning the object</li>\n+ * <li>the existing state must not be changed</li>\n+ * </ul>\n+ * If an object implements this interface but does not follow these rules,\n+ * the results of the execution are undefined.\n  */\n+@Beta\n public interface Immutable {\n }\n"}}, {"oid": "a4d6764880d1f301cb06243b3f00888ba7692478", "url": "https://github.com/hazelcast/hazelcast/commit/a4d6764880d1f301cb06243b3f00888ba7692478", "message": "Fixing serialization problem as per comments", "committedDate": "2020-03-13T18:13:32Z", "type": "commit"}, {"oid": "6c46c164c5136e02d4552147e66d8892d373b8c4", "url": "https://github.com/hazelcast/hazelcast/commit/6c46c164c5136e02d4552147e66d8892d373b8c4", "message": "Removing dimond operator", "committedDate": "2020-03-17T18:50:06Z", "type": "commit"}, {"oid": "d01b8f46cc873b511967c1ca5b54e19011d3991e", "url": "https://github.com/hazelcast/hazelcast/commit/d01b8f46cc873b511967c1ca5b54e19011d3991e", "message": "Checkstyle", "committedDate": "2020-03-20T11:22:15Z", "type": "commit"}, {"oid": "9da93576e5dd677a2e52c1888602fe84991d38a8", "url": "https://github.com/hazelcast/hazelcast/commit/9da93576e5dd677a2e52c1888602fe84991d38a8", "message": "Minor updates", "committedDate": "2020-03-20T11:26:42Z", "type": "commit"}, {"oid": "d1c75491cb4eea0990ff73afd1d72a8222382499", "url": "https://github.com/hazelcast/hazelcast/commit/d1c75491cb4eea0990ff73afd1d72a8222382499", "message": "Fix compilation", "committedDate": "2020-03-20T12:00:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5OTQ2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r395599460", "bodyText": "Having immutable only makes sense if your application accesses it over its local embedded node, otherwise serialization will happen if you reach data over client or over remote nodes to the application. Is this what you want? Or maybe you can consider using near cache for this case, it will be much faster.", "author": "ahmetmircik", "createdAt": "2020-03-20T12:19:44Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/GetOperation.java", "diffHunk": "@@ -38,7 +39,10 @@ public GetOperation(String name, Data dataKey) {\n \n     @Override\n     public void run() {\n-        result = mapServiceContext.toData(recordStore.get(dataKey, false, getCallerAddress()));\n+        Object currentValue = recordStore.get(dataKey, false, getCallerAddress());\n+        result = (currentValue instanceof Immutable)", "originalCommit": "d1c75491cb4eea0990ff73afd1d72a8222382499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MDEwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16736#discussion_r404390101", "bodyText": "Think about use cases with Jet (access happening node locally from with a Jet pipeline)", "author": "rajivgandhi1", "createdAt": "2020-04-06T21:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5OTQ2MA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "5d98eb258b209a7c1d581bda6b5bba1e188287c0", "url": "https://github.com/hazelcast/hazelcast/commit/5d98eb258b209a7c1d581bda6b5bba1e188287c0", "message": "Fix serialization of iteration batches", "committedDate": "2020-03-20T12:30:52Z", "type": "commit"}]}