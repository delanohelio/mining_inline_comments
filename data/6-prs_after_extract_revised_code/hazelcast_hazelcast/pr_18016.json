{"pr_number": 18016, "pr_title": "Support OBJECT type in comparison operators", "pr_createdAt": "2020-12-29T14:04:23Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/18016", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3NTYzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/18016#discussion_r549775633", "bodyText": "The check for class should be performed only for operands of OBJECT type since for all other operand types, we know for sure that they are comparable, and of the same type.", "author": "devozerov", "createdAt": "2020-12-29T16:54:16Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -77,6 +78,13 @@ public Boolean eval(Row row, ExpressionEvalContext context) {\n             return null;\n         }\n \n+        Class<?> leftClass = left.getClass();\n+        Class<?> rightClass = right.getClass();\n+\n+        if (!(left instanceof Comparable && leftClass.equals(rightClass))) {", "originalCommit": "fe3bc1a44a09267cf612d22d0eb95b7c43b32f70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5d5b1b6ea84534c5ef412bade2c91c1c1c180b63", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\nindex 5d745969066..e5bcad84a2c 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\n\n@@ -78,11 +79,18 @@ public final class ComparisonPredicate extends BiExpression<Boolean> implements\n             return null;\n         }\n \n-        Class<?> leftClass = left.getClass();\n-        Class<?> rightClass = right.getClass();\n+        if (this.operand1.getType().getTypeFamily() == QueryDataTypeFamily.OBJECT) {\n+            Class<?> leftClass = left.getClass();\n+            Class<?> rightClass = right.getClass();\n+\n+            if (!leftClass.equals(rightClass)) {\n+                throw QueryException.error(\"Cannot compare two OBJECT values, because they have different classes\");\n+            }\n+\n+            if (!(left instanceof Comparable)) {\n+                throw QueryException.error(\"Cannot compare OBJECT value because it doesn't implement Comparable interface\");\n+            }\n \n-        if (!(left instanceof Comparable && leftClass.equals(rightClass))) {\n-            throw QueryException.error(\"trying to compare two incomparable objects\");\n         }\n \n         Comparable leftComparable = (Comparable) left;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3NzQxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/18016#discussion_r549777410", "bodyText": "It is not very obvious from the message what does \"incomparable\" mean. Better messages could be (rough examples):\n\nIf the object is not comparable: Cannot compare OBJECT value because it doesn't implement Comparable interface\nIf objects are of different types: Cannot compare two OBJECT values, because they have different classes", "author": "devozerov", "createdAt": "2020-12-29T16:59:29Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -77,6 +78,13 @@ public Boolean eval(Row row, ExpressionEvalContext context) {\n             return null;\n         }\n \n+        Class<?> leftClass = left.getClass();\n+        Class<?> rightClass = right.getClass();\n+\n+        if (!(left instanceof Comparable && leftClass.equals(rightClass))) {\n+            throw QueryException.error(\"trying to compare two incomparable objects\");", "originalCommit": "fe3bc1a44a09267cf612d22d0eb95b7c43b32f70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5d5b1b6ea84534c5ef412bade2c91c1c1c180b63", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\nindex 5d745969066..e5bcad84a2c 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\n\n@@ -78,11 +79,18 @@ public final class ComparisonPredicate extends BiExpression<Boolean> implements\n             return null;\n         }\n \n-        Class<?> leftClass = left.getClass();\n-        Class<?> rightClass = right.getClass();\n+        if (this.operand1.getType().getTypeFamily() == QueryDataTypeFamily.OBJECT) {\n+            Class<?> leftClass = left.getClass();\n+            Class<?> rightClass = right.getClass();\n+\n+            if (!leftClass.equals(rightClass)) {\n+                throw QueryException.error(\"Cannot compare two OBJECT values, because they have different classes\");\n+            }\n+\n+            if (!(left instanceof Comparable)) {\n+                throw QueryException.error(\"Cannot compare OBJECT value because it doesn't implement Comparable interface\");\n+            }\n \n-        if (!(left instanceof Comparable && leftClass.equals(rightClass))) {\n-            throw QueryException.error(\"trying to compare two incomparable objects\");\n         }\n \n         Comparable leftComparable = (Comparable) left;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3ODAxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/18016#discussion_r549778016", "bodyText": "We now do not have tests for OBJECT vs non-OBJECT compares.", "author": "devozerov", "createdAt": "2020-12-29T17:00:37Z", "path": "hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicateIntegrationTest.java", "diffHunk": "@@ -223,7 +224,51 @@ public void testUnsupported() {\n         checkUnsupportedColumnColumn(ExpressionTypes.LOCAL_TIME, ExpressionTypes.allExcept());\n         checkUnsupportedColumnColumn(ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.allExcept());\n         checkUnsupportedColumnColumn(ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.allExcept());\n-        checkUnsupportedColumnColumn(ExpressionTypes.OBJECT, ExpressionTypes.allExcept());", "originalCommit": "fe3bc1a44a09267cf612d22d0eb95b7c43b32f70", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c5a8306b25438fa2f2d30a5f11caa14b2e01856", "chunk": "diff --git a/hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicateIntegrationTest.java b/hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicateIntegrationTest.java\nindex a83f9dc0658..c2fb8b789c9 100644\n--- a/hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicateIntegrationTest.java\n+++ b/hazelcast-sql-core/src/test/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicateIntegrationTest.java\n\n@@ -220,50 +228,268 @@ public class ComparisonPredicateIntegrationTest extends ExpressionTestSupport {\n     @Test\n     public void testUnsupported() {\n         // Column/column\n-        checkUnsupportedColumnColumn(ExpressionTypes.LOCAL_DATE, ExpressionTypes.allExcept());\n-        checkUnsupportedColumnColumn(ExpressionTypes.LOCAL_TIME, ExpressionTypes.allExcept());\n-        checkUnsupportedColumnColumn(ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.allExcept());\n-        checkUnsupportedColumnColumn(ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.allExcept());\n+        checkUnsupportedColumnColumn(\n+                ExpressionTypes.LOCAL_DATE, ExpressionTypes.allExcept(\n+                        ExpressionTypes.LOCAL_DATE,\n+                        ExpressionTypes.LOCAL_DATE_TIME,\n+                        ExpressionTypes.OFFSET_DATE_TIME));\n+        checkUnsupportedColumnColumn(\n+                ExpressionTypes.LOCAL_TIME, ExpressionTypes.allExcept(\n+                        ExpressionTypes.LOCAL_TIME,\n+                        ExpressionTypes.LOCAL_DATE_TIME,\n+                        ExpressionTypes.OFFSET_DATE_TIME));\n+        checkUnsupportedColumnColumn(\n+                ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.allExcept(\n+                        ExpressionTypes.LOCAL_DATE,\n+                        ExpressionTypes.LOCAL_TIME,\n+                        ExpressionTypes.LOCAL_DATE_TIME,\n+                        ExpressionTypes.OFFSET_DATE_TIME));\n+        checkUnsupportedColumnColumn(\n+                ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.allExcept(\n+                        ExpressionTypes.LOCAL_DATE,\n+                        ExpressionTypes.LOCAL_TIME,\n+                        ExpressionTypes.LOCAL_DATE_TIME,\n+                        ExpressionTypes.OFFSET_DATE_TIME));\n     }\n \n     @Test\n     public void testComparable_to_Comparable() {\n-        putBiValue(new ComparableImpl(1), new ComparableImpl(1));\n-        check(\"field1\", \"field2\", new ComparableImpl(1).compareTo(new ComparableImpl(1)));\n+        ExpressionBiValue value = ExpressionBiValue.createBiValue(\n+                ExpressionBiValue.createBiClass(ExpressionTypes.OBJECT, ExpressionTypes.OBJECT),\n+                new ComparableImpl(1),\n+                new ComparableImpl(1)\n+        );\n \n-        putBiValue(new ComparableImpl(1), new ComparableImpl(2));\n-        check(\"field1\", \"field2\", new ComparableImpl(1).compareTo(new ComparableImpl(2)));\n+        put(value);\n \n-        putBiValue(new ComparableImpl(2), new ComparableImpl(1));\n-        check(\"field1\", \"field2\", new ComparableImpl(2).compareTo(new ComparableImpl(1)));\n+        check(\"field1\", \"field2\", new ComparableImpl(1).compareTo(new ComparableImpl(1)));\n     }\n \n     @Test\n-    public void testComparable_and_NonComparable() {\n-        putBiValue(new ComparableImpl(1), new NonComparable());\n-        checkFailure(\"field1\", \"field2\", -1, \"trying to compare two incomparable objects\");\n+    public void testDifferentClassThatImplementsComparableInterface() {\n+        ExpressionBiValue value = ExpressionBiValue.createBiValue(\n+                ExpressionBiValue.createBiClass(ExpressionTypes.OBJECT, ExpressionTypes.OBJECT),\n+                new ComparableImpl(1),\n+                new ComparableImpl2(1)\n+        );\n+\n+        put(value);\n \n-        putBiValue(new NonComparable(), new ComparableImpl(1));\n         checkFailure(\"field1\", \"field2\", -1, \"trying to compare two incomparable objects\");\n     }\n \n     @Test\n-    public void testDifferentClassThatImplementsComparableInterface() {\n-        putBiValue(new ComparableImpl(1), new ComparableImpl2(1));\n+    public void testNonComparableObjects() {\n+        ExpressionBiValue value = ExpressionBiValue.createBiValue(\n+                ExpressionBiValue.createBiClass(ExpressionTypes.OBJECT, ExpressionTypes.OBJECT),\n+                new NonComparable(),\n+                new NonComparable()\n+        );\n+\n+        put(value);\n \n         checkFailure(\"field1\", \"field2\", -1, \"trying to compare two incomparable objects\");\n     }\n \n     @Test\n-    public void testNonComparableObjects() {\n-        putBiValue(new NonComparable(), new NonComparable());\n+    public void testCompare_LocalDate_with_LocalDate() {\n+        putBiValue(\n+            LocalDate.of(2020, 12, 30),\n+            LocalDate.of(2020, 12, 30),\n+            ExpressionTypes.LOCAL_DATE, ExpressionTypes.LOCAL_DATE\n+        );\n \n-        checkFailure(\"field1\", \"field2\", -1, \"trying to compare two incomparable objects\");\n+        check(\"field1\", \"field2\", LocalDate.of(2020, 12, 30).compareTo(LocalDate.of(2020, 12, 30)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDate_with_String() {\n+        put(ExpressionValue.create(ExpressionValue.createClass(ExpressionTypes.LOCAL_DATE), LocalDate.of(2020, 12, 30)));\n+\n+        check(\"field1\", \"'2020-12-30'\", LocalDate.of(2020, 12, 30).compareTo(LocalDate.of(2020, 12, 30)));\n+        check(\"'2020-12-30'\", \"field1\", LocalDate.of(2020, 12, 30).compareTo(LocalDate.of(2020, 12, 30)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalTime_with_LocalTime() {\n+        putBiValue(\n+            LocalTime.of(14, 2, 0),\n+            LocalTime.of(14, 2, 0),\n+            ExpressionTypes.LOCAL_TIME, ExpressionTypes.LOCAL_TIME\n+        );\n+\n+        check(\"field1\", \"field2\", LocalTime.of(14, 2, 0).compareTo(LocalTime.of(14, 2, 0)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalTime_with_String() {\n+        put(ExpressionValue.create(ExpressionValue.createClass(ExpressionTypes.LOCAL_TIME), LocalTime.of(14, 2, 0)));\n+\n+        check(\"field1\", \"'14:02:00'\", LocalTime.of(14, 2, 0).compareTo(LocalTime.of(14, 2, 0)));\n+        check(\"'14:02:00'\", \"field1\", LocalTime.of(14, 2, 0).compareTo(LocalTime.of(14, 2, 0)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTime_with_LocalDateTime() {\n+        putBiValue(\n+            LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+            LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+            ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.LOCAL_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"field2\", LocalDateTime.of(2020, 12, 30, 14, 2, 0).compareTo(LocalDateTime.of(2020, 12, 30, 14, 2, 0)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTime_with_String() {\n+        put(ExpressionValue.create(ExpressionValue.createClass(ExpressionTypes.LOCAL_DATE_TIME), LocalDateTime.of(2020, 12, 30, 14, 2, 0)));\n+\n+        check(\"field1\", \"'2020-12-30T14:02'\", LocalDateTime.of(2020, 12, 30, 14, 2, 0).compareTo(LocalDateTime.of(2020, 12, 30, 14, 2, 0)));\n+        check(\"'2020-12-30T14:02'\", \"field1\", LocalDateTime.of(2020, 12, 30, 14, 2, 0).compareTo(LocalDateTime.of(2020, 12, 30, 14, 2, 0)));\n+    }\n+\n+\n+    @Test\n+    public void testCompare_LocalDateTime_with_LocalDate() {\n+        putBiValue(\n+            LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+            LocalDate.of(2020, 12, 30),\n+            ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.LOCAL_DATE\n+        );\n+\n+        check(\"field1\", \"field2\", LocalDateTime.of(2020, 12, 30, 14, 2, 0).compareTo(LocalDate.of(2020, 12, 30).atStartOfDay()));\n+\n+        putBiValue(\n+            LocalDate.of(2020, 12, 30),\n+            LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+            ExpressionTypes.LOCAL_DATE, ExpressionTypes.LOCAL_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"field2\", LocalDate.of(2020, 12, 30).atStartOfDay().compareTo(LocalDateTime.of(2020, 12, 30, 14, 2, 0)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTime_with_LocalTime() {\n+        putBiValue(\n+                LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+                LocalTime.of(14, 2, 0),\n+                ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.LOCAL_TIME\n+        );\n+\n+        check(\"cast (field1 as TIME)\", \"field2\", LocalDateTime.of(2020, 12, 30, 14, 2, 0).toLocalTime().compareTo(LocalTime.of(14, 2, 0)));\n+        check(\"field1\", \"field2\", LocalDateTime.of(2020, 12, 30, 14, 2, 0).compareTo(LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 2, 0))));\n+\n+        putBiValue(\n+                LocalTime.of(14, 2, 0),\n+                LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+                ExpressionTypes.LOCAL_TIME, ExpressionTypes.LOCAL_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"cast (field2 as TIME)\", LocalTime.of(14, 2, 0).compareTo(LocalDateTime.of(2020, 12, 30, 14, 2, 0).toLocalTime()));\n+        check(\"field1\", \"field2\", LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 2, 0)).compareTo(LocalDateTime.of(2020, 12, 30, 14, 2, 0)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTimeWithTZ_with_LocalDateTimeWithTZ() {\n+        putBiValue(\n+            OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+            OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+            ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.OFFSET_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"field2\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTimeWithTZ_with_String() {\n+        put(ExpressionValue.create(ExpressionValue.createClass(\n+                ExpressionTypes.OFFSET_DATE_TIME), OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n+\n+        check(\"field1\", \"'2020-12-30T14:02Z'\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n+        check(\"'2020-12-30T14:02Z'\", \"field1\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n     }\n \n-    private void putBiValue(Object field1, Object field2) {\n+    @Test\n+    public void testCompare_LocalDateTimeWithTZ_with_LocalDateTime() {\n+        putBiValue(\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+                LocalDateTime.of(2020, 12, 30, 14, 2, 0), ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.LOCAL_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"field2\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)\n+                        .compareTo(ZonedDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), DEFAULT_TIME_ZONE).toOffsetDateTime()));\n+\n+        putBiValue(\n+                LocalDateTime.of(2020, 12, 30, 14, 2, 0),\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+                ExpressionTypes.LOCAL_DATE_TIME, ExpressionTypes.OFFSET_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"field2\",\n+                ZonedDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), DEFAULT_TIME_ZONE).toOffsetDateTime()\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTimeWithTZ_with_LocalDate() {\n+        putBiValue(\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+                LocalDate.of(2020, 12, 30), ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.LOCAL_DATE\n+        );\n+\n+        check(\"field1\", \"field2\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)\n+                        .compareTo(ZonedDateTime.of(LocalDate.of(2020, 12, 30).atStartOfDay(), DEFAULT_TIME_ZONE).toOffsetDateTime()));\n+\n+        putBiValue(\n+                LocalDate.of(2020, 12, 30),\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+                ExpressionTypes.LOCAL_DATE, ExpressionTypes.OFFSET_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"field2\",\n+                ZonedDateTime.of(LocalDate.of(2020, 12, 30).atStartOfDay(), DEFAULT_TIME_ZONE).toOffsetDateTime()\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n+    }\n+\n+    @Test\n+    public void testCompare_LocalDateTimeWithTZ_with_LocalTime() {\n+        putBiValue(\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+                LocalTime.of(14, 2, 0), ExpressionTypes.OFFSET_DATE_TIME, ExpressionTypes.LOCAL_TIME\n+        );\n+\n+        check(\"cast (field1 as TIME)\", \"field2\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC).toLocalTime()\n+                        .compareTo(LocalTime.of(14, 2, 0)));\n+        check(\"field1\", \"field2\",\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 2, 0)), ZoneOffset.UTC)));\n+\n+        putBiValue(\n+                LocalTime.of(14, 2, 0),\n+                OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC),\n+                ExpressionTypes.LOCAL_TIME, ExpressionTypes.OFFSET_DATE_TIME\n+        );\n+\n+        check(\"field1\", \"cast (field2 as TIME)\",\n+                LocalTime.of(14, 2, 0).compareTo(\n+                        OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC).toLocalTime()));\n+        check(\"field1\", \"field2\",\n+                OffsetDateTime.of(LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 2, 0)), ZoneOffset.UTC)\n+                        .compareTo(OffsetDateTime.of(LocalDateTime.of(2020, 12, 30, 14, 2, 0), ZoneOffset.UTC)));\n+    }\n+\n+    private void putBiValue(Object field1, Object field2, ExpressionType<?> type1, ExpressionType<?> type2) {\n         ExpressionBiValue value = ExpressionBiValue.createBiValue(\n-                ExpressionBiValue.createBiClass(ExpressionTypes.OBJECT, ExpressionTypes.OBJECT),\n+                ExpressionBiValue.createBiClass(type1, type2),\n                 field1,\n                 field2\n         );\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTU4MzI1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/18016#discussion_r555583253", "bodyText": "consider printing the actual class.\nmore diagnostics could be very useful here. for example with Portable object it would be good to know its class/factory IDs.\notherwise it's hard to tell what actually went wrong and how to fix it.", "author": "jerrinot", "createdAt": "2021-01-12T08:15:50Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java", "diffHunk": "@@ -77,6 +79,20 @@ public Boolean eval(Row row, ExpressionEvalContext context) {\n             return null;\n         }\n \n+        if (this.operand1.getType().getTypeFamily() == QueryDataTypeFamily.OBJECT) {\n+            Class<?> leftClass = left.getClass();\n+            Class<?> rightClass = right.getClass();\n+\n+            if (!leftClass.equals(rightClass)) {\n+                throw QueryException.error(\"Cannot compare two OBJECT values, because they have different classes\");", "originalCommit": "204c10d84dfb1fdfeab435fbd765e45d045ad9ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6c5a8306b25438fa2f2d30a5f11caa14b2e01856", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\nindex e5bcad84a2c..1235d2499d9 100644\n--- a/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\n+++ b/hazelcast/src/main/java/com/hazelcast/sql/impl/expression/predicate/ComparisonPredicate.java\n\n@@ -79,18 +79,11 @@ public final class ComparisonPredicate extends BiExpression<Boolean> implements\n             return null;\n         }\n \n-        if (this.operand1.getType().getTypeFamily() == QueryDataTypeFamily.OBJECT) {\n-            Class<?> leftClass = left.getClass();\n-            Class<?> rightClass = right.getClass();\n-\n-            if (!leftClass.equals(rightClass)) {\n-                throw QueryException.error(\"Cannot compare two OBJECT values, because they have different classes\");\n-            }\n-\n-            if (!(left instanceof Comparable)) {\n-                throw QueryException.error(\"Cannot compare OBJECT value because it doesn't implement Comparable interface\");\n-            }\n+        Class<?> leftClass = left.getClass();\n+        Class<?> rightClass = right.getClass();\n \n+        if (!(left instanceof Comparable && leftClass.equals(rightClass))) {\n+            throw QueryException.error(\"trying to compare two incomparable objects\");\n         }\n \n         Comparable leftComparable = (Comparable) left;\n"}}, {"oid": "6c5a8306b25438fa2f2d30a5f11caa14b2e01856", "url": "https://github.com/hazelcast/hazelcast/commit/6c5a8306b25438fa2f2d30a5f11caa14b2e01856", "message": "Support OBJECT type in comparison operators", "committedDate": "2021-01-15T11:36:30Z", "type": "commit"}, {"oid": "199549dfada196d2872cf87d8f3d2b2fb0261aaa", "url": "https://github.com/hazelcast/hazelcast/commit/199549dfada196d2872cf87d8f3d2b2fb0261aaa", "message": "fix checkstyle", "committedDate": "2021-01-15T11:36:33Z", "type": "commit"}, {"oid": "c2b67ba9184858586ec06c142fffc24e6efb8b57", "url": "https://github.com/hazelcast/hazelcast/commit/c2b67ba9184858586ec06c142fffc24e6efb8b57", "message": "update test", "committedDate": "2021-01-15T11:36:33Z", "type": "commit"}, {"oid": "5d5b1b6ea84534c5ef412bade2c91c1c1c180b63", "url": "https://github.com/hazelcast/hazelcast/commit/5d5b1b6ea84534c5ef412bade2c91c1c1c180b63", "message": "address review comments", "committedDate": "2021-01-15T11:38:47Z", "type": "commit"}, {"oid": "006b5233cd0a35f2483dcd544e9fab67b4b211f9", "url": "https://github.com/hazelcast/hazelcast/commit/006b5233cd0a35f2483dcd544e9fab67b4b211f9", "message": "added class names in query error messages", "committedDate": "2021-01-15T11:38:49Z", "type": "commit"}, {"oid": "c0730341e5bac89609e658b323ee5a7ab16ae453", "url": "https://github.com/hazelcast/hazelcast/commit/c0730341e5bac89609e658b323ee5a7ab16ae453", "message": "fix tests", "committedDate": "2021-01-15T11:38:50Z", "type": "commit"}, {"oid": "bcefa1fd725661c8712e9565c82f115dc1b15cc3", "url": "https://github.com/hazelcast/hazelcast/commit/bcefa1fd725661c8712e9565c82f115dc1b15cc3", "message": "rebase with master", "committedDate": "2021-01-15T11:50:03Z", "type": "commit"}, {"oid": "bcefa1fd725661c8712e9565c82f115dc1b15cc3", "url": "https://github.com/hazelcast/hazelcast/commit/bcefa1fd725661c8712e9565c82f115dc1b15cc3", "message": "rebase with master", "committedDate": "2021-01-15T11:50:03Z", "type": "forcePushed"}]}