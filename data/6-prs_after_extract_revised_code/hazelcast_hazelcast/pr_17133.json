{"pr_number": 17133, "pr_title": "Integrate concurrent off-heap B+tree index into the old engine", "pr_createdAt": "2020-06-26T13:15:33Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17133", "timeline": [{"oid": "01f680f9a967646e8e27cb05842ac1a06412d046", "url": "https://github.com/hazelcast/hazelcast/commit/01f680f9a967646e8e27cb05842ac1a06412d046", "message": "Disabled global lock for on-heap indexes\n\nOtherwise the updates are not atomic", "committedDate": "2020-06-29T06:48:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0ODAyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447448029", "bodyText": "Minor: mapConfig.getInMemoryFormat() != NATIVE || mapServiceContext.globalIndexEnabled()?", "author": "devozerov", "createdAt": "2020-06-30T06:48:00Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -179,7 +178,8 @@ protected Evictor newEvictor(EvictionPolicyComparator evictionPolicyComparator,\n \n     public boolean shouldUseGlobalIndex() {\n         // for non-native memory populate a single global index\n-        return !mapConfig.getInMemoryFormat().equals(NATIVE);\n+        return !mapConfig.getInMemoryFormat().equals(NATIVE)", "originalCommit": "01f680f9a967646e8e27cb05842ac1a06412d046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3NzU5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447477596", "bodyText": "Fixed", "author": "petrpleshachkov", "createdAt": "2020-06-30T07:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0ODAyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd6d8a67eb1b7dfd50f5d291c357e415c54d796e", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java b/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java\nindex 1dcec9ade8a..7437106a033 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java\n\n@@ -177,9 +177,7 @@ public class MapContainer {\n     }\n \n     public boolean shouldUseGlobalIndex() {\n-        // for non-native memory populate a single global index\n-        return !mapConfig.getInMemoryFormat().equals(NATIVE)\n-                || mapConfig.getInMemoryFormat().equals(NATIVE) && mapServiceContext.globalIndexEnabled();\n+        return mapConfig.getInMemoryFormat() != NATIVE || mapServiceContext.globalIndexEnabled();\n     }\n \n     protected static MemoryInfoAccessor getMemoryInfoAccessor() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ1MTY2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447451660", "bodyText": "If we are removing the global lock for HD index (which changes the behavior), is there a reason to leave it for other indexes?\nMaybe we should introduce a single property that will enable/disable global lock globally?", "author": "devozerov", "createdAt": "2020-06-30T06:55:28Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java", "diffHunk": "@@ -45,7 +45,7 @@\n     private volatile Map<Data, QueryableEntry> recordsWithNullValue;\n \n     public OrderedIndexStore(IndexCopyBehavior copyOn) {\n-        super(copyOn);\n+        super(copyOn, true);", "originalCommit": "01f680f9a967646e8e27cb05842ac1a06412d046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3MzUzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447473531", "bodyText": "We are still leaving it for other indexes.\n\nBitMapIndexStore is non-concurrent and we still have to keep the lock;\nOrderedIndexStore and UnorderedIndexStore as they are written now also non-concurrent. The code below is racy even relying on the concurrent data structures. We have to re-write these operations to make them concurrent. Also, the compute* methods of ConcurrentSkipListMap which we are using for the OrderedindexStore are non-atomic according to the JavaDoc - \"The function is NOT guaranteed to be applied once atomically.\"\n\n    private class AddFunctor implements IndexFunctor<Comparable, QueryableEntry> {\n\n        @Override\n        public Object invoke(Comparable value, QueryableEntry entry) {\n            if (value == NULL) {\n                return recordsWithNullValue.put(entry.getKeyData(), entry);\n            } else {\n                Map<Data, QueryableEntry> records = recordMap.get(value);\n                if (records == null) {\n                    records = new ConcurrentHashMap<>(1, LOAD_FACTOR, 1);\n                    recordMap.put(value, records);\n                }\n                return records.put(entry.getKeyData(), entry);\n            }\n        }\n\n    }\n\n\nThis is the reason why I don't remove the global lock for the on-heap indices.", "author": "petrpleshachkov", "createdAt": "2020-06-30T07:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ1MTY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3NDgxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447474812", "bodyText": "I'm not sure that we have to introduce a single property to enable the global lock, because as it is now we must use it for on-heap indices and if we are able to rewrite the code to make it thread-safe, we just remove them improving throughput.", "author": "petrpleshachkov", "createdAt": "2020-06-30T07:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ1MTY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MDcxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447480712", "bodyText": "I see, thanks.", "author": "devozerov", "createdAt": "2020-06-30T07:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ1MTY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyNzUwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r450827507", "bodyText": "Looks like we still can relax the locking a bit: take the locks for mutating operations and skip the locking for index queries. Probably there is no that much sense in doing so, the benefits would be visible for the old engine mainly, the new engine would not use the locks for the new iterator-based index query API, if understand things right. WDYT guys?", "author": "taburet", "createdAt": "2020-07-07T12:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ1MTY2MA=="}], "type": "inlineReview", "revised_code": {"commit": "50c3ec0cd8ff6bfb1dc200fa9ad63a0ea8d83555", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java b/hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java\nindex 0743c6399e7..f28937697c8 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/OrderedIndexStore.java\n\n@@ -45,7 +45,7 @@ public class OrderedIndexStore extends BaseSingleValueIndexStore {\n     private volatile Map<Data, QueryableEntry> recordsWithNullValue;\n \n     public OrderedIndexStore(IndexCopyBehavior copyOn) {\n-        super(copyOn, true);\n+        super(copyOn);\n         assert copyOn != null;\n         if (copyOn == IndexCopyBehavior.COPY_ON_WRITE) {\n             addFunctor = new CopyOnWriteAddFunctor();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3Njc1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447476757", "bodyText": "I cannot find usages of this method in either OS or ENT. Could you please point me to the code where it is used?", "author": "devozerov", "createdAt": "2020-06-30T07:42:19Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/IndexProvider.java", "diffHunk": "@@ -43,11 +43,13 @@\n      * @return the created index instance.\n      */\n     InternalIndex createIndex(\n-        IndexConfig config,\n-        Extractors extractors,\n-        InternalSerializationService ss,\n-        IndexCopyBehavior copyBehavior,\n-        PerIndexStats stats,\n-        StoreAdapter storeAdapter\n+            IndexConfig config,\n+            Extractors extractors,\n+            InternalSerializationService ss,\n+            IndexCopyBehavior copyBehavior,\n+            PerIndexStats stats,\n+            StoreAdapter storeAdapter\n     );\n+\n+    PerIndexStats createPerIndexStats(boolean ordered, boolean usesCachedQueryableEntries);", "originalCommit": "01f680f9a967646e8e27cb05842ac1a06412d046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUwNDQwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447504405", "bodyText": "A leftover code. Used it before but then rewrote it and forgot to remove this method. Fixed. Thanks!", "author": "petrpleshachkov", "createdAt": "2020-06-30T08:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3Njc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cd6d8a67eb1b7dfd50f5d291c357e415c54d796e", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/IndexProvider.java b/hazelcast/src/main/java/com/hazelcast/query/impl/IndexProvider.java\nindex 0a3dee2bcef..2fc6967bb36 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/IndexProvider.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/IndexProvider.java\n\n@@ -50,6 +50,4 @@ public interface IndexProvider {\n             PerIndexStats stats,\n             StoreAdapter storeAdapter\n     );\n-\n-    PerIndexStats createPerIndexStats(boolean ordered, boolean usesCachedQueryableEntries);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MDMxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447480311", "bodyText": "Is it guaranteed that updateMemoryCost is not invoked from several threads concurrently? I see that the fields of the superclass are updated through CAS operations.", "author": "devozerov", "createdAt": "2020-06-30T07:48:21Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/monitor/impl/HDGlobalPerIndexStats.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.monitor.impl;\n+\n+import com.hazelcast.internal.memory.MemoryAllocator;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+/**\n+ * The implementation of internal index stats specialized for HD global indexes.\n+ * <p>\n+ * The main trait of the implementation is the concurrency support, which is\n+ * required for HD global indexes because they are shared among partitions.\n+ */\n+public final class HDGlobalPerIndexStats extends GlobalPerIndexStats {\n+\n+    private static final AtomicLongFieldUpdater<HDGlobalPerIndexStats> MEMORY_COST = newUpdater(HDGlobalPerIndexStats.class,\n+            \"memoryCost\");\n+\n+    private volatile long memoryCost;\n+\n+    public HDGlobalPerIndexStats(boolean ordered, boolean usesCachedQueryableEntries) {\n+        super(ordered, usesCachedQueryableEntries);\n+    }\n+\n+    @Override\n+    public long getMemoryCost() {\n+        return memoryCost;\n+    }\n+\n+    @Override\n+    public MemoryAllocator wrapMemoryAllocator(MemoryAllocator memoryAllocator) {\n+        return new MemoryAllocatorWithStats(memoryAllocator);\n+    }\n+\n+    private void updateMemoryCost(long delta) {\n+        MEMORY_COST.lazySet(HDGlobalPerIndexStats.this, memoryCost + delta);", "originalCommit": "01f680f9a967646e8e27cb05842ac1a06412d046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NzYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r447587610", "bodyText": "Nice catch! Fixed to use CAS", "author": "petrpleshachkov", "createdAt": "2020-06-30T10:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MDMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "cd6d8a67eb1b7dfd50f5d291c357e415c54d796e", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/monitor/impl/HDGlobalPerIndexStats.java b/hazelcast/src/main/java/com/hazelcast/internal/monitor/impl/HDGlobalPerIndexStats.java\nindex 80ac7e23d22..487ee9d8782 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/monitor/impl/HDGlobalPerIndexStats.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/monitor/impl/HDGlobalPerIndexStats.java\n\n@@ -50,11 +50,11 @@ public final class HDGlobalPerIndexStats extends GlobalPerIndexStats {\n     }\n \n     private void updateMemoryCost(long delta) {\n-        MEMORY_COST.lazySet(HDGlobalPerIndexStats.this, memoryCost + delta);\n+        MEMORY_COST.addAndGet(HDGlobalPerIndexStats.this, delta);\n     }\n \n     private void resetMemoryCost() {\n-        MEMORY_COST.lazySet(HDGlobalPerIndexStats.this, 0);\n+        memoryCost = 0;\n     }\n \n     private class MemoryAllocatorWithStats implements MemoryAllocator {\n"}}, {"oid": "cd6d8a67eb1b7dfd50f5d291c357e415c54d796e", "url": "https://github.com/hazelcast/hazelcast/commit/cd6d8a67eb1b7dfd50f5d291c357e415c54d796e", "message": "Destroy global indexes when the map is being destroyed", "committedDate": "2020-07-03T13:05:37Z", "type": "forcePushed"}, {"oid": "50c3ec0cd8ff6bfb1dc200fa9ad63a0ea8d83555", "url": "https://github.com/hazelcast/hazelcast/commit/50c3ec0cd8ff6bfb1dc200fa9ad63a0ea8d83555", "message": "HD SQL: integrate concurrent off-heap B+tree index into the old query engine\n\n* Introduced a global system property to enable global HD indexes;\n\n* Introduced a new HDOrderedConcurrentIndexStore (based on BPlusTree) for global HD indexes\nsupport;\n\n* Fallback to the old partitioned HD index if the global indices are\ndisabled for HD.\n\nCloses https://github.com/hazelcast/hazelcast-enterprise/issues/3652", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "239cb6c4f4bb4274841d7ddf573b3c5391a74e26", "url": "https://github.com/hazelcast/hazelcast/commit/239cb6c4f4bb4274841d7ddf573b3c5391a74e26", "message": "Disabled global lock for on-heap indexes\n\nOtherwise the updates are not atomic", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "be7262d3f99cfa14f2f20c4361a66b01b0f697c5", "url": "https://github.com/hazelcast/hazelcast/commit/be7262d3f99cfa14f2f20c4361a66b01b0f697c5", "message": "Minor: made code a bit simpler", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "6ff173584a3338322a565d2e6ea4281a7717da3d", "url": "https://github.com/hazelcast/hazelcast/commit/6ff173584a3338322a565d2e6ea4281a7717da3d", "message": "Removed a felftover code", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "be7c5ce852d274d9ce10ff7607e11520fd5dc383", "url": "https://github.com/hazelcast/hazelcast/commit/be7c5ce852d274d9ce10ff7607e11520fd5dc383", "message": "Fixed a race condition in indices stats", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "99f225db55e444b925821291c1a52675f876b965", "url": "https://github.com/hazelcast/hazelcast/commit/99f225db55e444b925821291c1a52675f876b965", "message": "Prevent destroying HD Storage on migration\n\nbefore it can be used by other logic.", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "3be542e280f8c0f772c03d127cf1547a6fe3b44c", "url": "https://github.com/hazelcast/hazelcast/commit/3be542e280f8c0f772c03d127cf1547a6fe3b44c", "message": "Adjusted a unit test to handle global HD indices", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "3927f5cdd30a4dc2e8a50d70bd68622125a854aa", "url": "https://github.com/hazelcast/hazelcast/commit/3927f5cdd30a4dc2e8a50d70bd68622125a854aa", "message": "Adjusted a unit test", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "27e9681d70de1854b8b71cf7097f5037777a4b08", "url": "https://github.com/hazelcast/hazelcast/commit/27e9681d70de1854b8b71cf7097f5037777a4b08", "message": "Adjusted a unit test", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "7eb115508b52c5faa85b10a0415b49a8df09944e", "url": "https://github.com/hazelcast/hazelcast/commit/7eb115508b52c5faa85b10a0415b49a8df09944e", "message": "Destroy global indexes when the map is being destroyed", "committedDate": "2020-07-07T12:29:27Z", "type": "commit"}, {"oid": "7eb115508b52c5faa85b10a0415b49a8df09944e", "url": "https://github.com/hazelcast/hazelcast/commit/7eb115508b52c5faa85b10a0415b49a8df09944e", "message": "Destroy global indexes when the map is being destroyed", "committedDate": "2020-07-07T12:29:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxODA4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r450818084", "bodyText": "The javadoc looks outdated comparing to the actual code.", "author": "taburet", "createdAt": "2020-07-07T12:13:48Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseSingleValueIndexStore.java", "diffHunk": "@@ -27,13 +27,24 @@\n  * The base store for indexes that are unable to work with multi-value\n  * attributes natively. For such indexes {@link MultiResult}s are split into\n  * individual values and each value is inserted/removed separately.\n+ * <p>\n+ * All operations on the index store like insert/remove/getRecords are\n+ * not guarded by a global lock. The subclasses must either implement thread-safe", "originalCommit": "cd6d8a67eb1b7dfd50f5d291c357e415c54d796e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMzkzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17133#discussion_r450833936", "bodyText": "Fixed", "author": "petrpleshachkov", "createdAt": "2020-07-07T12:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgxODA4NA=="}], "type": "inlineReview", "revised_code": {"commit": "50c3ec0cd8ff6bfb1dc200fa9ad63a0ea8d83555", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/BaseSingleValueIndexStore.java b/hazelcast/src/main/java/com/hazelcast/query/impl/BaseSingleValueIndexStore.java\nindex 758f292ebd5..09b7943ee31 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/BaseSingleValueIndexStore.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/BaseSingleValueIndexStore.java\n\n@@ -43,8 +43,8 @@ public abstract class BaseSingleValueIndexStore extends BaseIndexStore {\n      */\n     private volatile boolean multiResultHasToDetectDuplicates;\n \n-    BaseSingleValueIndexStore(IndexCopyBehavior copyOn, boolean enableGlobalLock) {\n-        super(copyOn, enableGlobalLock);\n+    BaseSingleValueIndexStore(IndexCopyBehavior copyOn) {\n+        super(copyOn);\n     }\n \n     /**\n"}}, {"oid": "204e18f39e0d45214bbc74711587ab78422311f2", "url": "https://github.com/hazelcast/hazelcast/commit/204e18f39e0d45214bbc74711587ab78422311f2", "message": "Fixed JavaDoc", "committedDate": "2020-07-07T12:40:44Z", "type": "commit"}]}