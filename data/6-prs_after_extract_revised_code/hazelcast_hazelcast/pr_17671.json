{"pr_number": 17671, "pr_title": "Fix race in NodeId innitialization in FlakeId proxy", "pr_createdAt": "2020-10-02T14:15:04Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17671", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NDk1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r498854956", "bodyText": "enforcing the contract as described in JavaDoc", "author": "jerrinot", "createdAt": "2020-10-02T14:25:34Z", "path": "hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java", "diffHunk": "@@ -199,7 +199,9 @@ IdBatchAndWaitTime newIdBaseLocal(long now, int nodeId, int batchSize) {\n      * </ul>\n      */\n     private int getNodeId() {\n-        return getNodeId(System.nanoTime());\n+        int nodeId = getNodeId(System.nanoTime());\n+        assert nodeId > 0 || nodeId == NODE_ID_OUT_OF_RANGE : \"getNodeId() returned invalid value\";", "originalCommit": "17dee7c8bbbf26274a3df62f0fce0ae917ece86e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48086359e34e72c396d9e320f83fd04e81906384", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java b/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\nindex e31984d764..2aa8d9b3d1 100644\n--- a/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\n+++ b/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\n\n@@ -200,7 +200,7 @@ public class FlakeIdGeneratorProxy\n      */\n     private int getNodeId() {\n         int nodeId = getNodeId(System.nanoTime());\n-        assert nodeId > 0 || nodeId == NODE_ID_OUT_OF_RANGE : \"getNodeId() returned invalid value\";\n+        assert nodeId > 0 || nodeId == NODE_ID_OUT_OF_RANGE : \"getNodeId() returned invalid value: \" + nodeId;\n         return nodeId;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MzMzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r499553336", "bodyText": "Your code is OK, so I'm approving. This also works, I find it easier. If you like it you can replace it:\n        long nextNodeIdUpdate = this.nextNodeIdUpdate;\n        int nodeId = this.nodeId;\n        if (nextNodeIdUpdate <= nanoTime) {\n            if (nodeId == NODE_ID_OUT_OF_RANGE) {\n                return nodeId;\n            }\n            int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();\n            assert newNodeId >= 0 : \"newNodeId=\" + newNodeId;\n            newNodeId += nodeIdOffset;\n            if (newNodeId != nodeId) {\n                nodeId = newNodeId;\n\n                // If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId\n                if ((nodeId & -1 << bitsNodeId) != 0) {\n                    outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());\n                    logger.severe(\"Node ID is out of range (\" + nodeId + \"), this member won't be able to generate IDs. \"\n                            + \"Cluster restart is recommended.\");\n                    nodeId = NODE_ID_OUT_OF_RANGE;\n                }\n\n                // we ignore possible double initialization\n                this.nodeId = nodeId;\n                this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                if (logger.isFineEnabled()) {\n                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\n                }\n            }\n        }\nIt ensures that it's impossible to see no need to update before nodeId was assigned to some valid value.", "author": "viliam-durina", "createdAt": "2020-10-05T12:15:15Z", "path": "hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java", "diffHunk": "@@ -226,10 +227,18 @@ int getNodeId(long nanoTime) {\n \n                 // we ignore possible double initialization\n                 this.nodeId = nodeId;\n+                nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;", "originalCommit": "f9d0d7753b302f3ada62984d287dc37b4f63f8f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY1NzYyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r499657628", "bodyText": "indeed your version is easier to read. I applied it. It also addresses the  @mmedenjak finding - the hard to understand comment is simply not needed!\nI only made the local variables copies explicit: so localNodeId instead of just nodeId. I believe it's more readable.", "author": "jerrinot", "createdAt": "2020-10-05T14:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MzMzNg=="}], "type": "inlineReview", "revised_code": {"commit": "48086359e34e72c396d9e320f83fd04e81906384", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java b/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\nindex afb1589b85..2aa8d9b3d1 100644\n--- a/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\n+++ b/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\n\n@@ -209,39 +209,35 @@ public class FlakeIdGeneratorProxy\n         // Check if it is a time to check for updated nodeId. We need to recheck, because if duplicate node ID\n         // is assigned during a network split, this will be resolved after a cluster merge.\n         // We throttle the calls to avoid contention due to the lock+unlock call in getMemberListJoinVersion().\n-        int nodeId = this.nodeId;\n-        if (nodeId != NODE_ID_OUT_OF_RANGE && nextNodeIdUpdate <= nanoTime) {\n+        long localNextNodeIdUpdate = this.nextNodeIdUpdate;\n+        int localNodeId = this.nodeId;\n+        if (localNextNodeIdUpdate <= nanoTime) {\n+            if (localNodeId == NODE_ID_OUT_OF_RANGE) {\n+                return localNodeId;\n+            }\n             int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();\n             assert newNodeId >= 0 : \"newNodeId=\" + newNodeId;\n             newNodeId += nodeIdOffset;\n-            if (newNodeId != nodeId) {\n-                nodeId = newNodeId;\n+            if (newNodeId != localNodeId) {\n+                localNodeId = newNodeId;\n \n                 // If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId\n-                if ((nodeId & -1 << bitsNodeId) != 0) {\n+                if ((localNodeId & -1 << bitsNodeId) != 0) {\n                     outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());\n-                    logger.severe(\"Node ID is out of range (\" + nodeId + \"), this member won't be able to generate IDs. \"\n-                            + \"Cluster restart is recommended.\");\n-                    nodeId = NODE_ID_OUT_OF_RANGE;\n+                    logger.severe(\"Node ID is out of range (\" + localNodeId\n+                            + \"), this member won't be able to generate IDs. Cluster restart is recommended.\");\n+                    localNodeId = NODE_ID_OUT_OF_RANGE;\n                 }\n \n                 // we ignore possible double initialization\n-                this.nodeId = nodeId;\n-                nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n+                this.nodeId = localNodeId;\n+                this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                 if (logger.isFineEnabled()) {\n-                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\n+                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + localNodeId);\n                 }\n             }\n-        } else if (nodeId == NODE_ID_NOT_YET_SET) {\n-            // There is a race between the IF branch above and the local nodeId assignment just above the branch.\n-            // It could be we didn't take the branch yet the local nodeId variable still contains the\n-            // NODE_ID_NOT_YET_SET value.\n-            // Solution: At this point the nodeId *field* is guaranteed to be different from NODE_ID_NOT_YET_SET\n-            // so we can simply dereference it and return it as a result.\n-            nodeId = this.nodeId;\n         }\n-\n-        return nodeId;\n+       return localNodeId;\n     }\n \n     private Member getRandomMember() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1NTU4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17671#discussion_r499555584", "bodyText": "Minor: did you want to say \"It could be that we did take the branch, yet the local nodeId variable is set to NODE_ID_NOT_YET_SET\"? I must admit, I know what you did with the else branch but I don't understand the comment :)", "author": "mmedenjak", "createdAt": "2020-10-05T12:19:33Z", "path": "hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java", "diffHunk": "@@ -226,10 +227,18 @@ int getNodeId(long nanoTime) {\n \n                 // we ignore possible double initialization\n                 this.nodeId = nodeId;\n+                nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                 if (logger.isFineEnabled()) {\n                     logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\n                 }\n             }\n+        } else if (nodeId == NODE_ID_NOT_YET_SET) {\n+            // There is a race between the IF branch above and the local nodeId assignment just above the branch.\n+            // It could be we didn't take the branch yet the local nodeId variable still contains the", "originalCommit": "f9d0d7753b302f3ada62984d287dc37b4f63f8f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "48086359e34e72c396d9e320f83fd04e81906384", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java b/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\nindex afb1589b85..2aa8d9b3d1 100644\n--- a/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\n+++ b/hazelcast/src/main/java/com/hazelcast/flakeidgen/impl/FlakeIdGeneratorProxy.java\n\n@@ -209,39 +209,35 @@ public class FlakeIdGeneratorProxy\n         // Check if it is a time to check for updated nodeId. We need to recheck, because if duplicate node ID\n         // is assigned during a network split, this will be resolved after a cluster merge.\n         // We throttle the calls to avoid contention due to the lock+unlock call in getMemberListJoinVersion().\n-        int nodeId = this.nodeId;\n-        if (nodeId != NODE_ID_OUT_OF_RANGE && nextNodeIdUpdate <= nanoTime) {\n+        long localNextNodeIdUpdate = this.nextNodeIdUpdate;\n+        int localNodeId = this.nodeId;\n+        if (localNextNodeIdUpdate <= nanoTime) {\n+            if (localNodeId == NODE_ID_OUT_OF_RANGE) {\n+                return localNodeId;\n+            }\n             int newNodeId = getNodeEngine().getClusterService().getMemberListJoinVersion();\n             assert newNodeId >= 0 : \"newNodeId=\" + newNodeId;\n             newNodeId += nodeIdOffset;\n-            if (newNodeId != nodeId) {\n-                nodeId = newNodeId;\n+            if (newNodeId != localNodeId) {\n+                localNodeId = newNodeId;\n \n                 // If our node ID is out of range, assign NODE_ID_OUT_OF_RANGE to nodeId\n-                if ((nodeId & -1 << bitsNodeId) != 0) {\n+                if ((localNodeId & -1 << bitsNodeId) != 0) {\n                     outOfRangeMembers.add(getNodeEngine().getClusterService().getLocalMember().getUuid());\n-                    logger.severe(\"Node ID is out of range (\" + nodeId + \"), this member won't be able to generate IDs. \"\n-                            + \"Cluster restart is recommended.\");\n-                    nodeId = NODE_ID_OUT_OF_RANGE;\n+                    logger.severe(\"Node ID is out of range (\" + localNodeId\n+                            + \"), this member won't be able to generate IDs. Cluster restart is recommended.\");\n+                    localNodeId = NODE_ID_OUT_OF_RANGE;\n                 }\n \n                 // we ignore possible double initialization\n-                this.nodeId = nodeId;\n-                nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n+                this.nodeId = localNodeId;\n+                this.nextNodeIdUpdate = nanoTime + NODE_ID_UPDATE_INTERVAL_NS;\n                 if (logger.isFineEnabled()) {\n-                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + nodeId);\n+                    logger.fine(\"Node ID assigned to '\" + name + \"': \" + localNodeId);\n                 }\n             }\n-        } else if (nodeId == NODE_ID_NOT_YET_SET) {\n-            // There is a race between the IF branch above and the local nodeId assignment just above the branch.\n-            // It could be we didn't take the branch yet the local nodeId variable still contains the\n-            // NODE_ID_NOT_YET_SET value.\n-            // Solution: At this point the nodeId *field* is guaranteed to be different from NODE_ID_NOT_YET_SET\n-            // so we can simply dereference it and return it as a result.\n-            nodeId = this.nodeId;\n         }\n-\n-        return nodeId;\n+       return localNodeId;\n     }\n \n     private Member getRandomMember() {\n"}}, {"oid": "48086359e34e72c396d9e320f83fd04e81906384", "url": "https://github.com/hazelcast/hazelcast/commit/48086359e34e72c396d9e320f83fd04e81906384", "message": "Fix race in NodeId innitialization in FlakeId proxy\n\nFixes #16609\n\nReasoning:\nThe `nextNodeIdUpdate` timestamp was updated BEFORE the `nodeId` field.\nThis means when 2 threads were initializing the proxy concurrently\nthen the 2nd thread could see the timestamp already updated then skip the\nIF branch and return a stale version of nodeId - which was not updated yet.\n\nThis problem is fixed by updating the timestamp after the nodeId field.", "committedDate": "2020-10-05T14:46:18Z", "type": "commit"}, {"oid": "48086359e34e72c396d9e320f83fd04e81906384", "url": "https://github.com/hazelcast/hazelcast/commit/48086359e34e72c396d9e320f83fd04e81906384", "message": "Fix race in NodeId innitialization in FlakeId proxy\n\nFixes #16609\n\nReasoning:\nThe `nextNodeIdUpdate` timestamp was updated BEFORE the `nodeId` field.\nThis means when 2 threads were initializing the proxy concurrently\nthen the 2nd thread could see the timestamp already updated then skip the\nIF branch and return a stale version of nodeId - which was not updated yet.\n\nThis problem is fixed by updating the timestamp after the nodeId field.", "committedDate": "2020-10-05T14:46:18Z", "type": "forcePushed"}]}