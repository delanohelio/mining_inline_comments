{"pr_number": 17411, "pr_title": "Adds Nullable and Nonnull annotations to GenericRecord", "pr_createdAt": "2020-08-26T08:49:35Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17411", "timeline": [{"oid": "1491954f15784fce672c5e41c23d6ae19fc1a684", "url": "https://github.com/hazelcast/hazelcast/commit/1491954f15784fce672c5e41c23d6ae19fc1a684", "message": "Add more javadoc for cloneWithBuilder", "committedDate": "2020-08-26T08:58:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0NjU0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477146549", "bodyText": "javax.annotation.Nonnull?", "author": "mdogan", "createdAt": "2020-08-26T09:00:25Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java", "diffHunk": "@@ -22,6 +22,7 @@\n import com.hazelcast.nio.serialization.GenericRecord;\n import com.hazelcast.nio.serialization.HazelcastSerializationException;\n import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import org.jetbrains.annotations.NotNull;", "originalCommit": "1491954f15784fce672c5e41c23d6ae19fc1a684", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0ODY0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477148640", "bodyText": "Interesting. I have added javax.annotation.Nonnull to GenericRecord and then IDE put the annotations to subclasses automatically. It seems I should not trust the IDE. Correcting right away.", "author": "sancar", "createdAt": "2020-08-26T09:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE0NjU0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "969d25850755cb4e4ea7fe9a18085717c43b925f", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java b/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java\nindex a43e01ec90b..8baa9e4defb 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java\n\n@@ -22,7 +22,6 @@ import com.hazelcast.nio.serialization.FieldType;\n import com.hazelcast.nio.serialization.GenericRecord;\n import com.hazelcast.nio.serialization.HazelcastSerializationException;\n import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n-import org.jetbrains.annotations.NotNull;\n \n import javax.annotation.Nonnull;\n import java.util.Arrays;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE2MTA5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477161091", "bodyText": "Do we need to duplicate these annotations in implementations? They're already present in the interface.", "author": "puzpuzpuz", "createdAt": "2020-08-26T09:21:18Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java", "diffHunk": "@@ -41,123 +41,125 @@ public ClassDefinition getClassDefinition() {\n         return classDefinition;\n     }\n \n+    @Nonnull", "originalCommit": "6519d31529a8bbb83e8330cab8e7f9b8cf9d162b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE2NzYyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477167623", "bodyText": "IDE gives a warning if you don't. I think it is good to see it also here.", "author": "sancar", "createdAt": "2020-08-26T09:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE2MTA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3NzE5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477177195", "bodyText": "I see. Thanks for the clarification.", "author": "puzpuzpuz", "createdAt": "2020-08-26T09:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE2MTA5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java b/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java\nindex 8baa9e4defb..a43e01ec90b 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecord.java\n\n@@ -41,125 +42,125 @@ public class PortableGenericRecord implements GenericRecord {\n         return classDefinition;\n     }\n \n-    @Nonnull\n+    @NotNull\n     @Override\n     public Builder newBuilder() {\n         return Builder.portable(classDefinition);\n     }\n \n-    @Nonnull\n+    @NotNull\n     @Override\n     public Builder cloneWithBuilder() {\n         return new PortableGenericRecordBuilder(classDefinition, Arrays.copyOf(objects, objects.length));\n     }\n \n     @Override\n-    public GenericRecord[] readGenericRecordArray(@Nonnull String fieldName) {\n+    public GenericRecord[] readGenericRecordArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.PORTABLE_ARRAY);\n     }\n \n     @Override\n-    public GenericRecord readGenericRecord(@Nonnull String fieldName) {\n+    public GenericRecord readGenericRecord(@NotNull String fieldName) {\n         return read(fieldName, FieldType.PORTABLE);\n     }\n \n     @Override\n-    public boolean hasField(@Nonnull String fieldName) {\n+    public boolean hasField(@NotNull String fieldName) {\n         return classDefinition.hasField(fieldName);\n     }\n \n     @Override\n-    public FieldType getFieldType(@Nonnull String fieldName) {\n+    public FieldType getFieldType(@NotNull String fieldName) {\n         return classDefinition.getFieldType(fieldName);\n     }\n \n     @Override\n-    public boolean readBoolean(@Nonnull String fieldName) {\n+    public boolean readBoolean(@NotNull String fieldName) {\n         return read(fieldName, FieldType.BOOLEAN);\n     }\n \n     @Override\n-    public byte readByte(@Nonnull String fieldName) {\n+    public byte readByte(@NotNull String fieldName) {\n         return read(fieldName, FieldType.BYTE);\n     }\n \n     @Override\n-    public char readChar(@Nonnull String fieldName) {\n+    public char readChar(@NotNull String fieldName) {\n         return read(fieldName, FieldType.CHAR);\n     }\n \n     @Override\n-    public double readDouble(@Nonnull String fieldName) {\n+    public double readDouble(@NotNull String fieldName) {\n         return read(fieldName, FieldType.DOUBLE);\n     }\n \n     @Override\n-    public float readFloat(@Nonnull String fieldName) {\n+    public float readFloat(@NotNull String fieldName) {\n         return read(fieldName, FieldType.FLOAT);\n     }\n \n     @Override\n-    public int readInt(@Nonnull String fieldName) {\n+    public int readInt(@NotNull String fieldName) {\n         return read(fieldName, FieldType.INT);\n     }\n \n     @Override\n-    public long readLong(@Nonnull String fieldName) {\n+    public long readLong(@NotNull String fieldName) {\n         return read(fieldName, FieldType.LONG);\n     }\n \n     @Override\n-    public short readShort(@Nonnull String fieldName) {\n+    public short readShort(@NotNull String fieldName) {\n         return read(fieldName, FieldType.SHORT);\n     }\n \n     @Override\n-    public String readUTF(@Nonnull String fieldName) {\n+    public String readUTF(@NotNull String fieldName) {\n         return read(fieldName, FieldType.UTF);\n     }\n \n     @Override\n-    public boolean[] readBooleanArray(@Nonnull String fieldName) {\n+    public boolean[] readBooleanArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.BOOLEAN_ARRAY);\n     }\n \n     @Override\n-    public byte[] readByteArray(@Nonnull String fieldName) {\n+    public byte[] readByteArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.BYTE_ARRAY);\n     }\n \n     @Override\n-    public char[] readCharArray(@Nonnull String fieldName) {\n+    public char[] readCharArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.CHAR_ARRAY);\n     }\n \n     @Override\n-    public double[] readDoubleArray(@Nonnull String fieldName) {\n+    public double[] readDoubleArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.DOUBLE_ARRAY);\n     }\n \n     @Override\n-    public float[] readFloatArray(@Nonnull String fieldName) {\n+    public float[] readFloatArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.FLOAT_ARRAY);\n     }\n \n     @Override\n-    public int[] readIntArray(@Nonnull String fieldName) {\n+    public int[] readIntArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.INT_ARRAY);\n     }\n \n     @Override\n-    public long[] readLongArray(@Nonnull String fieldName) {\n+    public long[] readLongArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.LONG_ARRAY);\n     }\n \n     @Override\n-    public short[] readShortArray(@Nonnull String fieldName) {\n+    public short[] readShortArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.SHORT_ARRAY);\n     }\n \n     @Override\n-    public String[] readUTFArray(@Nonnull String fieldName) {\n+    public String[] readUTFArray(@NotNull String fieldName) {\n         return read(fieldName, FieldType.UTF_ARRAY);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3MzQ1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477173456", "bodyText": "still missing here in return type", "author": "cangencer", "createdAt": "2020-08-26T09:41:53Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -269,13 +296,14 @@\n          * @param classDefinition of the portable that we will create\n          * @return GenericRecordBuilder for Portable format\n          */\n-        static Builder portable(ClassDefinition classDefinition) {\n+        static Builder portable(@Nonnull ClassDefinition classDefinition) {", "originalCommit": "6519d31529a8bbb83e8330cab8e7f9b8cf9d162b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MTgwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477191808", "bodyText": "@cangencer I  updated the pr accordingly", "author": "sancar", "createdAt": "2020-08-26T10:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3MzQ1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\nindex f1772ad1fd3..d23c6239641 100644\n--- a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n\n@@ -302,6 +290,7 @@ public interface GenericRecord {\n \n         /**\n          * @return a new constructed GenericRecord\n+         * @throws HazelcastSerializationException when the GenericRecord cannot be build.\n          */\n         @Nonnull\n         GenericRecord build();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NTIyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477195224", "bodyText": "these are still missing :)", "author": "cangencer", "createdAt": "2020-08-26T10:20:55Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -292,7 +327,7 @@ static Builder portable(ClassDefinition classDefinition) {\n          *                                         Same field is trying to be overwritten without using\n          *                                         {@link GenericRecord#cloneWithBuilder()}.\n          */\n-        Builder writeBoolean(String fieldName, boolean value);\n+        Builder writeBoolean(@Nonnull String fieldName, boolean value);", "originalCommit": "c8614f1e6d524e0d0bcb5b4fc800956945d98071", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTkyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477215929", "bodyText": "I just didn't want to add NonNullable for obvious chaining pattern.", "author": "sancar", "createdAt": "2020-08-26T11:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NTIyNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NTg3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477195879", "bodyText": "I don't see any method named createGenericRecordBuilder ? I think it's newBuilder?", "author": "cangencer", "createdAt": "2020-08-26T10:22:14Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -70,183 +71,215 @@\n      *\n      * @return an empty generic record builder with same class definition as this one\n      */\n+    @Nonnull\n     Builder newBuilder();\n \n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n+     * So instead of following where only the `id` field is updated,\n+     * <pre>\n+     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()", "originalCommit": "c8614f1e6d524e0d0bcb5b4fc800956945d98071", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\nindex 66f29a4b28b..d23c6239641 100644\n--- a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n\n@@ -77,30 +77,12 @@ public interface GenericRecord {\n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n-     * So instead of following where only the `id` field is updated,\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()\n-     *                         .writeUTF(\"name\", genericRecord.readUTF(\"name\"))\n-     *                         .writeLong(\"id\", 4)\n-     *                         .writeUTF(\"surname\", genericRecord.readUTF(\"surname\"))\n-     *                         .writeInt(\"age\", genericRecord.readInt(\"age\")).build();\n-     * </pre>\n-     * `cloneWithBuilder` used as follows:\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder().writeInt(\"id\", 4).build();\n-     * </pre>\n      *\n      * @return a generic record builder with same class definition as this one and populated with same values.\n      */\n     @Nonnull\n     Builder cloneWithBuilder();\n \n-    /**\n-     * @param fieldName the name of the field\n-     * @return field type for the given field name\n-     * @throws IllegalArgumentException if the field name does not exist in the class definition\n-     */\n-    @Nonnull\n     FieldType getFieldType(@Nonnull String fieldName);\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NjYyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477196621", "bodyText": "I would shorthand this method to just builder()", "author": "cangencer", "createdAt": "2020-08-26T10:23:44Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -70,183 +71,215 @@\n      *\n      * @return an empty generic record builder with same class definition as this one\n      */\n+    @Nonnull\n     Builder newBuilder();", "originalCommit": "c8614f1e6d524e0d0bcb5b4fc800956945d98071", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\nindex 66f29a4b28b..d23c6239641 100644\n--- a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n\n@@ -77,30 +77,12 @@ public interface GenericRecord {\n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n-     * So instead of following where only the `id` field is updated,\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()\n-     *                         .writeUTF(\"name\", genericRecord.readUTF(\"name\"))\n-     *                         .writeLong(\"id\", 4)\n-     *                         .writeUTF(\"surname\", genericRecord.readUTF(\"surname\"))\n-     *                         .writeInt(\"age\", genericRecord.readInt(\"age\")).build();\n-     * </pre>\n-     * `cloneWithBuilder` used as follows:\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder().writeInt(\"id\", 4).build();\n-     * </pre>\n      *\n      * @return a generic record builder with same class definition as this one and populated with same values.\n      */\n     @Nonnull\n     Builder cloneWithBuilder();\n \n-    /**\n-     * @param fieldName the name of the field\n-     * @return field type for the given field name\n-     * @throws IllegalArgumentException if the field name does not exist in the class definition\n-     */\n-    @Nonnull\n     FieldType getFieldType(@Nonnull String fieldName);\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NzMyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477197321", "bodyText": "builderWithCopy()", "author": "cangencer", "createdAt": "2020-08-26T10:25:03Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -70,183 +71,215 @@\n      *\n      * @return an empty generic record builder with same class definition as this one\n      */\n+    @Nonnull\n     Builder newBuilder();\n \n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n+     * So instead of following where only the `id` field is updated,\n+     * <pre>\n+     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()\n+     *                         .writeUTF(\"name\", genericRecord.readUTF(\"name\"))\n+     *                         .writeLong(\"id\", 4)\n+     *                         .writeUTF(\"surname\", genericRecord.readUTF(\"surname\"))\n+     *                         .writeInt(\"age\", genericRecord.readInt(\"age\")).build();\n+     * </pre>\n+     * `cloneWithBuilder` used as follows:\n+     * <pre>\n+     *     GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder().writeInt(\"id\", 4).build();\n+     * </pre>\n      *\n      * @return a generic record builder with same class definition as this one and populated with same values.\n      */\n+    @Nonnull\n     Builder cloneWithBuilder();", "originalCommit": "c8614f1e6d524e0d0bcb5b4fc800956945d98071", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\nindex 66f29a4b28b..d23c6239641 100644\n--- a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n\n@@ -77,30 +77,12 @@ public interface GenericRecord {\n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n-     * So instead of following where only the `id` field is updated,\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()\n-     *                         .writeUTF(\"name\", genericRecord.readUTF(\"name\"))\n-     *                         .writeLong(\"id\", 4)\n-     *                         .writeUTF(\"surname\", genericRecord.readUTF(\"surname\"))\n-     *                         .writeInt(\"age\", genericRecord.readInt(\"age\")).build();\n-     * </pre>\n-     * `cloneWithBuilder` used as follows:\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder().writeInt(\"id\", 4).build();\n-     * </pre>\n      *\n      * @return a generic record builder with same class definition as this one and populated with same values.\n      */\n     @Nonnull\n     Builder cloneWithBuilder();\n \n-    /**\n-     * @param fieldName the name of the field\n-     * @return field type for the given field name\n-     * @throws IllegalArgumentException if the field name does not exist in the class definition\n-     */\n-    @Nonnull\n     FieldType getFieldType(@Nonnull String fieldName);\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5NzczNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477197737", "bodyText": "put instead of write , as write implies you have to do it sequentially.", "author": "cangencer", "createdAt": "2020-08-26T10:25:51Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -345,7 +380,7 @@ static Builder portable(ClassDefinition classDefinition) {\n          *                                         Same field is trying to be overwritten without using\n          *                                         {@link GenericRecord#cloneWithBuilder()}.\n          */\n-        Builder writeFloat(String fieldName, float value);\n+        Builder writeFloat(@Nonnull String fieldName, float value);", "originalCommit": "c8614f1e6d524e0d0bcb5b4fc800956945d98071", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5Nzg4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17411#discussion_r477197883", "bodyText": "get instead of read, as read implies sequential access rather than random access", "author": "cangencer", "createdAt": "2020-08-26T10:26:08Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -70,183 +71,215 @@\n      *\n      * @return an empty generic record builder with same class definition as this one\n      */\n+    @Nonnull\n     Builder newBuilder();\n \n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n+     * So instead of following where only the `id` field is updated,\n+     * <pre>\n+     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()\n+     *                         .writeUTF(\"name\", genericRecord.readUTF(\"name\"))\n+     *                         .writeLong(\"id\", 4)\n+     *                         .writeUTF(\"surname\", genericRecord.readUTF(\"surname\"))\n+     *                         .writeInt(\"age\", genericRecord.readInt(\"age\")).build();\n+     * </pre>\n+     * `cloneWithBuilder` used as follows:\n+     * <pre>\n+     *     GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder().writeInt(\"id\", 4).build();\n+     * </pre>\n      *\n      * @return a generic record builder with same class definition as this one and populated with same values.\n      */\n+    @Nonnull\n     Builder cloneWithBuilder();\n \n-    FieldType getFieldType(String fieldName);\n+    /**\n+     * @param fieldName the name of the field\n+     * @return field type for the given field name\n+     * @throws IllegalArgumentException if the field name does not exist in the class definition\n+     */\n+    @Nonnull\n+    FieldType getFieldType(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return true if field exists in the definition of the class. Note that returns true even if the field is null.\n      */\n-    boolean hasField(String fieldName);\n+    boolean hasField(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    boolean readBoolean(String fieldName);\n+    boolean readBoolean(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    byte readByte(String fieldName);\n+    byte readByte(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    char readChar(String fieldName);\n+    char readChar(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    double readDouble(String fieldName);\n+    double readDouble(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    float readFloat(String fieldName);\n+    float readFloat(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    int readInt(String fieldName);\n+    int readInt(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    long readLong(String fieldName);\n+    long readLong(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    short readShort(String fieldName);\n+    short readShort(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    String readUTF(String fieldName);\n+    @Nullable\n+    String readUTF(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    GenericRecord readGenericRecord(String fieldName);\n+    @Nullable\n+    GenericRecord readGenericRecord(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    boolean[] readBooleanArray(String fieldName);\n+    @Nullable\n+    boolean[] readBooleanArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    byte[] readByteArray(String fieldName);\n+    @Nullable\n+    byte[] readByteArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    char[] readCharArray(String fieldName);\n+    @Nullable\n+    char[] readCharArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    double[] readDoubleArray(String fieldName);\n+    @Nullable\n+    double[] readDoubleArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    float[] readFloatArray(String fieldName);\n+    @Nullable\n+    float[] readFloatArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    int[] readIntArray(String fieldName);\n+    @Nullable\n+    int[] readIntArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    long[] readLongArray(String fieldName);\n+    @Nullable\n+    long[] readLongArray(@Nonnull String fieldName);\n \n     /**\n      * @param fieldName the name of the field\n      * @return the value of the field\n      * @throws HazelcastSerializationException if the field name does not exist in the class definition or\n      *                                         the type of the field does not match the one in the class definition.\n      */\n-    short[] readShortArray(String fieldName);\n+    @Nullable\n+    short[] readShortArray(@Nonnull String fieldName);", "originalCommit": "c8614f1e6d524e0d0bcb5b4fc800956945d98071", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\nindex 66f29a4b28b..d23c6239641 100644\n--- a/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n+++ b/hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java\n\n@@ -77,30 +77,12 @@ public interface GenericRecord {\n     /**\n      * Returned {@link Builder} can be used to have exact copy and also just to update a couple of fields. By default,\n      * it will copy all the fields.\n-     * So instead of following where only the `id` field is updated,\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.createGenericRecordBuilder()\n-     *                         .writeUTF(\"name\", genericRecord.readUTF(\"name\"))\n-     *                         .writeLong(\"id\", 4)\n-     *                         .writeUTF(\"surname\", genericRecord.readUTF(\"surname\"))\n-     *                         .writeInt(\"age\", genericRecord.readInt(\"age\")).build();\n-     * </pre>\n-     * `cloneWithBuilder` used as follows:\n-     * <pre>\n-     *     GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder().writeInt(\"id\", 4).build();\n-     * </pre>\n      *\n      * @return a generic record builder with same class definition as this one and populated with same values.\n      */\n     @Nonnull\n     Builder cloneWithBuilder();\n \n-    /**\n-     * @param fieldName the name of the field\n-     * @return field type for the given field name\n-     * @throws IllegalArgumentException if the field name does not exist in the class definition\n-     */\n-    @Nonnull\n     FieldType getFieldType(@Nonnull String fieldName);\n \n     /**\n"}}, {"oid": "d21b9535ad5b5bae693e8fe59309a38f1cd59265", "url": "https://github.com/hazelcast/hazelcast/commit/d21b9535ad5b5bae693e8fe59309a38f1cd59265", "message": "Adds Nullable and Nonnull annotations to GenericRecord", "committedDate": "2020-08-26T13:13:04Z", "type": "commit"}, {"oid": "5a313c3d20c3fb29c344eee7f6293a3ce3129574", "url": "https://github.com/hazelcast/hazelcast/commit/5a313c3d20c3fb29c344eee7f6293a3ce3129574", "message": "Add more javadoc for cloneWithBuilder", "committedDate": "2020-08-26T13:13:05Z", "type": "commit"}, {"oid": "969d25850755cb4e4ea7fe9a18085717c43b925f", "url": "https://github.com/hazelcast/hazelcast/commit/969d25850755cb4e4ea7fe9a18085717c43b925f", "message": "Replace NotNull with NonNull", "committedDate": "2020-08-26T13:13:23Z", "type": "commit"}, {"oid": "f04856fa610f41bc1c9cb122a2dd0a8281fa97fb", "url": "https://github.com/hazelcast/hazelcast/commit/f04856fa610f41bc1c9cb122a2dd0a8281fa97fb", "message": "add more nonnull annotations and javadoc to getFieldType", "committedDate": "2020-08-26T13:13:23Z", "type": "commit"}, {"oid": "901b5c087a82f5e52ebd379a7fd87ee030965d55", "url": "https://github.com/hazelcast/hazelcast/commit/901b5c087a82f5e52ebd379a7fd87ee030965d55", "message": "more javadoc and javadoc fix", "committedDate": "2020-08-26T13:13:23Z", "type": "commit"}, {"oid": "901b5c087a82f5e52ebd379a7fd87ee030965d55", "url": "https://github.com/hazelcast/hazelcast/commit/901b5c087a82f5e52ebd379a7fd87ee030965d55", "message": "more javadoc and javadoc fix", "committedDate": "2020-08-26T13:13:23Z", "type": "forcePushed"}]}