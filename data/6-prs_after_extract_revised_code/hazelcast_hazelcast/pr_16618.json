{"pr_number": 16618, "pr_title": "Fix txn near cache", "pr_createdAt": "2020-02-05T16:28:47Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16618", "timeline": [{"oid": "997c9bc552b1dcd489880a3f92372b9f73456e9b", "url": "https://github.com/hazelcast/hazelcast/commit/997c9bc552b1dcd489880a3f92372b9f73456e9b", "message": "Fix txn near cache", "committedDate": "2020-02-05T16:44:24Z", "type": "forcePushed"}, {"oid": "a37ead056e9394ab2719dc3d030c4925206cebc7", "url": "https://github.com/hazelcast/hazelcast/commit/a37ead056e9394ab2719dc3d030c4925206cebc7", "message": "Fix txn near cache", "committedDate": "2020-02-05T18:07:37Z", "type": "commit"}, {"oid": "a37ead056e9394ab2719dc3d030c4925206cebc7", "url": "https://github.com/hazelcast/hazelcast/commit/a37ead056e9394ab2719dc3d030c4925206cebc7", "message": "Fix txn near cache", "committedDate": "2020-02-05T18:07:37Z", "type": "forcePushed"}, {"oid": "3b8ecbc7dce7ecd6a2e6b70ad04a28e51fe3d535", "url": "https://github.com/hazelcast/hazelcast/commit/3b8ecbc7dce7ecd6a2e6b70ad04a28e51fe3d535", "message": "Checkstyle", "committedDate": "2020-02-05T18:17:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NDg5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16618#discussion_r375794891", "bodyText": "If some exceptions happen in this block, we still call invalidation in the finally. We don't do this in the new code. Is it OK if we have an exceptional scenario? It seems in the new implementation we handle failures only on commit.", "author": "petrpleshachkov", "createdAt": "2020-02-06T12:00:50Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/tx/TransactionalMapProxy.java", "diffHunk": "@@ -143,19 +145,19 @@ public Object put(Object key, Object value, long ttl, TimeUnit timeUnit) {\n         checkNotNull(key, \"key can't be null\");\n         checkNotNull(value, \"value can't be null\");\n \n-        Object nearCacheKey = toNearCacheKeyWithStrategy(key);\n-        try {\n-            Data keyData = mapServiceContext.toData(nearCacheKey, partitionStrategy);\n-            Object valueBeforeTxn = toObjectIfNeeded(putInternal(keyData, mapServiceContext.toData(value), ttl, timeUnit));\n-\n-            TxnValueWrapper currentValue = txMap.get(keyData);\n-            Type type = valueBeforeTxn == null ? Type.NEW : Type.UPDATED;\n-            TxnValueWrapper wrapper = new TxnValueWrapper(value, type);\n-            txMap.put(keyData, wrapper);\n-            return currentValue == null ? valueBeforeTxn : checkIfRemoved(currentValue);\n-        } finally {", "originalCommit": "3b8ecbc7dce7ecd6a2e6b70ad04a28e51fe3d535", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzNjczNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16618#discussion_r375836737", "bodyText": "Yes it is ok not to have that finally block. The right place to apply invalidations is commit phase. Depending on the failure or success near cache interaction should happen in there.", "author": "ahmetmircik", "createdAt": "2020-02-06T13:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NDg5MQ=="}], "type": "inlineReview", "revised_code": null}]}