{"pr_number": 17713, "pr_title": "Add migration listener on client", "pr_createdAt": "2020-10-12T14:31:23Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17713", "timeline": [{"oid": "e2a00694597c8e9258a5b988bef8f471034f304e", "url": "https://github.com/hazelcast/hazelcast/commit/e2a00694597c8e9258a5b988bef8f471034f304e", "message": "regenerate protocol", "committedDate": "2020-10-12T19:11:02Z", "type": "forcePushed"}, {"oid": "1a347f2bf214e26aa5f35edadfbd99e410bbad5a", "url": "https://github.com/hazelcast/hazelcast/commit/1a347f2bf214e26aa5f35edadfbd99e410bbad5a", "message": "Test Migration Listener registration and remove", "committedDate": "2020-10-22T21:29:46Z", "type": "forcePushed"}, {"oid": "e16007ac5d0b7043cb1505b3b1181e3a5209d8e1", "url": "https://github.com/hazelcast/hazelcast/commit/e16007ac5d0b7043cb1505b3b1181e3a5209d8e1", "message": "Add Migration Listener on the client", "committedDate": "2020-10-28T19:45:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEyNDQ4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515124489", "bodyText": "No need to create new MigrationStateImpl object. We can pass event.getMigrationState to encode.. method", "author": "sancar", "createdAt": "2020-10-30T14:08:11Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientAddMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_FINISHED;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_STARTED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+\n+public class AddMigrationListenerMessageTask\n+        extends AbstractAddListenerMessageTask<Boolean> {\n+\n+    public AddMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected CompletableFuture<UUID> processInternal() {\n+        IPartitionService partitionService = getService(getServiceName());\n+\n+        MigrationListener listener = createMigrationListener();\n+\n+        if (parameters) {\n+            return newCompletedFuture(partitionService.addLocalMigrationListener(listener));\n+        }\n+\n+        return partitionService.addMigrationListenerAsync(listener);\n+    }\n+\n+    private MigrationListener createMigrationListener() {\n+        return new MigrationListener() {\n+\n+                @Override\n+                public void migrationStarted(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_STARTED));\n+                }\n+\n+                @Override\n+                public void migrationFinished(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_FINISHED));\n+                }\n+\n+                @Override\n+                public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+\n+                @Override\n+                public void replicaMigrationFailed(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+            };\n+    }\n+\n+    private void sendIfAlive(ClientMessage eventMessage) {\n+        if (endpoint.isAlive()) {\n+            sendClientMessage(MIGRATION_EVENT_TOPIC_ORDER_KEY, eventMessage);\n+        }\n+    }\n+\n+    private ClientMessage encodeReplicaMigrationEvent(ReplicaMigrationEvent event) {\n+        return ClientAddMigrationListenerCodec.encodeReplicaMigrationEvent(\n+                new MigrationStateImpl(", "originalCommit": "048a9fe4362fa1bd511fc376c8c38d52266603b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f143bc5426b6a6b36566bbd022911f6628fef02", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\nindex 175b0dd13d5..a555a4f7eda 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\n\n@@ -31,7 +31,6 @@ import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n \n import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n-import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_FINISHED;\n import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_STARTED;\n import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEyNDU2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515124564", "bodyText": "No need to create new MigrationStateImpl object. We can pass event.getMigrationState to encode.. method", "author": "sancar", "createdAt": "2020-10-30T14:08:17Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientAddMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_FINISHED;\n+import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_STARTED;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+\n+public class AddMigrationListenerMessageTask\n+        extends AbstractAddListenerMessageTask<Boolean> {\n+\n+    public AddMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected CompletableFuture<UUID> processInternal() {\n+        IPartitionService partitionService = getService(getServiceName());\n+\n+        MigrationListener listener = createMigrationListener();\n+\n+        if (parameters) {\n+            return newCompletedFuture(partitionService.addLocalMigrationListener(listener));\n+        }\n+\n+        return partitionService.addMigrationListenerAsync(listener);\n+    }\n+\n+    private MigrationListener createMigrationListener() {\n+        return new MigrationListener() {\n+\n+                @Override\n+                public void migrationStarted(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_STARTED));\n+                }\n+\n+                @Override\n+                public void migrationFinished(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, MIGRATION_FINISHED));\n+                }\n+\n+                @Override\n+                public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+\n+                @Override\n+                public void replicaMigrationFailed(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+            };\n+    }\n+\n+    private void sendIfAlive(ClientMessage eventMessage) {\n+        if (endpoint.isAlive()) {\n+            sendClientMessage(MIGRATION_EVENT_TOPIC_ORDER_KEY, eventMessage);\n+        }\n+    }\n+\n+    private ClientMessage encodeReplicaMigrationEvent(ReplicaMigrationEvent event) {\n+        return ClientAddMigrationListenerCodec.encodeReplicaMigrationEvent(\n+                new MigrationStateImpl(\n+                        event.getMigrationState().getStartTime(),\n+                        event.getMigrationState().getPlannedMigrations(),\n+                        event.getMigrationState().getCompletedMigrations(),\n+                        event.getMigrationState().getTotalElapsedTime()\n+                ),\n+                event.getPartitionId(),\n+                event.getReplicaIndex(),\n+                event.getSource() != null ? event.getSource().getUuid() : null,\n+                event.getDestination() != null ? event.getDestination().getUuid() : null,\n+                event.isSuccess(),\n+                event.getElapsedTime()\n+        );\n+    }\n+\n+    private ClientMessage encodeMigrationEvent(MigrationState event, int partitionId) {\n+        return ClientAddMigrationListenerCodec.encodeMigrationEvent(\n+                new MigrationStateImpl(", "originalCommit": "048a9fe4362fa1bd511fc376c8c38d52266603b0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f143bc5426b6a6b36566bbd022911f6628fef02", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\nindex 175b0dd13d5..a555a4f7eda 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\n\n@@ -31,7 +31,6 @@ import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n \n import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n-import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_FINISHED;\n import static com.hazelcast.internal.partition.MigrationEventHandler.MIGRATION_STARTED;\n import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n"}}, {"oid": "6f143bc5426b6a6b36566bbd022911f6628fef02", "url": "https://github.com/hazelcast/hazelcast/commit/6f143bc5426b6a6b36566bbd022911f6628fef02", "message": "Add Migration Listener on the client", "committedDate": "2020-10-30T15:32:31Z", "type": "commit"}, {"oid": "bdfec61bc81d797d53e7ab2b322e19577e13474a", "url": "https://github.com/hazelcast/hazelcast/commit/bdfec61bc81d797d53e7ab2b322e19577e13474a", "message": "Fix sending migration event order to the client", "committedDate": "2020-10-30T15:32:32Z", "type": "commit"}, {"oid": "c79ff0cd62341b535022a1cab056c92014134c86", "url": "https://github.com/hazelcast/hazelcast/commit/c79ff0cd62341b535022a1cab056c92014134c86", "message": "Avoid creating MigrationStateImpl", "committedDate": "2020-10-30T15:32:32Z", "type": "commit"}, {"oid": "048d48b66c0e99405fbf12fe18c6dc454826f408", "url": "https://github.com/hazelcast/hazelcast/commit/048d48b66c0e99405fbf12fe18c6dc454826f408", "message": "MigrationListener since 2.2", "committedDate": "2020-10-30T15:35:37Z", "type": "commit"}, {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27", "url": "https://github.com/hazelcast/hazelcast/commit/de33c992210703192e02d52ab7fd2d13de62ce27", "message": "Introduce migration event type to the protocol", "committedDate": "2020-10-30T17:00:10Z", "type": "commit"}, {"oid": "048a9fe4362fa1bd511fc376c8c38d52266603b0", "url": "https://github.com/hazelcast/hazelcast/commit/048a9fe4362fa1bd511fc376c8c38d52266603b0", "message": "Fix sending migration event order to the client", "committedDate": "2020-10-29T20:41:14Z", "type": "forcePushed"}, {"oid": "de33c992210703192e02d52ab7fd2d13de62ce27", "url": "https://github.com/hazelcast/hazelcast/commit/de33c992210703192e02d52ab7fd2d13de62ce27", "message": "Introduce migration event type to the protocol", "committedDate": "2020-10-30T17:00:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg4NzExMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515887110", "bodyText": "Hi @peterjot\nI have just realized the reason for using the partition id here. I did not know that we are using negative values of partition id as the event type. I have internally opened up this issue with the team. And we decided that in the client protocol we want to separate the event type from the partition id. So we are on the right track.\nIf I am not mistaken, we should not need to check the partition id anymore in this path, since we already made sure on the server we will not see Migration_started -1 and migration finished -2 on the partition id's.\nWhen you remove that this class will be fairly small. Can you remove this class and move the logic to\nPartitionServiceProxy. I think we don't need a new class and redirection for a couple of lines anymore.", "author": "sancar", "createdAt": "2020-11-02T10:47:33Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.partition;\n+\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+public final class MigrationEventHandler {\n+\n+    public static final int MIGRATION_STARTED_PARTITION_ID = -1;\n+    public static final int MIGRATION_FINISHED_PARTITION_ID = -2;\n+\n+    private final MigrationListener migrationListener;\n+\n+    public MigrationEventHandler(MigrationListener migrationListener) {\n+        this.migrationListener = migrationListener;\n+    }\n+\n+    public void handleMigrationEvent(MigrationState state, MigrationEventType type) {\n+        switch (type) {\n+            case MIGRATION_STARTED:\n+                migrationListener.migrationStarted(state);\n+                break;\n+            case MIGRATION_FINISHED:\n+                migrationListener.migrationFinished(state);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid event type: \" + type);\n+        }\n+    }\n+\n+    public void handleReplicaMigrationEvent(ReplicaMigrationEvent event) {\n+        switch (event.getPartitionId()) {", "originalCommit": "de33c992210703192e02d52ab7fd2d13de62ce27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java b/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java\ndeleted file mode 100644\nindex 7171ac222ee..00000000000\n--- a/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java\n+++ /dev/null\n\n@@ -1,63 +0,0 @@\n-/*\n- * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.hazelcast.internal.partition;\n-\n-import com.hazelcast.partition.MigrationListener;\n-import com.hazelcast.partition.MigrationState;\n-import com.hazelcast.partition.ReplicaMigrationEvent;\n-\n-public final class MigrationEventHandler {\n-\n-    public static final int MIGRATION_STARTED_PARTITION_ID = -1;\n-    public static final int MIGRATION_FINISHED_PARTITION_ID = -2;\n-\n-    private final MigrationListener migrationListener;\n-\n-    public MigrationEventHandler(MigrationListener migrationListener) {\n-        this.migrationListener = migrationListener;\n-    }\n-\n-    public void handleMigrationEvent(MigrationState state, MigrationEventType type) {\n-        switch (type) {\n-            case MIGRATION_STARTED:\n-                migrationListener.migrationStarted(state);\n-                break;\n-            case MIGRATION_FINISHED:\n-                migrationListener.migrationFinished(state);\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid event type: \" + type);\n-        }\n-    }\n-\n-    public void handleReplicaMigrationEvent(ReplicaMigrationEvent event) {\n-        switch (event.getPartitionId()) {\n-            case MIGRATION_STARTED_PARTITION_ID:\n-                handleMigrationEvent(event.getMigrationState(), MigrationEventType.MIGRATION_STARTED);\n-                break;\n-            case MIGRATION_FINISHED_PARTITION_ID:\n-                handleMigrationEvent(event.getMigrationState(), MigrationEventType.MIGRATION_FINISHED);\n-                break;\n-            default:\n-                if (event.isSuccess()) {\n-                    migrationListener.replicaMigrationCompleted(event);\n-                } else {\n-                    migrationListener.replicaMigrationFailed(event);\n-                }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5MDk3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515890971", "bodyText": "Leaving the default state empty make much more sense if you think about future extensions. Let's say this client connected to a new server, which has a new migration event type. Old clients should not throw an exception or log something aggressively because it is expected and old clients should just ignore it.", "author": "sancar", "createdAt": "2020-11-02T10:54:13Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.partition;\n+\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+public final class MigrationEventHandler {\n+\n+    public static final int MIGRATION_STARTED_PARTITION_ID = -1;\n+    public static final int MIGRATION_FINISHED_PARTITION_ID = -2;\n+\n+    private final MigrationListener migrationListener;\n+\n+    public MigrationEventHandler(MigrationListener migrationListener) {\n+        this.migrationListener = migrationListener;\n+    }\n+\n+    public void handleMigrationEvent(MigrationState state, MigrationEventType type) {\n+        switch (type) {\n+            case MIGRATION_STARTED:\n+                migrationListener.migrationStarted(state);\n+                break;\n+            case MIGRATION_FINISHED:\n+                migrationListener.migrationFinished(state);\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid event type: \" + type);", "originalCommit": "de33c992210703192e02d52ab7fd2d13de62ce27", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java b/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java\ndeleted file mode 100644\nindex 7171ac222ee..00000000000\n--- a/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventHandler.java\n+++ /dev/null\n\n@@ -1,63 +0,0 @@\n-/*\n- * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.hazelcast.internal.partition;\n-\n-import com.hazelcast.partition.MigrationListener;\n-import com.hazelcast.partition.MigrationState;\n-import com.hazelcast.partition.ReplicaMigrationEvent;\n-\n-public final class MigrationEventHandler {\n-\n-    public static final int MIGRATION_STARTED_PARTITION_ID = -1;\n-    public static final int MIGRATION_FINISHED_PARTITION_ID = -2;\n-\n-    private final MigrationListener migrationListener;\n-\n-    public MigrationEventHandler(MigrationListener migrationListener) {\n-        this.migrationListener = migrationListener;\n-    }\n-\n-    public void handleMigrationEvent(MigrationState state, MigrationEventType type) {\n-        switch (type) {\n-            case MIGRATION_STARTED:\n-                migrationListener.migrationStarted(state);\n-                break;\n-            case MIGRATION_FINISHED:\n-                migrationListener.migrationFinished(state);\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid event type: \" + type);\n-        }\n-    }\n-\n-    public void handleReplicaMigrationEvent(ReplicaMigrationEvent event) {\n-        switch (event.getPartitionId()) {\n-            case MIGRATION_STARTED_PARTITION_ID:\n-                handleMigrationEvent(event.getMigrationState(), MigrationEventType.MIGRATION_STARTED);\n-                break;\n-            case MIGRATION_FINISHED_PARTITION_ID:\n-                handleMigrationEvent(event.getMigrationState(), MigrationEventType.MIGRATION_FINISHED);\n-                break;\n-            default:\n-                if (event.isSuccess()) {\n-                    migrationListener.replicaMigrationCompleted(event);\n-                } else {\n-                    migrationListener.replicaMigrationFailed(event);\n-                }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5ODYwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515898601", "bodyText": "I am not really sure about this but, I think,  MigrationEventType class is not necessary. We are using enum classes like this when we want to expose them to the API. In this case, an static int on MessageTask/PartitionServiceProxy could do the job as well.\nEven if this stays, it should be moved to the client package as this is a specific type for client only.\nMore specifically com.hazelcast.client.impl should be ok.", "author": "sancar", "createdAt": "2020-11-02T11:08:13Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.partition;\n+\n+\n+/**\n+ * Migration event types.\n+ * @see MigrationEventHandler\n+ */\n+public enum MigrationEventType {", "originalCommit": "de33c992210703192e02d52ab7fd2d13de62ce27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkxODA1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r515918053", "bodyText": "Yes, this enum is no longer needed if we remove MigrationEventHandler", "author": "peterjot", "createdAt": "2020-11-02T11:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg5ODYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventType.java b/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventType.java\ndeleted file mode 100644\nindex 807d1e1aaa0..00000000000\n--- a/hazelcast/src/main/java/com/hazelcast/internal/partition/MigrationEventType.java\n+++ /dev/null\n\n@@ -1,58 +0,0 @@\n-/*\n- * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.hazelcast.internal.partition;\n-\n-\n-/**\n- * Migration event types.\n- * @see MigrationEventHandler\n- */\n-public enum MigrationEventType {\n-\n-    /**\n-     * An event type indicating that the migration process started.\n-     */\n-    MIGRATION_STARTED(0),\n-\n-    /**\n-     * An event type indicating that the migration process finished.\n-     */\n-    MIGRATION_FINISHED(1);\n-\n-    private final int type;\n-\n-    MigrationEventType(final int type) {\n-        this.type = type;\n-    }\n-\n-    /**\n-     * @return unique ID of the event type.\n-     */\n-    public int getType() {\n-        return type;\n-    }\n-\n-    public static MigrationEventType getByType(final int type) {\n-        if (type == MIGRATION_STARTED.type) {\n-            return MIGRATION_STARTED;\n-        }\n-        if (type == MIGRATION_FINISHED.type) {\n-            return MIGRATION_FINISHED;\n-        }\n-        throw new IllegalArgumentException(\"Invalid event type: \" + type);\n-    }\n-}\n"}}, {"oid": "c89af2737b19817c43a3755d70a81ef1aad7960d", "url": "https://github.com/hazelcast/hazelcast/commit/c89af2737b19817c43a3755d70a81ef1aad7960d", "message": "Remove MigrationEventHandler and MigrationEventType", "committedDate": "2020-11-02T12:31:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzYwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517977605", "bodyText": "nit: should use IPartitionService.SERVICE_NAME", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:23:08Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.InternalPartitionService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+public class RemoveMigrationListenerMessageTask\n+        extends AbstractRemoveListenerMessageTask<UUID> {\n+\n+    public RemoveMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Future<Boolean> deRegisterListener() {\n+        InternalPartitionService service = getService(InternalPartitionService.SERVICE_NAME);", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "578c6dfd25d2338dbaf01a564c84ae96102442fc", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\nindex c9ac491a2ce..53ba0c20a11 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\n\n@@ -20,6 +20,7 @@ import com.hazelcast.client.impl.protocol.ClientMessage;\n import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n import com.hazelcast.instance.impl.Node;\n import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n import com.hazelcast.internal.partition.InternalPartitionService;\n \n import java.security.Permission;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzY1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517977653", "bodyText": "nit: should use IPartitionService.SERVICE_NAME", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:23:15Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.InternalPartitionService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+public class RemoveMigrationListenerMessageTask\n+        extends AbstractRemoveListenerMessageTask<UUID> {\n+\n+    public RemoveMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Future<Boolean> deRegisterListener() {\n+        InternalPartitionService service = getService(InternalPartitionService.SERVICE_NAME);\n+        return service.removeMigrationListenerAsync(parameters);\n+    }\n+\n+    @Override\n+    protected UUID getRegistrationId() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    protected UUID decodeClientMessage(ClientMessage clientMessage) {\n+        return ClientRemoveMigrationListenerCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        return ClientRemoveMigrationListenerCodec.encodeResponse((Boolean) response);\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return InternalPartitionService.SERVICE_NAME;", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "578c6dfd25d2338dbaf01a564c84ae96102442fc", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\nindex c9ac491a2ce..53ba0c20a11 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\n\n@@ -20,6 +20,7 @@ import com.hazelcast.client.impl.protocol.ClientMessage;\n import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n import com.hazelcast.instance.impl.Node;\n import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n import com.hazelcast.internal.partition.InternalPartitionService;\n \n import java.security.Permission;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3OTc1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517979759", "bodyText": "A potentially stupid question for @sancar. Why don't we specify InternalPartitionService.MIGRATION_EVENT_TOPIC here, like we do it in AddMigrationListenerMessageTask? This way SecurityContext interceptor won't be able to handle (and potentially reject) the remove listener operation. Or I'm missing something and there is a reason to have it this way?", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:27:01Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.InternalPartitionService;\n+\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+public class RemoveMigrationListenerMessageTask\n+        extends AbstractRemoveListenerMessageTask<UUID> {\n+\n+    public RemoveMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected Future<Boolean> deRegisterListener() {\n+        InternalPartitionService service = getService(InternalPartitionService.SERVICE_NAME);\n+        return service.removeMigrationListenerAsync(parameters);\n+    }\n+\n+    @Override\n+    protected UUID getRegistrationId() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    protected UUID decodeClientMessage(ClientMessage clientMessage) {\n+        return ClientRemoveMigrationListenerCodec.decodeRequest(clientMessage);\n+    }\n+\n+    @Override\n+    protected ClientMessage encodeResponse(Object response) {\n+        return ClientRemoveMigrationListenerCodec.encodeResponse((Boolean) response);\n+    }\n+\n+    @Override\n+    public String getServiceName() {\n+        return InternalPartitionService.SERVICE_NAME;\n+    }\n+\n+    @Override\n+    public Permission getRequiredPermission() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String getDistributedObjectName() {\n+        return null;", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY5MDEyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518690123", "bodyText": "Marking this one as resolved. The plan is to have a better documentation around SecurityContext.", "author": "puzpuzpuz", "createdAt": "2020-11-06T11:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3OTc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "578c6dfd25d2338dbaf01a564c84ae96102442fc", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\nindex c9ac491a2ce..53ba0c20a11 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/RemoveMigrationListenerMessageTask.java\n\n@@ -20,6 +20,7 @@ import com.hazelcast.client.impl.protocol.ClientMessage;\n import com.hazelcast.client.impl.protocol.codec.ClientRemoveMigrationListenerCodec;\n import com.hazelcast.instance.impl.Node;\n import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n import com.hazelcast.internal.partition.InternalPartitionService;\n \n import java.security.Permission;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4Mjk5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517982997", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean removeMigrationListener(UUID registrationId) {\n          \n          \n            \n                public boolean removeMigrationListener(@Nonnull UUID registrationId) {", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:32:44Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java", "diffHunk": "@@ -74,21 +84,51 @@ public Partition getPartition(@Nonnull Object key) {\n     }\n \n     @Override\n-    public UUID addMigrationListener(MigrationListener migrationListener) {\n-        throw new UnsupportedOperationException();\n+    public UUID addMigrationListener(@Nonnull MigrationListener migrationListener) {\n+        checkNotNull(migrationListener, \"migrationListener can't be null\");\n+        EventHandler<ClientMessage> handler = new ClientMigrationEventHandler(migrationListener);\n+        return listenerService.registerListener(createMigrationListenerCodec(), handler);\n     }\n \n     @Override\n     public boolean removeMigrationListener(UUID registrationId) {", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "103713afa902578c349e669802e34ee504664ca6", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java b/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\nindex 552295f0d49..fd866d62229 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\n\n@@ -91,7 +91,7 @@ public final class PartitionServiceProxy implements PartitionService {\n     }\n \n     @Override\n-    public boolean removeMigrationListener(UUID registrationId) {\n+    public boolean removeMigrationListener(@Nonnull UUID registrationId) {\n         checkNotNull(registrationId, \"registrationId can't be null\");\n         return listenerService.deregisterListener(registrationId);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4MzQxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517983413", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean removePartitionLostListener(UUID registrationId) {\n          \n          \n            \n                public boolean removePartitionLostListener(@Nonnull UUID registrationId) {", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:33:32Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java", "diffHunk": "@@ -74,21 +84,51 @@ public Partition getPartition(@Nonnull Object key) {\n     }\n \n     @Override\n-    public UUID addMigrationListener(MigrationListener migrationListener) {\n-        throw new UnsupportedOperationException();\n+    public UUID addMigrationListener(@Nonnull MigrationListener migrationListener) {\n+        checkNotNull(migrationListener, \"migrationListener can't be null\");\n+        EventHandler<ClientMessage> handler = new ClientMigrationEventHandler(migrationListener);\n+        return listenerService.registerListener(createMigrationListenerCodec(), handler);\n     }\n \n     @Override\n     public boolean removeMigrationListener(UUID registrationId) {\n-        throw new UnsupportedOperationException();\n+        checkNotNull(registrationId, \"registrationId can't be null\");\n+        return listenerService.deregisterListener(registrationId);\n     }\n \n     @Override\n-    public UUID addPartitionLostListener(PartitionLostListener partitionLostListener) {\n+    public UUID addPartitionLostListener(@Nonnull PartitionLostListener partitionLostListener) {\n+        checkNotNull(partitionLostListener, \"migrationListener can't be null\");\n         EventHandler<ClientMessage> handler = new ClientPartitionLostEventHandler(partitionLostListener);\n         return listenerService.registerListener(createPartitionLostListenerCodec(), handler);\n     }\n \n+    @Override\n+    public boolean removePartitionLostListener(UUID registrationId) {", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "103713afa902578c349e669802e34ee504664ca6", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java b/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\nindex 552295f0d49..fd866d62229 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\n\n@@ -91,7 +91,7 @@ public final class PartitionServiceProxy implements PartitionService {\n     }\n \n     @Override\n-    public boolean removeMigrationListener(UUID registrationId) {\n+    public boolean removeMigrationListener(@Nonnull UUID registrationId) {\n         checkNotNull(registrationId, \"registrationId can't be null\");\n         return listenerService.deregisterListener(registrationId);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4MzkxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517983917", "bodyText": "nit: it would be nice to leave a comment on the no-op default case here", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:34:26Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java", "diffHunk": "@@ -154,4 +193,52 @@ public void handlePartitionLostEvent(int partitionId, int lostBackupCount, UUID\n         }\n     }\n \n+    private class ClientMigrationEventHandler extends ClientAddMigrationListenerCodec.AbstractEventHandler\n+            implements EventHandler<ClientMessage> {\n+\n+        private final MigrationListener listener;\n+\n+        ClientMigrationEventHandler(MigrationListener listener) {\n+            this.listener = listener;\n+        }\n+\n+        @Override\n+        public void handleMigrationEvent(MigrationState migrationState, int type) {\n+            switch (type) {\n+                case MIGRATION_STARTED:\n+                    listener.migrationStarted(migrationState);\n+                    break;\n+                case MIGRATION_FINISHED:\n+                    listener.migrationFinished(migrationState);\n+                    break;\n+                default:", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "103713afa902578c349e669802e34ee504664ca6", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java b/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\nindex 552295f0d49..fd866d62229 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/proxy/PartitionServiceProxy.java\n\n@@ -212,6 +212,7 @@ public final class PartitionServiceProxy implements PartitionService {\n                     listener.migrationFinished(migrationState);\n                     break;\n                 default:\n+                    // left empty for future type extensions instead of throwing an exception\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5Mzk5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517993998", "bodyText": "Shouldn't we call sendClientMessage(null, eventMessage); here? MIGRATION_EVENT_TOPIC_ORDER_KEY constant is not a partition id. @sancar WDYT?", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:52:44Z", "path": "hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.impl.protocol.task;\n+\n+import com.hazelcast.client.impl.protocol.ClientMessage;\n+import com.hazelcast.client.impl.protocol.codec.ClientAddMigrationListenerCodec;\n+import com.hazelcast.client.impl.proxy.PartitionServiceProxy;\n+import com.hazelcast.cluster.Member;\n+import com.hazelcast.instance.impl.Node;\n+import com.hazelcast.internal.nio.Connection;\n+import com.hazelcast.internal.partition.IPartitionService;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+\n+import javax.annotation.Nullable;\n+import java.security.Permission;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n+import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n+\n+public class AddMigrationListenerMessageTask\n+        extends AbstractAddListenerMessageTask<Boolean> {\n+\n+    public AddMigrationListenerMessageTask(ClientMessage clientMessage, Node node, Connection connection) {\n+        super(clientMessage, node, connection);\n+    }\n+\n+    @Override\n+    protected CompletableFuture<UUID> processInternal() {\n+        IPartitionService partitionService = getService(getServiceName());\n+\n+        MigrationListener listener = createMigrationListener();\n+\n+        if (parameters) {\n+            return newCompletedFuture(partitionService.addLocalMigrationListener(listener));\n+        }\n+\n+        return partitionService.addMigrationListenerAsync(listener);\n+    }\n+\n+    private MigrationListener createMigrationListener() {\n+        return new MigrationListener() {\n+\n+                @Override\n+                public void migrationStarted(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, PartitionServiceProxy.MIGRATION_STARTED));\n+                }\n+\n+                @Override\n+                public void migrationFinished(MigrationState state) {\n+                    sendIfAlive(encodeMigrationEvent(state, PartitionServiceProxy.MIGRATION_FINISHED));\n+                }\n+\n+                @Override\n+                public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+\n+                @Override\n+                public void replicaMigrationFailed(ReplicaMigrationEvent event) {\n+                    sendIfAlive(encodeReplicaMigrationEvent(event));\n+                }\n+            };\n+    }\n+\n+    private void sendIfAlive(ClientMessage eventMessage) {\n+        if (endpoint.isAlive()) {\n+            sendClientMessage(MIGRATION_EVENT_TOPIC_ORDER_KEY, eventMessage);", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY5NDM3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518694370", "bodyText": "@peterjot I'm afraid that I forced you to revert a properly working code with this comment. \ud83d\ude05\nI've discussed this call with @sancar and it appears that we need to have a partition id (or a magic number to be more precise) here. That's because of the following.\nWhen the message is send this way, -1 is implicitly used as the partition id. Then the Java client receives an event, it sees the -1 and executes the corresponding handler on a random thread. Which means that we're loosing the order on the client side when we use sendClientMessage(null, eventMessage); here.\nCould you restore the previous implementation and add a comment around this call to help with avoiding confusion in the future?", "author": "puzpuzpuz", "createdAt": "2020-11-06T11:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5Mzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMDIxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518730212", "bodyText": "Sure, I also added a test to check it :P", "author": "peterjot", "createdAt": "2020-11-06T12:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5Mzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMjUxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518732511", "bodyText": "Thanks. Let me run the test suite now.", "author": "puzpuzpuz", "createdAt": "2020-11-06T12:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5Mzk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMzQxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518733412", "bodyText": "Could you also add a use a constant \"partition id\" to enforce event handling order comment here?\nhttps://github.com/hazelcast/hazelcast/pull/17713/files#diff-98463052a544c8d2833cd2c4761dad8b0187e5653e20b84452bad5ecf3a636d6R85", "author": "puzpuzpuz", "createdAt": "2020-11-06T12:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5Mzk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "103713afa902578c349e669802e34ee504664ca6", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\nindex 1abee23ab44..8ab81a9f822 100644\n--- a/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\n+++ b/hazelcast/src/main/java/com/hazelcast/client/impl/protocol/task/AddMigrationListenerMessageTask.java\n\n@@ -33,7 +33,6 @@ import java.util.UUID;\n import java.util.concurrent.CompletableFuture;\n \n import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n-import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC_ORDER_KEY;\n import static com.hazelcast.spi.impl.InternalCompletableFuture.newCompletedFuture;\n \n public class AddMigrationListenerMessageTask\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzU4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r517997582", "bodyText": "Another stupid question for @sancar. Why don't we use event.getPartitionId() instead of MIGRATION_EVENT_TOPIC_ORDER_KEY here?\nA side note. I don't really like this implicit logic based on hash code for event order key. We may easily run into collisions between different event types without even noticing it.", "author": "puzpuzpuz", "createdAt": "2020-11-05T11:58:47Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionEventManager.java", "diffHunk": "@@ -79,25 +83,25 @@ public void sendMigrationEvent(MigrationState state, MigrationInfo migrationInfo\n     }\n \n     public void sendMigrationProcessStartedEvent(MigrationState state) {\n-        ReplicaMigrationEvent event = new ReplicaMigrationEventImpl(state, MIGRATION_STARTED, 0, null, null, false, 0L);\n+        ReplicaMigrationEvent event =\n+                new ReplicaMigrationEventImpl(state, MIGRATION_STARTED_PARTITION_ID, 0, null, null, false, 0L);\n         sendMigrationEvent(event);\n     }\n \n     public void sendMigrationProcessCompletedEvent(MigrationState state) {\n-        ReplicaMigrationEvent event = new ReplicaMigrationEventImpl(state, MIGRATION_FINISHED, 0, null, null, false, 0L);\n+        ReplicaMigrationEvent event =\n+                new ReplicaMigrationEventImpl(state, MIGRATION_FINISHED_PARTITION_ID, 0, null, null, false, 0L);\n         sendMigrationEvent(event);\n     }\n \n     private void sendMigrationEvent(ReplicaMigrationEvent event) {\n         EventService eventService = nodeEngine.getEventService();\n         // All migration events are sent in order.\n-        eventService.publishEvent(SERVICE_NAME, MIGRATION_EVENT_TOPIC, event, MIGRATION_EVENT_TOPIC.hashCode());\n+        eventService.publishEvent(SERVICE_NAME, MIGRATION_EVENT_TOPIC, event, MIGRATION_EVENT_TOPIC_ORDER_KEY);", "originalCommit": "c89af2737b19817c43a3755d70a81ef1aad7960d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMTA5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518401097", "bodyText": "I dare to answer this question :D\nIf you take a look at lines 86 and 92\nYou can see that when the migration process is started or finished we send accordingly partitionId = -1 if started or -2 if finished. But on typical ReplicaMigrationEvent we send partitionId from MigrationInfo (line 75) .\nTo ensure that these events are sent in the correct order, they should have the same orderKey\n@sancar  If I understand correctly, even if there are collisions, at most two types of events will be handled on the same worker, right?", "author": "peterjot", "createdAt": "2020-11-05T22:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU2NDQyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518564423", "bodyText": "If you take a look at lines 86 and 92\nYou can see that when the migration process is started or finished we send accordingly partitionId = -1 if started or -2 if finished. But on typical ReplicaMigrationEvent we send partitionId from MigrationInfo (line 75) .\n\nMakes sense. So, the reason is those global events.\nAs for the collisions, I've checked the local branch which boils down to StripedExecutor#getWorker and it seems that collisions are tolerated by the design.", "author": "puzpuzpuz", "createdAt": "2020-11-06T07:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NzU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "103713afa902578c349e669802e34ee504664ca6", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionEventManager.java b/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionEventManager.java\nindex ac261e04471..a72eac0ab91 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionEventManager.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/partition/impl/PartitionEventManager.java\n\n@@ -97,7 +96,7 @@ public class PartitionEventManager {\n     private void sendMigrationEvent(ReplicaMigrationEvent event) {\n         EventService eventService = nodeEngine.getEventService();\n         // All migration events are sent in order.\n-        eventService.publishEvent(SERVICE_NAME, MIGRATION_EVENT_TOPIC, event, MIGRATION_EVENT_TOPIC_ORDER_KEY);\n+        eventService.publishEvent(SERVICE_NAME, MIGRATION_EVENT_TOPIC, event, MIGRATION_EVENT_TOPIC.hashCode());\n     }\n \n     public UUID addMigrationListener(@Nonnull MigrationListener listener) {\n"}}, {"oid": "103713afa902578c349e669802e34ee504664ca6", "url": "https://github.com/hazelcast/hazelcast/commit/103713afa902578c349e669802e34ee504664ca6", "message": "Send client message with key = null", "committedDate": "2020-11-05T22:16:27Z", "type": "commit"}, {"oid": "578c6dfd25d2338dbaf01a564c84ae96102442fc", "url": "https://github.com/hazelcast/hazelcast/commit/578c6dfd25d2338dbaf01a564c84ae96102442fc", "message": "Use IPartitionService instead of InternalPartitionService", "committedDate": "2020-11-05T22:49:53Z", "type": "commit"}, {"oid": "912e4e51b22d47b603930b1ef0146cb6273020ef", "url": "https://github.com/hazelcast/hazelcast/commit/912e4e51b22d47b603930b1ef0146cb6273020ef", "message": "Use IPartitionService instead of InternalPartitionService", "committedDate": "2020-11-05T22:52:12Z", "type": "commit"}, {"oid": "cd91e2bc440a86a1f1a63660225851af8615943c", "url": "https://github.com/hazelcast/hazelcast/commit/cd91e2bc440a86a1f1a63660225851af8615943c", "message": "Send client message with key = MIGRATION_EVENT_TOPIC hash code and add a test", "committedDate": "2020-11-06T12:36:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNDM5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518734393", "bodyText": "nit: redundant new line.", "author": "puzpuzpuz", "createdAt": "2020-11-06T12:57:33Z", "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);\n+    }\n+\n+    private <T extends MigrationListener> void testMigrationListenerInvoked(T clientListener,\n+                                              Function<MigrationListener, HazelcastInstance> clientFactory,\n+                                              Consumer<T> assertFunction) {\n+\n+        HazelcastInstance instance1 = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = clientFactory.apply(clientListener);\n+        warmUpPartitions(instance1, client);\n+\n+        // Change to NO_MIGRATION to prevent repartitioning\n+        // before 2nd member started and ready.\n+        instance1.getCluster().changeClusterState(ClusterState.NO_MIGRATION);\n+\n+        HazelcastInstance instance2 = hazelcastFactory.newHazelcastInstance();\n+\n+        changeClusterStateEventually(instance2, ClusterState.ACTIVE);\n+        waitAllForSafeState(instance2, instance1, client);\n+\n+        assertRegistrationsSizeEventually(instance1, 1);\n+        assertFunction.accept(clientListener);\n+    }\n+\n+    private void verifyMigrationListenerNeverInvoked(MigrationListener listener) {\n+        verify(listener, never()).migrationStarted(any(MigrationStateImpl.class));\n+        verify(listener, never()).migrationFinished(any(MigrationStateImpl.class));\n+        verify(listener, never()).replicaMigrationCompleted(any(ReplicaMigrationEvent.class));\n+        verify(listener, never()).replicaMigrationFailed(any(ReplicaMigrationEvent.class));\n+    }\n+\n+    private void assertMigrationProcess(PartitionMigrationListenerTest.EventCollectingMigrationListener listener) {\n+        PartitionMigrationListenerTest.MigrationEventsPack eventsPack = listener.ensureAndGetSingleEventPack();\n+        assertMigrationProcessCompleted(eventsPack);\n+        assertMigrationProcessEventsConsistent(eventsPack);\n+        assertMigrationEventsConsistentWithResult(eventsPack);\n+    }\n+\n+    private PartitionMigrationListenerTest.EventCollectingMigrationListener eventCollectingMigrationListener() {\n+        return new PartitionMigrationListenerTest.EventCollectingMigrationListener();\n+    }\n+\n+    private void assertRegistrationsSizeEventually(HazelcastInstance instance, int size) {\n+        assertTrueEventually(() -> {\n+            EventService eventService = getNode(instance).getNodeEngine().getEventService();\n+            Collection<EventRegistration> registrations = eventService\n+                    .getRegistrations(SERVICE_NAME, MIGRATION_EVENT_TOPIC);\n+            assertEquals(size, registrations.size());\n+        });\n+    }\n+\n+    static class SingleThreadMigrationListener implements MigrationListener {\n+\n+        private String threadName;\n+        private boolean finished = false;\n+\n+        @Override\n+        public void migrationStarted(MigrationState state) {\n+            assertNull(threadName);\n+            threadName = Thread.currentThread().getName();\n+        }\n+\n+        @Override\n+        public void migrationFinished(MigrationState state) {\n+            assertNotNull(threadName);\n+            assertEquals(threadName, Thread.currentThread().getName());\n+            finished = true;\n+        }\n+\n+        @Override\n+        public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+            assertNotNull(threadName);\n+            assertEquals(threadName, Thread.currentThread().getName());\n+", "originalCommit": "cd91e2bc440a86a1f1a63660225851af8615943c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "032c8a972565a6b9fa7de69900508c902a68a854", "chunk": "diff --git a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\nindex c85992f7dbf..1f3d9c4aa7a 100644\n--- a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n+++ b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n\n@@ -56,8 +56,6 @@ import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNTE1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518735153", "bodyText": "This field should be volatile.", "author": "puzpuzpuz", "createdAt": "2020-11-06T12:59:10Z", "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);\n+    }\n+\n+    private <T extends MigrationListener> void testMigrationListenerInvoked(T clientListener,\n+                                              Function<MigrationListener, HazelcastInstance> clientFactory,\n+                                              Consumer<T> assertFunction) {\n+\n+        HazelcastInstance instance1 = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = clientFactory.apply(clientListener);\n+        warmUpPartitions(instance1, client);\n+\n+        // Change to NO_MIGRATION to prevent repartitioning\n+        // before 2nd member started and ready.\n+        instance1.getCluster().changeClusterState(ClusterState.NO_MIGRATION);\n+\n+        HazelcastInstance instance2 = hazelcastFactory.newHazelcastInstance();\n+\n+        changeClusterStateEventually(instance2, ClusterState.ACTIVE);\n+        waitAllForSafeState(instance2, instance1, client);\n+\n+        assertRegistrationsSizeEventually(instance1, 1);\n+        assertFunction.accept(clientListener);\n+    }\n+\n+    private void verifyMigrationListenerNeverInvoked(MigrationListener listener) {\n+        verify(listener, never()).migrationStarted(any(MigrationStateImpl.class));\n+        verify(listener, never()).migrationFinished(any(MigrationStateImpl.class));\n+        verify(listener, never()).replicaMigrationCompleted(any(ReplicaMigrationEvent.class));\n+        verify(listener, never()).replicaMigrationFailed(any(ReplicaMigrationEvent.class));\n+    }\n+\n+    private void assertMigrationProcess(PartitionMigrationListenerTest.EventCollectingMigrationListener listener) {\n+        PartitionMigrationListenerTest.MigrationEventsPack eventsPack = listener.ensureAndGetSingleEventPack();\n+        assertMigrationProcessCompleted(eventsPack);\n+        assertMigrationProcessEventsConsistent(eventsPack);\n+        assertMigrationEventsConsistentWithResult(eventsPack);\n+    }\n+\n+    private PartitionMigrationListenerTest.EventCollectingMigrationListener eventCollectingMigrationListener() {\n+        return new PartitionMigrationListenerTest.EventCollectingMigrationListener();\n+    }\n+\n+    private void assertRegistrationsSizeEventually(HazelcastInstance instance, int size) {\n+        assertTrueEventually(() -> {\n+            EventService eventService = getNode(instance).getNodeEngine().getEventService();\n+            Collection<EventRegistration> registrations = eventService\n+                    .getRegistrations(SERVICE_NAME, MIGRATION_EVENT_TOPIC);\n+            assertEquals(size, registrations.size());\n+        });\n+    }\n+\n+    static class SingleThreadMigrationListener implements MigrationListener {\n+\n+        private String threadName;\n+        private boolean finished = false;", "originalCommit": "cd91e2bc440a86a1f1a63660225851af8615943c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "032c8a972565a6b9fa7de69900508c902a68a854", "chunk": "diff --git a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\nindex c85992f7dbf..1f3d9c4aa7a 100644\n--- a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n+++ b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n\n@@ -56,8 +56,6 @@ import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNjY1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518736650", "bodyText": "This line exceeds 130 chars.", "author": "puzpuzpuz", "createdAt": "2020-11-06T13:02:00Z", "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);", "originalCommit": "cd91e2bc440a86a1f1a63660225851af8615943c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "032c8a972565a6b9fa7de69900508c902a68a854", "chunk": "diff --git a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\nindex c85992f7dbf..1f3d9c4aa7a 100644\n--- a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n+++ b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n\n@@ -56,8 +56,6 @@ import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczOTkwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518739909", "bodyText": "This and other asserts in this and replicaMigrationFailed methods don't affect the test result, i.e. if we change this line to assertNull(threadName);, the test still passes. Maybe, it's a good idea to introduce another boolean field which will be changed to false when the listener is invoked on a different thread. Then this field could be checked in assertAllMethodsInvokedOnTheSameThread method.", "author": "puzpuzpuz", "createdAt": "2020-11-06T13:08:40Z", "path": "hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.client.partitionservice;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.test.TestHazelcastFactory;\n+import com.hazelcast.cluster.ClusterState;\n+import com.hazelcast.config.ListenerConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.partition.MigrationStateImpl;\n+import com.hazelcast.internal.util.UuidUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.PartitionMigrationListenerTest;\n+import com.hazelcast.partition.PartitionService;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.spi.impl.eventservice.EventRegistration;\n+import com.hazelcast.spi.impl.eventservice.EventService;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static com.hazelcast.internal.cluster.impl.AdvancedClusterStateTest.changeClusterStateEventually;\n+import static com.hazelcast.internal.partition.IPartitionService.SERVICE_NAME;\n+import static com.hazelcast.internal.partition.InternalPartitionService.MIGRATION_EVENT_TOPIC;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationEventsConsistentWithResult;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessCompleted;\n+import static com.hazelcast.partition.PartitionMigrationListenerTest.assertMigrationProcessEventsConsistent;\n+import static com.hazelcast.test.Accessors.getNode;\n+import static com.hazelcast.test.HazelcastTestSupport.assertTrueEventually;\n+import static com.hazelcast.test.HazelcastTestSupport.waitAllForSafeState;\n+import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ClientMigrationListenerTest {\n+\n+    private final TestHazelcastFactory hazelcastFactory = new TestHazelcastFactory();\n+\n+    @After\n+    public void tearDown() {\n+        hazelcastFactory.terminateAll();\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByConfig() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(mock(MigrationListener.class)));\n+\n+        hazelcastFactory.newHazelcastClient(clientConfig);\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenRegisteredByPartitionService() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+\n+        client.getPartitionService().addMigrationListener(mock(MigrationListener.class));\n+\n+        assertRegistrationsSizeEventually(instance, 1);\n+    }\n+\n+    @Test\n+    public void testAddMigrationListener_whenListenerRegisteredTwice() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID id1 = partitionService.addMigrationListener(listener);\n+        UUID id2 = partitionService.addMigrationListener(listener);\n+\n+        assertNotEquals(id1, id2);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void testRemoveMigrationListener_whenNullListener() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        partitionService.removeMigrationListener(null);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenNonExistingRegistrationId() {\n+        hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService partitionService = client.getPartitionService();\n+\n+        boolean result = partitionService.removeMigrationListener(UuidUtil.newUnsecureUUID());\n+\n+        assertFalse(result);\n+    }\n+\n+    @Test\n+    public void testRemoveMigrationListener_whenExistingRegistrationId() {\n+        HazelcastInstance instance = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+        PartitionService clientPartitionService = client.getPartitionService();\n+        MigrationListener listener = mock(MigrationListener.class);\n+\n+        UUID registrationId = clientPartitionService.addMigrationListener(listener);\n+        assertRegistrationsSizeEventually(instance, 1);\n+\n+        boolean removed = clientPartitionService.removeMigrationListener(registrationId);\n+        assertRegistrationsSizeEventually(instance, 0);\n+        assertTrue(removed);\n+\n+        HazelcastInstance hz2 = hazelcastFactory.newHazelcastInstance();\n+        warmUpPartitions(instance, hz2);\n+\n+        verifyMigrationListenerNeverInvoked(listener);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByConfig() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            ClientConfig clientConfig = new ClientConfig().addListenerConfig(new ListenerConfig(listener));\n+            return hazelcastFactory.newHazelcastClient(clientConfig);\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testMigrationListenerInvoked_whenRegisteredByPartitionService() {\n+        PartitionMigrationListenerTest.EventCollectingMigrationListener clientListener = eventCollectingMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, this::assertMigrationProcess);\n+    }\n+\n+    @Test\n+    public void testAllMigrationListenerMethodsInvokedOnTheSameThread() {\n+        SingleThreadMigrationListener clientListener = new SingleThreadMigrationListener();\n+        Function<MigrationListener, HazelcastInstance> clientSupplier = listener -> {\n+            HazelcastInstance client = hazelcastFactory.newHazelcastClient();\n+            client.getPartitionService().addMigrationListener(listener);\n+            return client;\n+        };\n+\n+        testMigrationListenerInvoked(clientListener, clientSupplier, SingleThreadMigrationListener::assertAllMethodsInvokedOnTheSameThread);\n+    }\n+\n+    private <T extends MigrationListener> void testMigrationListenerInvoked(T clientListener,\n+                                              Function<MigrationListener, HazelcastInstance> clientFactory,\n+                                              Consumer<T> assertFunction) {\n+\n+        HazelcastInstance instance1 = hazelcastFactory.newHazelcastInstance();\n+        HazelcastInstance client = clientFactory.apply(clientListener);\n+        warmUpPartitions(instance1, client);\n+\n+        // Change to NO_MIGRATION to prevent repartitioning\n+        // before 2nd member started and ready.\n+        instance1.getCluster().changeClusterState(ClusterState.NO_MIGRATION);\n+\n+        HazelcastInstance instance2 = hazelcastFactory.newHazelcastInstance();\n+\n+        changeClusterStateEventually(instance2, ClusterState.ACTIVE);\n+        waitAllForSafeState(instance2, instance1, client);\n+\n+        assertRegistrationsSizeEventually(instance1, 1);\n+        assertFunction.accept(clientListener);\n+    }\n+\n+    private void verifyMigrationListenerNeverInvoked(MigrationListener listener) {\n+        verify(listener, never()).migrationStarted(any(MigrationStateImpl.class));\n+        verify(listener, never()).migrationFinished(any(MigrationStateImpl.class));\n+        verify(listener, never()).replicaMigrationCompleted(any(ReplicaMigrationEvent.class));\n+        verify(listener, never()).replicaMigrationFailed(any(ReplicaMigrationEvent.class));\n+    }\n+\n+    private void assertMigrationProcess(PartitionMigrationListenerTest.EventCollectingMigrationListener listener) {\n+        PartitionMigrationListenerTest.MigrationEventsPack eventsPack = listener.ensureAndGetSingleEventPack();\n+        assertMigrationProcessCompleted(eventsPack);\n+        assertMigrationProcessEventsConsistent(eventsPack);\n+        assertMigrationEventsConsistentWithResult(eventsPack);\n+    }\n+\n+    private PartitionMigrationListenerTest.EventCollectingMigrationListener eventCollectingMigrationListener() {\n+        return new PartitionMigrationListenerTest.EventCollectingMigrationListener();\n+    }\n+\n+    private void assertRegistrationsSizeEventually(HazelcastInstance instance, int size) {\n+        assertTrueEventually(() -> {\n+            EventService eventService = getNode(instance).getNodeEngine().getEventService();\n+            Collection<EventRegistration> registrations = eventService\n+                    .getRegistrations(SERVICE_NAME, MIGRATION_EVENT_TOPIC);\n+            assertEquals(size, registrations.size());\n+        });\n+    }\n+\n+    static class SingleThreadMigrationListener implements MigrationListener {\n+\n+        private String threadName;\n+        private boolean finished = false;\n+\n+        @Override\n+        public void migrationStarted(MigrationState state) {\n+            assertNull(threadName);\n+            threadName = Thread.currentThread().getName();\n+        }\n+\n+        @Override\n+        public void migrationFinished(MigrationState state) {\n+            assertNotNull(threadName);\n+            assertEquals(threadName, Thread.currentThread().getName());\n+            finished = true;\n+        }\n+\n+        @Override\n+        public void replicaMigrationCompleted(ReplicaMigrationEvent event) {\n+            assertNotNull(threadName);", "originalCommit": "cd91e2bc440a86a1f1a63660225851af8615943c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxNjczMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17713#discussion_r518816731", "bodyText": "Good point! Thank you for the code review and suggestions \ud83d\ude03", "author": "peterjot", "createdAt": "2020-11-06T15:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczOTkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "032c8a972565a6b9fa7de69900508c902a68a854", "chunk": "diff --git a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\nindex c85992f7dbf..1f3d9c4aa7a 100644\n--- a/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n+++ b/hazelcast/src/test/java/com/hazelcast/client/partitionservice/ClientMigrationListenerTest.java\n\n@@ -56,8 +56,6 @@ import static com.hazelcast.test.HazelcastTestSupport.warmUpPartitions;\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.Mockito.mock;\n"}}, {"oid": "032c8a972565a6b9fa7de69900508c902a68a854", "url": "https://github.com/hazelcast/hazelcast/commit/032c8a972565a6b9fa7de69900508c902a68a854", "message": "Test migration listener invoked on a single thread", "committedDate": "2020-11-06T15:04:03Z", "type": "commit"}]}