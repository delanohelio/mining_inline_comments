{"pr_number": 17291, "pr_title": "Move SQL parser to Jet", "pr_createdAt": "2020-08-03T06:31:46Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17291", "timeline": [{"oid": "9095cec7953b7aff30074e0443030ce0cb991a9d", "url": "https://github.com/hazelcast/hazelcast/commit/9095cec7953b7aff30074e0443030ce0cb991a9d", "message": "Remove custom parser, connector, external tables infrastructure.\n\nAdd parser, converter & optimizer integration points for Jet.", "committedDate": "2020-07-31T13:39:07Z", "type": "commit"}, {"oid": "71b11df1db58fa43485e3931c4d783cf2aaf92b2", "url": "https://github.com/hazelcast/hazelcast/commit/71b11df1db58fa43485e3931c4d783cf2aaf92b2", "message": "Simplify", "committedDate": "2020-08-03T06:11:15Z", "type": "commit"}, {"oid": "2e4ad522df9a10e3163c702ccc5090c1686f28b8", "url": "https://github.com/hazelcast/hazelcast/commit/2e4ad522df9a10e3163c702ccc5090c1686f28b8", "message": "Make checkstyle happier", "committedDate": "2020-08-03T06:39:43Z", "type": "commit"}, {"oid": "b717890b12bea8011c00a3692774371d61918746", "url": "https://github.com/hazelcast/hazelcast/commit/b717890b12bea8011c00a3692774371d61918746", "message": "Tweaks", "committedDate": "2020-08-03T14:23:32Z", "type": "commit"}, {"oid": "77a834b8f39f9b63b2d940ad1453bbd65e040572", "url": "https://github.com/hazelcast/hazelcast/commit/77a834b8f39f9b63b2d940ad1453bbd65e040572", "message": "Merge branch 'sql' into parser-move\n\n# Conflicts:\n#\thazelcast-sql/src/test/java/com/hazelcast/sql/schema/SchemaTest.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlServiceImpl.java", "committedDate": "2020-08-04T09:00:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyODg0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17291#discussion_r465028846", "bodyText": "Changes in this class look suspicious to me - what if we reveal that some context information that is needed for a new command is not passed here?\nAn alternative is to move the whole parser instantiation to jetSqlBackend. This way the risk of the aforementioned problem is zero.", "author": "devozerov", "createdAt": "2020-08-04T12:55:46Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/QueryParser.java", "diffHunk": "@@ -19,100 +19,70 @@\n import com.hazelcast.sql.SqlErrorCode;\n import com.hazelcast.sql.impl.JetSqlBackend;\n import com.hazelcast.sql.impl.QueryException;\n-import com.hazelcast.sql.impl.calcite.parser.HazelcastSqlParser;\n import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlConformance;\n-import org.apache.calcite.rel.type.RelDataType;\n-import org.apache.calcite.sql.SqlCall;\n-import org.apache.calcite.sql.SqlHint;\n import org.apache.calcite.sql.SqlKind;\n import org.apache.calcite.sql.SqlNode;\n import org.apache.calcite.sql.SqlOperator;\n-import org.apache.calcite.sql.SqlOperatorTable;\n-import org.apache.calcite.sql.SqlSelect;\n import org.apache.calcite.sql.parser.SqlParser;\n-import org.apache.calcite.sql.util.SqlBasicVisitor;\n+import org.apache.calcite.sql.parser.SqlParserImplFactory;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n-import java.util.Collections;\n-import java.util.HashSet;\n+import javax.annotation.Nullable;\n import java.util.Set;\n \n+import static java.util.Collections.emptySet;\n+\n /**\n  * Performs syntactic and semantic validation of the query, and converts the parse tree into a relational tree.\n  */\n public class QueryParser {\n \n-    /** A hint to force execution of a query on Jet. */\n-    private static final String RUN_ON_JET_HINT = \"jet\";\n+    private final SqlParser.Config parserConfig;\n \n-    private static final SqlParser.Config CONFIG;\n     private final SqlValidator validator;\n-\n-    static {\n+    private final Set<SqlKind> extensionSqlKinds;\n+    private final Set<SqlOperator> extensionSqlOperators;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public QueryParser(\n+            SqlValidator validator,\n+            @Nullable JetSqlBackend jetSqlBackend\n+    ) {\n         SqlParser.ConfigBuilder configBuilder = SqlParser.configBuilder();\n-\n         CasingConfiguration.DEFAULT.toParserConfig(configBuilder);\n         configBuilder.setConformance(HazelcastSqlConformance.INSTANCE);\n-        configBuilder.setParserFactory(HazelcastSqlParser.FACTORY);\n-\n-        CONFIG = configBuilder.build();\n-    }\n+        if (jetSqlBackend != null) {\n+            configBuilder.setParserFactory((SqlParserImplFactory) jetSqlBackend.createParserFactory());\n+        }\n+        this.parserConfig = configBuilder.build();\n \n-    public QueryParser(SqlValidator validator) {\n         this.validator = validator;\n+        this.extensionSqlKinds = jetSqlBackend == null ? emptySet() : (Set<SqlKind>) jetSqlBackend.kinds();", "originalCommit": "77a834b8f39f9b63b2d940ad1453bbd65e040572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2NDc3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17291#discussion_r465064772", "bodyText": "I have slightly refactored QueryParser, UnsupportedOperationVisitor is specific to either IMDG & JET", "author": "gierlachg", "createdAt": "2020-08-04T13:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyODg0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ec719494d724707465448d01871132259b2942e3", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/QueryParser.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/QueryParser.java\nindex 8743708847..b55f44ce42 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/QueryParser.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/QueryParser.java\n\n@@ -20,69 +20,104 @@ import com.hazelcast.sql.SqlErrorCode;\n import com.hazelcast.sql.impl.JetSqlBackend;\n import com.hazelcast.sql.impl.QueryException;\n import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlConformance;\n-import org.apache.calcite.sql.SqlKind;\n+import com.hazelcast.sql.impl.calcite.validate.HazelcastSqlValidator;\n+import org.apache.calcite.prepare.Prepare.CatalogReader;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n import org.apache.calcite.sql.SqlNode;\n-import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.parser.SqlParseException;\n import org.apache.calcite.sql.parser.SqlParser;\n+import org.apache.calcite.sql.parser.SqlParser.Config;\n import org.apache.calcite.sql.parser.SqlParserImplFactory;\n+import org.apache.calcite.sql.util.SqlVisitor;\n+import org.apache.calcite.sql.validate.SqlConformance;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n import javax.annotation.Nullable;\n-import java.util.Set;\n-\n-import static java.util.Collections.emptySet;\n \n /**\n  * Performs syntactic and semantic validation of the query, and converts the parse tree into a relational tree.\n  */\n public class QueryParser {\n \n-    private final SqlParser.Config parserConfig;\n+    private final RelDataTypeFactory typeFactory;\n+    private final CatalogReader catalogReader;\n+    private final SqlConformance conformance;\n \n-    private final SqlValidator validator;\n-    private final Set<SqlKind> extensionSqlKinds;\n-    private final Set<SqlOperator> extensionSqlOperators;\n+    private final JetSqlBackend jetSqlBackend;\n \n-    @SuppressWarnings(\"unchecked\")\n     public QueryParser(\n-            SqlValidator validator,\n+            RelDataTypeFactory typeFactory,\n+            CatalogReader catalogReader,\n+            SqlConformance conformance,\n             @Nullable JetSqlBackend jetSqlBackend\n     ) {\n-        SqlParser.ConfigBuilder configBuilder = SqlParser.configBuilder();\n-        CasingConfiguration.DEFAULT.toParserConfig(configBuilder);\n-        configBuilder.setConformance(HazelcastSqlConformance.INSTANCE);\n-        if (jetSqlBackend != null) {\n-            configBuilder.setParserFactory((SqlParserImplFactory) jetSqlBackend.createParserFactory());\n-        }\n-        this.parserConfig = configBuilder.build();\n+        this.typeFactory = typeFactory;\n+        this.catalogReader = catalogReader;\n+        this.conformance = conformance;\n \n-        this.validator = validator;\n-        this.extensionSqlKinds = jetSqlBackend == null ? emptySet() : (Set<SqlKind>) jetSqlBackend.kinds();\n-        this.extensionSqlOperators = jetSqlBackend == null ? emptySet() : (Set<SqlOperator>) jetSqlBackend.operators();\n+        this.jetSqlBackend = jetSqlBackend;\n     }\n \n     public QueryParseResult parse(String sql) {\n         try {\n-            SqlParser parser = SqlParser.create(sql, parserConfig);\n+            try {\n+                return parseImdg(sql);\n+            } catch (Exception e) {\n+                if (jetSqlBackend != null) {\n+                    return parseJet(sql);\n+                } else {\n+                    throw e;\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw QueryException.error(SqlErrorCode.PARSING, e.getMessage(), e);\n+        }\n+    }\n \n-            SqlNode node = validator.validate(parser.parseStmt());\n+    private QueryParseResult parseImdg(String sql) throws SqlParseException {\n+        Config config = createConfig(null);\n+        SqlParser parser = SqlParser.create(sql, config);\n \n-            UnsupportedOperationVisitor visitor = new UnsupportedOperationVisitor(\n-                validator.getCatalogReader(),\n-                extensionSqlKinds,\n-                extensionSqlOperators\n-            );\n-            node.accept(visitor);\n+        SqlValidator validator = new HazelcastSqlValidator(catalogReader, typeFactory, conformance);\n+        SqlNode node = validator.validate(parser.parseStmt());\n \n-            return new QueryParseResult(\n+        SqlVisitor<Void> visitor = new UnsupportedOperationVisitor(catalogReader);\n+        node.accept(visitor);\n+\n+        return new QueryParseResult(\n                 node,\n                 validator.getParameterRowType(node),\n-                visitor.isExclusivelyImdgStatement()\n-            );\n+                true,\n+                validator);\n+    }\n \n-            // TODO: Get column names through SqlSelect.selectList[i].toString() (and, possibly, origins?)?\n-        } catch (Exception e) {\n-            throw QueryException.error(SqlErrorCode.PARSING, e.getMessage(), e);\n+    @SuppressWarnings(\"unchecked\")\n+    private QueryParseResult parseJet(String sql) throws SqlParseException {\n+        assert jetSqlBackend != null;\n+\n+        Config config = createConfig((SqlParserImplFactory) jetSqlBackend.createParserFactory());\n+        SqlParser parser = SqlParser.create(sql, config);\n+\n+        SqlValidator validator = (SqlValidator) jetSqlBackend.createValidator(catalogReader, typeFactory, conformance);\n+        SqlNode node = validator.validate(parser.parseStmt());\n+\n+        SqlVisitor<Void> visitor = (SqlVisitor<Void>) jetSqlBackend.createUnsupportedOperationVisitor(catalogReader);\n+        node.accept(visitor);\n+\n+        return new QueryParseResult(\n+                node,\n+                validator.getParameterRowType(node),\n+                false,\n+                validator);\n+    }\n+\n+    private static Config createConfig(SqlParserImplFactory parserImplFactory) {\n+        SqlParser.ConfigBuilder configBuilder = SqlParser.configBuilder();\n+        CasingConfiguration.DEFAULT.toParserConfig(configBuilder);\n+        configBuilder.setConformance(HazelcastSqlConformance.INSTANCE);\n+        if (parserImplFactory != null) {\n+            configBuilder.setParserFactory(parserImplFactory);\n         }\n+        return configBuilder.build();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMDY0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17291#discussion_r465030646", "bodyText": "The same concern as in the parser. It may happen that Jet would require a custom syntax somewhere deep inside some other fragment (e.g. SELECT statement), We will not be able to extend the UnsupportedOperationVisitor without a separate IMDG release.", "author": "devozerov", "createdAt": "2020-08-04T12:58:42Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "diffHunk": "@@ -182,19 +170,26 @@\n         SUPPORTED_OPERATORS.add(SqlStdOperatorTable.CURRENT_TIMESTAMP);\n         SUPPORTED_OPERATORS.add(SqlStdOperatorTable.LOCALTIMESTAMP);\n         SUPPORTED_OPERATORS.add(SqlStdOperatorTable.LOCALTIME);\n-\n-        // Other/Extensions\n-        SUPPORTED_OPERATORS.add(SqlOption.OPERATOR);\n     }\n \n-    private final Set<SqlOperator> extensionOperators;\n+    private final SqlValidatorCatalogReader catalogReader;\n+\n+    private final Set<SqlKind> extensionSqlKinds;\n+    private final Set<SqlOperator> extensionSqlOperators;\n+\n+    private boolean exclusivelyImdgStatement;\n \n     UnsupportedOperationVisitor(\n             SqlValidatorCatalogReader catalogReader,\n-            Set<SqlOperator> extensionOperators\n+            Set<SqlKind> extensionSqlKinds,\n+            Set<SqlOperator> extensionSqlOperators\n     ) {\n         this.catalogReader = catalogReader;\n-        this.extensionOperators = extensionOperators;\n+\n+        this.extensionSqlKinds = extensionSqlKinds;", "originalCommit": "77a834b8f39f9b63b2d940ad1453bbd65e040572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA2NDk5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17291#discussion_r465064996", "bodyText": "UnsupportedOperationVisitor is no longer shared", "author": "gierlachg", "createdAt": "2020-08-04T13:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAzMDY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ec719494d724707465448d01871132259b2942e3", "chunk": "diff --git a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java\nindex 05cf32a36a..d40b546d1f 100644\n--- a/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java\n+++ b/hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java\n\n@@ -174,22 +173,10 @@ public final class UnsupportedOperationVisitor implements SqlVisitor<Void> {\n \n     private final SqlValidatorCatalogReader catalogReader;\n \n-    private final Set<SqlKind> extensionSqlKinds;\n-    private final Set<SqlOperator> extensionSqlOperators;\n-\n-    private boolean exclusivelyImdgStatement;\n-\n     UnsupportedOperationVisitor(\n-            SqlValidatorCatalogReader catalogReader,\n-            Set<SqlKind> extensionSqlKinds,\n-            Set<SqlOperator> extensionSqlOperators\n+            SqlValidatorCatalogReader catalogReader\n     ) {\n         this.catalogReader = catalogReader;\n-\n-        this.extensionSqlKinds = extensionSqlKinds;\n-        this.extensionSqlOperators = extensionSqlOperators;\n-\n-        this.exclusivelyImdgStatement = true;\n     }\n \n     @Override\n"}}, {"oid": "ec719494d724707465448d01871132259b2942e3", "url": "https://github.com/hazelcast/hazelcast/commit/ec719494d724707465448d01871132259b2942e3", "message": "Refactor parser & converter", "committedDate": "2020-08-04T13:45:17Z", "type": "commit"}, {"oid": "52f455e2340214a3221dc32a13d69ab65dbd86ad", "url": "https://github.com/hazelcast/hazelcast/commit/52f455e2340214a3221dc32a13d69ab65dbd86ad", "message": "Make checkstyle happier", "committedDate": "2020-08-04T13:57:32Z", "type": "commit"}]}