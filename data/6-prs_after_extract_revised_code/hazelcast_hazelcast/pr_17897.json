{"pr_number": 17897, "pr_title": "Remove StoreAdapter", "pr_createdAt": "2020-11-25T15:14:10Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17897", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3Mzc2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r530973760", "bodyText": "Do we really need hasNext local variable here? return true seems enough.", "author": "petrpleshachkov", "createdAt": "2020-11-26T11:47:49Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {\n+                    T temp = givenIterator.next();\n+                    if (filter.test(temp)) {\n+                        next = temp;\n+                        hasNext = true;", "originalCommit": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056483", "bodyText": "no need, fixed.", "author": "ahmetmircik", "createdAt": "2020-11-26T14:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3Mzc2MA=="}], "type": "inlineReview", "revised_code": {"commit": "1937d07211e6a511422d407e9f7e8c2719040c71", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\nindex 8a6f53bcb9f..0a09348a519 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n\n@@ -69,63 +61,6 @@ public final class IterableUtil {\n         };\n     }\n \n-    /**\n-     * Lazily filters iterated elements.\n-     *\n-     * @return a new iterable object which\n-     * has an iterator capable of filtering elements\n-     */\n-    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n-        Iterator<T> givenIterator = iterable.iterator();\n-\n-        Iterator<T> filteringIterator = new Iterator<T>() {\n-            private T next;\n-\n-            @Override\n-            public boolean hasNext() {\n-                boolean hasNext = false;\n-                while (givenIterator.hasNext()) {\n-                    T temp = givenIterator.next();\n-                    if (filter.test(temp)) {\n-                        next = temp;\n-                        hasNext = true;\n-                        break;\n-                    }\n-                }\n-                return hasNext;\n-            }\n-\n-            @Override\n-            public T next() {\n-                if (next == null) {\n-                    throw new NoSuchElementException();\n-                }\n-                return next;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-        return () -> filteringIterator;\n-    }\n-\n-    /**\n-     * @return size of iterable\n-     */\n-    public static int size(Iterable iterable) {\n-        checkNotNull(iterable, \"iterable cannot be null\");\n-\n-        int size = 0;\n-        Iterator iterator = iterable.iterator();\n-        while (iterator.hasNext()) {\n-            iterator.next();\n-            size++;\n-        }\n-        return size;\n-    }\n-\n     public static <T, R> Iterator<R> limit(final Iterator<R> iterator, final int limit) {\n         return new Iterator<R>() {\n             private int iterated;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NTU0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r530975543", "bodyText": "We should throw NoSuchElementException only if there is no next element not expecting that the user called hasNext() before that. I'd put it like\nif (!hasNext()) {\n    throw new NoSuchElementException()\n}", "author": "petrpleshachkov", "createdAt": "2020-11-26T11:51:04Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {\n+                    T temp = givenIterator.next();\n+                    if (filter.test(temp)) {\n+                        next = temp;\n+                        hasNext = true;\n+                        break;\n+                    }\n+                }\n+                return hasNext;\n+            }\n+\n+            @Override\n+            public T next() {\n+                if (next == null) {", "originalCommit": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQ2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056460", "bodyText": "fixed.", "author": "ahmetmircik", "createdAt": "2020-11-26T14:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NTU0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1937d07211e6a511422d407e9f7e8c2719040c71", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\nindex 8a6f53bcb9f..0a09348a519 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n\n@@ -69,63 +61,6 @@ public final class IterableUtil {\n         };\n     }\n \n-    /**\n-     * Lazily filters iterated elements.\n-     *\n-     * @return a new iterable object which\n-     * has an iterator capable of filtering elements\n-     */\n-    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n-        Iterator<T> givenIterator = iterable.iterator();\n-\n-        Iterator<T> filteringIterator = new Iterator<T>() {\n-            private T next;\n-\n-            @Override\n-            public boolean hasNext() {\n-                boolean hasNext = false;\n-                while (givenIterator.hasNext()) {\n-                    T temp = givenIterator.next();\n-                    if (filter.test(temp)) {\n-                        next = temp;\n-                        hasNext = true;\n-                        break;\n-                    }\n-                }\n-                return hasNext;\n-            }\n-\n-            @Override\n-            public T next() {\n-                if (next == null) {\n-                    throw new NoSuchElementException();\n-                }\n-                return next;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-        return () -> filteringIterator;\n-    }\n-\n-    /**\n-     * @return size of iterable\n-     */\n-    public static int size(Iterable iterable) {\n-        checkNotNull(iterable, \"iterable cannot be null\");\n-\n-        int size = 0;\n-        Iterator iterator = iterable.iterator();\n-        while (iterator.hasNext()) {\n-            iterator.next();\n-            size++;\n-        }\n-        return size;\n-    }\n-\n     public static <T, R> Iterator<R> limit(final Iterator<R> iterator, final int limit) {\n         return new Iterator<R>() {\n             private int iterated;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NjE5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r530976193", "bodyText": "If I call hasNext() multiple times it shouldn't advance the iterator, but it seems it does.", "author": "petrpleshachkov", "createdAt": "2020-11-26T11:52:15Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,63 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+\n+            @Override\n+            public boolean hasNext() {\n+                boolean hasNext = false;\n+                while (givenIterator.hasNext()) {", "originalCommit": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQ0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056440", "bodyText": "good catch, fixed.", "author": "ahmetmircik", "createdAt": "2020-11-26T14:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3NjE5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "1937d07211e6a511422d407e9f7e8c2719040c71", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\nindex 8a6f53bcb9f..0a09348a519 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n\n@@ -69,63 +61,6 @@ public final class IterableUtil {\n         };\n     }\n \n-    /**\n-     * Lazily filters iterated elements.\n-     *\n-     * @return a new iterable object which\n-     * has an iterator capable of filtering elements\n-     */\n-    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n-        Iterator<T> givenIterator = iterable.iterator();\n-\n-        Iterator<T> filteringIterator = new Iterator<T>() {\n-            private T next;\n-\n-            @Override\n-            public boolean hasNext() {\n-                boolean hasNext = false;\n-                while (givenIterator.hasNext()) {\n-                    T temp = givenIterator.next();\n-                    if (filter.test(temp)) {\n-                        next = temp;\n-                        hasNext = true;\n-                        break;\n-                    }\n-                }\n-                return hasNext;\n-            }\n-\n-            @Override\n-            public T next() {\n-                if (next == null) {\n-                    throw new NoSuchElementException();\n-                }\n-                return next;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-        return () -> filteringIterator;\n-    }\n-\n-    /**\n-     * @return size of iterable\n-     */\n-    public static int size(Iterable iterable) {\n-        checkNotNull(iterable, \"iterable cannot be null\");\n-\n-        int size = 0;\n-        Iterator iterator = iterable.iterator();\n-        while (iterator.hasNext()) {\n-            iterator.next();\n-            size++;\n-        }\n-        return size;\n-    }\n-\n     public static <T, R> Iterator<R> limit(final Iterator<R> iterator, final int limit) {\n         return new Iterator<R>() {\n             private int iterated;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNDY1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531014651", "bodyText": "Is this method called on the partition thread?", "author": "petrpleshachkov", "createdAt": "2020-11-26T13:03:13Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java", "diffHunk": "@@ -158,7 +159,24 @@ public Indexes createIndexes(boolean global) {\n                 .indexProvider(mapServiceContext.getIndexProvider(mapConfig))\n                 .usesCachedQueryableEntries(mapConfig.getCacheDeserializedValues() != CacheDeserializedValues.NEVER)\n                 .partitionCount(partitionCount)\n-                .build();\n+                .resultFilter(queryableEntry -> hasNotExpired(queryableEntry)).build();\n+    }\n+\n+    /**\n+     * @return {@code true} if queryableEntry has\n+     * not expired, otherwise returns {@code false}\n+     */\n+    private boolean hasNotExpired(QueryableEntry queryableEntry) {", "originalCommit": "649c68e6c52cc1a4f06503cc76c1877f21e8a90d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1NjQyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531056425", "bodyText": "yes, when it is not global index or i can't find counter example at least. I have added check assertRunningOnPartitionThread when index is not global.", "author": "ahmetmircik", "createdAt": "2020-11-26T14:14:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNDY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1937d07211e6a511422d407e9f7e8c2719040c71", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java b/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java\nindex 81a5578bc3a..7066204a6be 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/MapContainer.java\n\n@@ -159,24 +158,7 @@ public class MapContainer {\n                 .indexProvider(mapServiceContext.getIndexProvider(mapConfig))\n                 .usesCachedQueryableEntries(mapConfig.getCacheDeserializedValues() != CacheDeserializedValues.NEVER)\n                 .partitionCount(partitionCount)\n-                .resultFilter(queryableEntry -> hasNotExpired(queryableEntry)).build();\n-    }\n-\n-    /**\n-     * @return {@code true} if queryableEntry has\n-     * not expired, otherwise returns {@code false}\n-     */\n-    private boolean hasNotExpired(QueryableEntry queryableEntry) {\n-        Data keyData = queryableEntry.getKeyData();\n-        IPartitionService partitionService = mapServiceContext.getNodeEngine().getPartitionService();\n-        int partitionId = partitionService.getPartitionId(keyData);\n-        if (!partitionService.isPartitionOwner(partitionId)) {\n-            // throw entry out if it is not owned by this local node.\n-            return false;\n-        }\n-\n-        RecordStore recordStore = mapServiceContext.getExistingRecordStore(partitionId, name);\n-        return recordStore != null && !recordStore.expireOrAccess(keyData);\n+                .build();\n     }\n \n     public final void initEvictor() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531067652", "bodyText": "Not sure that we need hasNextCallCount and nextCallCount. Why not using just next? If it is not null the hasNext() returns true immediately. The next() will first call hasNext() and if it exists, return it (assigning next to null). Something similar to the HDBplusTree#EntryIterator.", "author": "petrpleshachkov", "createdAt": "2020-11-26T14:32:00Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java", "diffHunk": "@@ -61,6 +69,72 @@ public void remove() {\n         };\n     }\n \n+    /**\n+     * Lazily filters iterated elements.\n+     *\n+     * @return a new iterable object which\n+     * has an iterator capable of filtering elements\n+     */\n+    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n+        Iterator<T> givenIterator = iterable.iterator();\n+\n+        @SuppressWarnings(\"checkstyle:anoninnerlength\")\n+        Iterator<T> filteringIterator = new Iterator<T>() {\n+            private T next;\n+            private int hasNextCallCount;", "originalCommit": "087f511ac69d46eb4a29141ad41ed10acf43033b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwMjkyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531102929", "bodyText": "but in that case consecutive hasNext calls advance state, i don't want it to happen.", "author": "ahmetmircik", "createdAt": "2020-11-26T15:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwNTE0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531105149", "bodyText": "No, it'll check that next variable is not null and return quickly.", "author": "petrpleshachkov", "createdAt": "2020-11-26T15:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODUzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r531118538", "bodyText": "Oops i see now, my test was wrong, also fixed it, thx.", "author": "ahmetmircik", "createdAt": "2020-11-26T15:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA2NzY1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1937d07211e6a511422d407e9f7e8c2719040c71", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\nindex 4e5d8250e46..0a09348a519 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/IterableUtil.java\n\n@@ -69,72 +61,6 @@ public final class IterableUtil {\n         };\n     }\n \n-    /**\n-     * Lazily filters iterated elements.\n-     *\n-     * @return a new iterable object which\n-     * has an iterator capable of filtering elements\n-     */\n-    public static <T> Iterable<T> filter(Iterable<T> iterable, Predicate<T> filter) {\n-        Iterator<T> givenIterator = iterable.iterator();\n-\n-        @SuppressWarnings(\"checkstyle:anoninnerlength\")\n-        Iterator<T> filteringIterator = new Iterator<T>() {\n-            private T next;\n-            private int hasNextCallCount;\n-            private int nextCallCount;\n-\n-            @Override\n-            public boolean hasNext() {\n-                if (nextCallCount < hasNextCallCount) {\n-                    return true;\n-                }\n-\n-                while (givenIterator.hasNext()) {\n-                    T temp = givenIterator.next();\n-                    hasNextCallCount++;\n-                    if (filter.test(temp)) {\n-                        next = temp;\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }\n-\n-            @Override\n-            public T next() {\n-                if (nextCallCount < hasNextCallCount\n-                        || hasNext()) {\n-                    nextCallCount++;\n-                    return next;\n-                }\n-\n-                throw new NoSuchElementException();\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-        return () -> filteringIterator;\n-    }\n-\n-    /**\n-     * @return size of iterable\n-     */\n-    public static int size(Iterable iterable) {\n-        checkNotNull(iterable, \"iterable cannot be null\");\n-\n-        int size = 0;\n-        Iterator iterator = iterable.iterator();\n-        while (iterator.hasNext()) {\n-            iterator.next();\n-            size++;\n-        }\n-        return size;\n-    }\n-\n     public static <T, R> Iterator<R> limit(final Iterator<R> iterator, final int limit) {\n         return new Iterator<R>() {\n             private int iterated;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r534378964", "bodyText": "I'm a bit lost here. Now we don't update the isIndexStoreExpirable field anywhere but we still use the return value from BaseIndexStore#isExpirable in three places. Can you elaborate on this change?", "author": "mmedenjak", "createdAt": "2020-12-02T18:12:41Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java", "diffHunk": "@@ -145,13 +145,6 @@ private Comparable sanitizeScalar(Object input) {\n         }\n     }\n \n-    void markIndexStoreExpirableIfNecessary(QueryableEntry record) {", "originalCommit": "363350d26f61d1186dad831d737aa2426b40dd83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQyNzIxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r534427212", "bodyText": "leftover, removed that method and related stuff.", "author": "ahmetmircik", "createdAt": "2020-12-02T19:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTA1NzExMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r535057110", "bodyText": "Still, can you elaborate a bit on how it's safe to remove all of that code? With the removal, the dependant code now acts as if isExpirable() == false, always.", "author": "mmedenjak", "createdAt": "2020-12-03T10:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTEwMzg4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r535103881", "bodyText": "All filtering for expiry is done in one place now. In Indexes#query method,resultFilter will check for expiry. See the related part in that method:\n   if (result != null && resultFilter != null) {\n            return IterableUtil.filter(result, resultFilter);\n        } else {\n            return result;\n        }\n\nIn MapContainer we add new filter:\npublic Indexes createIndexes(boolean global) {\n        int partitionCount = mapServiceContext.getNodeEngine().getPartitionService().getPartitionCount();\n\n        return Indexes.newBuilder(serializationService, mapServiceContext.getIndexCopyBehavior(), mapConfig.getInMemoryFormat())\n                .global(global)\n                .extractors(extractors)\n                .statsEnabled(mapConfig.isStatisticsEnabled())\n                .indexProvider(mapServiceContext.getIndexProvider(mapConfig))\n                .usesCachedQueryableEntries(mapConfig.getCacheDeserializedValues() != CacheDeserializedValues.NEVER)\n                .partitionCount(partitionCount)\n                .resultFilter(queryableEntry -> hasNotExpired(queryableEntry)).build();\n    }\n\nWith these changes, we are removing leaked map stuff to querying system, this will help to better isolate map and indexing.", "author": "ahmetmircik", "createdAt": "2020-12-03T11:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5NzM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17897#discussion_r535397341", "bodyText": "Thanks for the explanation!", "author": "mmedenjak", "createdAt": "2020-12-03T16:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM3ODk2NA=="}], "type": "inlineReview", "revised_code": {"commit": "7ee371d45d2228cc504bd8beb5d3c59ae088724c", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java b/hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java\nindex 2d197ff8585..68208b29174 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/BaseIndexStore.java\n\n@@ -145,31 +131,19 @@ public abstract class BaseIndexStore implements IndexStore {\n         }\n     }\n \n-    boolean isExpirable() {\n-        return isIndexStoreExpirable;\n-    }\n-\n     interface CopyFunctor<A, B> {\n-\n         Map<A, B> invoke(Map<A, B> map);\n-\n     }\n \n     interface IndexFunctor<A, B> {\n-\n         Object invoke(A param1, B param2);\n-\n     }\n \n     private class PassThroughFunctor implements CopyFunctor<Data, QueryableEntry> {\n \n         @Override\n         public Map<Data, QueryableEntry> invoke(Map<Data, QueryableEntry> map) {\n-            if (MapUtil.isNullOrEmpty(map)) {\n-                return map;\n-            }\n-\n-            return isExpirable() ? new ExpirationAwareHashMapDelegate(map) : map;\n+            return map;\n         }\n     }\n \n"}}, {"oid": "1937d07211e6a511422d407e9f7e8c2719040c71", "url": "https://github.com/hazelcast/hazelcast/commit/1937d07211e6a511422d407e9f7e8c2719040c71", "message": "remove adapter", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "34bda86807eec0b981cd7db6a038d54916f901b0", "url": "https://github.com/hazelcast/hazelcast/commit/34bda86807eec0b981cd7db6a038d54916f901b0", "message": "loop to filter in Indexes", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "ac435eae2addeab14056c31444b53e3674a9f0e9", "url": "https://github.com/hazelcast/hazelcast/commit/ac435eae2addeab14056c31444b53e3674a9f0e9", "message": "add result != null", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "069a0fae87d5ca5571fa8611008001b7952c0b49", "url": "https://github.com/hazelcast/hazelcast/commit/069a0fae87d5ca5571fa8611008001b7952c0b49", "message": "Return iterable from indexes.query", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "2ad70f2391b310ea98271aadb82f493457335f71", "url": "https://github.com/hazelcast/hazelcast/commit/2ad70f2391b310ea98271aadb82f493457335f71", "message": "spotbugs", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "800edbdedbf99bea6d03e77a9f4f52fe13da5616", "url": "https://github.com/hazelcast/hazelcast/commit/800edbdedbf99bea6d03e77a9f4f52fe13da5616", "message": "comments", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "f3e4f6999e77b6fdc69a7510572ea35a0fc7894b", "url": "https://github.com/hazelcast/hazelcast/commit/f3e4f6999e77b6fdc69a7510572ea35a0fc7894b", "message": "optimize for non expirable record stores", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "136f2c1880a7ad2d08751ce066b4cec1772a1eda", "url": "https://github.com/hazelcast/hazelcast/commit/136f2c1880a7ad2d08751ce066b4cec1772a1eda", "message": "optimize for non expirable record stores 2", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "c9e750d258f59644d2525dbe2626e7e9e411408b", "url": "https://github.com/hazelcast/hazelcast/commit/c9e750d258f59644d2525dbe2626e7e9e411408b", "message": "optimize for non expirable record stores 3", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "0956fc0cc641f7e7381cafa751bb599449983396", "url": "https://github.com/hazelcast/hazelcast/commit/0956fc0cc641f7e7381cafa751bb599449983396", "message": "optimize for non expirable record stores 4", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "da66aa5e9d01689fa276cdb478d3d279af13d010", "url": "https://github.com/hazelcast/hazelcast/commit/da66aa5e9d01689fa276cdb478d3d279af13d010", "message": "javadoc updates", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "e014f7153c6ff456ebda524b550c45f4ef04dca1", "url": "https://github.com/hazelcast/hazelcast/commit/e014f7153c6ff456ebda524b550c45f4ef04dca1", "message": "address review comments", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "e9dd1c6aabd8915954bb1592886559a0232b4270", "url": "https://github.com/hazelcast/hazelcast/commit/e9dd1c6aabd8915954bb1592886559a0232b4270", "message": "checkstyle", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "42406f8bdf91d148a6bc38748df10c88befd843d", "url": "https://github.com/hazelcast/hazelcast/commit/42406f8bdf91d148a6bc38748df10c88befd843d", "message": "address review comments 2", "committedDate": "2020-12-02T18:24:03Z", "type": "commit"}, {"oid": "7ee371d45d2228cc504bd8beb5d3c59ae088724c", "url": "https://github.com/hazelcast/hazelcast/commit/7ee371d45d2228cc504bd8beb5d3c59ae088724c", "message": "address review", "committedDate": "2020-12-02T18:24:04Z", "type": "commit"}, {"oid": "7ee371d45d2228cc504bd8beb5d3c59ae088724c", "url": "https://github.com/hazelcast/hazelcast/commit/7ee371d45d2228cc504bd8beb5d3c59ae088724c", "message": "address review", "committedDate": "2020-12-02T18:24:04Z", "type": "forcePushed"}, {"oid": "9014bcb8c0682de201a835ca5abcd15534454331", "url": "https://github.com/hazelcast/hazelcast/commit/9014bcb8c0682de201a835ca5abcd15534454331", "message": "fix checkstyle", "committedDate": "2020-12-02T18:52:41Z", "type": "commit"}]}