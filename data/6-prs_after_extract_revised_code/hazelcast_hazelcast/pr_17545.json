{"pr_number": 17545, "pr_title": "Extract value from MetadataAwareValue", "pr_createdAt": "2020-09-15T10:07:28Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17545", "timeline": [{"oid": "56f5fa5324ae53c66b92c8e6274a880ddc04d5f9", "url": "https://github.com/hazelcast/hazelcast/commit/56f5fa5324ae53c66b92c8e6274a880ddc04d5f9", "message": "Extract value from MetadataAwareValue", "committedDate": "2020-09-15T15:15:13Z", "type": "forcePushed"}, {"oid": "f36983d82ce026bfddd28898f6246e146833b973", "url": "https://github.com/hazelcast/hazelcast/commit/f36983d82ce026bfddd28898f6246e146833b973", "message": "Extract value from MetadataAwareValue", "committedDate": "2020-09-15T15:20:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM3MzgzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17545#discussion_r493373836", "bodyText": "Do you need to unwrap the value here as well?", "author": "mmedenjak", "createdAt": "2020-09-23T09:35:52Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/mapstore/MetadataAwareMapDataStore.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.map.impl.mapstore;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.map.EntryLoader;\n+import com.hazelcast.map.impl.mapstore.writebehind.TxnReservedCapacityCounter;\n+import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+\n+import static com.hazelcast.map.impl.record.Record.UNSET;\n+\n+/**\n+ * Should be created one per record-store due to the {@code lastLoadedTtl} field.\n+ */\n+public class MetadataAwareMapDataStore<K, V> implements MapDataStore<K, V> {\n+\n+    private final MapDataStore<K, V> delegate;\n+\n+    private long lastLoadedTtl = UNSET;\n+\n+    public MetadataAwareMapDataStore(MapDataStore<K, V> delegate) {\n+        this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public V add(K key, V value, long expirationTime, long now, UUID transactionId) {\n+        return delegate.add(key, value, expirationTime, now, transactionId);\n+    }\n+\n+    @Override\n+    public V addBackup(K key, V value, long expirationTime, long now, UUID transactionId) {\n+        return delegate.addBackup(key, value, expirationTime, now, transactionId);\n+    }\n+\n+    @Override\n+    public void addForcibly(DelayedEntry<Data, Object> delayedEntry) {\n+        delegate.addForcibly(delayedEntry);\n+    }\n+\n+    @Override\n+    public void addTransient(K key, long now) {\n+        delegate.addTransient(key, now);\n+    }\n+\n+    @Override\n+    public void remove(K key, long now, UUID transactionId) {\n+        delegate.remove(key, now, transactionId);\n+    }\n+\n+    @Override\n+    public void removeBackup(K key, long now, UUID transactionId) {\n+        delegate.removeBackup(key, now, transactionId);\n+    }\n+\n+    @Override\n+    public void reset() {\n+        delegate.reset();\n+    }\n+\n+    @Override\n+    public V load(K key) {\n+        V loadedValue = delegate.load(key);\n+        if (loadedValue != null) {\n+            EntryLoader.MetadataAwareValue<V> metadataAwareValue = toMetadataAware(loadedValue);\n+            long remainingTtl = toRemainingTtl(metadataAwareValue);\n+            loadedValue = remainingTtl <= 0 ? null : metadataAwareValue.getValue();\n+            lastLoadedTtl = remainingTtl > 0 ? remainingTtl : UNSET;\n+        } else {\n+            lastLoadedTtl = UNSET;\n+        }\n+        return loadedValue;\n+    }\n+\n+    @Override\n+    public void loadAll(Collection givenKeys,\n+                        BiConsumer<Map.Entry, Long> loadedEntryWithTtlConsumer) {\n+        Map map = delegate.loadAll(givenKeys);\n+\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry) iterator.next();\n+            EntryLoader.MetadataAwareValue<V> metadataAwareValue = toMetadataAware(entry.getValue());\n+            long remainingTtl = toRemainingTtl(metadataAwareValue);\n+            if (remainingTtl > 0) {\n+                AbstractMap.SimpleImmutableEntry newEntry = new AbstractMap.SimpleImmutableEntry(entry.getKey(),\n+                        metadataAwareValue.getValue());\n+                loadedEntryWithTtlConsumer.accept(newEntry, remainingTtl);\n+            }\n+        }\n+    }\n+\n+    public long toRemainingTtl(EntryLoader.MetadataAwareValue<V> metadataAwareValue) {\n+        return metadataAwareValue.getExpirationTime() - System.currentTimeMillis();\n+    }\n+\n+    public EntryLoader.MetadataAwareValue<V> toMetadataAware(Object loadedValue) {\n+        return (EntryLoader.MetadataAwareValue<V>) loadedValue;\n+    }\n+\n+    @Override\n+    public long getLastLoadedTtl() {\n+        return lastLoadedTtl;\n+    }\n+\n+    @Override\n+    public Map loadAll(Collection keys) {\n+        Map map = delegate.loadAll(keys);\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry) iterator.next();\n+            long remainingTtl = toRemainingTtl(toMetadataAware(entry.getValue()));", "originalCommit": "dcc991f18380d668123030a3ca867aa6bad7c89e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "725c6ebbd5499bd404c2a9c60049e728076dcffa", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/mapstore/MetadataAwareMapDataStore.java b/hazelcast/src/main/java/com/hazelcast/map/impl/mapstore/MetadataAwareMapDataStore.java\ndeleted file mode 100644\nindex 168a310b9e..0000000000\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/mapstore/MetadataAwareMapDataStore.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*\n- * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.hazelcast.map.impl.mapstore;\n-\n-import com.hazelcast.internal.serialization.Data;\n-import com.hazelcast.map.EntryLoader;\n-import com.hazelcast.map.impl.mapstore.writebehind.TxnReservedCapacityCounter;\n-import com.hazelcast.map.impl.mapstore.writebehind.entry.DelayedEntry;\n-\n-import java.util.AbstractMap;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.UUID;\n-import java.util.function.BiConsumer;\n-\n-import static com.hazelcast.map.impl.record.Record.UNSET;\n-\n-/**\n- * Should be created one per record-store due to the {@code lastLoadedTtl} field.\n- */\n-public class MetadataAwareMapDataStore<K, V> implements MapDataStore<K, V> {\n-\n-    private final MapDataStore<K, V> delegate;\n-\n-    private long lastLoadedTtl = UNSET;\n-\n-    public MetadataAwareMapDataStore(MapDataStore<K, V> delegate) {\n-        this.delegate = delegate;\n-    }\n-\n-    @Override\n-    public V add(K key, V value, long expirationTime, long now, UUID transactionId) {\n-        return delegate.add(key, value, expirationTime, now, transactionId);\n-    }\n-\n-    @Override\n-    public V addBackup(K key, V value, long expirationTime, long now, UUID transactionId) {\n-        return delegate.addBackup(key, value, expirationTime, now, transactionId);\n-    }\n-\n-    @Override\n-    public void addForcibly(DelayedEntry<Data, Object> delayedEntry) {\n-        delegate.addForcibly(delayedEntry);\n-    }\n-\n-    @Override\n-    public void addTransient(K key, long now) {\n-        delegate.addTransient(key, now);\n-    }\n-\n-    @Override\n-    public void remove(K key, long now, UUID transactionId) {\n-        delegate.remove(key, now, transactionId);\n-    }\n-\n-    @Override\n-    public void removeBackup(K key, long now, UUID transactionId) {\n-        delegate.removeBackup(key, now, transactionId);\n-    }\n-\n-    @Override\n-    public void reset() {\n-        delegate.reset();\n-    }\n-\n-    @Override\n-    public V load(K key) {\n-        V loadedValue = delegate.load(key);\n-        if (loadedValue != null) {\n-            EntryLoader.MetadataAwareValue<V> metadataAwareValue = toMetadataAware(loadedValue);\n-            long remainingTtl = toRemainingTtl(metadataAwareValue);\n-            loadedValue = remainingTtl <= 0 ? null : metadataAwareValue.getValue();\n-            lastLoadedTtl = remainingTtl > 0 ? remainingTtl : UNSET;\n-        } else {\n-            lastLoadedTtl = UNSET;\n-        }\n-        return loadedValue;\n-    }\n-\n-    @Override\n-    public void loadAll(Collection givenKeys,\n-                        BiConsumer<Map.Entry, Long> loadedEntryWithTtlConsumer) {\n-        Map map = delegate.loadAll(givenKeys);\n-\n-        Iterator iterator = map.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry entry = (Map.Entry) iterator.next();\n-            EntryLoader.MetadataAwareValue<V> metadataAwareValue = toMetadataAware(entry.getValue());\n-            long remainingTtl = toRemainingTtl(metadataAwareValue);\n-            if (remainingTtl > 0) {\n-                AbstractMap.SimpleImmutableEntry newEntry = new AbstractMap.SimpleImmutableEntry(entry.getKey(),\n-                        metadataAwareValue.getValue());\n-                loadedEntryWithTtlConsumer.accept(newEntry, remainingTtl);\n-            }\n-        }\n-    }\n-\n-    public long toRemainingTtl(EntryLoader.MetadataAwareValue<V> metadataAwareValue) {\n-        return metadataAwareValue.getExpirationTime() - System.currentTimeMillis();\n-    }\n-\n-    public EntryLoader.MetadataAwareValue<V> toMetadataAware(Object loadedValue) {\n-        return (EntryLoader.MetadataAwareValue<V>) loadedValue;\n-    }\n-\n-    @Override\n-    public long getLastLoadedTtl() {\n-        return lastLoadedTtl;\n-    }\n-\n-    @Override\n-    public Map loadAll(Collection keys) {\n-        Map map = delegate.loadAll(keys);\n-        Iterator iterator = map.entrySet().iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry entry = (Map.Entry) iterator.next();\n-            long remainingTtl = toRemainingTtl(toMetadataAware(entry.getValue()));\n-            if (remainingTtl < 0) {\n-                iterator.remove();\n-            }\n-        }\n-        return map;\n-    }\n-\n-    @Override\n-    public void removeAll(Collection keys) {\n-        delegate.removeAll(keys);\n-    }\n-\n-    @Override\n-    public boolean loadable(K key) {\n-        return delegate.loadable(key);\n-    }\n-\n-    @Override\n-    public int notFinishedOperationsCount() {\n-        return delegate.notFinishedOperationsCount();\n-    }\n-\n-    @Override\n-    public boolean isPostProcessingMapStore() {\n-        return delegate.isPostProcessingMapStore();\n-    }\n-\n-    @Override\n-    public long softFlush() {\n-        return delegate.softFlush();\n-    }\n-\n-    @Override\n-    public void hardFlush() {\n-        delegate.hardFlush();\n-    }\n-\n-    @Override\n-    public V flush(K key, V value, boolean backup) {\n-        return delegate.flush(key, value, backup);\n-    }\n-\n-    @Override\n-    public boolean isWithExpirationTime() {\n-        return delegate.isWithExpirationTime();\n-    }\n-\n-    @Override\n-    public TxnReservedCapacityCounter getTxnReservedCapacityCounter() {\n-        return delegate.getTxnReservedCapacityCounter();\n-    }\n-\n-    public MapDataStore unwrap() {\n-        return delegate;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM5ODI2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17545#discussion_r493398261", "bodyText": "I understand that now, because of concurrency, we need create per-record store wrappers. Although it does move some code out of the record store, I'm thinking is it worth it. I can imagine lots of wrappers are created with high partition counts and it's just to keep the last loaded TTL value and some additional code.\nAlthough it complicates the record store, can we try keeping the code in the record store instead and avoid the map store wrapper?", "author": "mmedenjak", "createdAt": "2020-09-23T10:00:55Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java", "diffHunk": "@@ -370,28 +372,19 @@ public String getLockOwnerInfo(Data key) {\n \n     @Override\n     public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress) {\n-        Object value = mapDataStore.load(key);\n-        if (value == null) {\n+        Object oldValue = mapDataStore.load(key);\n+        if (oldValue == null) {\n             return null;\n         }\n \n-        long ttl = UNSET;\n-        if (mapDataStore.isWithExpirationTime()) {\n-            MetadataAwareValue loaderEntry = (MetadataAwareValue) value;\n-            long proposedTtl = expirationTimeToTtl(loaderEntry.getExpirationTime());\n-            if (proposedTtl <= 0) {\n-                return null;\n-            }\n-            value = loaderEntry.getValue();\n-            ttl = proposedTtl;\n-        }\n-        Record record = createRecord(key, value, ttl, UNSET, getNow());\n-        markRecordStoreExpirable(ttl, UNSET);\n+        long lastLoadedTtl = mapDataStore.getLastLoadedTtl();", "originalCommit": "dcc991f18380d668123030a3ca867aa6bad7c89e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3Mjk2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17545#discussion_r494772965", "bodyText": "makes sense, i removed wrapper.", "author": "ahmetmircik", "createdAt": "2020-09-25T06:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM5ODI2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "725c6ebbd5499bd404c2a9c60049e728076dcffa", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java\nindex 89cc89f02e..c7387e026b 100644\n--- a/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java\n+++ b/hazelcast/src/main/java/com/hazelcast/map/impl/recordstore/DefaultRecordStore.java\n\n@@ -370,21 +368,55 @@ public class DefaultRecordStore extends AbstractEvictableRecordStore {\n         return lockStore != null ? lockStore.getOwnerInfo(key) : null;\n     }\n \n+    /**\n+     * Loads value of key. If necessary loads it by\n+     * extracting from {@link MetadataAwareValue}\n+     *\n+     * @return loaded value from map-store,\n+     * when no value found returns null\n+     */\n+    private Object loadValueOf(Data key) {\n+        Object value = mapDataStore.load(key);\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (mapDataStore.isWithExpirationTime()) {\n+            MetadataAwareValue loaderEntry = (MetadataAwareValue) value;\n+            long proposedTtl = expirationTimeToTtl(loaderEntry.getExpirationTime());\n+            if (proposedTtl <= 0) {\n+                return null;\n+            }\n+            value = loaderEntry.getValue();\n+        }\n+\n+        return value;\n+    }\n+\n     @Override\n     public Record loadRecordOrNull(Data key, boolean backup, Address callerAddress) {\n-        Object oldValue = mapDataStore.load(key);\n-        if (oldValue == null) {\n+        Object value = mapDataStore.load(key);\n+        if (value == null) {\n             return null;\n         }\n \n-        long lastLoadedTtl = mapDataStore.getLastLoadedTtl();\n-        Record record = createRecord(key, oldValue, lastLoadedTtl, UNSET, getNow());\n-        markRecordStoreExpirable(lastLoadedTtl, UNSET);\n+        long ttl = UNSET;\n+        if (mapDataStore.isWithExpirationTime()) {\n+            MetadataAwareValue loaderEntry = (MetadataAwareValue) value;\n+            long proposedTtl = expirationTimeToTtl(loaderEntry.getExpirationTime());\n+            if (proposedTtl <= 0) {\n+                return null;\n+            }\n+            value = loaderEntry.getValue();\n+            ttl = proposedTtl;\n+        }\n+        Record record = createRecord(key, value, ttl, UNSET, getNow());\n+        markRecordStoreExpirable(ttl, UNSET);\n         storage.put(key, record);\n         mutationObserver.onLoadRecord(key, record, backup);\n         if (!backup) {\n             mapEventPublisher.publishEvent(callerAddress, name, EntryEventType.LOADED,\n-                    key, null, oldValue, null);\n+                    key, null, value, null);\n         }\n         evictEntries(key);\n         // here, we are only publishing events for loaded\n"}}, {"oid": "725c6ebbd5499bd404c2a9c60049e728076dcffa", "url": "https://github.com/hazelcast/hazelcast/commit/725c6ebbd5499bd404c2a9c60049e728076dcffa", "message": "Extract loaded value from MetadataAware", "committedDate": "2020-09-24T20:52:35Z", "type": "forcePushed"}, {"oid": "879d8153813ddcd1e9312ccd6e3bb5250f00b6d3", "url": "https://github.com/hazelcast/hazelcast/commit/879d8153813ddcd1e9312ccd6e3bb5250f00b6d3", "message": "Extract loaded value from MetadataAware", "committedDate": "2020-09-24T20:57:18Z", "type": "commit"}, {"oid": "879d8153813ddcd1e9312ccd6e3bb5250f00b6d3", "url": "https://github.com/hazelcast/hazelcast/commit/879d8153813ddcd1e9312ccd6e3bb5250f00b6d3", "message": "Extract loaded value from MetadataAware", "committedDate": "2020-09-24T20:57:18Z", "type": "forcePushed"}, {"oid": "f57f2904c9c88a4f761dcb057ba0a2165b1ef345", "url": "https://github.com/hazelcast/hazelcast/commit/f57f2904c9c88a4f761dcb057ba0a2165b1ef345", "message": "fix test", "committedDate": "2020-09-24T21:58:03Z", "type": "commit"}]}