{"pr_number": 16971, "pr_title": "Introduction of CPU thread affinity", "pr_createdAt": "2020-05-11T06:24:12Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16971", "timeline": [{"oid": "f10829ffc8198176e3695b9c54852b89923b178a", "url": "https://github.com/hazelcast/hazelcast/commit/f10829ffc8198176e3695b9c54852b89923b178a", "message": "Introduced thread affinity", "committedDate": "2020-05-11T06:26:09Z", "type": "forcePushed"}, {"oid": "3a9c78d2d36daa04bebbed7736ce60f8864380fd", "url": "https://github.com/hazelcast/hazelcast/commit/3a9c78d2d36daa04bebbed7736ce60f8864380fd", "message": "More work on affinity", "committedDate": "2020-05-11T07:22:30Z", "type": "forcePushed"}, {"oid": "2bf220034cb7d23137cf7452408d5c4c5b58b4b4", "url": "https://github.com/hazelcast/hazelcast/commit/2bf220034cb7d23137cf7452408d5c4c5b58b4b4", "message": "More work on affinity", "committedDate": "2020-05-12T09:15:02Z", "type": "forcePushed"}, {"oid": "7ae1c036e6502b96e791162c69bbdf651ff551cb", "url": "https://github.com/hazelcast/hazelcast/commit/7ae1c036e6502b96e791162c69bbdf651ff551cb", "message": "More work on affinity", "committedDate": "2020-05-12T12:14:25Z", "type": "forcePushed"}, {"oid": "e1396a33be1c01acf0e8897489da778d67ce55e5", "url": "https://github.com/hazelcast/hazelcast/commit/e1396a33be1c01acf0e8897489da778d67ce55e5", "message": "More work on affinity", "committedDate": "2020-05-12T12:43:27Z", "type": "forcePushed"}, {"oid": "19f72d7d8278450ffda9868f5f62108b0e9334f8", "url": "https://github.com/hazelcast/hazelcast/commit/19f72d7d8278450ffda9868f5f62108b0e9334f8", "message": "Lot of work on improved syntax", "committedDate": "2020-05-13T11:21:46Z", "type": "forcePushed"}, {"oid": "ed803d7e9dabb81a17b49dc57408c4ed4e9e7846", "url": "https://github.com/hazelcast/hazelcast/commit/ed803d7e9dabb81a17b49dc57408c4ed4e9e7846", "message": "Added logging which thread gets which cores", "committedDate": "2020-05-13T12:41:49Z", "type": "forcePushed"}, {"oid": "44e4078cb88d6c5a0c9668ca3dee2015962fcd9f", "url": "https://github.com/hazelcast/hazelcast/commit/44e4078cb88d6c5a0c9668ca3dee2015962fcd9f", "message": "Added logging which thread gets which cores", "committedDate": "2020-05-14T08:12:02Z", "type": "forcePushed"}, {"oid": "ccaef4834fe3c482f345d9cc29304843657ad3d4", "url": "https://github.com/hazelcast/hazelcast/commit/ccaef4834fe3c482f345d9cc29304843657ad3d4", "message": "Added logging which thread gets which cores", "committedDate": "2020-05-14T12:35:30Z", "type": "forcePushed"}, {"oid": "c3c73dc34acc7d2085a7d7bce4e95a56b280ee30", "url": "https://github.com/hazelcast/hazelcast/commit/c3c73dc34acc7d2085a7d7bce4e95a56b280ee30", "message": "Added logging which thread gets which cores", "committedDate": "2020-05-18T08:57:43Z", "type": "forcePushed"}, {"oid": "4b9602123a02f3b6fb447f260879554c929efd26", "url": "https://github.com/hazelcast/hazelcast/commit/4b9602123a02f3b6fb447f260879554c929efd26", "message": "Added logging which thread gets which cores", "committedDate": "2020-05-18T11:05:36Z", "type": "forcePushed"}, {"oid": "d074a3636018062ab9e33841933b1eb80dbb0de7", "url": "https://github.com/hazelcast/hazelcast/commit/d074a3636018062ab9e33841933b1eb80dbb0de7", "message": "Introduced thread affinity", "committedDate": "2020-05-18T11:07:42Z", "type": "forcePushed"}, {"oid": "6513f4eb64a9dd51522bfcbd2ccf560ad7a1b3fd", "url": "https://github.com/hazelcast/hazelcast/commit/6513f4eb64a9dd51522bfcbd2ccf560ad7a1b3fd", "message": "Introduced thread affinity", "committedDate": "2020-05-18T13:04:56Z", "type": "forcePushed"}, {"oid": "26ffacd7ef44bfa1606daafa1e75a4cde37fd0e8", "url": "https://github.com/hazelcast/hazelcast/commit/26ffacd7ef44bfa1606daafa1e75a4cde37fd0e8", "message": "Introduced thread affinity", "committedDate": "2020-05-19T03:34:12Z", "type": "forcePushed"}, {"oid": "f266a5c0d666850b293d998c72e2898ca7da8feb", "url": "https://github.com/hazelcast/hazelcast/commit/f266a5c0d666850b293d998c72e2898ca7da8feb", "message": "Introduced thread affinity", "committedDate": "2020-05-19T07:18:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2MzQ1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427163455", "bodyText": "Extra line", "author": "blazember", "createdAt": "2020-05-19T09:32:05Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java", "diffHunk": "@@ -501,6 +510,7 @@ public Context() {\n             }\n         }\n \n+", "originalCommit": "f266a5c0d666850b293d998c72e2898ca7da8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8530ed1f42ed92911ea2c2c4f70ad119665c927b", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java b/hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java\nindex f93d796c2a0..f0eef6ba858 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/networking/nio/NioNetworking.java\n\n@@ -510,7 +510,6 @@ public final class NioNetworking implements Networking, DynamicMetricsProvider {\n             }\n         }\n \n-\n         public Context selectionKeyWakeupEnabled(boolean selectionKeyWakeupEnabled) {\n             this.selectionKeyWakeupEnabled = selectionKeyWakeupEnabled;\n             return this;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjI0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427166247", "bodyText": "Shouldn't we use logging instead? Our logging should have already been initialized when we get here.", "author": "blazember", "createdAt": "2020-05-19T09:36:33Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import net.openhft.affinity.Affinity;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class is threadsafe.\n+ */\n+public class ThreadAffinity {\n+    public static final ThreadAffinity DISABLED = new ThreadAffinity(null);\n+\n+    final List<BitSet> allowedCpusList;\n+    final AtomicInteger threadIndex = new AtomicInteger();\n+\n+    public ThreadAffinity(String affinity) {\n+        allowedCpusList = parse(affinity);\n+\n+        if (allowedCpusList.isEmpty()) {\n+            return;\n+        }\n+\n+        if (!isAffinityAvailable()) {\n+            throw new RuntimeException(\"Can't use affinity '\" + affinity + \"'. Thread affinity support is not available.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a new ThreadAffinity based on a system property.\n+     *\n+     * If no property is set, then affinity is disabled.\n+     *\n+     * @param property the name of the system property.\n+     * @return the created ThreadAffinity.\n+     * @throws InvalidAffinitySyntaxException if there is a problem with the value.\n+     */\n+    public static ThreadAffinity newSystemThreadAffinity(String property) {\n+        String value = System.getProperty(property);\n+        try {\n+            return new ThreadAffinity(value);\n+        } catch (InvalidAffinitySyntaxException e) {\n+            throw new InvalidAffinitySyntaxException(\"Invalid affinity syntax for System property '\" + property + \"'.\"\n+                    + \" Value '\" + value + \"'. \"\n+                    + \" Errormessage '\" + e.getMessage() + \"'\");\n+        }\n+    }\n+\n+    public int getThreadCount() {\n+        return allowedCpusList.size();\n+    }\n+\n+\n+    public BitSet nextAllowedCpus() {\n+        if (allowedCpusList.isEmpty()) {\n+            return null;\n+        }\n+\n+        int index = threadIndex.getAndIncrement() % allowedCpusList.size();\n+        return allowedCpusList.get(index);\n+    }\n+\n+    public boolean isEnabled() {\n+        return !allowedCpusList.isEmpty();\n+    }\n+\n+    private static boolean isAffinityAvailable() {\n+        try {\n+            boolean jnaAvailable = Affinity.isJNAAvailable();\n+            if (!jnaAvailable) {\n+                System.err.println(\"jna is not available\");\n+            }\n+            return jnaAvailable;\n+        } catch (NoClassDefFoundError e) {\n+            e.printStackTrace();", "originalCommit": "f266a5c0d666850b293d998c72e2898ca7da8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8530ed1f42ed92911ea2c2c4f70ad119665c927b", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java b/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\nindex ace585e2b4a..4aaf77d6a2c 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\n\n@@ -16,6 +16,7 @@\n \n package com.hazelcast.internal.util;\n \n+import com.hazelcast.logging.Logger;\n import net.openhft.affinity.Affinity;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NDA3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427184077", "bodyText": "Missing \"be\".", "author": "blazember", "createdAt": "2020-05-19T10:06:11Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import net.openhft.affinity.Affinity;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class is threadsafe.\n+ */\n+public class ThreadAffinity {\n+    public static final ThreadAffinity DISABLED = new ThreadAffinity(null);\n+\n+    final List<BitSet> allowedCpusList;\n+    final AtomicInteger threadIndex = new AtomicInteger();\n+\n+    public ThreadAffinity(String affinity) {\n+        allowedCpusList = parse(affinity);\n+\n+        if (allowedCpusList.isEmpty()) {\n+            return;\n+        }\n+\n+        if (!isAffinityAvailable()) {\n+            throw new RuntimeException(\"Can't use affinity '\" + affinity + \"'. Thread affinity support is not available.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a new ThreadAffinity based on a system property.\n+     *\n+     * If no property is set, then affinity is disabled.\n+     *\n+     * @param property the name of the system property.\n+     * @return the created ThreadAffinity.\n+     * @throws InvalidAffinitySyntaxException if there is a problem with the value.\n+     */\n+    public static ThreadAffinity newSystemThreadAffinity(String property) {\n+        String value = System.getProperty(property);\n+        try {\n+            return new ThreadAffinity(value);\n+        } catch (InvalidAffinitySyntaxException e) {\n+            throw new InvalidAffinitySyntaxException(\"Invalid affinity syntax for System property '\" + property + \"'.\"\n+                    + \" Value '\" + value + \"'. \"\n+                    + \" Errormessage '\" + e.getMessage() + \"'\");\n+        }\n+    }\n+\n+    public int getThreadCount() {\n+        return allowedCpusList.size();\n+    }\n+\n+\n+    public BitSet nextAllowedCpus() {\n+        if (allowedCpusList.isEmpty()) {\n+            return null;\n+        }\n+\n+        int index = threadIndex.getAndIncrement() % allowedCpusList.size();\n+        return allowedCpusList.get(index);\n+    }\n+\n+    public boolean isEnabled() {\n+        return !allowedCpusList.isEmpty();\n+    }\n+\n+    private static boolean isAffinityAvailable() {\n+        try {\n+            boolean jnaAvailable = Affinity.isJNAAvailable();\n+            if (!jnaAvailable) {\n+                System.err.println(\"jna is not available\");\n+            }\n+            return jnaAvailable;\n+        } catch (NoClassDefFoundError e) {\n+            e.printStackTrace();\n+            System.err.println(\"Affinity jar isn't available\");\n+            return false;\n+        }\n+    }\n+\n+    static List<BitSet> parse(String affinity) {\n+        List<BitSet> cpus = new ArrayList<>();\n+        if (affinity == null) {\n+            return cpus;\n+        }\n+\n+        affinity = affinity.trim();\n+        if (affinity.isEmpty()) {\n+            return cpus;\n+        }\n+\n+        List<CpuGroup> groups = new AffinityParser(affinity).parse();\n+        for (CpuGroup group : groups) {\n+            BitSet allowedCpus = new BitSet();\n+\n+            for (Integer cpu : group.cpus) {\n+                allowedCpus.set(cpu);\n+            }\n+            for (int k = 0; k < group.threadCount; k++) {\n+                cpus.add(allowedCpus);\n+            }\n+        }\n+\n+        return cpus;\n+    }\n+\n+    static class AffinityParser {\n+        private final String string;\n+        private final List<CpuGroup> groups = new ArrayList<>();\n+        private int index;\n+        private int digit;\n+        private int integer;\n+        private int fromRange;\n+        private int toRange;\n+\n+        AffinityParser(String string) {\n+            this.string = string;\n+        }\n+\n+        List<CpuGroup> parse() {\n+            if (!expression() || index < string.length()) {\n+                throw new InvalidAffinitySyntaxException(\"Syntax Error at \" + index);\n+            }\n+\n+            // verification that we have no duplicate cpus.\n+            BitSet usedCpus = new BitSet();\n+            for (CpuGroup group : groups) {\n+                for (Integer cpu : group.cpus) {\n+                    if (usedCpus.get(cpu)) {\n+                        throw new InvalidAffinitySyntaxException(\"Duplicate CPU found, offending CPU=\" + cpu);\n+                    }\n+                    usedCpus.set(cpu);\n+                }\n+            }\n+\n+            return groups;\n+        }\n+\n+        boolean expression() {\n+            if (!item()) {\n+                return false;\n+            }\n+\n+            while (character(',')) {\n+                if (!item()) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        boolean item() {\n+            if (range()) {\n+                for (int cpu = fromRange; cpu <= toRange; cpu++) {\n+                    CpuGroup group = new CpuGroup();\n+                    group.cpus.add(cpu);\n+                    group.threadCount = 1;\n+                    groups.add(group);\n+                }\n+                return true;\n+            } else {\n+                return group();\n+            }\n+        }\n+\n+        boolean range() {\n+            if (!integer()) {\n+                return false;\n+            }\n+            fromRange = integer;\n+            toRange = integer;\n+            if (character('-')) {\n+                if (!integer()) {\n+                    return false;\n+                }\n+                toRange = integer;\n+                if (toRange < fromRange) {\n+                    error(\"ToRange can't smaller than fromRange, toRange=\" + toRange + \" fromRange=\" + fromRange + \".\");", "originalCommit": "f266a5c0d666850b293d998c72e2898ca7da8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8530ed1f42ed92911ea2c2c4f70ad119665c927b", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java b/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\nindex ace585e2b4a..4aaf77d6a2c 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\n\n@@ -16,6 +16,7 @@\n \n package com.hazelcast.internal.util;\n \n+import com.hazelcast.logging.Logger;\n import net.openhft.affinity.Affinity;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4NTk3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427185977", "bodyText": "Missing \"cannot\".", "author": "blazember", "createdAt": "2020-05-19T10:09:11Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import net.openhft.affinity.Affinity;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * This class is threadsafe.\n+ */\n+public class ThreadAffinity {\n+    public static final ThreadAffinity DISABLED = new ThreadAffinity(null);\n+\n+    final List<BitSet> allowedCpusList;\n+    final AtomicInteger threadIndex = new AtomicInteger();\n+\n+    public ThreadAffinity(String affinity) {\n+        allowedCpusList = parse(affinity);\n+\n+        if (allowedCpusList.isEmpty()) {\n+            return;\n+        }\n+\n+        if (!isAffinityAvailable()) {\n+            throw new RuntimeException(\"Can't use affinity '\" + affinity + \"'. Thread affinity support is not available.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a new ThreadAffinity based on a system property.\n+     *\n+     * If no property is set, then affinity is disabled.\n+     *\n+     * @param property the name of the system property.\n+     * @return the created ThreadAffinity.\n+     * @throws InvalidAffinitySyntaxException if there is a problem with the value.\n+     */\n+    public static ThreadAffinity newSystemThreadAffinity(String property) {\n+        String value = System.getProperty(property);\n+        try {\n+            return new ThreadAffinity(value);\n+        } catch (InvalidAffinitySyntaxException e) {\n+            throw new InvalidAffinitySyntaxException(\"Invalid affinity syntax for System property '\" + property + \"'.\"\n+                    + \" Value '\" + value + \"'. \"\n+                    + \" Errormessage '\" + e.getMessage() + \"'\");\n+        }\n+    }\n+\n+    public int getThreadCount() {\n+        return allowedCpusList.size();\n+    }\n+\n+\n+    public BitSet nextAllowedCpus() {\n+        if (allowedCpusList.isEmpty()) {\n+            return null;\n+        }\n+\n+        int index = threadIndex.getAndIncrement() % allowedCpusList.size();\n+        return allowedCpusList.get(index);\n+    }\n+\n+    public boolean isEnabled() {\n+        return !allowedCpusList.isEmpty();\n+    }\n+\n+    private static boolean isAffinityAvailable() {\n+        try {\n+            boolean jnaAvailable = Affinity.isJNAAvailable();\n+            if (!jnaAvailable) {\n+                System.err.println(\"jna is not available\");\n+            }\n+            return jnaAvailable;\n+        } catch (NoClassDefFoundError e) {\n+            e.printStackTrace();\n+            System.err.println(\"Affinity jar isn't available\");\n+            return false;\n+        }\n+    }\n+\n+    static List<BitSet> parse(String affinity) {\n+        List<BitSet> cpus = new ArrayList<>();\n+        if (affinity == null) {\n+            return cpus;\n+        }\n+\n+        affinity = affinity.trim();\n+        if (affinity.isEmpty()) {\n+            return cpus;\n+        }\n+\n+        List<CpuGroup> groups = new AffinityParser(affinity).parse();\n+        for (CpuGroup group : groups) {\n+            BitSet allowedCpus = new BitSet();\n+\n+            for (Integer cpu : group.cpus) {\n+                allowedCpus.set(cpu);\n+            }\n+            for (int k = 0; k < group.threadCount; k++) {\n+                cpus.add(allowedCpus);\n+            }\n+        }\n+\n+        return cpus;\n+    }\n+\n+    static class AffinityParser {\n+        private final String string;\n+        private final List<CpuGroup> groups = new ArrayList<>();\n+        private int index;\n+        private int digit;\n+        private int integer;\n+        private int fromRange;\n+        private int toRange;\n+\n+        AffinityParser(String string) {\n+            this.string = string;\n+        }\n+\n+        List<CpuGroup> parse() {\n+            if (!expression() || index < string.length()) {\n+                throw new InvalidAffinitySyntaxException(\"Syntax Error at \" + index);\n+            }\n+\n+            // verification that we have no duplicate cpus.\n+            BitSet usedCpus = new BitSet();\n+            for (CpuGroup group : groups) {\n+                for (Integer cpu : group.cpus) {\n+                    if (usedCpus.get(cpu)) {\n+                        throw new InvalidAffinitySyntaxException(\"Duplicate CPU found, offending CPU=\" + cpu);\n+                    }\n+                    usedCpus.set(cpu);\n+                }\n+            }\n+\n+            return groups;\n+        }\n+\n+        boolean expression() {\n+            if (!item()) {\n+                return false;\n+            }\n+\n+            while (character(',')) {\n+                if (!item()) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        boolean item() {\n+            if (range()) {\n+                for (int cpu = fromRange; cpu <= toRange; cpu++) {\n+                    CpuGroup group = new CpuGroup();\n+                    group.cpus.add(cpu);\n+                    group.threadCount = 1;\n+                    groups.add(group);\n+                }\n+                return true;\n+            } else {\n+                return group();\n+            }\n+        }\n+\n+        boolean range() {\n+            if (!integer()) {\n+                return false;\n+            }\n+            fromRange = integer;\n+            toRange = integer;\n+            if (character('-')) {\n+                if (!integer()) {\n+                    return false;\n+                }\n+                toRange = integer;\n+                if (toRange < fromRange) {\n+                    error(\"ToRange can't smaller than fromRange, toRange=\" + toRange + \" fromRange=\" + fromRange + \".\");\n+                }\n+            }\n+\n+            return true;\n+        }\n+\n+        private void error(String error) {\n+            throw new InvalidAffinitySyntaxException(error + \" at index:\" + index);\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:NPathComplexity\")\n+        boolean group() {\n+            if (!character('[')) {\n+                return false;\n+            }\n+\n+            if (!range()) {\n+                return false;\n+            }\n+\n+            CpuGroup group = new CpuGroup();\n+            addCpuRangeToGroup(group);\n+\n+            while (character(',')) {\n+                if (!range()) {\n+                    return false;\n+                }\n+\n+                addCpuRangeToGroup(group);\n+            }\n+\n+            if (!character(']')) {\n+                return false;\n+            }\n+\n+            if (character(':')) {\n+                if (!integer()) {\n+                    return false;\n+                }\n+                group.threadCount = integer;\n+                if (group.threadCount == 0) {\n+                    error(\"Thread count can't be 0.\");\n+                } else if (group.threadCount > group.cpus.size()) {\n+                    error(\"Thread count be larger than number of cpu's in the group. \"", "originalCommit": "f266a5c0d666850b293d998c72e2898ca7da8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8530ed1f42ed92911ea2c2c4f70ad119665c927b", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java b/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\nindex ace585e2b4a..4aaf77d6a2c 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/ThreadAffinity.java\n\n@@ -16,6 +16,7 @@\n \n package com.hazelcast.internal.util;\n \n+import com.hazelcast.logging.Logger;\n import net.openhft.affinity.Affinity;\n \n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4ODMxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427188310", "bodyText": "Should be logging here and below.", "author": "blazember", "createdAt": "2020-05-19T10:12:53Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java", "diffHunk": "@@ -71,10 +81,19 @@ protected void afterRun() {\n \n     }\n \n-    /**\n-     * Manages the thread lifecycle and can be overridden to customize if needed.\n-     */\n-    public void run() {\n+    @Override\n+    public final void run() {\n+        if (allowedCpus != null) {\n+            Affinity.setAffinity(allowedCpus);\n+            BitSet actualCpus = Affinity.getAffinity();\n+            if (!actualCpus.equals(allowedCpus)) {\n+                System.out.println(getName() + \" affinity was not applied successfully. \"", "originalCommit": "f266a5c0d666850b293d998c72e2898ca7da8feb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8530ed1f42ed92911ea2c2c4f70ad119665c927b", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java b/hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java\nindex 205d05cdcb1..81f0255fd2e 100644\n--- a/hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java\n+++ b/hazelcast/src/main/java/com/hazelcast/internal/util/executor/HazelcastManagedThread.java\n\n@@ -86,11 +88,12 @@ public class HazelcastManagedThread extends Thread {\n         if (allowedCpus != null) {\n             Affinity.setAffinity(allowedCpus);\n             BitSet actualCpus = Affinity.getAffinity();\n+            ILogger logger = Logger.getLogger(HazelcastManagedThread.class);\n             if (!actualCpus.equals(allowedCpus)) {\n-                System.out.println(getName() + \" affinity was not applied successfully. \"\n-                        + \"Expected cpus:\" + allowedCpus + \". Actual cpus:\" + actualCpus);\n+                logger.warning(getName() + \" affinity was not applied successfully. \"\n+                        + \"Expected CPUs:\" + allowedCpus + \". Actual CPUs:\" + actualCpus);\n             } else {\n-                System.out.println(getName() + \" has affinity for cpus:\" + allowedCpus);\n+                logger.info(getName() + \" has affinity for CPUs:\" + allowedCpus);\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427189524", "bodyText": "Would make sense to add a test for negative numbers too. Both for groups and thread count.", "author": "blazember", "createdAt": "2020-05-19T10:15:05Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util;\n+\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.BitSet;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ThreadAffinityTest {\n+\n+    @Test\n+    public void whenNull() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(null);\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test\n+    public void whenEmptyString() {\n+        ThreadAffinity threadAffinity = new ThreadAffinity(\"\");\n+\n+        assertFalse(threadAffinity.isEnabled());\n+        assertNull(threadAffinity.nextAllowedCpus());\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenSyntaxError() {\n+        new ThreadAffinity(\"abc\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n+    public void whenTrailingComma() {\n+        new ThreadAffinity(\"10,\");\n+    }\n+\n+    @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)", "originalCommit": "f266a5c0d666850b293d998c72e2898ca7da8feb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxMDc3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427210778", "bodyText": "Negative integers are not parsed by the parser.", "author": "pveentjer", "createdAt": "2020-05-19T10:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMxNTg4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427315880", "bodyText": "Shouldn't we get an InvalidAffinitySyntaxException for such a setting?", "author": "blazember", "createdAt": "2020-05-19T13:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxODgxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16971#discussion_r427718817", "bodyText": "You will. Check the syntax for an integer. it will expect 1 digit followed by zero or more digits. If it sees a '-', it won't recognize it and you get a syntax error.", "author": "pveentjer", "createdAt": "2020-05-20T03:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE4OTUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "0e98042da02a8c4f25b67fb3b2db24190d422e56", "chunk": "diff --git a/hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java b/hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java\nindex d032177d6ff..84841de1c2d 100644\n--- a/hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java\n+++ b/hazelcast/src/test/java/com/hazelcast/internal/util/ThreadAffinityTest.java\n\n@@ -56,6 +56,7 @@ public class ThreadAffinityTest {\n         new ThreadAffinity(\"abc\");\n     }\n \n+\n     @Test(expected = ThreadAffinity.InvalidAffinitySyntaxException.class)\n     public void whenTrailingComma() {\n         new ThreadAffinity(\"10,\");\n"}}, {"oid": "8530ed1f42ed92911ea2c2c4f70ad119665c927b", "url": "https://github.com/hazelcast/hazelcast/commit/8530ed1f42ed92911ea2c2c4f70ad119665c927b", "message": "Introduced thread affinity", "committedDate": "2020-05-19T11:06:16Z", "type": "forcePushed"}, {"oid": "0e98042da02a8c4f25b67fb3b2db24190d422e56", "url": "https://github.com/hazelcast/hazelcast/commit/0e98042da02a8c4f25b67fb3b2db24190d422e56", "message": "Introduced thread affinity", "committedDate": "2020-05-20T01:43:41Z", "type": "forcePushed"}, {"oid": "a7e7defde2086b20a3af93e6d59ff4fadfd06ae4", "url": "https://github.com/hazelcast/hazelcast/commit/a7e7defde2086b20a3af93e6d59ff4fadfd06ae4", "message": "Introduced thread affinity", "committedDate": "2020-05-20T06:10:23Z", "type": "commit"}, {"oid": "a7e7defde2086b20a3af93e6d59ff4fadfd06ae4", "url": "https://github.com/hazelcast/hazelcast/commit/a7e7defde2086b20a3af93e6d59ff4fadfd06ae4", "message": "Introduced thread affinity", "committedDate": "2020-05-20T06:10:23Z", "type": "forcePushed"}]}