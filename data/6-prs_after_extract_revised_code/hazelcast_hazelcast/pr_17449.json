{"pr_number": 17449, "pr_title": "Improve SQL index consistency checks", "pr_createdAt": "2020-09-01T12:53:51Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17449", "timeline": [{"oid": "7159ea6ee96120f7a235605ea99ded9d398ecb3a", "url": "https://github.com/hazelcast/hazelcast/commit/7159ea6ee96120f7a235605ea99ded9d398ecb3a", "message": "WIP", "committedDate": "2020-08-31T13:08:13Z", "type": "commit"}, {"oid": "83d1376a898b84dfade28b65f484098eb76a8748", "url": "https://github.com/hazelcast/hazelcast/commit/83d1376a898b84dfade28b65f484098eb76a8748", "message": "WIP", "committedDate": "2020-09-01T10:13:22Z", "type": "commit"}, {"oid": "da13a86b57f6c5c23224de4c0455ec9580b7dc8e", "url": "https://github.com/hazelcast/hazelcast/commit/da13a86b57f6c5c23224de4c0455ec9580b7dc8e", "message": "Tests for PartitionIdSetTest", "committedDate": "2020-09-01T11:23:53Z", "type": "commit"}, {"oid": "44b8eb3662a6d982dc60576c85071022063d5ff7", "url": "https://github.com/hazelcast/hazelcast/commit/44b8eb3662a6d982dc60576c85071022063d5ff7", "message": "Tests for PartitionIdSetTest", "committedDate": "2020-09-01T11:24:19Z", "type": "commit"}, {"oid": "8da03d238e72cb69d2a092acaf6d5ea0a7f3075a", "url": "https://github.com/hazelcast/hazelcast/commit/8da03d238e72cb69d2a092acaf6d5ea0a7f3075a", "message": "Tracker test", "committedDate": "2020-09-01T11:35:47Z", "type": "commit"}, {"oid": "b5b91c1697f9be523684c4d0a379b6166291554f", "url": "https://github.com/hazelcast/hazelcast/commit/b5b91c1697f9be523684c4d0a379b6166291554f", "message": "Merge branch 'master' into sql-index-consistency", "committedDate": "2020-09-01T11:37:23Z", "type": "commit"}, {"oid": "3b2869359d3ca0768d3774bcda65e0868b6c1c93", "url": "https://github.com/hazelcast/hazelcast/commit/3b2869359d3ca0768d3774bcda65e0868b6c1c93", "message": "Docs", "committedDate": "2020-09-01T11:49:30Z", "type": "commit"}, {"oid": "f41a3e645eb8ae1d55e98bb28baae37c96dd25c5", "url": "https://github.com/hazelcast/hazelcast/commit/f41a3e645eb8ae1d55e98bb28baae37c96dd25c5", "message": "Tests", "committedDate": "2020-09-01T12:09:23Z", "type": "commit"}, {"oid": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "url": "https://github.com/hazelcast/hazelcast/commit/7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "message": "Fixes", "committedDate": "2020-09-01T12:45:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg1MzM5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481853395", "bodyText": "Can you document every field in this class? What is the semantics behind pending field?", "author": "petrpleshachkov", "createdAt": "2020-09-02T07:55:09Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void mark(int partition) {\n+        complete(partition, true);\n+    }\n+\n+    public void unmark(int partition) {\n+        complete(partition, false);\n+    }\n+\n+    private void complete(int partition, boolean mark) {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            assert oldState.pending > 0;\n+\n+            PartitionIdSet newIndexedPartitions = oldState.indexedPartitions.copy();\n+\n+            if (mark) {\n+                newIndexedPartitions.add(partition);\n+            } else {\n+                newIndexedPartitions.remove(partition);\n+            }\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                newIndexedPartitions,\n+                oldState.pending - 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void clear() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                new PartitionIdSet(partitionCount),\n+                0\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private static final class State {\n+\n+        private final long version;", "originalCommit": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2MTQ2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r482061465", "bodyText": "Added JavaDocs.", "author": "devozerov", "createdAt": "2020-09-02T13:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg1MzM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2MTkwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r482061905", "bodyText": "The pending field is incremented when the partition update is about to start and decremented when it is finished. When it is greater than 0, the index is not safe to use.", "author": "devozerov", "createdAt": "2020-09-02T13:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg1MzM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex a1f722418c4..04c6f1f3565 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -140,10 +140,17 @@ public class GlobalIndexPartitionTracker {\n         }\n     }\n \n+    /**\n+     * State of the indexed partitions.\n+     */\n     private static final class State {\n-\n+        /** Monotonically increasing version, that is incremented on every partition info update. */\n         private final long version;\n+\n+        /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n+\n+        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzIyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481963226", "bodyText": "Typo: double contains", "author": "petrpleshachkov", "createdAt": "2020-09-02T10:23:53Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -75,4 +91,26 @@\n      */\n     PerIndexStats getPerIndexStats();\n \n+    /**\n+     * Get monotonically increasing stamp that confirms that the index contains contains", "originalCommit": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2MTIyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r482061229", "bodyText": "Fixed typo", "author": "devozerov", "createdAt": "2020-09-02T13:18:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2MzIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java b/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\nindex 9d0ed4af1eb..c3ed02cfcad 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\n\n@@ -92,7 +92,7 @@ public interface InternalIndex extends Index {\n     PerIndexStats getPerIndexStats();\n \n     /**\n-     * Get monotonically increasing stamp that confirms that the index contains contains\n+     * Get monotonically increasing stamp that confirms that the index contains\n      * only expected partitions, and that there are no concurrent partition updates, and\n      * there are no active partition updates (see {@link #beginPartitionUpdate()}).\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDY4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481964687", "bodyText": "Minor: {@code false} otherwise", "author": "petrpleshachkov", "createdAt": "2020-09-02T10:26:28Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -75,4 +91,26 @@\n      */\n     PerIndexStats getPerIndexStats();\n \n+    /**\n+     * Get monotonically increasing stamp that confirms that the index contains contains\n+     * only expected partitions, and that there are no concurrent partition updates, and\n+     * there are no active partition updates (see {@link #beginPartitionUpdate()}).\n+     * <p>\n+     * Received stamp is used to verify that the index is still valid for the given\n+     * set of partitions through a call to {@link #validatePartitionStamp(long)}.\n+     *\n+     * @param expectedPartitionIds expected indexed partitions\n+     * @return stamp or {@code null}\n+     */\n+    Long getPartitionStamp(PartitionIdSet expectedPartitionIds);\n+\n+    /**\n+     * Verifies that the given partition stamp is still valid. It is valid iff there were\n+     * no partition updates since the call to the {@link #getPartitionStamp(PartitionIdSet)}\n+     * that produced this stamp.\n+     *\n+     * @param stamp stamp\n+     * @return {@code true} if the stamp is still valid", "originalCommit": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2MTM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r482061363", "bodyText": "Added the proposed JavaDoc", "author": "devozerov", "createdAt": "2020-09-02T13:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk2NDY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java b/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\nindex 9d0ed4af1eb..c3ed02cfcad 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\n\n@@ -92,7 +92,7 @@ public interface InternalIndex extends Index {\n     PerIndexStats getPerIndexStats();\n \n     /**\n-     * Get monotonically increasing stamp that confirms that the index contains contains\n+     * Get monotonically increasing stamp that confirms that the index contains\n      * only expected partitions, and that there are no concurrent partition updates, and\n      * there are no active partition updates (see {@link #beginPartitionUpdate()}).\n      * <p>\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NDgwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481974804", "bodyText": "It seems we can avoid lock()/unlock() calls and use state.compareAndSet(oldState, newState) in the cycle?", "author": "petrpleshachkov", "createdAt": "2020-09-02T10:44:51Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);", "originalCommit": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2MDc1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r482060755", "bodyText": "This method is invoked rarely (typically from a single thread), and the body of the critical section is small, so there is no apparent need to use CASes.", "author": "devozerov", "createdAt": "2020-09-02T13:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NDgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex a1f722418c4..04c6f1f3565 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -140,10 +140,17 @@ public class GlobalIndexPartitionTracker {\n         }\n     }\n \n+    /**\n+     * State of the indexed partitions.\n+     */\n     private static final class State {\n-\n+        /** Monotonically increasing version, that is incremented on every partition info update. */\n         private final long version;\n+\n+        /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n+\n+        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3NTQzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r481975433", "bodyText": "The same compareAndSet logic applies here?", "author": "petrpleshachkov", "createdAt": "2020-09-02T10:45:58Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void mark(int partition) {\n+        complete(partition, true);\n+    }\n+\n+    public void unmark(int partition) {\n+        complete(partition, false);\n+    }\n+\n+    private void complete(int partition, boolean mark) {\n+        lock.lock();", "originalCommit": "7ade3b18f78c2278ec909b7da6a7fdb62b6a80f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex a1f722418c4..04c6f1f3565 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -140,10 +140,17 @@ public class GlobalIndexPartitionTracker {\n         }\n     }\n \n+    /**\n+     * State of the indexed partitions.\n+     */\n     private static final class State {\n-\n+        /** Monotonically increasing version, that is incremented on every partition info update. */\n         private final long version;\n+\n+        /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n+\n+        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"oid": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "url": "https://github.com/hazelcast/hazelcast/commit/af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "message": "Typos", "committedDate": "2020-09-02T13:18:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTEwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483531106", "bodyText": "Do we need to move this up to before clearing all of the indexes? And do we need to guard it with populateIndexes like we do for other index operations?", "author": "mmedenjak", "createdAt": "2020-09-04T10:26:57Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/MapReplicationStateHolder.java", "diffHunk": "@@ -167,6 +167,9 @@ void applyState() {\n \n                 long nowInMillis = Clock.currentTimeMillis();\n                 final InternalIndex[] indexesSnapshot = indexes.getIndexes();\n+\n+                Indexes.beginPartitionUpdate(indexesSnapshot);", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2NDk3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483564970", "bodyText": "I do not think this is needed. When clear is called, the PartitionIdSet of indexed partitions is cleared. Therefore, if the query expected some partitions to be indexed, say [1, 2, 3, 4], the SQL engine will not be able to get valid stamp, and the query will fail instead of returning incorrect results.", "author": "devozerov", "createdAt": "2020-09-04T11:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMTEwNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjA5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483532090", "bodyText": "How did we not return results before this change? I guess since this operation was serialised with other index-read operations on the partition thread? Or is it because we only returned results after marking it as indexed?", "author": "mmedenjak", "createdAt": "2020-09-04T10:29:12Z", "path": "hazelcast/src/main/java/com/hazelcast/map/impl/operation/AddIndexOperation.java", "diffHunk": "@@ -91,6 +91,8 @@ public void runInternal() {\n \n         SerializationService serializationService = getNodeEngine().getSerializationService();\n \n+        index.beginPartitionUpdate();", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2NDE2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483564166", "bodyText": "When an index is being built, we index partitions one by one. The query fragment that should be executed on the given member, has a set of expected partitions, say [1, 2, 3, 4]. Unless all of them are indexed, the SQL query will report an error. This 'beginPartitionUpdate' adds one more check: if the partitions [1, 2, 3, 4] are already indexed AND another partition is being indexed at the moment, we disallow querying indexes as well, because it may return more entries than needed.\nDoes it answer your question?", "author": "devozerov", "createdAt": "2020-09-04T11:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2Njk5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483566998", "bodyText": "Sure, I was wondering generally in the context of the old query engine though, but if you don't know, that's ok.", "author": "mmedenjak", "createdAt": "2020-09-04T11:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3ODg4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483578884", "bodyText": "I think I didn't understand your question in my first answer.\nIf your question is \"how come that the old predicate API worked\", then I think that it is subject to the same inconsistency issue, but it is harder to reproduce because the old predicate API does not hold index iterators opened for the prolonged time. As mentioned in other comments, I'll create a follow-up ticket for the predicate API fix.", "author": "devozerov", "createdAt": "2020-09-04T12:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUzMjA5MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTQ4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483541483", "bodyText": "Since you just use state.get and state.set, this can be a volatile State", "author": "mmedenjak", "createdAt": "2020-09-04T10:50:29Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2NTk4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483565981", "bodyText": "The problem with volatile State is that it cannot be initialized safely in the constructor, because formally the assignment of the constructed tracker could be moved before the assignment of the state field, leading to NPE. The solution to this is either some final object holder, like in the current PR, or some sort of additional null-checks in several places. I tried the latter, and it appeared more complex than just final holder.", "author": "devozerov", "createdAt": "2020-09-04T11:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex 04c6f1f3565..8a786efc203 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -150,7 +150,7 @@ public class GlobalIndexPartitionTracker {\n         /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n \n-        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n+        /** The number of partitions that are being updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTY5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483541692", "bodyText": "Minor: are being", "author": "mmedenjak", "createdAt": "2020-09-04T10:51:02Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {\n+        return state.get().indexedPartitions.size();\n+    }\n+\n+    public void beginPartitionUpdate() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                oldState.indexedPartitions,\n+                oldState.pending + 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void mark(int partition) {\n+        complete(partition, true);\n+    }\n+\n+    public void unmark(int partition) {\n+        complete(partition, false);\n+    }\n+\n+    private void complete(int partition, boolean mark) {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            assert oldState.pending > 0;\n+\n+            PartitionIdSet newIndexedPartitions = oldState.indexedPartitions.copy();\n+\n+            if (mark) {\n+                newIndexedPartitions.add(partition);\n+            } else {\n+                newIndexedPartitions.remove(partition);\n+            }\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                newIndexedPartitions,\n+                oldState.pending - 1\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    public void clear() {\n+        lock.lock();\n+\n+        try {\n+            State oldState = state.get();\n+\n+            State newState = new State(\n+                oldState.version + 1,\n+                new PartitionIdSet(partitionCount),\n+                0\n+            );\n+\n+            state.set(newState);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * State of the indexed partitions.\n+     */\n+    private static final class State {\n+        /** Monotonically increasing version, that is incremented on every partition info update. */\n+        private final long version;\n+\n+        /** Partitions that are currently indexed. */\n+        private final PartitionIdSet indexedPartitions;\n+\n+        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2NjMxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483566316", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-09-04T11:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MTY5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex 04c6f1f3565..8a786efc203 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -150,7 +150,7 @@ public class GlobalIndexPartitionTracker {\n         /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n \n-        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n+        /** The number of partitions that are being updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MjExNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483542114", "bodyText": "Minor: Why is it named marked and not e.g. indexed?", "author": "mmedenjak", "createdAt": "2020-09-04T10:52:00Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);\n+    }\n+\n+    public int markedCount() {", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU2NzExOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483567118", "bodyText": "Good question. Renamed all \"marked\" names to \"indexed\".", "author": "devozerov", "createdAt": "2020-09-04T11:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MjExNA=="}], "type": "inlineReview", "revised_code": {"commit": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex 04c6f1f3565..8a786efc203 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -150,7 +150,7 @@ public class GlobalIndexPartitionTracker {\n         /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n \n-        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n+        /** The number of partitions that are being updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0Mjg1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483542858", "bodyText": "Why does it need to be boxed? Can we use something like Integer.MIN_VALUE or -1 instead? Can you add javadoc for future maintenance?", "author": "mmedenjak", "createdAt": "2020-09-04T10:53:36Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3MzA0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483573044", "bodyText": "Changed the stamp to long with -1 as a marker of the invalid stamp.", "author": "devozerov", "createdAt": "2020-09-04T12:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0Mjg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex 04c6f1f3565..8a786efc203 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -150,7 +150,7 @@ public class GlobalIndexPartitionTracker {\n         /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n \n-        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n+        /** The number of partitions that are being updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MzI3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483543273", "bodyText": "If you want, you can double the range by starting with something like Integer.MIN_VALUE", "author": "mmedenjak", "createdAt": "2020-09-04T10:54:34Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3MjYzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483572637", "bodyText": "I think even positive 4-byte integers would be sufficient for most cases. However, long is definitively safe, does not do any harm, and is simpler from the implementation standpoint.", "author": "devozerov", "createdAt": "2020-09-04T12:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0MzI3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex 04c6f1f3565..8a786efc203 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -150,7 +150,7 @@ public class GlobalIndexPartitionTracker {\n         /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n \n-        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n+        /** The number of partitions that are being updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NjQ2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483546460", "bodyText": "Since we don't check the pending count here, is it possible we say the index partition is marked/indexed while it's being (un)populated?", "author": "mmedenjak", "createdAt": "2020-09-04T11:01:45Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.query.impl;\n+\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Tracker of indexed partition for global indexes.\n+ * <p>\n+ * Used by {@link InternalIndex} to keep track of indexed partitions and decide whether the query\n+ * using this index could be executed or not.\n+ */\n+public class GlobalIndexPartitionTracker {\n+\n+    private static final long VERSION_INITIAL = 0;\n+\n+    /** Lock to serialize updates to the state. */\n+    private final ReentrantLock lock = new ReentrantLock();\n+\n+    /** Number of partitions in the cluster. */\n+    private final int partitionCount;\n+\n+    /** Current state. */\n+    private final AtomicReference<State> state;\n+\n+    public GlobalIndexPartitionTracker(int partitionCount) {\n+        this.partitionCount = partitionCount;\n+\n+        state = new AtomicReference<>(new State(VERSION_INITIAL, new PartitionIdSet(partitionCount), 0));\n+    }\n+\n+    public Long getPartitionStamp(PartitionIdSet expectedPartitionIds) {\n+        State state0 = state.get();\n+\n+        if (state0.pending > 0 || !state0.indexedPartitions.equals(expectedPartitionIds)) {\n+            return null;\n+        }\n+\n+        return state0.version;\n+    }\n+\n+    public boolean validatePartitionStamp(long version) {\n+        return state.get().version == version;\n+    }\n+\n+    public boolean isMarked(int partitionId) {\n+        return state.get().indexedPartitions.contains(partitionId);", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NDE2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483574168", "bodyText": "Yes, this is a kind of counter-intuitive for the case when we begin the de-indexing of the indexed partition. This is not a problem for SQL, because it relies on stamps. But could be a problem for the old predicate API - there is definitively a window of inconsistency there.\nI will create a follow-up issue to fix the predicate API as well. This is not urgent, because it is not a regression, but a bug that sits there for years.", "author": "devozerov", "createdAt": "2020-09-04T12:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NjQ2MA=="}], "type": "inlineReview", "revised_code": {"commit": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\nindex 04c6f1f3565..8a786efc203 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/GlobalIndexPartitionTracker.java\n\n@@ -150,7 +150,7 @@ public class GlobalIndexPartitionTracker {\n         /** Partitions that are currently indexed. */\n         private final PartitionIdSet indexedPartitions;\n \n-        /** The number of partitions that are baing updated at the moment (indexing or deindexing).  */\n+        /** The number of partitions that are being updated at the moment (indexing or deindexing).  */\n         private final int pending;\n \n         private State(long version, PartitionIdSet indexedPartitions, int pending) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NzEwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483547101", "bodyText": "As mentioned in other comment, do we distinguish which index partition is not safe to query and which is safe to query?", "author": "mmedenjak", "createdAt": "2020-09-04T11:03:22Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -56,6 +57,21 @@\n      */\n     boolean allPartitionsIndexed(int ownedPartitionCount);\n \n+    /**\n+     * Notifies the index that a partition update is about to begin. Could be caused be either\n+     * partition add (e.g. migration from another member, dynamic index creation), or partition\n+     * remove (e.g. migration to another member).\n+     * <p>\n+     * While in this state, the index cannot be queried by the SQL engine safely, because it\n+     * will produce inconsistent results.\n+     * <p>\n+     * Internally this call increments the counter of active partition updates. The counter", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NDU3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483574579", "bodyText": "No, because this is not important for SQL - if there is at least one partition in the inconsistent state, we cannot query the whole index. As mentioned in the comment above, predicate API will require a separate fix.", "author": "devozerov", "createdAt": "2020-09-04T12:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NzEwMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NzQzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483547438", "bodyText": "Add explanation for null or some other special value like -1 if you want to avoid boxing. It was a bit odd seeing you get a boxed Long while you can validate a primitive long.", "author": "mmedenjak", "createdAt": "2020-09-04T11:04:09Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java", "diffHunk": "@@ -75,4 +91,26 @@\n      */\n     PerIndexStats getPerIndexStats();\n \n+    /**\n+     * Get monotonically increasing stamp that confirms that the index contains\n+     * only expected partitions, and that there are no concurrent partition updates, and\n+     * there are no active partition updates (see {@link #beginPartitionUpdate()}).\n+     * <p>\n+     * Received stamp is used to verify that the index is still valid for the given", "originalCommit": "af8f93e86c722fbcb41baea7dfea3949adb1eaf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NTQwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17449#discussion_r483575402", "bodyText": "Added a reference to the GlobalIndexPartitionTracker.getPartitionStamp method, where the semantical meaning of the -1 is explained.", "author": "devozerov", "createdAt": "2020-09-04T12:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU0NzQzOA=="}], "type": "inlineReview", "revised_code": {"commit": "7aa819d519957c047046d5ca3c89199badbfcc42", "chunk": "diff --git a/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java b/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\nindex c3ed02cfcad..01f76d0ef29 100644\n--- a/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\n+++ b/hazelcast/src/main/java/com/hazelcast/query/impl/InternalIndex.java\n\n@@ -100,9 +100,9 @@ public interface InternalIndex extends Index {\n      * set of partitions through a call to {@link #validatePartitionStamp(long)}.\n      *\n      * @param expectedPartitionIds expected indexed partitions\n-     * @return stamp or {@code null}\n+     * @return stamp\n      */\n-    Long getPartitionStamp(PartitionIdSet expectedPartitionIds);\n+    long getPartitionStamp(PartitionIdSet expectedPartitionIds);\n \n     /**\n      * Verifies that the given partition stamp is still valid. It is valid iff there were\n"}}, {"oid": "49d122aa86e684d05247dad3eced499fd7b2fca6", "url": "https://github.com/hazelcast/hazelcast/commit/49d122aa86e684d05247dad3eced499fd7b2fca6", "message": "Merge branch 'master' into sql-index-consistency", "committedDate": "2020-09-04T11:37:50Z", "type": "commit"}, {"oid": "080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "url": "https://github.com/hazelcast/hazelcast/commit/080b2f94367c9f6a89c3fda315c95c81cf8d5e30", "message": "Typo", "committedDate": "2020-09-04T11:47:50Z", "type": "commit"}, {"oid": "9ee9079bfa4e37f943fd212ba55a2b12a811ecbe", "url": "https://github.com/hazelcast/hazelcast/commit/9ee9079bfa4e37f943fd212ba55a2b12a811ecbe", "message": "Tracker: marked -> indexed", "committedDate": "2020-09-04T11:49:27Z", "type": "commit"}, {"oid": "7aa819d519957c047046d5ca3c89199badbfcc42", "url": "https://github.com/hazelcast/hazelcast/commit/7aa819d519957c047046d5ca3c89199badbfcc42", "message": "Make stamp non-nullable", "committedDate": "2020-09-04T12:03:04Z", "type": "commit"}, {"oid": "8d2cd358887e31f4745be8a27a1f7005dd92f64c", "url": "https://github.com/hazelcast/hazelcast/commit/8d2cd358887e31f4745be8a27a1f7005dd92f64c", "message": "Minor", "committedDate": "2020-09-04T12:08:16Z", "type": "commit"}]}