{"pr_number": 1247, "pr_title": "dump entries that could not be deserialized into files", "pr_createdAt": "2020-06-30T15:23:20Z", "pr_url": "https://github.com/bakdata/conquery/pull/1247", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3Mjc1NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448972754", "bodyText": "kannst du das im constructor reingeben?", "author": "awildturtok", "createdAt": "2020-07-02T12:43:01Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -94,6 +115,22 @@ public SerializingStore(XodusStore store, Validator validator, IStoreInfo storeI\n \t\tkeyReader = Jackson.BINARY_MAPPER\n \t\t\t\t\t\t\t.readerFor(storeInfo.getKeyType())\n \t\t\t\t\t\t\t.withView(InternalOnly.class);\n+\t\t\n+\t\tremoveUnreadablesFromUnderlyingStore = ConqueryConfig.getInstance().getStorage().isRemoveUnreadablesFromStore();\n+\t\t\n+\t\t// Prepare dump directory if there is one set in the config\n+\t\tOptional<File> dumpUnreadable = ConqueryConfig.getInstance().getStorage().getUnreadbleDataDumpDirectory();", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "43afcddbc171830970c89db36b82547a6490d416", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 409b1f827..90974f0c4 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -116,20 +108,17 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\t\t\t\t\t.readerFor(storeInfo.getKeyType())\n \t\t\t\t\t\t\t.withView(InternalOnly.class);\n \t\t\n-\t\tremoveUnreadablesFromUnderlyingStore = ConqueryConfig.getInstance().getStorage().isRemoveUnreadablesFromStore();\n-\t\t\n-\t\t// Prepare dump directory if there is one set in the config\n \t\tOptional<File> dumpUnreadable = ConqueryConfig.getInstance().getStorage().getUnreadbleDataDumpDirectory();\n \t\tif(dumpUnreadable.isPresent()) {\n-\t\t\tunreadableValuesDumpDir = dumpUnreadable.get();\n-\t\t\tif(!unreadableValuesDumpDir.exists()) {\n-\t\t\t\tunreadableValuesDumpDir.mkdirs();\n+\t\t\tdumpDir = dumpUnreadable.get();\n+\t\t\tif(!dumpDir.exists()) {\n+\t\t\t\tdumpDir.mkdirs();\n \t\t\t}\n-\t\t\telse if(!unreadableValuesDumpDir.isDirectory()) {\n-\t\t\t\tthrow new IllegalArgumentException(String.format(\"The provided path points to an existing file which is not a directory. Was: %s\", unreadableValuesDumpDir.getAbsolutePath()));\n+\t\t\telse if(!dumpDir.isDirectory()) {\n+\t\t\t\tthrow new IllegalArgumentException(String.format(\"The provided path points to an existing file which is not a directory. Was: %s\", dumpDir.getAbsolutePath()));\n \t\t\t}\n \t\t} else {\n-\t\t\tunreadableValuesDumpDir = null;\n+\t\t\tdumpDir = null;\n \t\t}\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MzY0Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448973646", "bodyText": "das kannst du als lokale variablen umsetzen", "author": "awildturtok", "createdAt": "2020-07-02T12:44:35Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -71,6 +81,17 @@\n \t */\n \tprivate final IStoreInfo storeInfo;\n \n+\tprivate int totalProcessed = 0;", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxMjcyNQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r455812725", "bodyText": "Hab ich gemacht, war auch gut f\u00fcr den test", "author": "thoniTUB", "createdAt": "2020-07-16T14:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MzY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "43afcddbc171830970c89db36b82547a6490d416", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 409b1f827..90974f0c4 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -85,12 +82,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \tprivate int failedKeys = 0;\n \tprivate int failedValues = 0;\n \n-\t/**\n-\t * If set, all values that cannot be read are dumped as single files into this directory.\n-\t */\n-\tprivate final File unreadableValuesDumpDir;\n-\t\n-\tprivate final boolean removeUnreadablesFromUnderlyingStore;\n+\tprivate final File dumpDir;\n \n \t@SuppressWarnings(\"unchecked\")\n \tpublic SerializingStore(XodusStore store, Validator validator, IStoreInfo storeInfo) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NDc2MQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448974761", "bodyText": "kann mir vorstellen, dass das ganz sch\u00f6n lange logs werden. w\u00fcrde das glaube ich eher pro element einzeln loggen dann habeben wir nicht eine ewig lange zeile", "author": "awildturtok", "createdAt": "2020-07-02T12:46:29Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +152,65 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\ttotalProcessed = 0;\n+\t\tfailedKeys = 0;\n+\t\tfailedValues = 0;\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\ttotalProcessed++;\n \t\t\ttry {\n \t\t\t\ttry {\n \t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n \t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\t\tif(unreadableValuesDumpDir != null) {\t\t\t\t\t\t\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\t\t\t\t\t\t\n+\t\t\t\t\t}\n+\t\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t\t}\n+\t\t\t\t\tfailedValues++;\n \t\t\t\t}\n \t\t\t} catch (Exception e) {\n \t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tfailedKeys++;\n \t\t\t}\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(String.format(\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\ttotalProcessed, failedKeys,\n+\t\t\t(float) failedKeys/totalProcessed*100,\n+\t\t\tfailedValues,\n+\t\t\t(float) failedValues/totalProcessed*100));\n+\t\t\n+\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.info(\"Removing the following unreadable elements from the store {}: {}\", storeInfo.getXodusName(), unreadables.stream()\n+\t\t\t\t.map(ByteIterable::getBytesUnsafe)\n+\t\t\t\t.map(String::new)\n+\t\t\t\t.collect(Collectors.toList()));", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxMDQ2Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r455810466", "bodyText": "Ich hab das  log gek\u00fcrzt", "author": "thoniTUB", "createdAt": "2020-07-16T14:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NDc2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "43afcddbc171830970c89db36b82547a6490d416", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 409b1f827..90974f0c4 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -156,12 +145,8 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\ttry {\n \t\t\treturn readValue(binValue);\t\t\t\n \t\t} catch (Exception e) {\n-\t\t\tif(unreadableValuesDumpDir != null) {\n-\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n-\t\t\t}\n-\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n-\t\t\t\tremove(key);\n-\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\tif(dumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString());\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\tThrowables.throwIfUnchecked(e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NTE2NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448975164", "bodyText": "Namen sanitizen f\u00fcr filename", "author": "awildturtok", "createdAt": "2020-07-02T12:47:11Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +290,36 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n+\t\t// Create dump filehandle\n+\t\tFile dumpfile = new File(Path.of(unreadableDumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n+\t\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n+\t\t\t\tstoreName,\n+\t\t\t\tkeyOfDump", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "43afcddbc171830970c89db36b82547a6490d416", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 409b1f827..90974f0c4 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -290,18 +261,10 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t}\n \t}\n \n-\t/**\n-\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n-\t * @param obj The object to dump.\n-\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n-\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n-\t * @param storeName The name of the store which is also used in the dump file name.\n-\t */\n-\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n-\t\t// Create dump filehandle\n-\t\tFile dumpfile = new File(Path.of(unreadableDumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n+\tprivate void dumpToFile(ByteIterable obj, String keyOfDump) {\n+\t\tFile dumpfile = new File(Path.of(dumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n \t\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n-\t\t\t\tstoreName,\n+\t\t\t\tthis.storeInfo.getXodusName(),\n \t\t\t\tkeyOfDump\n \t\t\t\t)\n \t\t\t).toString());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NTg4NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448975884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlog.warn(\"Unable to dump unreadable value of key \" + keyOfDump + \" to file \" + dumpfile +\".\", e);\n          \n          \n            \n            \t\t\tlog.error(\"Unable to dump unreadable value of key `{}` to file `{}`\",keyOfDump, dumpfile, e);", "author": "awildturtok", "createdAt": "2020-07-02T12:48:26Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +290,36 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n+\t\t// Create dump filehandle\n+\t\tFile dumpfile = new File(Path.of(unreadableDumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n+\t\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n+\t\t\t\tstoreName,\n+\t\t\t\tkeyOfDump\n+\t\t\t\t)\n+\t\t\t).toString());\n+\t\tif(dumpfile.exists()) {\n+\t\t\tlog.warn(\"Abort dumping of file {} because it already exists.\",dumpfile);\n+\t\t\treturn;\n+\t\t}\n+\t\t// Write dump\n+\t\ttry {\n+\t\t\tlog.info(\"Dumping value of key {} to {} (because it cannot be deserialized anymore).\", keyOfDump, dumpfile.getCanonicalPath());\n+\t\t\tJsonNode dump = Jackson.BINARY_MAPPER.readerFor(JsonNode.class).readValue(obj.getBytesUnsafe(), 0, obj.getLength());\n+\t\t\tJackson.MAPPER.writer().writeValue(dumpfile, dump);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tlog.warn(\"Unable to dump unreadable value of key \" + keyOfDump + \" to file \" + dumpfile +\".\", e);", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "43afcddbc171830970c89db36b82547a6490d416", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 409b1f827..90974f0c4 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -290,18 +261,10 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t}\n \t}\n \n-\t/**\n-\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n-\t * @param obj The object to dump.\n-\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n-\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n-\t * @param storeName The name of the store which is also used in the dump file name.\n-\t */\n-\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n-\t\t// Create dump filehandle\n-\t\tFile dumpfile = new File(Path.of(unreadableDumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n+\tprivate void dumpToFile(ByteIterable obj, String keyOfDump) {\n+\t\tFile dumpfile = new File(Path.of(dumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n \t\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n-\t\t\t\tstoreName,\n+\t\t\t\tthis.storeInfo.getXodusName(),\n \t\t\t\tkeyOfDump\n \t\t\t\t)\n \t\t\t).toString());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NjE2MQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448976161", "bodyText": "reicht null nicht?", "author": "awildturtok", "createdAt": "2020-07-02T12:48:58Z", "path": "backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java", "diffHunk": "@@ -21,4 +23,14 @@\n \tprivate boolean useWeakDictionaryCaching = true;\n \t@NotNull\n \tprivate Duration weakCacheDuration = Duration.hours(48);\n+\t\n+\t/**\n+\t * Flag for the {@link SerializingStore} whether to delete values from the underlying store, that cannot be mapped to an object anymore.\n+\t */\n+\tprivate boolean removeUnreadablesFromStore = false;\n+\t\n+\t/**\n+\t * When set, all values that could not be deserialized from the persistent store, are dump into individual files.\n+\t */\n+\tprivate Optional<File> unreadbleDataDumpDirectory = Optional.empty();", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxMjQwNw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r455812407", "bodyText": "Ich fand den guava anspruch ganz gut, dass man kein null ausgibt, damit man sich dar\u00fcber Gedanken macht wenn mal etwas nicht gesetzt ist.\nIn einer Klasse intern kann man weiterhin null nutzen, aber da Konfigurationen genau dazu ausgelegt sind, dass sie andere Sachen konfigurieren finde ich optional hier besser", "author": "thoniTUB", "createdAt": "2020-07-16T14:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NjE2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "43afcddbc171830970c89db36b82547a6490d416", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java b/backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java\nindex 164aa4f54..71e75b70c 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java\n\n@@ -20,17 +20,13 @@ public class StorageConfig {\n \tprivate boolean validateOnWrite = false;\n \t@NotNull @Valid\n \tprivate XodusConfig xodus = new XodusConfig();\n+\n \tprivate boolean useWeakDictionaryCaching = true;\n \t@NotNull\n \tprivate Duration weakCacheDuration = Duration.hours(48);\n+\n+\t@Min(1)\n+\tprivate int nThreads = Runtime.getRuntime().availableProcessors();\n \t\n-\t/**\n-\t * Flag for the {@link SerializingStore} whether to delete values from the underlying store, that cannot be mapped to an object anymore.\n-\t */\n-\tprivate boolean removeUnreadablesFromStore = false;\n-\t\n-\t/**\n-\t * When set, all values that could not be deserialized from the persistent store, are dump into individual files.\n-\t */\n-\tprivate Optional<File> unreadbleDataDumpDirectory = Optional.empty();\n+\tprivate Optional<File> unreadbleDataDumpDirectory = null;\n }\n"}}, {"oid": "43afcddbc171830970c89db36b82547a6490d416", "url": "https://github.com/bakdata/conquery/commit/43afcddbc171830970c89db36b82547a6490d416", "message": "dump entries that could not be deserialized to file", "committedDate": "2020-07-16T14:34:50Z", "type": "commit"}, {"oid": "ece07c940c95fc63a8ce55b162968fbb45ce4709", "url": "https://github.com/bakdata/conquery/commit/ece07c940c95fc63a8ce55b162968fbb45ce4709", "message": "set config parameter default value", "committedDate": "2020-07-16T14:35:41Z", "type": "commit"}, {"oid": "40905fb3fed450d1c5a9c5793af5493002281a1b", "url": "https://github.com/bakdata/conquery/commit/40905fb3fed450d1c5a9c5793af5493002281a1b", "message": "add comment", "committedDate": "2020-07-16T14:35:41Z", "type": "commit"}, {"oid": "12b3c2109d7d3526cebfa77566afe106d53fac3c", "url": "https://github.com/bakdata/conquery/commit/12b3c2109d7d3526cebfa77566afe106d53fac3c", "message": "adds option to delete unreadble values from store", "committedDate": "2020-07-16T14:35:43Z", "type": "commit"}, {"oid": "a276e50cfd6c15213e11059e30b106ee67da36a1", "url": "https://github.com/bakdata/conquery/commit/a276e50cfd6c15213e11059e30b106ee67da36a1", "message": "automatic update to docs", "committedDate": "2020-07-16T14:36:02Z", "type": "commit"}, {"oid": "df87eb6e40d1f7b100e7419258fb88ff7cf30158", "url": "https://github.com/bakdata/conquery/commit/df87eb6e40d1f7b100e7419258fb88ff7cf30158", "message": "adds null return value when getting an deleted value", "committedDate": "2020-07-16T14:36:04Z", "type": "commit"}, {"oid": "89d7b80b5f67e9a5c79f4e9817edda390f2bbcd4", "url": "https://github.com/bakdata/conquery/commit/89d7b80b5f67e9a5c79f4e9817edda390f2bbcd4", "message": "makes dump funtion static", "committedDate": "2020-07-16T14:36:05Z", "type": "commit"}, {"oid": "868b20ed31eae8800b26586f3cf616eb9dd34b74", "url": "https://github.com/bakdata/conquery/commit/868b20ed31eae8800b26586f3cf616eb9dd34b74", "message": "adds missings method signature changes", "committedDate": "2020-07-16T14:36:05Z", "type": "commit"}, {"oid": "ee05c2c24879aed79ef67f07a04eb2ef0e02031f", "url": "https://github.com/bakdata/conquery/commit/ee05c2c24879aed79ef67f07a04eb2ef0e02031f", "message": "Update backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-07-16T14:36:06Z", "type": "commit"}, {"oid": "78debfebc49298e281d3992f67c1de6a6dff1fed", "url": "https://github.com/bakdata/conquery/commit/78debfebc49298e281d3992f67c1de6a6dff1fed", "message": "sanitize dumpfilename", "committedDate": "2020-07-16T14:36:06Z", "type": "commit"}, {"oid": "bdedb2404d02057fb2f10d8095c233a2058b2a30", "url": "https://github.com/bakdata/conquery/commit/bdedb2404d02057fb2f10d8095c233a2058b2a30", "message": "removes unnecessary function parameter", "committedDate": "2020-07-16T14:36:26Z", "type": "commit"}, {"oid": "c766fa9777e9468f229ebebcc10028156c72f086", "url": "https://github.com/bakdata/conquery/commit/c766fa9777e9468f229ebebcc10028156c72f086", "message": "adds test for corrupted values", "committedDate": "2020-07-16T14:36:26Z", "type": "commit"}, {"oid": "32216f71c9c06ffcc0a88264571a90d596503915", "url": "https://github.com/bakdata/conquery/commit/32216f71c9c06ffcc0a88264571a90d596503915", "message": "applies split phase to for-each and adds test for corrupt keys.", "committedDate": "2020-07-16T14:36:27Z", "type": "commit"}, {"oid": "90f99b2f34f811cad1695feb4eb525a4217506ed", "url": "https://github.com/bakdata/conquery/commit/90f99b2f34f811cad1695feb4eb525a4217506ed", "message": "adds test test for removal of corrupt entries", "committedDate": "2020-07-16T14:36:27Z", "type": "commit"}, {"oid": "86253b586f4da9f26fe2c4c31c62dbac4a44a90d", "url": "https://github.com/bakdata/conquery/commit/86253b586f4da9f26fe2c4c31c62dbac4a44a90d", "message": "tests removal of key and value corrupted entries", "committedDate": "2020-07-16T14:36:28Z", "type": "commit"}, {"oid": "c04d1d5efb376ca2f494e9b90fc25ab684bbf800", "url": "https://github.com/bakdata/conquery/commit/c04d1d5efb376ca2f494e9b90fc25ab684bbf800", "message": "clean up the test", "committedDate": "2020-07-16T14:36:29Z", "type": "commit"}, {"oid": "840e9eee470f82fb9211f4ca3edf0cf5adf2f5ac", "url": "https://github.com/bakdata/conquery/commit/840e9eee470f82fb9211f4ca3edf0cf5adf2f5ac", "message": "also test the content auf the dumpfile to be correct", "committedDate": "2020-07-16T14:36:30Z", "type": "commit"}, {"oid": "9ba11eb793a38464c1a4c4cb1bcb66f75aec516d", "url": "https://github.com/bakdata/conquery/commit/9ba11eb793a38464c1a4c4cb1bcb66f75aec516d", "message": "shortens log info", "committedDate": "2020-07-16T14:36:30Z", "type": "commit"}, {"oid": "5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "url": "https://github.com/bakdata/conquery/commit/5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "message": "bubble storage config up to not use the global singleton", "committedDate": "2020-07-16T14:36:31Z", "type": "commit"}, {"oid": "5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "url": "https://github.com/bakdata/conquery/commit/5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "message": "bubble storage config up to not use the global singleton", "committedDate": "2020-07-16T14:36:31Z", "type": "forcePushed"}, {"oid": "2568b35229fe379fae7276de8fe3035b09a52360", "url": "https://github.com/bakdata/conquery/commit/2568b35229fe379fae7276de8fe3035b09a52360", "message": "Merge 5aeb8e2e48dcefeb9a663cebd59bfc470382ecba into 1a6db33c8864ca4c173045d6dd32b0bcbfab4780", "committedDate": "2020-07-16T14:37:31Z", "type": "commit"}, {"oid": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "url": "https://github.com/bakdata/conquery/commit/3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "message": "automatic update to docs", "committedDate": "2020-07-16T14:39:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI4Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456308286", "bodyText": "Finde ich in get fragw\u00fcrdig weil du dann theoretisch immer IO im hauptpfad hast", "author": "awildturtok", "createdAt": "2020-07-17T08:47:36Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MTEyNQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456391125", "bodyText": "Aber der ganze store ist doch IO", "author": "thoniTUB", "createdAt": "2020-07-17T11:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MTc3Nw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456391777", "bodyText": "Lol, Fair!", "author": "awildturtok", "createdAt": "2020-07-17T11:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..3980e3aa9 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -231,7 +231,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\n \t\t// Remove corrupted entries from the store if configured so\n \t\tif(removeUnreadablesFromUnderlyingStore) {\n-\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n \t\t\tunreadables.forEach(store::remove);\t\t\t\n \t\t}\n \t\treturn result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODg4NQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456308885", "bodyText": "Das du da den BinaryMaper verwendest sieht mir falsch aus. reicht es nicht die Daten einfach zu dumpen?", "author": "awildturtok", "createdAt": "2020-07-17T08:48:42Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3OTA4Mw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456379083", "bodyText": "Ich m\u00f6chte aber schon einen sinnigen Dateinamen haben. Da dachte ich dass der Key eines Objektes ganz gut ist", "author": "thoniTUB", "createdAt": "2020-07-17T11:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyMzIzOQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456423239", "bodyText": "Ich nehme jetzt die unsafe bytes zu einem String und lasse dar\u00fcber den savefilename regex laufen.", "author": "thoniTUB", "createdAt": "2020-07-17T12:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODg4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..3980e3aa9 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -231,7 +231,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\n \t\t// Remove corrupted entries from the store if configured so\n \t\tif(removeUnreadablesFromUnderlyingStore) {\n-\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n \t\t\tunreadables.forEach(store::remove);\t\t\t\n \t\t}\n \t\treturn result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTU3Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456309576", "bodyText": "Refactor mal den ganzen Try-Catch Block in eine Funtion die eine Deserialisierende Funktion bekommt und einen Wert rausgibt, dann sparst du dir redundanz und aufgebl\u00e4hten code", "author": "awildturtok", "createdAt": "2020-07-17T08:49:57Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyMzY0OA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456423648", "bodyText": "hab die Funktion ausgelagert", "author": "thoniTUB", "createdAt": "2020-07-17T12:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTU3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..3980e3aa9 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -231,7 +231,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\n \t\t// Remove corrupted entries from the store if configured so\n \t\tif(removeUnreadablesFromUnderlyingStore) {\n-\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n \t\t\tunreadables.forEach(store::remove);\t\t\t\n \t\t}\n \t\treturn result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1OQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456309959", "bodyText": "das if kannst du dir hier sparen weil du hier ja nur collectest", "author": "awildturtok", "createdAt": "2020-07-17T08:50:40Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IOException e1) {\n+\t\t\t\t\t\tlog.warn(\"Cannot dump value for key (Bytes {}) to file because the key could not be parsed to in to a String\", k.toString());\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n \t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t}\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = null;\n+\t\t\ttry {\n+\t\t\t\tvalue = readValue(v);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\tdumpToFile(v, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse value for key \" + key, e);\t\t\t\t\t\t\n+\t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..3980e3aa9 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -231,7 +231,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\n \t\t// Remove corrupted entries from the store if configured so\n \t\tif(removeUnreadablesFromUnderlyingStore) {\n-\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n \t\t\tunreadables.forEach(store::remove);\t\t\t\n \t\t}\n \t\treturn result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDEzMA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456310130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n          \n          \n            \n            \t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());", "author": "awildturtok", "createdAt": "2020-07-17T08:50:56Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IOException e1) {\n+\t\t\t\t\t\tlog.warn(\"Cannot dump value for key (Bytes {}) to file because the key could not be parsed to in to a String\", k.toString());\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n \t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t}\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = null;\n+\t\t\ttry {\n+\t\t\t\tvalue = readValue(v);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\tdumpToFile(v, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse value for key \" + key, e);\t\t\t\t\t\t\n+\t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t}\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n \t\t\t}\n+\t\t\t\n+\t\t\t// Apply the conusmer to key and value\n+\t\t\ttry {\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n+\t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(String.format(\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\tresult.getTotalProcessed(), result.getFailedKeys(),\n+\t\t\t(float) result.getFailedKeys()/result.getTotalProcessed()*100,\n+\t\t\tresult.getFailedValues(),\n+\t\t\t(float) result.getFailedValues()/result.getTotalProcessed()*100));\n+\t\t\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..3980e3aa9 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -231,7 +231,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\n \t\t// Remove corrupted entries from the store if configured so\n \t\tif(removeUnreadablesFromUnderlyingStore) {\n-\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n \t\t\tunreadables.forEach(store::remove);\t\t\t\n \t\t}\n \t\treturn result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDMzNw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456310337", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tlog.trace(\"Removing value to key {} from store\", key, storeInfo.getXodusName());\n          \n          \n            \n            \t\tlog.trace(\"Removing value to key {} from Store[{}]\", key, storeInfo.getXodusName());", "author": "awildturtok", "createdAt": "2020-07-17T08:51:22Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -148,6 +252,7 @@ public void update(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic void remove(KEY key) {\n+\t\tlog.trace(\"Removing value to key {} from store\", key, storeInfo.getXodusName());", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe8a96fa5955a909533e70bdd9ada4917ca3fb38", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..2bebd76d0 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -252,7 +252,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \n \t@Override\n \tpublic void remove(KEY key) {\n-\t\tlog.trace(\"Removing value to key {} from store\", key, storeInfo.getXodusName());\n+\t\tlog.trace(\"Removing value to key {} from Store[{}]\", key, storeInfo.getXodusName());\n \t\tstore.remove(writeKey(key));\n \t}\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDc5NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456310794", "bodyText": "W\u00e4re glaube ich auch Sinnvoller alles in eine Datei zu schreiben/appenden, dann sparst du dir IO und File Handles.", "author": "awildturtok", "createdAt": "2020-07-17T08:52:13Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +314,44 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5NDA1Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456394056", "bodyText": "Da die dumps momentan leichter mit find und grep zu sichten sind lasse ich es erstmal so", "author": "thoniTUB", "createdAt": "2020-07-17T11:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "bd14e7d178e972736ca317e157228eea46e180b2", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..f19102975 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -349,7 +349,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\tstoreName,\n \t\t\tkeyOfDump,\n \t\t\tDUMP_FILE_EXTENTION\n-\t\t\t).replaceAll(\"[\\\\\\\\/:*?\\\"<>|]\", \"\");\n+\t\t\t).replaceAll(\"[^a-zA-Z0-9\\\\.\\\\-]\", \"_\");\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMTc2NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456311764", "bodyText": "https://stackoverflow.com/a/15075907/409761", "author": "awildturtok", "createdAt": "2020-07-17T08:54:07Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +314,44 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n+\t\t// Create dump filehandle\n+\t\tFile dumpfile = new File(unreadableDumpDir, makeDumpfileName(keyOfDump, storeName));\n+\t\tif(dumpfile.exists()) {\n+\t\t\tlog.warn(\"Abort dumping of file {} because it already exists.\",dumpfile);\n+\t\t\treturn;\n+\t\t}\n+\t\t// Write dump\n+\t\ttry {\n+\t\t\tlog.info(\"Dumping value of key {} to {} (because it cannot be deserialized anymore).\", keyOfDump, dumpfile.getCanonicalPath());\n+\t\t\tJsonNode dump = Jackson.BINARY_MAPPER.readerFor(JsonNode.class).readValue(obj.getBytesUnsafe(), 0, obj.getLength());\n+\t\t\tJackson.MAPPER.writer().writeValue(dumpfile, dump);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tlog.error(\"Unable to dump unreadable value of key `{}` to file `{}`\",keyOfDump, dumpfile, e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generates a valid file name from the key of the dump object, the store and the current time.\n+\t * However, it does not ensure that there is no file with such a name.\n+\t */\n+\tprivate static String makeDumpfileName(String keyOfDump, String storeName) {\n+\t\treturn String.format(\"%s-%s-%s.%s\",\n+\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n+\t\t\tstoreName,\n+\t\t\tkeyOfDump,\n+\t\t\tDUMP_FILE_EXTENTION\n+\t\t\t).replaceAll(\"[\\\\\\\\/:*?\\\"<>|]\", \"\");", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bd14e7d178e972736ca317e157228eea46e180b2", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex 743b2046d..f19102975 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -349,7 +349,7 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \t\t\tstoreName,\n \t\t\tkeyOfDump,\n \t\t\tDUMP_FILE_EXTENTION\n-\t\t\t).replaceAll(\"[\\\\\\\\/:*?\\\"<>|]\", \"\");\n+\t\t\t).replaceAll(\"[^a-zA-Z0-9\\\\.\\\\-]\", \"_\");\n \t}\n \n \t@Override\n"}}, {"oid": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "url": "https://github.com/bakdata/conquery/commit/fb2e9c601db55683af7525e398623c6a6fe1bb9d", "message": "Update backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-07-17T11:15:00Z", "type": "commit"}, {"oid": "fe8a96fa5955a909533e70bdd9ada4917ca3fb38", "url": "https://github.com/bakdata/conquery/commit/fe8a96fa5955a909533e70bdd9ada4917ca3fb38", "message": "Update backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-07-17T11:15:32Z", "type": "commit"}, {"oid": "bd14e7d178e972736ca317e157228eea46e180b2", "url": "https://github.com/bakdata/conquery/commit/bd14e7d178e972736ca317e157228eea46e180b2", "message": "change sanitizer statement", "committedDate": "2020-07-17T11:51:06Z", "type": "commit"}, {"oid": "68f76b37a2e4b681d5bb946efbb720e2e924a0cf", "url": "https://github.com/bakdata/conquery/commit/68f76b37a2e4b681d5bb946efbb720e2e924a0cf", "message": "remove unnecessary ifs for collection", "committedDate": "2020-07-17T11:54:34Z", "type": "commit"}, {"oid": "7f8b309ea8b932a096105b227ddd48b257a7c19e", "url": "https://github.com/bakdata/conquery/commit/7f8b309ea8b932a096105b227ddd48b257a7c19e", "message": "extracts method for deserialization", "committedDate": "2020-07-17T12:26:51Z", "type": "commit"}, {"oid": "82ec48ee07b0259ec924c2c89db610446bdc6b3a", "url": "https://github.com/bakdata/conquery/commit/82ec48ee07b0259ec924c2c89db610446bdc6b3a", "message": "extracts dumping into deserialization method", "committedDate": "2020-07-17T12:44:13Z", "type": "commit"}, {"oid": "b069cbdfd6f691d4fde2d997189d3304c83a5620", "url": "https://github.com/bakdata/conquery/commit/b069cbdfd6f691d4fde2d997189d3304c83a5620", "message": "compiles the regex once", "committedDate": "2020-07-17T12:52:58Z", "type": "commit"}, {"oid": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "url": "https://github.com/bakdata/conquery/commit/0b97152388bee6773ae9b50f23a0271cc3d1b520", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-17T12:55:28Z", "type": "commit"}, {"oid": "2dca2869f2c11f75d194d10b66a5be08706a494e", "url": "https://github.com/bakdata/conquery/commit/2dca2869f2c11f75d194d10b66a5be08706a494e", "message": "surpress NaN output", "committedDate": "2020-07-17T13:10:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjcxNA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456432714", "bodyText": "Ist das nicht sogar komplett statisch?", "author": "awildturtok", "createdAt": "2020-07-17T13:12:24Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +155,100 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n+\t/**\n+\t * Iterates a given consumer over the entries of this store.\n+\t * Depending on the {@link StorageConfig} corrupt entries may be dump to a file and/or removed from the store.\n+\t * These entries are not submitted to the consumer.\n+\t */\n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationStatistic forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationStatistic result = new IterationStatistic();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = getDeserializedAndDumpFailed(\n+\t\t\t\tk,\n+\t\t\t\tthis::readKey,\n+\t\t\t\t() -> new String(k.getBytesUnsafe()),\n+\t\t\t\tv,\n+\t\t\t\t\"Could not parse key [{}]\");\n+\t\t\tif (key == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = getDeserializedAndDumpFailed(\n+\t\t\t\tv, \n+\t\t\t\tthis::readValue, \n+\t\t\t\t() -> key.toString(),\n+\t\t\t\tv, \n+\t\t\t\t\"Could not parse value for key [{}]\");\n+\t\t\tif (value == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Apply the conusmer to key and value\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n \t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(\n+\t\t\tString.format(\n+\t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\tresult.getFailedKeys(),\n+\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\tresult.getFailedValues(),\n+\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif (removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tunreadables.forEach(store::remove);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\tprivate <TYPE> TYPE getDeserializedAndDumpFailed(ByteIterable serial, Function<ByteIterable, TYPE> deserializer, Supplier<String> onFailKeyStringSupplier, ByteIterable onFailOrigValue, String onFailWarnMsgFmt ){", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1OTYzMw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456459633", "bodyText": "Ja das kann man machen, dann m\u00fcssten die Config parameter noch reingereicht werden, aber dann ist die Parameterliste super lang.\nDa die Methode privat ist w\u00fcrde ich es so lassen", "author": "thoniTUB", "createdAt": "2020-07-17T13:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjcxNA=="}], "type": "inlineReview", "revised_code": {"commit": "168d1a20947aee5b371327ff8b0ad3873f32d7b9", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex bc9ae7929..5e54e0383 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -220,15 +220,16 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \n \t\t});\n \t\t// Print some statistics\n+\t\tint total = result.getTotalProcessed();\n \t\tlog.info(\n \t\t\tString.format(\n \t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n \t\t\t\tthis.storeInfo.getXodusName(),\n-\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\ttotal,\n \t\t\t\tresult.getFailedKeys(),\n-\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\ttotal > 0 ? (float) result.getFailedKeys() / total * 100 : 0,\n \t\t\t\tresult.getFailedValues(),\n-\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\t\t\t\ttotal > 0 ? (float) result.getFailedValues() / total * 100 : 0));\n \n \t\t// Remove corrupted entries from the store if configured so\n \t\tif (removeUnreadablesFromUnderlyingStore) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDAwMg==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456434002", "bodyText": "Sollte das nicht immer warnen?", "author": "awildturtok", "createdAt": "2020-07-17T13:14:42Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +155,100 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n+\t/**\n+\t * Iterates a given consumer over the entries of this store.\n+\t * Depending on the {@link StorageConfig} corrupt entries may be dump to a file and/or removed from the store.\n+\t * These entries are not submitted to the consumer.\n+\t */\n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationStatistic forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationStatistic result = new IterationStatistic();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = getDeserializedAndDumpFailed(\n+\t\t\t\tk,\n+\t\t\t\tthis::readKey,\n+\t\t\t\t() -> new String(k.getBytesUnsafe()),\n+\t\t\t\tv,\n+\t\t\t\t\"Could not parse key [{}]\");\n+\t\t\tif (key == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = getDeserializedAndDumpFailed(\n+\t\t\t\tv, \n+\t\t\t\tthis::readValue, \n+\t\t\t\t() -> key.toString(),\n+\t\t\t\tv, \n+\t\t\t\t\"Could not parse value for key [{}]\");\n+\t\t\tif (value == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Apply the conusmer to key and value\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n \t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(\n+\t\t\tString.format(\n+\t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\tresult.getFailedKeys(),\n+\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\tresult.getFailedValues(),\n+\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif (removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tunreadables.forEach(store::remove);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\tprivate <TYPE> TYPE getDeserializedAndDumpFailed(ByteIterable serial, Function<ByteIterable, TYPE> deserializer, Supplier<String> onFailKeyStringSupplier, ByteIterable onFailOrigValue, String onFailWarnMsgFmt ){\n+\t\ttry {\n+\t\t\treturn deserializer.apply(serial);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(onFailOrigValue, onFailKeyStringSupplier.get(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t} else {\n+\t\t\t\tlog.warn(onFailWarnMsgFmt, onFailKeyStringSupplier.get(), e);", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDE0Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456434146", "bodyText": "Sonst wei\u00dft du ja gar nicht sicher, dass es was gedumpt hat?", "author": "awildturtok", "createdAt": "2020-07-17T13:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MTk3Mw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456461973", "bodyText": "ich habs etwas umge\u00e4ndert damit der stacktrace nur geworfen wird, wenn TRACE aktiviert wird", "author": "thoniTUB", "createdAt": "2020-07-17T14:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDAwMg=="}], "type": "inlineReview", "revised_code": {"commit": "168d1a20947aee5b371327ff8b0ad3873f32d7b9", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex bc9ae7929..5e54e0383 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -220,15 +220,16 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \n \t\t});\n \t\t// Print some statistics\n+\t\tint total = result.getTotalProcessed();\n \t\tlog.info(\n \t\t\tString.format(\n \t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n \t\t\t\tthis.storeInfo.getXodusName(),\n-\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\ttotal,\n \t\t\t\tresult.getFailedKeys(),\n-\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\ttotal > 0 ? (float) result.getFailedKeys() / total * 100 : 0,\n \t\t\t\tresult.getFailedValues(),\n-\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\t\t\t\ttotal > 0 ? (float) result.getFailedValues() / total * 100 : 0));\n \n \t\t// Remove corrupted entries from the store if configured so\n \t\tif (removeUnreadablesFromUnderlyingStore) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDQ0Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456434446", "bodyText": "hier fehlt etwas doku aber brauchst es nicht \u00fcbertreiben intention reicht", "author": "awildturtok", "createdAt": "2020-07-17T13:15:28Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +155,100 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n+\t/**\n+\t * Iterates a given consumer over the entries of this store.\n+\t * Depending on the {@link StorageConfig} corrupt entries may be dump to a file and/or removed from the store.\n+\t * These entries are not submitted to the consumer.\n+\t */\n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationStatistic forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationStatistic result = new IterationStatistic();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = getDeserializedAndDumpFailed(\n+\t\t\t\tk,\n+\t\t\t\tthis::readKey,\n+\t\t\t\t() -> new String(k.getBytesUnsafe()),\n+\t\t\t\tv,\n+\t\t\t\t\"Could not parse key [{}]\");\n+\t\t\tif (key == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = getDeserializedAndDumpFailed(\n+\t\t\t\tv, \n+\t\t\t\tthis::readValue, \n+\t\t\t\t() -> key.toString(),\n+\t\t\t\tv, \n+\t\t\t\t\"Could not parse value for key [{}]\");\n+\t\t\tif (value == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Apply the conusmer to key and value\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n \t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(\n+\t\t\tString.format(\n+\t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\tresult.getFailedKeys(),\n+\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\tresult.getFailedValues(),\n+\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif (removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tunreadables.forEach(store::remove);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\tprivate <TYPE> TYPE getDeserializedAndDumpFailed(ByteIterable serial, Function<ByteIterable, TYPE> deserializer, Supplier<String> onFailKeyStringSupplier, ByteIterable onFailOrigValue, String onFailWarnMsgFmt ){", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "168d1a20947aee5b371327ff8b0ad3873f32d7b9", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\nindex bc9ae7929..5e54e0383 100644\n--- a/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n+++ b/backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\n@@ -220,15 +220,16 @@ public class SerializingStore<KEY, VALUE> implements Store<KEY, VALUE> {\n \n \t\t});\n \t\t// Print some statistics\n+\t\tint total = result.getTotalProcessed();\n \t\tlog.info(\n \t\t\tString.format(\n \t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n \t\t\t\tthis.storeInfo.getXodusName(),\n-\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\ttotal,\n \t\t\t\tresult.getFailedKeys(),\n-\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\ttotal > 0 ? (float) result.getFailedKeys() / total * 100 : 0,\n \t\t\t\tresult.getFailedValues(),\n-\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\t\t\t\ttotal > 0 ? (float) result.getFailedValues() / total * 100 : 0));\n \n \t\t// Remove corrupted entries from the store if configured so\n \t\tif (removeUnreadablesFromUnderlyingStore) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNjg5MA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456436890", "bodyText": "Das nimmt auch ein Lambda wie in PreprocessorCommand: listFiles(((dir, name) -> name.endsWith(ConqueryConstants.EXTENSION_DESCRIPTION)));", "author": "awildturtok", "createdAt": "2020-07-17T13:20:04Z", "path": "backend/src/test/java/com/bakdata/conquery/io/xodus/stores/SerializingStoreDumpTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.bakdata.conquery.io.xodus.stores;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.validation.Validator;\n+\n+import com.bakdata.conquery.apiv1.QueryDescription;\n+import com.bakdata.conquery.io.jackson.Jackson;\n+import com.bakdata.conquery.io.xodus.StoreInfo;\n+import com.bakdata.conquery.io.xodus.stores.SerializingStore.IterationStatistic;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.config.StorageConfig;\n+import com.bakdata.conquery.models.exceptions.JSONException;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.query.concept.specific.CQReusedQuery;\n+import com.google.common.io.Files;\n+import io.dropwizard.jersey.validation.Validators;\n+import jetbrains.exodus.env.Environment;\n+import jetbrains.exodus.env.Environments;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FileUtils;\n+import org.assertj.core.api.Condition;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+@Slf4j\n+public class SerializingStoreDumpTest {\n+\n+\tprivate File tmpDir;\n+\tprivate Environment env;\n+\tprivate StorageConfig config;\n+\t\n+\t// Test data\n+\tprivate final ConceptQuery cQuery = new ConceptQuery(new CQReusedQuery(new ManagedExecutionId(new DatasetId(\"testD\"), UUID.randomUUID())));\n+\tprivate final User user = new User(\"username\",\"userlabel\");\n+\t\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\ttmpDir = Files.createTempDir();\n+\t\tenv = Environments.newInstance(tmpDir);\n+\t\tconfig = new StorageConfig();\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void destroy() throws IOException {\n+\t\tenv.close();\n+\t\tFileUtils.deleteDirectory(tmpDir);\n+\t}\n+\t\n+\tprivate <KEY, VALUE> SerializingStore<KEY, VALUE> createSerializedStore(StorageConfig config, Environment environment, Validator validator, IStoreInfo storeId) {\n+\t\treturn new SerializingStore<>(config, new XodusStore(environment, storeId), validator, storeId);\n+\t}\n+\t\n+\t/**\n+\t * Tests if entries with corrupted values are dumped.\n+\t */\n+\t@Test\n+\tpublic void testCorruptValueDump() throws JSONException, IOException {\n+\t\t// Set dump directory to this tests temp-dir\n+\t\tconfig.setUnreadbleDataDumpDirectory(Optional.of(tmpDir));\n+\t\t\n+\t\t// Open a store and insert a valid key-value pair (UserId & User)\n+\t\ttry (SerializingStore<UserId, User> store = createSerializedStore(config, env, Validators.newValidator(), StoreInfo.AUTH_USER)){\n+\t\t\tstore.add(user.getId(), user);\n+\t\t}\n+\t\t\n+\t\t// Open that store again, with a different config to insert a corrupt entry (UserId & ManagedQuery)\t\t\n+\t\ttry (SerializingStore<UserId, QueryDescription> store = createSerializedStore(config, env, Validators.newValidator(), new CorruptableStoreInfo(StoreInfo.AUTH_USER.getXodusName(), UserId.class, QueryDescription.class))){\n+\t\t\tstore.add(new UserId(\"testU2\"), cQuery);\n+\t\t}\n+\t\t\n+\t\t// Reopen the store with the initial value and try to iterate over all entries (this triggers the dump or removal of invalid entries)\n+\t\ttry (SerializingStore<UserId, User> store = createSerializedStore(config, env, Validators.newValidator(), StoreInfo.AUTH_USER)){\n+\t\t\tIterationStatistic expectedResult = new IterationStatistic();\n+\t\t\texpectedResult.setTotalProcessed(2);\n+\t\t\texpectedResult.setFailedKeys(0);\n+\t\t\texpectedResult.setFailedValues(1);\n+\t\t\t\n+\t\t\t// Iterate (do nothing with the entries themselves)\n+\t\t\tIterationStatistic result = store.forEach((k,v,s) -> {});\n+\t\t\tassertThat(result).isEqualTo(expectedResult);\n+\t\t}\n+\t\t\n+\t\t// Test if the correct number of dumpfiles was generated\n+\t\tCondition<File> dumpFileCond = new Condition<>(f -> f.getName().endsWith(SerializingStore.DUMP_FILE_EXTENTION) , \"dump file\");\n+\t\tassertThat(tmpDir.listFiles()).areExactly(1, dumpFileCond);\n+\t\t\n+\t\t// Test if the dump is correct\n+\t\tFile dumpFile = getDumpFile(dumpFileCond);\n+\n+\t\tassertThat((QueryDescription) Jackson.MAPPER.readerFor(QueryDescription.class).readValue(dumpFile)).isEqualTo(cQuery);\n+\t}\n+\n+\tprivate File getDumpFile(Condition<File> dumpFileCond) {\n+\t\tFile dumpFile = tmpDir.listFiles(new FileFilter() {\n+\n+\t\t\t@Override\n+\t\t\tpublic boolean accept(File pathname) {\n+\t\t\t\treturn dumpFileCond.matches(pathname);", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "168d1a20947aee5b371327ff8b0ad3873f32d7b9", "chunk": "diff --git a/backend/src/test/java/com/bakdata/conquery/io/xodus/stores/SerializingStoreDumpTest.java b/backend/src/test/java/com/bakdata/conquery/io/xodus/stores/SerializingStoreDumpTest.java\nindex c5ea8e1df..bbdc50cae 100644\n--- a/backend/src/test/java/com/bakdata/conquery/io/xodus/stores/SerializingStoreDumpTest.java\n+++ b/backend/src/test/java/com/bakdata/conquery/io/xodus/stores/SerializingStoreDumpTest.java\n\n@@ -3,7 +3,6 @@ package com.bakdata.conquery.io.xodus.stores;\n import static org.assertj.core.api.Assertions.assertThat;\n \n import java.io.File;\n-import java.io.FileFilter;\n import java.io.IOException;\n import java.util.Optional;\n import java.util.UUID;\n"}}, {"oid": "168d1a20947aee5b371327ff8b0ad3873f32d7b9", "url": "https://github.com/bakdata/conquery/commit/168d1a20947aee5b371327ff8b0ad3873f32d7b9", "message": "review changes", "committedDate": "2020-07-17T14:12:20Z", "type": "commit"}, {"oid": "6d4dae536c80426410ba821a49c29499c42545ca", "url": "https://github.com/bakdata/conquery/commit/6d4dae536c80426410ba821a49c29499c42545ca", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-17T14:20:33Z", "type": "commit"}, {"oid": "c48d2a030120bf92d1eb7f5aeb3dded2acbdf7b1", "url": "https://github.com/bakdata/conquery/commit/c48d2a030120bf92d1eb7f5aeb3dded2acbdf7b1", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-17T15:08:09Z", "type": "commit"}, {"oid": "84cb5c53e28c3819f95bed1bb018fae1886e8b80", "url": "https://github.com/bakdata/conquery/commit/84cb5c53e28c3819f95bed1bb018fae1886e8b80", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-20T06:33:33Z", "type": "commit"}]}