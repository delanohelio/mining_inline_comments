{"pr_number": 1505, "pr_title": "correct datacontext generation", "pr_createdAt": "2020-12-15T16:51:22Z", "pr_url": "https://github.com/bakdata/conquery/pull/1505", "timeline": [{"oid": "98fe8b24ef4277c37094c1efa170f9f37e97f08c", "url": "https://github.com/bakdata/conquery/commit/98fe8b24ef4277c37094c1efa170f9f37e97f08c", "message": "wip: date context relative to context mode", "committedDate": "2020-12-16T08:01:32Z", "type": "commit"}, {"oid": "40235a99da8de863c16ec2e3ed5c9e2f5dd10133", "url": "https://github.com/bakdata/conquery/commit/40235a99da8de863c16ec2e3ed5c9e2f5dd10133", "message": "algorithm draft", "committedDate": "2020-12-16T08:01:33Z", "type": "commit"}, {"oid": "f2bd1f2a01ddf90bea2667699a307aca267458da", "url": "https://github.com/bakdata/conquery/commit/f2bd1f2a01ddf90bea2667699a307aca267458da", "message": "fix date context tests", "committedDate": "2020-12-16T08:01:33Z", "type": "commit"}, {"oid": "8c70b44e1e82235b3849e2f93611401bc3a2e951", "url": "https://github.com/bakdata/conquery/commit/8c70b44e1e82235b3849e2f93611401bc3a2e951", "message": "makes integration tests pass", "committedDate": "2020-12-16T08:01:34Z", "type": "commit"}, {"oid": "2cdfbb5b9b8b2efa7536cc4a856e4adc2ed72d91", "url": "https://github.com/bakdata/conquery/commit/2cdfbb5b9b8b2efa7536cc4a856e4adc2ed72d91", "message": "cleanup", "committedDate": "2020-12-16T08:01:35Z", "type": "commit"}, {"oid": "924dfe735085f75a63273e1b49f48222c880f976", "url": "https://github.com/bakdata/conquery/commit/924dfe735085f75a63273e1b49f48222c880f976", "message": "fixes query tests", "committedDate": "2020-12-16T08:01:36Z", "type": "commit"}, {"oid": "66da8f642ce1c1cddd6f0d12655906af5d050ec1", "url": "https://github.com/bakdata/conquery/commit/66da8f642ce1c1cddd6f0d12655906af5d050ec1", "message": "using extra enum to descripte calendar units", "committedDate": "2020-12-16T08:01:36Z", "type": "commit"}, {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332", "url": "https://github.com/bakdata/conquery/commit/9861f332a05035e9b60b59a2b61bbf0136730332", "message": "automatic update to docs", "committedDate": "2020-12-16T08:01:37Z", "type": "commit"}, {"oid": "9861f332a05035e9b60b59a2b61bbf0136730332", "url": "https://github.com/bakdata/conquery/commit/9861f332a05035e9b60b59a2b61bbf0136730332", "message": "automatic update to docs", "committedDate": "2020-12-16T08:01:37Z", "type": "forcePushed"}, {"oid": "1ad65b600010a1cbec5de3739b76cb28451340bb", "url": "https://github.com/bakdata/conquery/commit/1ad65b600010a1cbec5de3739b76cb28451340bb", "message": "adds more tests", "committedDate": "2020-12-16T09:53:48Z", "type": "commit"}, {"oid": "53aac6b9881ef0b82d2fc8d3e85110977ad50259", "url": "https://github.com/bakdata/conquery/commit/53aac6b9881ef0b82d2fc8d3e85110977ad50259", "message": "wip more doku", "committedDate": "2020-12-16T09:54:05Z", "type": "commit"}, {"oid": "a3ae6f610e1d932579b8731c7d1986df5656cf85", "url": "https://github.com/bakdata/conquery/commit/a3ae6f610e1d932579b8731c7d1986df5656cf85", "message": "Merge branch 'develop' into feature/correct-datacontext-generation\n\n# Conflicts:\n#\tbackend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "committedDate": "2020-12-16T10:08:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTE0Ng==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544101146", "bodyText": "falsche Anno", "author": "awildturtok", "createdAt": "2020-12-16T08:24:56Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "diffHunk": "@@ -89,4 +93,32 @@ public String getLocalizedTypeLabel() {\n \t\treturn C10N.get(ExportFormC10n.class, I18n.LOCALE.get()).getType();\n \t}\n \n+\n+\n+\t@org.jetbrains.annotations.NotNull", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53aac6b9881ef0b82d2fc8d3e85110977ad50259", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java b/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java\nindex 8519241af..768ec6e0d 100644\n--- a/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java\n+++ b/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java\n\n@@ -94,8 +94,13 @@ public class ExportForm implements Form, NamespacedIdHolding {\n \t}\n \n \n-\n-\t@org.jetbrains.annotations.NotNull\n+\t/**\n+\t * Maps the given resolution to a fitting alignment. It tried to use the alignment which was given as a hint.\n+\t * If the alignment and \n+\t * @param resolutions\n+\t * @param alignmentHint\n+\t * @return\n+\t */\n \tpublic static List<ExportForm.ResolutionAndAlignment> getResolutionAlignmentMap(List<DateContext.Resolution> resolutions, DateContext.Alignment alignmentHint) {\n \n \t\treturn resolutions.stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMTcyOQ==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544101729", "bodyText": "den else branch finde ich nicht sauber, mach lieber eine Liste draus oder besser eine Methode", "author": "awildturtok", "createdAt": "2020-12-16T08:25:52Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java", "diffHunk": "@@ -89,4 +93,32 @@ public String getLocalizedTypeLabel() {\n \t\treturn C10N.get(ExportFormC10n.class, I18n.LOCALE.get()).getType();\n \t}\n \n+\n+\n+\t@org.jetbrains.annotations.NotNull\n+\tpublic static List<ExportForm.ResolutionAndAlignment> getResolutionAlignmentMap(List<DateContext.Resolution> resolutions, DateContext.Alignment alignmentHint) {\n+\n+\t\treturn resolutions.stream()\n+\t\t\t\t.map(r -> ResolutionAndAlignment.of(r, r.getSupportedAlignments().contains(alignmentHint)? alignmentHint : r.getSupportedAlignments().iterator().next()))", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53aac6b9881ef0b82d2fc8d3e85110977ad50259", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java b/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java\nindex 8519241af..768ec6e0d 100644\n--- a/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java\n+++ b/backend/src/main/java/com/bakdata/conquery/apiv1/forms/export_form/ExportForm.java\n\n@@ -94,8 +94,13 @@ public class ExportForm implements Form, NamespacedIdHolding {\n \t}\n \n \n-\n-\t@org.jetbrains.annotations.NotNull\n+\t/**\n+\t * Maps the given resolution to a fitting alignment. It tried to use the alignment which was given as a hint.\n+\t * If the alignment and \n+\t * @param resolutions\n+\t * @param alignmentHint\n+\t * @return\n+\t */\n \tpublic static List<ExportForm.ResolutionAndAlignment> getResolutionAlignmentMap(List<DateContext.Resolution> resolutions, DateContext.Alignment alignmentHint) {\n \n \t\treturn resolutions.stream()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544103614", "bodyText": "Warum handlest du die unterschiedlich? Kann es denn vorkommen, dass du das enum direkt bekommst und nicht den String oder andersrum?", "author": "awildturtok", "createdAt": "2020-12-16T08:28:50Z", "path": "backend/src/main/java/com/bakdata/conquery/models/externalservice/ResultType.java", "diffHunk": "@@ -42,13 +42,13 @@ public String print(PrintSettings cfg, Object f) {\n \n \t\t@Override\n \t\tpublic String print(PrintSettings cfg, Object f) {\n-\t\t\tif (f instanceof DateContextMode) {\n-\t\t\t\treturn ((DateContextMode) f).toString(cfg.getLocale());\n+\t\t\tif (f instanceof DateContext.Resolution) {", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxODExNA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544218114", "bodyText": "Der Fall im TryBlock ist momentan die Regel. Ich hatte das if statement mal hinzugef\u00fcgt, sollten wir eine strengere typisierung haben. Ich werde mal versuchen das If-Statement zum standard zu machen", "author": "thoniTUB", "createdAt": "2020-12-16T11:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIxODQ3NA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544218474", "bodyText": "Okay, ich lasse es", "author": "thoniTUB", "createdAt": "2020-12-16T11:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMzYxNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDQ4Mg==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544104482", "bodyText": "del", "author": "awildturtok", "createdAt": "2020-12-16T08:30:13Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -25,6 +25,7 @@\n import com.fasterxml.jackson.annotation.JsonCreator;\n import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n+import org.apache.commons.lang3.tuple.Pair;", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be68a54f61652ece9762c314a8394cf008299f79", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java b/backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java\nindex 1fcd8e30d..2e51f102a 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java\n\n@@ -25,7 +25,6 @@ import com.bakdata.conquery.models.query.resultinfo.ResultInfoCollector;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import lombok.Getter;\n import lombok.RequiredArgsConstructor;\n-import org.apache.commons.lang3.tuple.Pair;\n \n @Getter\n @CPSType(id=\"ABSOLUTE_FORM_QUERY\", base=QueryDescription.class)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDgxNA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544104814", "bodyText": "JsonIgnore? Oder kann das FE uns das schicken?", "author": "awildturtok", "createdAt": "2020-12-16T08:30:50Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/AbsoluteFormQuery.java", "diffHunk": "@@ -38,7 +39,7 @@\n \t@NotNull @Valid\n \tprivate final ArrayConceptQuery features;\n \t@NotNull\n-\tprivate final List<DateContextMode> resolutions;\n+\tprivate final List<ExportForm.ResolutionAndAlignment> resolutionsAndAlignmentMap;", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwMzE2MQ==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544203161", "bodyText": "Das JupyEnd k\u00f6nnte es schicken, aber es nutzt soweit ich wei\u00df die FormDescription", "author": "thoniTUB", "createdAt": "2020-12-16T10:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwNDgxNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExOTU2MQ==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544119561", "bodyText": "was bedeutet es, dass es an stelle 0 und 1 ist?", "author": "awildturtok", "createdAt": "2020-12-16T08:54:06Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -189,13 +189,13 @@ private boolean hasCompleteDateContexts(List<DateContext> contexts) {\n \t\tif (featurePlan.getAggregatorSize() > 0 && outcomePlan.getAggregatorSize() > 0) {\n \t\t\t// We have features and outcomes check if both have complete date ranges (they should be at the beginning of the list)\n \t\t\treturn contexts.size()>=2\n-\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n-\t\t\t\t&& contexts.get(1).getSubdivisionMode().equals(DateContextMode.COMPLETE)\n+\t\t\t\t&& contexts.get(0).getSubdivisionMode().equals(DateContext.Resolution.COMPLETE)", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NzY0Mw==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544247643", "bodyText": "Das ist leider in implizierter Contract, dass wenn ein COMPLETE Context gefordert ist, diese am Anfang der Context-Liste stehen", "author": "thoniTUB", "createdAt": "2020-12-16T12:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExOTU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "be68a54f61652ece9762c314a8394cf008299f79", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java b/backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java\nindex 990db3417..61a3ecea8 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java\n\n@@ -186,6 +189,9 @@ public class RelativeFormQueryPlan implements QueryPlan {\n \n \n \tprivate boolean hasCompleteDateContexts(List<DateContext> contexts) {\n+\t\tif(contexts.isEmpty()){\n+\t\t\treturn false;\n+\t\t}\n \t\tif (featurePlan.getAggregatorSize() > 0 && outcomePlan.getAggregatorSize() > 0) {\n \t\t\t// We have features and outcomes check if both have complete date ranges (they should be at the beginning of the list)\n \t\t\treturn contexts.size()>=2\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyMDI1Nw==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544120257", "bodyText": "Da fehlt auf jeden Fall Doku", "author": "awildturtok", "createdAt": "2020-12-16T08:55:06Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53aac6b9881ef0b82d2fc8d3e85110977ad50259", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\nindex 3e118f2d6..e62ff513d 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n\n@@ -287,6 +287,17 @@ public class DateContext {\n \t\t};\n \t}\n \n+\t/**\n+\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n+\t * or the outcome date range (after the index). The computed feature and outcome date ranges\n+\t * @param event\n+\t * @param indexPlacement\n+\t * @param featureTime\n+\t * @param outcomeTime\n+\t * @param timeUnit\n+\t * @param resolutionAndAlignment\n+\t * @return\n+\t */\n \tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContext.CalendarUnit timeUnit, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tif (featureTime < 1 && outcomeTime < 1) {\n \t\t\tthrow new IllegalArgumentException(\"Both relative times were smaller than 1 (featureTime: \" + featureTime\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyNDc2MA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544124760", "bodyText": "das                        interessant\n  Formatting ist", "author": "awildturtok", "createdAt": "2020-12-16T09:01:43Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,281 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n-\t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n-\t * @param timeUnit\n-\t * @return\n-\t */\n-\tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContextMode timeUnit, List<DateContextMode> subdivisionModes) {\n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {", "originalCommit": "9861f332a05035e9b60b59a2b61bbf0136730332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI3NzIwMw==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544277203", "bodyText": "Ich habs nur einheitlich gemacht bei allen ;)", "author": "thoniTUB", "createdAt": "2020-12-16T12:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEyNDc2MA=="}], "type": "inlineReview", "revised_code": {"commit": "53aac6b9881ef0b82d2fc8d3e85110977ad50259", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\nindex 3e118f2d6..e62ff513d 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n\n@@ -287,6 +287,17 @@ public class DateContext {\n \t\t};\n \t}\n \n+\t/**\n+\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n+\t * or the outcome date range (after the index). The computed feature and outcome date ranges\n+\t * @param event\n+\t * @param indexPlacement\n+\t * @param featureTime\n+\t * @param outcomeTime\n+\t * @param timeUnit\n+\t * @param resolutionAndAlignment\n+\t * @return\n+\t */\n \tpublic static List<DateContext> generateRelativeContexts(int event, IndexPlacement indexPlacement, int featureTime,\tint outcomeTime, DateContext.CalendarUnit timeUnit, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tif (featureTime < 1 && outcomeTime < 1) {\n \t\t\tthrow new IllegalArgumentException(\"Both relative times were smaller than 1 (featureTime: \" + featureTime\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDExOA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544194118", "bodyText": "das OOB'd wenn aligendSubdivisions empt ist", "author": "awildturtok", "createdAt": "2020-12-16T10:43:32Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));", "originalCommit": "a3ae6f610e1d932579b8731c7d1986df5656cf85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0MzQ5Nw==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544243497", "bodyText": "Danke sehr, gut gesehen", "author": "thoniTUB", "createdAt": "2020-12-16T12:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDExOA=="}], "type": "inlineReview", "revised_code": {"commit": "2e9eb91780bccdaec7646cbab6186ebee51ced76", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\nindex e62ff513d..105ed6c58 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n\n@@ -288,7 +288,7 @@ public class DateContext {\n \t}\n \n \t/**\n-\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n+\t * Generates a list of date contexts around an index date which belong either to a feature date range (before the index)\n \t * or the outcome date range (after the index). The computed feature and outcome date ranges\n \t * @param event\n \t * @param indexPlacement\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NDM2Ng==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544194366", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n          \n          \n            \n            \t * Generates a list of date contexts around an index date which belong either to a feature date range (before the index)", "author": "awildturtok", "createdAt": "2020-12-16T10:43:56Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java", "diffHunk": "@@ -65,100 +69,292 @@\n \t */\n \t@Getter\n \t@Nullable\n-\tprivate DateContextMode subdivisionMode;\n+\tprivate Resolution subdivisionMode;\n \n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, DateContextMode ... subdivisionMode ) {\n-\t\treturn generateAbsoluteContexts(dateRangeMask, Arrays.asList(subdivisionMode));\n-\t}\n-\t\n-\t/**\n-\t * Returns the date ranges that fit into a mask specified as date range, which\n-\t * are optional subdivided in to year-wise or quarter-wise date ranges.\n-\t * If a smaller subdivision mode is chosen, \n-\t *\n-\t * @param dateRangeMask The mask that is applied onto the dates.\n-\t * @param subdivisionModes    The subdivision modes that define the granularity of the\n-\t *                      result.\n-\t * @return All date ranges as wrapped into {@link DateContext} that were in the\n-\t *         mask.\n-\t */\n-\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<DateContextMode> subdivisionModes) {\n+\tpublic static List<DateContext> generateAbsoluteContexts(CDateRange dateRangeMask, List<ExportForm.ResolutionAndAlignment> resolutionAndAlignment) {\n \t\tList<DateContext> dcList = new ArrayList<>();\n \n-\t\tfor (DateContextMode mode : subdivisionModes) {\n+\t\tfor (ExportForm.ResolutionAndAlignment mode : resolutionAndAlignment) {\n+\t\t\tFunction<CDateRange, List<CDateRange>> divider = getDateRangeSubdivider(AlignmentReference.START, mode.getResolution(), mode.getAlignment());\n \t\t\t// Start counting index form 0 for every subdivision mode\n \t\t\tint index = 0;\n-\t\t\tfor (CDateRange quarterInMask : mode.subdivideRange(dateRangeMask)) {\n+\t\t\tfor (CDateRange quarterInMask : divider.apply(dateRangeMask)) {\n \t\t\t\tindex++;\n \t\t\t\tDateContext dc = new DateContext(quarterInMask, FeatureGroup.OUTCOME,\n \t\t\t\t\t// For now there is no index for complete\n-\t\t\t\t\tmode.equals(DateContextMode.COMPLETE) ? null : index, null, mode);\n+\t\t\t\t\tmode.getResolution().equals(Resolution.COMPLETE) ? null : index, null, mode.getResolution());\n \t\t\t\tdcList.add(dc);\n \t\t\t}\n \t\t}\n \t\treturn dcList;\n \t}\n \n+\tpublic static enum AlignmentReference {\n+\t\tSTART(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn alignedSubDivisions;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMinValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(prioInteressingBorder, lastDaterange.getMaxValue());\n+\t\t\t}\n+\t\t},\n+\t\tEND(){\n+\t\t\t@Override\n+\t\t\tpublic List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions) {\n+\t\t\t\treturn Lists.reverse(alignedSubDivisions);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int getInterestingBorder(CDateRange daterange) {\n+\t\t\t\treturn daterange.getMaxValue();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder) {\n+\t\t\t\treturn CDateRange.of(lastDaterange.getMinValue(), prioInteressingBorder);\n+\t\t\t}\n+\t\t};\n+\n+\t\tpublic abstract List<CDateRange> getAlignedIterationDirection(List<CDateRange> alignedSubDivisions);\n+\t\tpublic abstract int getInterestingBorder(CDateRange daterange);\n+\t\tpublic abstract CDateRange makeMergedRange(CDateRange lastDaterange, int prioInteressingBorder);\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Resolution {\n+\t\t/**\n+\t\t * For returning contexts with a single {@link CDateRange} for the entire\n+\t\t * {@link FeatureGroup}.\n+\t\t */\n+\t\tCOMPLETE(null, Map.of(\n+\t\t\t\tAlignment.NO_ALIGN, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).complete();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * years.\n+\t\t */\n+\t\tYEARS(COMPLETE, Map.of(\n+\t\t\t\tAlignment.YEAR, 1,\n+\t\t\t\tAlignment.QUARTER, 4,\n+\t\t\t\tAlignment.DAY, 365)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).year();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * quarters.\n+\t\t */\n+\t\tQUARTERS(YEARS, Map.of(\n+\t\t\t\tAlignment.QUARTER, 1,\n+\t\t\t\tAlignment.DAY, 90)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).quarter();\n+\t\t\t}\n+\t\t},\n+\n+\t\t/**\n+\t\t * The {@link CDateRange} contexts per {@link FeatureGroup} are subdivided into\n+\t\t * days.\n+\t\t */\n+\t\tDAYS(QUARTERS, Map.of(\n+\t\t\t\tAlignment.DAY, 1)) {\n+\t\t\t@Override\n+\t\t\tpublic String toString(Locale locale) {\n+\n+\t\t\t\treturn C10N.get(DateContextResolutionC10n.class, locale).day();\n+\t\t\t}\n+\t\t};\n+\n+\n+\t\t@JsonIgnore\n+\t\tprivate final Resolution coarser;\n+\n+\t\t/**\n+\t\t * Holds which calendar alignments are supported by this resolution and\n+\t\t * the amount of how many of such subdividions fill in this resolusion subdivision.\n+\t\t */\n+\t\t@JsonIgnore\n+\t\tprivate final Map<Alignment, Integer> compatibleAlignmentsAndAmount;\n+\n+\n+\t\tprivate List<Resolution> thisAndCoarserSubdivisions;\n+\n+\t\tpublic abstract String toString(Locale locale);\n+\n+\t\t@JsonIgnore\n+\t\tpublic Collection<Alignment> getSupportedAlignments(){\n+\t\t\treturn compatibleAlignmentsAndAmount.keySet();\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic OptionalInt getAmountForAlignment(Alignment alignment){\n+\t\t\tif (!this.compatibleAlignmentsAndAmount.containsKey(alignment)) {\n+\t\t\t\treturn OptionalInt.empty();\n+\t\t\t}\n+\t\t\treturn OptionalInt.of(this.compatibleAlignmentsAndAmount.get(alignment));\n+\t\t}\n+\n+\t\t@JsonIgnore\n+\t\tpublic List<Resolution> getThisAndCoarserSubdivisions() {\n+\t\t\tif (thisAndCoarserSubdivisions != null) {\n+\t\t\t\treturn thisAndCoarserSubdivisions;\n+\t\t\t}\n+\t\t\tList<Resolution> thisAndCoarser = new ArrayList<>();\n+\t\t\tif (coarser != null) {\n+\t\t\t\tthisAndCoarser.addAll(coarser.getThisAndCoarserSubdivisions());\n+\t\t\t}\n+\t\t\tthisAndCoarser.add(this);\n+\t\t\treturn thisAndCoarserSubdivisions = Collections.unmodifiableList(thisAndCoarser);\n+\n+\t\t}\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum Alignment {\n+\t\tNO_ALIGN(List::of), // Special case for resolution == COMPLETE\n+\t\tDAY(CDateRange::getCoveredDays),\n+\t\tQUARTER(CDateRange::getCoveredQuarters),\n+\t\tYEAR(CDateRange::getCoveredYears);\n+\n+\t\t@Getter @JsonIgnore\n+\t\tprivate final Function<CDateRange,List<CDateRange>> subdivider;\n+\t}\n+\n+\t@RequiredArgsConstructor\n+\tpublic static enum CalendarUnit {\n+\t\tDAYS(Alignment.DAY),\n+\t\tQUARTERS(Alignment.QUARTER),\n+\t\tYEARS(Alignment.YEAR);\n+\n+\t\t@Getter\n+\t\tprivate final Alignment alignment;\n+\t}\n+\n+\tpublic static Function<CDateRange,List<CDateRange>> getDateRangeSubdivider(AlignmentReference alignRef, Resolution resolution, Alignment alignment){\n+\t\tint alignedPerResolution = resolution.getAmountForAlignment(alignment).orElseThrow(() -> new ConqueryError.ExecutionCreationPlanDateContextError(alignment, resolution));\n+\n+\t\tif (alignedPerResolution == 1) {\n+\t\t\t// When the alignment fits the resolution we can use the the alignment subdivision directly\n+\t\t\treturn (dateRange) -> {\n+\t\t\t\treturn alignment.getSubdivider().apply(dateRange);\n+\t\t\t};\n+\t\t}\n+\n+\t\treturn (dateRange) -> {\n+\t\t\tList<CDateRange> result = new ArrayList<>();\n+\t\t\tList<CDateRange> alignedSubdivisions = alignRef.getAlignedIterationDirection(alignment.getSubdivider().apply(dateRange));\n+\n+\t\t\tint alignedSubdivisionCount = 1;\n+\t\t\tint interestingDate = 0;\n+\t\t\tfor (CDateRange alignedSubdivision : alignedSubdivisions) {\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 1) {\n+\t\t\t\t\t// Start a new resolution-sized subdivision\n+\t\t\t\t\tinterestingDate = alignRef.getInterestingBorder(alignedSubdivision);\n+\t\t\t\t}\n+\t\t\t\tif (alignedSubdivisionCount % alignedPerResolution == 0) {\n+\t\t\t\t\t// Finish a resolution-sized subdivision\n+\t\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivision, interestingDate));\n+\t\t\t\t}\n+\t\t\t\talignedSubdivisionCount++;\n+\t\t\t}\n+\n+\t\t\tif (alignedSubdivisionCount % alignedPerResolution != 1) {\n+\t\t\t\t// The loop did not fullfill the resolution-sized subdivision it begun\n+\t\t\t\tresult.add(alignRef.makeMergedRange(alignedSubdivisions.get(alignedSubdivisions.size() - 1), interestingDate));\n+\t\t\t}\n+\n+\t\t\treturn alignRef.getAlignedIterationDirection(result);\n+\t\t};\n+\t}\n+\n \t/**\n-\t * Returns the date ranges that are in the specified range around the event.\n-\t * \n-\t * @param event       The date (as days from epoch day) from which the\n-\t *                    relative range is calculated.\n-\t * @param indexPlacement  Indicates to which {@link FeatureGroup} the range of the\n-\t *                    event belongs.\n-\t * @param featureTime The number of feature timeunit ranges.\n-\t * @param outcomeTime The number of outcome timeunit ranges.\n+\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)", "originalCommit": "a3ae6f610e1d932579b8731c7d1986df5656cf85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e9eb91780bccdaec7646cbab6186ebee51ced76", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\nindex e62ff513d..105ed6c58 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n\n@@ -288,7 +288,7 @@ public class DateContext {\n \t}\n \n \t/**\n-\t * Generates a list of date contexts qround an index date which belong either to a feature date range (before the index)\n+\t * Generates a list of date contexts around an index date which belong either to a feature date range (before the index)\n \t * or the outcome date range (after the index). The computed feature and outcome date ranges\n \t * @param event\n \t * @param indexPlacement\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NTczOA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544195738", "bodyText": "CDateSet ?", "author": "awildturtok", "createdAt": "2020-12-16T10:46:10Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/DateRangeSubDivider.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.bakdata.conquery.models.forms.util;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+public interface DateRangeSubDivider {\n+\n+    List<CDateRange> subdivideRange(CDateRange range);", "originalCommit": "a3ae6f610e1d932579b8731c7d1986df5656cf85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIwNTczOA==", "url": "https://github.com/bakdata/conquery/pull/1505#discussion_r544205738", "bodyText": "Die DateRanges werden letztendlich in DateRestricting Nodes der einzelnen SubQueries gef\u00fcttert. Das w\u00e4re hier nicht sinnvoll eine komplexe Stuktur noch herumzubauen, um sie letztendlich wieder auszupacken.", "author": "thoniTUB", "createdAt": "2020-12-16T11:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE5NTczOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "2e9eb91780bccdaec7646cbab6186ebee51ced76", "url": "https://github.com/bakdata/conquery/commit/2e9eb91780bccdaec7646cbab6186ebee51ced76", "message": "Update backend/src/main/java/com/bakdata/conquery/models/forms/util/DateContext.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-12-16T10:58:03Z", "type": "commit"}, {"oid": "be68a54f61652ece9762c314a8394cf008299f79", "url": "https://github.com/bakdata/conquery/commit/be68a54f61652ece9762c314a8394cf008299f79", "message": "adds more doku", "committedDate": "2020-12-16T12:56:08Z", "type": "commit"}, {"oid": "853c6ab3ae9ca4dba8ed104da9d45749713afcef", "url": "https://github.com/bakdata/conquery/commit/853c6ab3ae9ca4dba8ed104da9d45749713afcef", "message": "automatic update to docs", "committedDate": "2020-12-16T12:58:53Z", "type": "commit"}, {"oid": "92edc71b3b5c70b8a4551a9d566c524795ae0f2c", "url": "https://github.com/bakdata/conquery/commit/92edc71b3b5c70b8a4551a9d566c524795ae0f2c", "message": "Merge branch 'develop' into feature/correct-datacontext-generation\n\n# Conflicts:\n#\tbackend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "committedDate": "2020-12-16T14:08:38Z", "type": "commit"}]}