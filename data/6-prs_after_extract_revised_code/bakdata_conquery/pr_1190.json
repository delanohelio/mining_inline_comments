{"pr_number": 1190, "pr_title": "secondary id improvements", "pr_createdAt": "2020-05-12T17:36:08Z", "pr_url": "https://github.com/bakdata/conquery/pull/1190", "timeline": [{"oid": "b5631ac81459638fd10582e460f793e4e62b1afd", "url": "https://github.com/bakdata/conquery/commit/b5631ac81459638fd10582e460f793e4e62b1afd", "message": "added support to SECONDARY_ID_QUERY queries for tables without secondary\nids", "committedDate": "2020-05-03T22:10:58Z", "type": "commit"}, {"oid": "da078e8751b24fbc073bfe350ec8c22c436e2212", "url": "https://github.com/bakdata/conquery/commit/da078e8751b24fbc073bfe350ec8c22c436e2212", "message": "added secondary id information to REST API", "committedDate": "2020-05-03T22:29:36Z", "type": "commit"}, {"oid": "381defd5c54bdb80668d4642f33a15c039fe2df5", "url": "https://github.com/bakdata/conquery/commit/381defd5c54bdb80668d4642f33a15c039fe2df5", "message": "Merge branch 'develop' into feature/secondary_id_improvements", "committedDate": "2020-05-12T17:36:13Z", "type": "commit"}, {"oid": "97a6ca4b89acfe8cd96a64e3c21d3dd327056c13", "url": "https://github.com/bakdata/conquery/commit/97a6ca4b89acfe8cd96a64e3c21d3dd327056c13", "message": "Merge 381defd5c54bdb80668d4642f33a15c039fe2df5 into 3567834601be40d3e38a5b1ef8293ecc0c41778b", "committedDate": "2020-05-12T17:36:15Z", "type": "commit"}, {"oid": "6b068cbc8c54330e6fb9b53d2847b43c25de3820", "url": "https://github.com/bakdata/conquery/commit/6b068cbc8c54330e6fb9b53d2847b43c25de3820", "message": "automatic update to docs", "committedDate": "2020-05-12T17:38:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc3NjUzNw==", "url": "https://github.com/bakdata/conquery/pull/1190#discussion_r425776537", "bodyText": "Warum nicht die Ids?", "author": "awildturtok", "createdAt": "2020-05-15T12:46:01Z", "path": "backend/src/main/java/com/bakdata/conquery/models/api/description/FERoot.java", "diffHunk": "@@ -12,5 +16,6 @@\n  */\n @Getter\n public class FERoot {\n+\tprivate Set<String> secondaryIds = new HashSet<>();", "originalCommit": "6b068cbc8c54330e6fb9b53d2847b43c25de3820", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc4MjMwNg==", "url": "https://github.com/bakdata/conquery/pull/1190#discussion_r425782306", "bodyText": "Kannst du die tables vorher auf trennen und dann die schleifen machen? Der Code macht schon so viel, da muss das nicht noch mit drin rumschwirren", "author": "awildturtok", "createdAt": "2020-05-15T12:56:26Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java", "diffHunk": "@@ -74,32 +72,24 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\t\treturn EntityResult.notContained();\n \t\t}\n \n+\t\tList<Table> tablesWithoutSecondary = new ArrayList<>();\n+\t\t//first execute only tables with secondaryIds\n \t\tfor(Table currentTable : query.getRequiredTables()) {\n-\t\t\tcurrentSecondaryIdColumn = findSecondaryIdColumn(currentTable);\n-\t\t\tnextTable(ctx, currentTable);\n-\t\t\tfor(Bucket bucket : entity.getBucket(currentTable.getId())) {\n-\t\t\t\tint localEntity = bucket.toLocal(entity.getId());\n-\t\t\t\tAStringType<?> secondaryIdType = (AStringType<?>)currentSecondaryIdColumn.getTypeFor(bucket);\n-\t\t\t\tnextBlock(bucket);\n-\t\t\t\tif(bucket.containsLocalEntity(localEntity)) {\n-\t\t\t\t\tif(isOfInterest(bucket)) {\n-\t\t\t\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n-\t\t\t\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n-\t\t\t\t\t\tfor(int event = start; event < end ; event++) {\n-\t\t\t\t\t\t\t//we ignore events with no value in the secondaryIdColumn\n-\t\t\t\t\t\t\tif(bucket.has(event, currentSecondaryIdColumn)) {\n-\t\t\t\t\t\t\t\tString key = secondaryIdType.getElement(bucket.getString(event, currentSecondaryIdColumn));\n-\t\t\t\t\t\t\t\tchildPerKey\n-\t\t\t\t\t\t\t\t\t.computeIfAbsent(key, k->this.createChild(k, ctx, bucket))\n-\t\t\t\t\t\t\t\t\t.nextEvent(bucket, event);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tColumn secondaryIdColumn = findSecondaryIdColumn(currentTable);", "originalCommit": "6b068cbc8c54330e6fb9b53d2847b43c25de3820", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3fa3727efb1c9234a940671c7afc013cf29bd9bc", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java b/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\nindex 4a20899e1..cc812bcee 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\n\n@@ -66,105 +41,139 @@ public class SecondaryIdQueryPlan implements QueryPlan {\n \t */\n \t@Override\n \tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tif (!query.isOfInterest(entity)) {\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n \t\tquery.checkRequiredTables(ctx.getStorage());\n \t\tquery.init(entity);\n-\t\tif (query.getRequiredTables().isEmpty()) {\n+\n+\t\tif (query.getRequiredTables().get().isEmpty()) {\n \t\t\treturn EntityResult.notContained();\n \t\t}\n \n-\t\tList<Table> tablesWithoutSecondary = new ArrayList<>();\n+\n+\t\tList<TableId> tablesWithoutSecondary = new ArrayList<>();\n \t\t//first execute only tables with secondaryIds\n-\t\tfor(Table currentTable : query.getRequiredTables()) {\n-\t\t\tColumn secondaryIdColumn = findSecondaryIdColumn(currentTable);\n-\t\t\tif(secondaryIdColumn != null) {\n-\t\t\t\texecute(ctx, entity, secondaryIdColumn);\n+\t\tfor (TableId currentTable : query.getRequiredTables().get()) {\n+\t\t\tColumn secondaryIdColumn = findSecondaryIdColumn(currentTable, ctx.getStorage());\n+\t\t\tif (secondaryIdColumn != null) {\n+\t\t\t\texecuteQueriesWithSecondaryId(ctx, entity, secondaryIdColumn);\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttablesWithoutSecondary.add(currentTable);\n \t\t\t}\n \t\t}\n \t\t//afterwards the remaining tables, since we now spawned all children\n-\t\tfor(Table currentTable : tablesWithoutSecondary) {\n-\t\t\texecute(ctx, entity, currentTable);\n+\t\tfor (TableId currentTable : tablesWithoutSecondary) {\n+\t\t\texecuteQueriesWithoutSecondaryId(ctx, entity, currentTable);\n \t\t}\n-\t\t\n-\t\t\n-\t\t\n+\n+\n \t\tvar result = new ArrayList<Object[]>(childPerKey.values().size());\n-\t\tfor(var child:childPerKey.entrySet()) {\n-\t\t\tif(child.getValue().isContained()) {\n+\t\tfor (var child : childPerKey.entrySet()) {\n+\t\t\tif (child.getValue().isContained()) {\n \t\t\t\tresult.add(ArrayUtils.insert(0, child.getValue().result().getValues(), child.getKey()));\n \t\t\t}\n \t\t}\n-\t\tif(result.isEmpty()) {\n+\t\tif (result.isEmpty()) {\n \t\t\treturn EntityResult.notContained();\n \t\t}\n \t\treturn EntityResult.multilineOf(entity.getId(), result);\n \t}\n \n-\tprivate void execute(QueryExecutionContext ctx, Entity entity, Column secondaryIdColumn) {\n+\t/**\n+\t * selects the right column for the given secondaryId from a table\n+\t */\n+\tprivate Column findSecondaryIdColumn(TableId tableId, NamespacedStorage storage) {\n+\t\tfinal Table table = storage.getDataset().getTables().getOrFail(tableId);\n+\n+\t\tfor (Column col : table.getColumns()) {\n+\t\t\tif (!secondaryId.equals(col.getSecondaryId())) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\treturn col;\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\tprivate void executeQueriesWithSecondaryId(QueryExecutionContext ctx, Entity entity, Column secondaryIdColumn) {\n \t\tTable currentTable = secondaryIdColumn.getTable();\n-\t\tnextTable(ctx, currentTable);\n-\t\tfor(Bucket bucket : entity.getBucket(currentTable.getId())) {\n+\t\tnextTable(ctx, currentTable.getId());\n+\t\tfor (Bucket bucket : entity.getBucket(currentTable.getId())) {\n \t\t\tint localEntity = bucket.toLocal(entity.getId());\n-\t\t\tAStringType<?> secondaryIdType = (AStringType<?>)secondaryIdColumn.getTypeFor(bucket);\n+\t\t\tAStringType<?> secondaryIdType = (AStringType<?>) secondaryIdColumn.getTypeFor(bucket);\n \t\t\tnextBlock(bucket);\n-\t\t\tif(bucket.containsLocalEntity(localEntity)) {\n-\t\t\t\tif(isOfInterest(bucket)) {\n-\t\t\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n-\t\t\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n-\t\t\t\t\tfor(int event = start; event < end ; event++) {\n-\t\t\t\t\t\t//we ignore events with no value in the secondaryIdColumn\n-\t\t\t\t\t\tif(bucket.has(event, secondaryIdColumn)) {\n-\t\t\t\t\t\t\tString key = secondaryIdType.getElement(bucket.getString(event, secondaryIdColumn));\n-\t\t\t\t\t\t\tchildPerKey\n-\t\t\t\t\t\t\t\t.computeIfAbsent(key, k->this.createChild(k, secondaryIdColumn, ctx, bucket))\n-\t\t\t\t\t\t\t\t.nextEvent(bucket, event);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\tif (!bucket.containsLocalEntity(localEntity) || !isOfInterest(bucket)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n+\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n+\n+\t\t\tfor (int event = start; event < end; event++) {\n+\t\t\t\t//we ignore events with no value in the secondaryIdColumn\n+\t\t\t\tif (!bucket.has(event, secondaryIdColumn)) {\n+\t\t\t\t\tcontinue;\n \t\t\t\t}\n+\n+\t\t\t\tString key = secondaryIdType.getElement(bucket.getString(event, secondaryIdColumn));\n+\t\t\t\tchildPerKey.computeIfAbsent(key, k -> this.createChild(secondaryIdColumn, ctx, bucket))\n+\t\t\t\t\t\t   .nextEvent(bucket, event);\n \t\t\t}\n \t\t}\n \t}\n-\t\n-\tprivate void execute(QueryExecutionContext ctx, Entity entity, Table currentTable) {\n+\n+\tprivate void executeQueriesWithoutSecondaryId(QueryExecutionContext ctx, Entity entity, TableId currentTable) {\n \t\tnextTable(ctx, currentTable);\n-\t\tfor(Bucket bucket : entity.getBucket(currentTable.getId())) {\n+\t\tfor (Bucket bucket : entity.getBucket(currentTable)) {\n \t\t\tint localEntity = bucket.toLocal(entity.getId());\n \t\t\tnextBlock(bucket);\n-\t\t\tif(bucket.containsLocalEntity(localEntity)) {\n-\t\t\t\tif(isOfInterest(bucket)) {\n-\t\t\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n-\t\t\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n-\t\t\t\t\tfor(int event = start; event < end ; event++) {\n-\t\t\t\t\t\tfor(ConceptQueryPlan child : childPerKey.values()) {\n-\t\t\t\t\t\t\tchild.nextEvent(bucket, event);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\tif (!bucket.containsLocalEntity(localEntity) || !isOfInterest(bucket)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n+\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n+\n+\t\t\tfor (int event = start; event < end; event++) {\n+\t\t\t\tfor (ConceptQueryPlan child : childPerKey.values()) {\n+\t\t\t\t\tchild.nextEvent(bucket, event);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\tprivate boolean isOfInterest(Bucket bucket) {\n-\t\tfor(ConceptQueryPlan c:childPerKey.values()) {\n-\t\t\tc.isOfInterest(bucket);\n+\tprivate void nextTable(QueryExecutionContext ctx, TableId currentTable) {\n+\t\tquery.nextTable(ctx, currentTable);\n+\t\tfor (ConceptQueryPlan c : childPerKey.values()) {\n+\t\t\tc.nextTable(ctx, currentTable);\n \t\t}\n-\t\treturn query.isOfInterest(bucket);\n \t}\n \n \tprivate void nextBlock(Bucket bucket) {\n \t\tquery.nextBlock(bucket);\n-\t\tfor(ConceptQueryPlan c:childPerKey.values()) {\n+\t\tfor (ConceptQueryPlan c : childPerKey.values()) {\n \t\t\tc.nextBlock(bucket);\n \t\t}\n \t}\n \n-\tprivate void nextTable(QueryExecutionContext ctx, Table currentTable) {\n-\t\tquery.nextTable(ctx, currentTable);\n-\t\tfor(ConceptQueryPlan c:childPerKey.values()) {\n-\t\t\tc.nextTable(ctx, currentTable);\n-\t\t}\n+\tprivate boolean isOfInterest(Bucket bucket) {\n+\t\treturn query.isOfInterest(bucket);\n+\t}\n+\n+\t/**\n+\t * if a new distinct secondaryId was found we create a new clone of the ConceptQueryPlan\n+\t * and bring it up to speed\n+\t */\n+\tprivate ConceptQueryPlan createChild(Column secondaryIdColumn, QueryExecutionContext currentContext, Bucket currentBucket) {\n+\t\tConceptQueryPlan plan = query.clone(new CloneContext(currentContext.getStorage()));\n+\t\tplan.init(query.getEntity());\n+\t\tplan.nextTable(currentContext, secondaryIdColumn.getId().getTable());\n+\t\tplan.isOfInterest(currentBucket);\n+\t\tplan.nextBlock(currentBucket);\n+\t\treturn plan;\n \t}\n \n \t@Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTc4MjY2MA==", "url": "https://github.com/bakdata/conquery/pull/1190#discussion_r425782660", "bodyText": "Bitte unterschiedliche namen anstatt overloading", "author": "awildturtok", "createdAt": "2020-05-15T12:57:05Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java", "diffHunk": "@@ -112,6 +102,50 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\treturn EntityResult.multilineOf(entity.getId(), result);\n \t}\n \n+\tprivate void execute(QueryExecutionContext ctx, Entity entity, Column secondaryIdColumn) {", "originalCommit": "6b068cbc8c54330e6fb9b53d2847b43c25de3820", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3fa3727efb1c9234a940671c7afc013cf29bd9bc", "chunk": "diff --git a/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java b/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\nindex 4a20899e1..cc812bcee 100644\n--- a/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\n+++ b/backend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\n\n@@ -66,105 +41,139 @@ public class SecondaryIdQueryPlan implements QueryPlan {\n \t */\n \t@Override\n \tpublic EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n+\t\tif (!query.isOfInterest(entity)) {\n+\t\t\treturn EntityResult.notContained();\n+\t\t}\n+\n \t\tquery.checkRequiredTables(ctx.getStorage());\n \t\tquery.init(entity);\n-\t\tif (query.getRequiredTables().isEmpty()) {\n+\n+\t\tif (query.getRequiredTables().get().isEmpty()) {\n \t\t\treturn EntityResult.notContained();\n \t\t}\n \n-\t\tList<Table> tablesWithoutSecondary = new ArrayList<>();\n+\n+\t\tList<TableId> tablesWithoutSecondary = new ArrayList<>();\n \t\t//first execute only tables with secondaryIds\n-\t\tfor(Table currentTable : query.getRequiredTables()) {\n-\t\t\tColumn secondaryIdColumn = findSecondaryIdColumn(currentTable);\n-\t\t\tif(secondaryIdColumn != null) {\n-\t\t\t\texecute(ctx, entity, secondaryIdColumn);\n+\t\tfor (TableId currentTable : query.getRequiredTables().get()) {\n+\t\t\tColumn secondaryIdColumn = findSecondaryIdColumn(currentTable, ctx.getStorage());\n+\t\t\tif (secondaryIdColumn != null) {\n+\t\t\t\texecuteQueriesWithSecondaryId(ctx, entity, secondaryIdColumn);\n \t\t\t}\n \t\t\telse {\n \t\t\t\ttablesWithoutSecondary.add(currentTable);\n \t\t\t}\n \t\t}\n \t\t//afterwards the remaining tables, since we now spawned all children\n-\t\tfor(Table currentTable : tablesWithoutSecondary) {\n-\t\t\texecute(ctx, entity, currentTable);\n+\t\tfor (TableId currentTable : tablesWithoutSecondary) {\n+\t\t\texecuteQueriesWithoutSecondaryId(ctx, entity, currentTable);\n \t\t}\n-\t\t\n-\t\t\n-\t\t\n+\n+\n \t\tvar result = new ArrayList<Object[]>(childPerKey.values().size());\n-\t\tfor(var child:childPerKey.entrySet()) {\n-\t\t\tif(child.getValue().isContained()) {\n+\t\tfor (var child : childPerKey.entrySet()) {\n+\t\t\tif (child.getValue().isContained()) {\n \t\t\t\tresult.add(ArrayUtils.insert(0, child.getValue().result().getValues(), child.getKey()));\n \t\t\t}\n \t\t}\n-\t\tif(result.isEmpty()) {\n+\t\tif (result.isEmpty()) {\n \t\t\treturn EntityResult.notContained();\n \t\t}\n \t\treturn EntityResult.multilineOf(entity.getId(), result);\n \t}\n \n-\tprivate void execute(QueryExecutionContext ctx, Entity entity, Column secondaryIdColumn) {\n+\t/**\n+\t * selects the right column for the given secondaryId from a table\n+\t */\n+\tprivate Column findSecondaryIdColumn(TableId tableId, NamespacedStorage storage) {\n+\t\tfinal Table table = storage.getDataset().getTables().getOrFail(tableId);\n+\n+\t\tfor (Column col : table.getColumns()) {\n+\t\t\tif (!secondaryId.equals(col.getSecondaryId())) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\treturn col;\n+\t\t}\n+\n+\t\treturn null;\n+\t}\n+\n+\tprivate void executeQueriesWithSecondaryId(QueryExecutionContext ctx, Entity entity, Column secondaryIdColumn) {\n \t\tTable currentTable = secondaryIdColumn.getTable();\n-\t\tnextTable(ctx, currentTable);\n-\t\tfor(Bucket bucket : entity.getBucket(currentTable.getId())) {\n+\t\tnextTable(ctx, currentTable.getId());\n+\t\tfor (Bucket bucket : entity.getBucket(currentTable.getId())) {\n \t\t\tint localEntity = bucket.toLocal(entity.getId());\n-\t\t\tAStringType<?> secondaryIdType = (AStringType<?>)secondaryIdColumn.getTypeFor(bucket);\n+\t\t\tAStringType<?> secondaryIdType = (AStringType<?>) secondaryIdColumn.getTypeFor(bucket);\n \t\t\tnextBlock(bucket);\n-\t\t\tif(bucket.containsLocalEntity(localEntity)) {\n-\t\t\t\tif(isOfInterest(bucket)) {\n-\t\t\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n-\t\t\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n-\t\t\t\t\tfor(int event = start; event < end ; event++) {\n-\t\t\t\t\t\t//we ignore events with no value in the secondaryIdColumn\n-\t\t\t\t\t\tif(bucket.has(event, secondaryIdColumn)) {\n-\t\t\t\t\t\t\tString key = secondaryIdType.getElement(bucket.getString(event, secondaryIdColumn));\n-\t\t\t\t\t\t\tchildPerKey\n-\t\t\t\t\t\t\t\t.computeIfAbsent(key, k->this.createChild(k, secondaryIdColumn, ctx, bucket))\n-\t\t\t\t\t\t\t\t.nextEvent(bucket, event);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\tif (!bucket.containsLocalEntity(localEntity) || !isOfInterest(bucket)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n+\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n+\n+\t\t\tfor (int event = start; event < end; event++) {\n+\t\t\t\t//we ignore events with no value in the secondaryIdColumn\n+\t\t\t\tif (!bucket.has(event, secondaryIdColumn)) {\n+\t\t\t\t\tcontinue;\n \t\t\t\t}\n+\n+\t\t\t\tString key = secondaryIdType.getElement(bucket.getString(event, secondaryIdColumn));\n+\t\t\t\tchildPerKey.computeIfAbsent(key, k -> this.createChild(secondaryIdColumn, ctx, bucket))\n+\t\t\t\t\t\t   .nextEvent(bucket, event);\n \t\t\t}\n \t\t}\n \t}\n-\t\n-\tprivate void execute(QueryExecutionContext ctx, Entity entity, Table currentTable) {\n+\n+\tprivate void executeQueriesWithoutSecondaryId(QueryExecutionContext ctx, Entity entity, TableId currentTable) {\n \t\tnextTable(ctx, currentTable);\n-\t\tfor(Bucket bucket : entity.getBucket(currentTable.getId())) {\n+\t\tfor (Bucket bucket : entity.getBucket(currentTable)) {\n \t\t\tint localEntity = bucket.toLocal(entity.getId());\n \t\t\tnextBlock(bucket);\n-\t\t\tif(bucket.containsLocalEntity(localEntity)) {\n-\t\t\t\tif(isOfInterest(bucket)) {\n-\t\t\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n-\t\t\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n-\t\t\t\t\tfor(int event = start; event < end ; event++) {\n-\t\t\t\t\t\tfor(ConceptQueryPlan child : childPerKey.values()) {\n-\t\t\t\t\t\t\tchild.nextEvent(bucket, event);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\tif (!bucket.containsLocalEntity(localEntity) || !isOfInterest(bucket)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tint start = bucket.getFirstEventOfLocal(localEntity);\n+\t\t\tint end = bucket.getLastEventOfLocal(localEntity);\n+\n+\t\t\tfor (int event = start; event < end; event++) {\n+\t\t\t\tfor (ConceptQueryPlan child : childPerKey.values()) {\n+\t\t\t\t\tchild.nextEvent(bucket, event);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n \n-\tprivate boolean isOfInterest(Bucket bucket) {\n-\t\tfor(ConceptQueryPlan c:childPerKey.values()) {\n-\t\t\tc.isOfInterest(bucket);\n+\tprivate void nextTable(QueryExecutionContext ctx, TableId currentTable) {\n+\t\tquery.nextTable(ctx, currentTable);\n+\t\tfor (ConceptQueryPlan c : childPerKey.values()) {\n+\t\t\tc.nextTable(ctx, currentTable);\n \t\t}\n-\t\treturn query.isOfInterest(bucket);\n \t}\n \n \tprivate void nextBlock(Bucket bucket) {\n \t\tquery.nextBlock(bucket);\n-\t\tfor(ConceptQueryPlan c:childPerKey.values()) {\n+\t\tfor (ConceptQueryPlan c : childPerKey.values()) {\n \t\t\tc.nextBlock(bucket);\n \t\t}\n \t}\n \n-\tprivate void nextTable(QueryExecutionContext ctx, Table currentTable) {\n-\t\tquery.nextTable(ctx, currentTable);\n-\t\tfor(ConceptQueryPlan c:childPerKey.values()) {\n-\t\t\tc.nextTable(ctx, currentTable);\n-\t\t}\n+\tprivate boolean isOfInterest(Bucket bucket) {\n+\t\treturn query.isOfInterest(bucket);\n+\t}\n+\n+\t/**\n+\t * if a new distinct secondaryId was found we create a new clone of the ConceptQueryPlan\n+\t * and bring it up to speed\n+\t */\n+\tprivate ConceptQueryPlan createChild(Column secondaryIdColumn, QueryExecutionContext currentContext, Bucket currentBucket) {\n+\t\tConceptQueryPlan plan = query.clone(new CloneContext(currentContext.getStorage()));\n+\t\tplan.init(query.getEntity());\n+\t\tplan.nextTable(currentContext, secondaryIdColumn.getId().getTable());\n+\t\tplan.isOfInterest(currentBucket);\n+\t\tplan.nextBlock(currentBucket);\n+\t\treturn plan;\n \t}\n \n \t@Override\n"}}, {"oid": "3fa3727efb1c9234a940671c7afc013cf29bd9bc", "url": "https://github.com/bakdata/conquery/commit/3fa3727efb1c9234a940671c7afc013cf29bd9bc", "message": "Merge remote-tracking branch 'origin/develop' into feature/secondary_id_improvements\n\n# Conflicts:\n#\tbackend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java", "committedDate": "2020-09-30T12:39:33Z", "type": "commit"}, {"oid": "0b9358e318581706270aa5a02951f2c5a09ba0df", "url": "https://github.com/bakdata/conquery/commit/0b9358e318581706270aa5a02951f2c5a09ba0df", "message": "automatic update to docs", "committedDate": "2020-09-30T12:42:02Z", "type": "commit"}, {"oid": "f4926dd24dc011e3adddb3c0f553f03c32c5c8a1", "url": "https://github.com/bakdata/conquery/commit/f4926dd24dc011e3adddb3c0f553f03c32c5c8a1", "message": "fix table of columns", "committedDate": "2020-10-01T12:47:15Z", "type": "commit"}, {"oid": "19593d07950b9501fb057d07a57d87a4a66b69ef", "url": "https://github.com/bakdata/conquery/commit/19593d07950b9501fb057d07a57d87a4a66b69ef", "message": "Merge remote-tracking branch 'origin/develop' into feature/secondary_id_improvements\n\n# Conflicts:\n#\tbackend/src/main/java/com/bakdata/conquery/models/query/queryplan/SecondaryIdQueryPlan.java\n#\tdocs/Concept JSONs.md", "committedDate": "2020-10-01T14:19:25Z", "type": "commit"}, {"oid": "e18f2299c1eb1fa27b956b3800f24d015bbcb1ed", "url": "https://github.com/bakdata/conquery/commit/e18f2299c1eb1fa27b956b3800f24d015bbcb1ed", "message": "automatic update to docs", "committedDate": "2020-10-01T14:21:34Z", "type": "commit"}, {"oid": "91b4d30f942371c44433d3540ea718f18ffd6b2b", "url": "https://github.com/bakdata/conquery/commit/91b4d30f942371c44433d3540ea718f18ffd6b2b", "message": "fix execution order", "committedDate": "2020-10-01T14:37:26Z", "type": "commit"}, {"oid": "f89c048c46a6cad055832b7ac98fdff796fb61ee", "url": "https://github.com/bakdata/conquery/commit/f89c048c46a6cad055832b7ac98fdff796fb61ee", "message": "Merge branch 'develop' into feature/secondary_id_improvements", "committedDate": "2020-10-07T14:58:42Z", "type": "commit"}]}