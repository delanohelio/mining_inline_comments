{"pr_number": 4695, "pr_title": "[Timelock Partitioning] Allow Switching to Batched Single Leader", "pr_createdAt": "2020-04-02T19:46:45Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4695", "timeline": [{"oid": "35f361d365dfe9257ca0d6f469309e7180badc5f", "url": "https://github.com/palantir/atlasdb/commit/35f361d365dfe9257ca0d6f469309e7180badc5f", "message": "Wip", "committedDate": "2020-04-02T16:25:51Z", "type": "commit"}, {"oid": "f2249c8e1195b581317302c447500c5c4bfb3837", "url": "https://github.com/palantir/atlasdb/commit/f2249c8e1195b581317302c447500c5c4bfb3837", "message": "Refactor", "committedDate": "2020-04-02T16:30:43Z", "type": "commit"}, {"oid": "77f26eb4cf4eb1937911b4a13716136dd77b22ef", "url": "https://github.com/palantir/atlasdb/commit/77f26eb4cf4eb1937911b4a13716136dd77b22ef", "message": "Add file", "committedDate": "2020-04-02T16:31:36Z", "type": "commit"}, {"oid": "ca200850c96d12511f0f426d77e8b5b8abc50d9d", "url": "https://github.com/palantir/atlasdb/commit/ca200850c96d12511f0f426d77e8b5b8abc50d9d", "message": "Add tests", "committedDate": "2020-04-02T17:13:38Z", "type": "commit"}, {"oid": "f2d693784bad9bfd06f616fe852de57c07662efb", "url": "https://github.com/palantir/atlasdb/commit/f2d693784bad9bfd06f616fe852de57c07662efb", "message": "Fix tests and some small nits:", "committedDate": "2020-04-02T19:46:36Z", "type": "commit"}, {"oid": "2aaebee4d2ab0ffc623a4b214451c2e9d0b0cdaf", "url": "https://github.com/palantir/atlasdb/commit/2aaebee4d2ab0ffc623a4b214451c2e9d0b0cdaf", "message": "Fix other template", "committedDate": "2020-04-03T09:48:42Z", "type": "commit"}, {"oid": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "url": "https://github.com/palantir/atlasdb/commit/882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "message": "Add generated changelog entries", "committedDate": "2020-04-03T09:48:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDQ1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404970457", "bodyText": "uncertain: Might be better to use primitive BooleanSupplier, though I wouldn't block if you need Supplier<T> for something down the line.", "author": "jeremyk-91", "createdAt": "2020-04-07T17:04:01Z", "path": "timelock-agent/src/main/java/com/palantir/atlasdb/timelock/paxos/SingleLeaderNetworkClientFactories.java", "diffHunk": "@@ -26,21 +27,25 @@\n import com.palantir.paxos.PaxosLearnerNetworkClient;\n import com.palantir.paxos.SingleLeaderAcceptorNetworkClient;\n import com.palantir.paxos.SingleLeaderLearnerNetworkClient;\n-import com.palantir.timelock.paxos.TimelockPaxosAcceptorAdapter;\n-import com.palantir.timelock.paxos.TimelockPaxosLearnerAdapter;\n+import com.palantir.timelock.paxos.TimelockPaxosAcceptorAdapters;\n+import com.palantir.timelock.paxos.TimelockPaxosLearnerAdapters;\n \n @Value.Immutable\n abstract class SingleLeaderNetworkClientFactories implements\n         NetworkClientFactories, Dependencies.NetworkClientFactories {\n \n+    @Value.Default\n+    Supplier<Boolean> useBatchedEndpoints() {", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkxMzIwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r408913205", "bodyText": "PredicateSwitchedProxy uses Supplier<Boolean> so just more consistent", "author": "gmaretic", "createdAt": "2020-04-15T15:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDQ1Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3Nzc1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404977751", "bodyText": "Let's use an AtomicLong and accumulateAndGet: not wrong because of how it's used, but there could be unwanted race conditions", "author": "jeremyk-91", "createdAt": "2020-04-07T17:15:11Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.atlasdb.timelock.paxos.WithSeq;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosValue;\n+\n+public class BatchTimelockPaxosLearnerAdapter implements PaxosLearner {\n+    private final PaxosUseCase paxosUseCase;\n+    private final Client client;\n+    private final BatchPaxosLearnerRpcClient rpcClient;\n+\n+    private volatile long lastKnownSequence = Long.MIN_VALUE;\n+\n+    public BatchTimelockPaxosLearnerAdapter(\n+            PaxosUseCase paxosUseCase,\n+            Client client,\n+            BatchPaxosLearnerRpcClient rpcClient) {\n+        this.paxosUseCase = paxosUseCase;\n+        this.client = client;\n+        this.rpcClient = rpcClient;\n+    }\n+\n+    public static PaxosLearner singleLeader(BatchPaxosLearnerRpcClient rpcClient) {\n+        return new BatchTimelockPaxosLearnerAdapter(\n+                PaxosUseCase.LEADER_FOR_ALL_CLIENTS,\n+                PaxosUseCase.PSEUDO_LEADERSHIP_CLIENT,\n+                rpcClient);\n+    }\n+\n+    @Override\n+    public void learn(long seq, PaxosValue val) {\n+        rpcClient.learn(paxosUseCase, ImmutableSetMultimap.of(client, val));\n+        updateLastKnownSequence(seq);\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getLearnedValue(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValues(paxosUseCase, ImmutableSet.of(WithSeq.of(client, seq)))\n+                .get(client);\n+        checkResult(result);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        updateLastKnownSequence(seq);\n+        return Optional.of(Iterables.getOnlyElement(result));\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getGreatestLearnedValue() {\n+        Set<PaxosValue> result = rpcClient\n+                .getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, lastKnownSequence))\n+                .get(client);\n+        Optional<PaxosValue> greatestIfExists = result.stream()\n+                .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);\n+        greatestIfExists.ifPresent(paxosValue -> updateLastKnownSequence(paxosValue.getRound()));\n+        return greatestIfExists;\n+    }\n+\n+    @Override\n+    public Collection<PaxosValue> getLearnedValuesSince(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, seq))\n+                .get(client);\n+        result.stream().map(PaxosValue::getRound).mapToLong(x -> x).max().ifPresent(this::updateLastKnownSequence);\n+        return result;\n+    }\n+\n+    private <T> void checkResult(Set<T> result) {\n+        Preconditions.checkState(result.size() <= 1,\n+                \"Unexpected result {} in a call for client {}.\",\n+                SafeArg.of(\"result\", result),\n+                SafeArg.of(\"client\", client));\n+    }\n+\n+    private void updateLastKnownSequence(long seq) {\n+        if (seq > lastKnownSequence) {\n+            lastKnownSequence = seq;\n+        }", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c1df9987b4512160b021b4e6fb7a7553893d081", "chunk": "diff --git a/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java b/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\nindex 017c1933eb..f1afc0b6e7 100644\n--- a/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\n+++ b/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\n\n@@ -17,8 +17,10 @@\n package com.palantir.timelock.paxos;\n \n import java.util.Collection;\n+import java.util.Comparator;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3OTkxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404979911", "bodyText": "Nice! Many ways to go about this, and looks like you picked the one that touches the volatile/atomic thing as little as possible.", "author": "jeremyk-91", "createdAt": "2020-04-07T17:18:44Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.atlasdb.timelock.paxos.WithSeq;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosValue;\n+\n+public class BatchTimelockPaxosLearnerAdapter implements PaxosLearner {\n+    private final PaxosUseCase paxosUseCase;\n+    private final Client client;\n+    private final BatchPaxosLearnerRpcClient rpcClient;\n+\n+    private volatile long lastKnownSequence = Long.MIN_VALUE;\n+\n+    public BatchTimelockPaxosLearnerAdapter(\n+            PaxosUseCase paxosUseCase,\n+            Client client,\n+            BatchPaxosLearnerRpcClient rpcClient) {\n+        this.paxosUseCase = paxosUseCase;\n+        this.client = client;\n+        this.rpcClient = rpcClient;\n+    }\n+\n+    public static PaxosLearner singleLeader(BatchPaxosLearnerRpcClient rpcClient) {\n+        return new BatchTimelockPaxosLearnerAdapter(\n+                PaxosUseCase.LEADER_FOR_ALL_CLIENTS,\n+                PaxosUseCase.PSEUDO_LEADERSHIP_CLIENT,\n+                rpcClient);\n+    }\n+\n+    @Override\n+    public void learn(long seq, PaxosValue val) {\n+        rpcClient.learn(paxosUseCase, ImmutableSetMultimap.of(client, val));\n+        updateLastKnownSequence(seq);\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getLearnedValue(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValues(paxosUseCase, ImmutableSet.of(WithSeq.of(client, seq)))\n+                .get(client);\n+        checkResult(result);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        updateLastKnownSequence(seq);\n+        return Optional.of(Iterables.getOnlyElement(result));\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getGreatestLearnedValue() {\n+        Set<PaxosValue> result = rpcClient\n+                .getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, lastKnownSequence))\n+                .get(client);\n+        Optional<PaxosValue> greatestIfExists = result.stream()\n+                .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);\n+        greatestIfExists.ifPresent(paxosValue -> updateLastKnownSequence(paxosValue.getRound()));\n+        return greatestIfExists;\n+    }\n+\n+    @Override\n+    public Collection<PaxosValue> getLearnedValuesSince(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, seq))\n+                .get(client);\n+        result.stream().map(PaxosValue::getRound).mapToLong(x -> x).max().ifPresent(this::updateLastKnownSequence);", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c1df9987b4512160b021b4e6fb7a7553893d081", "chunk": "diff --git a/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java b/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\nindex 017c1933eb..f1afc0b6e7 100644\n--- a/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\n+++ b/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\n\n@@ -17,8 +17,10 @@\n package com.palantir.timelock.paxos;\n \n import java.util.Collection;\n+import java.util.Comparator;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4MDk1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404980953", "bodyText": "Equivalent, but I think I like the readability of this better:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);\n          \n          \n            \n                            .max(Comparator.comparingLong(PaxosValue::getRound));", "author": "jeremyk-91", "createdAt": "2020-04-07T17:20:23Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.atlasdb.timelock.paxos.WithSeq;\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.paxos.PaxosLearner;\n+import com.palantir.paxos.PaxosValue;\n+\n+public class BatchTimelockPaxosLearnerAdapter implements PaxosLearner {\n+    private final PaxosUseCase paxosUseCase;\n+    private final Client client;\n+    private final BatchPaxosLearnerRpcClient rpcClient;\n+\n+    private volatile long lastKnownSequence = Long.MIN_VALUE;\n+\n+    public BatchTimelockPaxosLearnerAdapter(\n+            PaxosUseCase paxosUseCase,\n+            Client client,\n+            BatchPaxosLearnerRpcClient rpcClient) {\n+        this.paxosUseCase = paxosUseCase;\n+        this.client = client;\n+        this.rpcClient = rpcClient;\n+    }\n+\n+    public static PaxosLearner singleLeader(BatchPaxosLearnerRpcClient rpcClient) {\n+        return new BatchTimelockPaxosLearnerAdapter(\n+                PaxosUseCase.LEADER_FOR_ALL_CLIENTS,\n+                PaxosUseCase.PSEUDO_LEADERSHIP_CLIENT,\n+                rpcClient);\n+    }\n+\n+    @Override\n+    public void learn(long seq, PaxosValue val) {\n+        rpcClient.learn(paxosUseCase, ImmutableSetMultimap.of(client, val));\n+        updateLastKnownSequence(seq);\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getLearnedValue(long seq) {\n+        Set<PaxosValue> result = rpcClient.getLearnedValues(paxosUseCase, ImmutableSet.of(WithSeq.of(client, seq)))\n+                .get(client);\n+        checkResult(result);\n+        if (result.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        updateLastKnownSequence(seq);\n+        return Optional.of(Iterables.getOnlyElement(result));\n+    }\n+\n+    @Override\n+    public Optional<PaxosValue> getGreatestLearnedValue() {\n+        Set<PaxosValue> result = rpcClient\n+                .getLearnedValuesSince(paxosUseCase, ImmutableMap.of(client, lastKnownSequence))\n+                .get(client);\n+        Optional<PaxosValue> greatestIfExists = result.stream()\n+                .reduce((fst, snd) -> fst.getRound() > snd.getRound() ? fst : snd);", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c1df9987b4512160b021b4e6fb7a7553893d081", "chunk": "diff --git a/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java b/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\nindex 017c1933eb..f1afc0b6e7 100644\n--- a/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\n+++ b/timelock-agent/src/main/java/com/palantir/timelock/paxos/BatchTimelockPaxosLearnerAdapter.java\n\n@@ -17,8 +17,10 @@\n package com.palantir.timelock.paxos;\n \n import java.util.Collection;\n+import java.util.Comparator;\n import java.util.Optional;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.ImmutableSet;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NjQzMg==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404986432", "bodyText": "Discussed offline: Here, iteration order is very important. It's essential that we go through these in the same order - and while these are both lists, there is an underlying set and technically no guarantee that the iteration order is consistent. Thus, I'd suggest making PaxosResourcesFactory#remoteUris return a list rather than a set.", "author": "jeremyk-91", "createdAt": "2020-04-07T17:28:53Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimelockPaxosAcceptorAdapters.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.Streams;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosAcceptorRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosRemoteClients;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.common.proxy.PredicateSwitchedProxy;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+import com.palantir.paxos.PaxosAcceptor;\n+\n+public final class TimelockPaxosAcceptorAdapters {\n+    private TimelockPaxosAcceptorAdapters() {\n+        // pl0x n0\n+    }\n+\n+    public static List<PaxosAcceptor> create(\n+            PaxosUseCase paxosUseCase,\n+            PaxosRemoteClients remoteClients,\n+            Supplier<Boolean> useBatchedSingleLeader,\n+            Client client) {\n+        switch (paxosUseCase) {\n+            case LEADER_FOR_ALL_CLIENTS:\n+                return Streams.zip(\n+                        remoteClients.batchAcceptor().stream(),\n+                        remoteClients.singleLeaderAcceptor().stream(),", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4Nzg1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404987859", "bodyText": "\ud83d\udcaf", "author": "jeremyk-91", "createdAt": "2020-04-07T17:31:01Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/paxos/TimelockPaxosLearnerAdapters.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.paxos;\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.collect.Streams;\n+import com.palantir.atlasdb.timelock.paxos.BatchPaxosLearnerRpcClient;\n+import com.palantir.atlasdb.timelock.paxos.Client;\n+import com.palantir.atlasdb.timelock.paxos.PaxosRemoteClients;\n+import com.palantir.atlasdb.timelock.paxos.PaxosUseCase;\n+import com.palantir.common.proxy.PredicateSwitchedProxy;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+import com.palantir.paxos.PaxosLearner;\n+\n+public final class TimelockPaxosLearnerAdapters {\n+    private TimelockPaxosLearnerAdapters() {\n+        // how many times", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5MDU0OA==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r404990548", "bodyText": "These should be 9086 and 9092, just because of wiremock we might actually use six ports, not three.", "author": "jeremyk-91", "createdAt": "2020-04-07T17:35:13Z", "path": "timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/suite/SingleLeaderPaxosSuite.java", "diffHunk": "@@ -43,20 +43,29 @@\n             \"non-batched timestamp paxos single leader\",\n             \"paxosMultiServer.ftl\",\n             generateThreeNodeTimelockCluster(9080, builder ->\n-                    builder.clientPaxosBuilder(builder.clientPaxosBuilder().isUseBatchPaxos(false))\n+                    builder.clientPaxosBuilder(builder.clientPaxosBuilder().isUseBatchPaxosTimestamp(false))\n                             .leaderMode(PaxosLeaderMode.SINGLE_LEADER)));\n \n     public static final TestableTimelockCluster BATCHED_TIMESTAMP_PAXOS = new TestableTimelockCluster(\n             \"batched timestamp paxos single leader\",\n             \"paxosMultiServer.ftl\",\n             generateThreeNodeTimelockCluster(9083, builder ->", "originalCommit": "882c1172abb5fe0c30dfe26cd9e1a1f9ba2911fe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c1df9987b4512160b021b4e6fb7a7553893d081", "chunk": "diff --git a/timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/suite/SingleLeaderPaxosSuite.java b/timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/suite/SingleLeaderPaxosSuite.java\nindex c4d52e2122..cc51ce39db 100644\n--- a/timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/suite/SingleLeaderPaxosSuite.java\n+++ b/timelock-server/src/suiteTest/java/com/palantir/atlasdb/timelock/suite/SingleLeaderPaxosSuite.java\n\n@@ -49,7 +49,7 @@ public final class SingleLeaderPaxosSuite {\n     public static final TestableTimelockCluster BATCHED_TIMESTAMP_PAXOS = new TestableTimelockCluster(\n             \"batched timestamp paxos single leader\",\n             \"paxosMultiServer.ftl\",\n-            generateThreeNodeTimelockCluster(9083, builder ->\n+            generateThreeNodeTimelockCluster(9086, builder ->\n                     builder.clientPaxosBuilder(\n                             builder.clientPaxosBuilder().isUseBatchPaxosTimestamp(true))\n                             .leaderMode(PaxosLeaderMode.SINGLE_LEADER)));\n"}}, {"oid": "5c1df9987b4512160b021b4e6fb7a7553893d081", "url": "https://github.com/palantir/atlasdb/commit/5c1df9987b4512160b021b4e6fb7a7553893d081", "message": "Address CR", "committedDate": "2020-04-15T15:26:07Z", "type": "commit"}, {"oid": "0fbd9073e2ae4f46f972e5d6ee536e32c74f0af2", "url": "https://github.com/palantir/atlasdb/commit/0fbd9073e2ae4f46f972e5d6ee536e32c74f0af2", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into tp/allow-bsl", "committedDate": "2020-04-15T15:26:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNDU1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4695#discussion_r409024552", "bodyText": "I would have thought containsExactly (without the inAnyOrder bit) would have been enough?", "author": "jeremyk-91", "createdAt": "2020-04-15T17:49:09Z", "path": "timelock-agent/src/test/java/com/palantir/timelock/paxos/PaxosRemotingUtilsTest.java", "diffHunk": "@@ -141,14 +136,14 @@ public void addProtocolAddsHttpsIfSslPresent() {\n \n     @Test\n     public void addProtocolsAddsHttpIfSslNotPresent() {\n-        assertThat(PaxosRemotingUtils.addProtocols(NO_SSL_TIMELOCK, ImmutableSet.of(\"foo:1\", \"bar:2\")))\n-                .containsExactlyInAnyOrder(\"http://foo:1\", \"http://bar:2\");\n+        assertThat(PaxosRemotingUtils.addProtocols(NO_SSL_TIMELOCK, ImmutableList.of(\"foo:1\", \"bar:2\")))\n+                .isEqualTo(ImmutableList.of(\"http://foo:1\", \"http://bar:2\"));\n     }\n \n     @Test\n     public void addProtocolsAddsHttpsIfSslPresent() {\n-        assertThat(PaxosRemotingUtils.addProtocols(SSL_TIMELOCK, ImmutableSet.of(\"foo:1\", \"bar:2\")))\n-                .containsExactlyInAnyOrder(\"https://foo:1\", \"https://bar:2\");\n+        assertThat(PaxosRemotingUtils.addProtocols(SSL_TIMELOCK, ImmutableList.of(\"foo:1\", \"bar:2\")))\n+                .isEqualTo(ImmutableList.of(\"https://foo:1\", \"https://bar:2\"));", "originalCommit": "5c1df9987b4512160b021b4e6fb7a7553893d081", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}