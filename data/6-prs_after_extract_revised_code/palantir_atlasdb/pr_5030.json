{"pr_number": 5030, "pr_title": "[DB TimeLock] 3C.3 - getAllNamespaces() / MultiSequenceTimestampSeriesProvider", "pr_createdAt": "2020-10-14T10:43:00Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5030", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NTQ1Ng==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504845456", "bodyText": "Can we add tests for both these conditions above?", "author": "sudiksha27", "createdAt": "2020-10-14T17:20:24Z", "path": "timelock-agent/src/main/java/com/palantir/timelock/ServiceDiscoveringDatabaseTimeLockSupplier.java", "diffHunk": "@@ -64,10 +68,21 @@ public void close() {\n     }\n \n     public synchronized ManagedTimestampService getManagedTimestampService(DbTimestampCreationSetting setting) {\n+        Preconditions.checkState(\n+                DbTimestampCreationSettings.caseOf(setting)\n+                .multipleSeries((tableReference, series) ->\n+                        tableReference.equals(AtlasDbConstants.DB_TIMELOCK_TIMESTAMP_TABLE))\n+                .otherwise_(false),\n+                \"Attempted to create a managed timestamp service in db timelock that was not the normal db timelock\"\n+                        + \" timestamp table! This is unexpected, and we are prohibiting this creation for safety.\",\n+                SafeArg.of(\"setting\", setting));\n         return timestampServiceFactory.apply(setting);\n     }\n \n-    public synchronized TimestampSeriesProvider getTimestampSeriesProvider() {\n-        return timestampSeriesProvider;\n+    public synchronized TimestampSeriesProvider getTimestampSeriesProvider(TableReference tableReference) {\n+        Preconditions.checkState(tableReference.equals(AtlasDbConstants.DB_TIMELOCK_TIMESTAMP_TABLE),\n+                \"Attempted to create a timestamp series provider in db timelock that was not the normal db timelock\"\n+                        + \" timestamp table! This is unexpected, and we are prohibiting this creation for safety.\");\n+        return timestampSeriesProvider.apply(tableReference);", "originalCommit": "faafc8e388b437e69bf1aca07a67ed20a38406c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NDQ2Nw==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504944467", "bodyText": "Will do!", "author": "jeremyk-91", "createdAt": "2020-10-14T20:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NTQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NDk1MQ==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504944951", "bodyText": "will add, yeah admittedly the testing of error cases on this pr was a bit weak", "author": "jeremyk-91", "createdAt": "2020-10-14T20:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg0NTQ1Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1NDg5OQ==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504854899", "bodyText": "Might be hard to write but would be good to have tests for this.", "author": "sudiksha27", "createdAt": "2020-10-14T17:36:05Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/timestamp/MultiSequenceTimestampSeriesProvider.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.keyvalue.dbkvs.timestamp;\n+\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.Set;\n+\n+import org.apache.commons.dbutils.QueryRunner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableSet;\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeries;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeriesProvider;\n+import com.palantir.atlasdb.keyvalue.dbkvs.impl.ConnectionManagerAwareDbKvs;\n+import com.palantir.exception.PalantirSqlException;\n+import com.palantir.nexus.db.pool.ConnectionManager;\n+\n+/**\n+ * Reads all of the series from a timestamp table written to by timestamp bound stores using the\n+ * {@link MultiSequencePhysicalBoundStoreStrategy} strategy.\n+ */\n+public final class MultiSequenceTimestampSeriesProvider implements TimestampSeriesProvider {\n+    private static final Logger log = LoggerFactory.getLogger(MultiSequenceTimestampSeriesProvider.class);\n+\n+    private final ConnectionManager connManager;\n+    private final TableReference timestampTable;\n+\n+    private MultiSequenceTimestampSeriesProvider(ConnectionManager connManager,\n+            TableReference timestampTable) {\n+        this.connManager = connManager;\n+        this.timestampTable = timestampTable;\n+    }\n+\n+    public static TimestampSeriesProvider create(\n+            KeyValueService rawKvs,\n+            TableReference tableReference,\n+            boolean initializeAsync) {\n+        if (initializeAsync) {\n+            log.warn(\"Asynchronous initialization not implemented, will initialize synchronously.\");\n+        }\n+\n+        Preconditions.checkArgument(rawKvs instanceof ConnectionManagerAwareDbKvs,\n+                \"DbAtlasDbFactory expects a raw kvs of type ConnectionManagerAwareDbKvs, found %s\", rawKvs.getClass());\n+        ConnectionManagerAwareDbKvs dbkvs = (ConnectionManagerAwareDbKvs) rawKvs;\n+        return new MultiSequenceTimestampSeriesProvider(dbkvs.getConnectionManager(), tableReference);\n+    }\n+\n+    @Override\n+    public Set<TimestampSeries> getKnownSeries() {\n+        try (Connection connection = connManager.getConnection()) {\n+            String sql = String.format(\"SELECT client FROM %s FOR UPDATE\", timestampTable.getQualifiedName());\n+            QueryRunner runner = new QueryRunner();\n+            return runner.query(connection, sql, rs -> {\n+                ImmutableSet.Builder<TimestampSeries> series = ImmutableSet.builder();\n+                while (rs.next()) {\n+                    series.add(TimestampSeries.of(rs.getString(\"client\")));\n+                }\n+                return series.build();\n+            });\n+        } catch (SQLException e) {\n+            throw PalantirSqlException.create(e);\n+        }\n+    }", "originalCommit": "faafc8e388b437e69bf1aca07a67ed20a38406c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NDgxOA==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504944818", "bodyText": "Yeah, I'm relying a bit strongly on the MultiNodePaxosTimeLockServerIntegrationTest here. I'll see what I can do", "author": "jeremyk-91", "createdAt": "2020-10-14T20:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg1NDg5OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2NDQ4OA==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504864488", "bodyText": "Apologies in advance - why is singleSeries needed? As far as I see, dbKvs accepts only multiSeries; otherwise ServiceDiscoveringAtlasSupplier takes Optional creationParameters, so why an assertion that creationParameters should be empty not enough here?", "author": "sudiksha27", "createdAt": "2020-10-14T17:52:18Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/RelationalDbTimeLockFactory.java", "diffHunk": "@@ -59,15 +63,23 @@ public KeyValueService createRawKeyValueService(\n     @Override\n     public ManagedTimestampService createManagedTimestampService(\n             KeyValueService rawKvs,\n-            Optional<DbTimestampCreationSetting> dbTimestampCreationSetting,\n+            DbTimestampCreationSetting dbTimestampCreationSetting,\n             boolean initializeAsync) {\n-        return delegate.createManagedTimestampService(rawKvs, dbTimestampCreationSetting, initializeAsync);\n+        return DbTimestampCreationSettings.caseOf(dbTimestampCreationSetting)\n+                .multipleSeries((un, used) ->\n+                        delegate.createManagedTimestampService(\n+                                rawKvs, Optional.of(dbTimestampCreationSetting), initializeAsync))\n+                .singleSeries(unused -> {\n+                    throw new SafeIllegalStateException(\"DB TimeLock cannot be used with\"", "originalCommit": "faafc8e388b437e69bf1aca07a67ed20a38406c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NzUxMQ==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r504947511", "bodyText": "You're right that we currently call into this method only with multiSeries. DbKVS does accept singleSeries too, though (it has to for large internal product), unless I'm missing something, and I'd want to be resilient to anyone changing this in the future without knowing this.\n... that said, based on this I think we can simplify the design here substantially - because we split DbAtlasDbFactory and RelationalDbTimeLockFactory, we don't actually need the DbTimestampCreationSetting at all I think. Probably not for this PR, and it does not need to be finished this week, but we should get that in before we call this workstream complete.", "author": "jeremyk-91", "createdAt": "2020-10-14T20:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2NDQ4OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "7cc784a796b10edc8e47e3c0c87145e8771b5842", "url": "https://github.com/palantir/atlasdb/commit/7cc784a796b10edc8e47e3c0c87145e8771b5842", "message": "3C.3 - canGetAllNamespaces works", "committedDate": "2020-10-14T20:49:02Z", "type": "commit"}, {"oid": "44ec8305f32daaa7d33886d7e642b2fa27986c61", "url": "https://github.com/palantir/atlasdb/commit/44ec8305f32daaa7d33886d7e642b2fa27986c61", "message": "meep", "committedDate": "2020-10-14T20:49:04Z", "type": "commit"}, {"oid": "44ec8305f32daaa7d33886d7e642b2fa27986c61", "url": "https://github.com/palantir/atlasdb/commit/44ec8305f32daaa7d33886d7e642b2fa27986c61", "message": "meep", "committedDate": "2020-10-14T20:49:04Z", "type": "forcePushed"}, {"oid": "199fc9fd0b017e888e72c8f15ecbd76e3475002f", "url": "https://github.com/palantir/atlasdb/commit/199fc9fd0b017e888e72c8f15ecbd76e3475002f", "message": "Tests", "committedDate": "2020-10-15T09:40:12Z", "type": "commit"}, {"oid": "bf2084013476ac924ca288b6a693f0f755ee36e7", "url": "https://github.com/palantir/atlasdb/commit/bf2084013476ac924ca288b6a693f0f755ee36e7", "message": "Parallel tests", "committedDate": "2020-10-15T10:02:01Z", "type": "commit"}, {"oid": "685e1f1cd6173c1c9b28c0e0e7005ba8b46b935d", "url": "https://github.com/palantir/atlasdb/commit/685e1f1cd6173c1c9b28c0e0e7005ba8b46b935d", "message": "changelog", "committedDate": "2020-10-15T10:24:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzODM2Ng==", "url": "https://github.com/palantir/atlasdb/pull/5030#discussion_r505438366", "bodyText": "Nice! Thanks for adding the tests", "author": "sudiksha27", "createdAt": "2020-10-15T10:35:11Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/memory/InMemoryDbTimeLockFactory.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.memory;\n+\n+import java.util.Map;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.common.collect.Maps;\n+import com.palantir.atlasdb.config.DbTimestampCreationSetting;\n+import com.palantir.atlasdb.config.DbTimestampCreationSettings;\n+import com.palantir.atlasdb.config.LeaderConfig;\n+import com.palantir.atlasdb.keyvalue.api.KeyValueService;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeries;\n+import com.palantir.atlasdb.keyvalue.api.TimestampSeriesProvider;\n+import com.palantir.atlasdb.keyvalue.impl.InMemoryKeyValueService;\n+import com.palantir.atlasdb.spi.KeyValueServiceConfig;\n+import com.palantir.atlasdb.timestamp.DbTimeLockFactory;\n+import com.palantir.atlasdb.util.MetricsManager;\n+import com.palantir.timestamp.InMemoryTimestampService;\n+import com.palantir.timestamp.ManagedTimestampService;\n+\n+@AutoService(DbTimeLockFactory.class)\n+public class InMemoryDbTimeLockFactory implements DbTimeLockFactory {\n+    private final Map<TimestampSeries, ManagedTimestampService> services = Maps.newHashMap();\n+", "originalCommit": "199fc9fd0b017e888e72c8f15ecbd76e3475002f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}