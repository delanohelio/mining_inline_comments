{"pr_number": 4968, "pr_title": "Transaction#markTableInvolved.", "pr_createdAt": "2020-08-28T19:38:59Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4968", "timeline": [{"oid": "e98b03d811d6ba5f3a34e5d399cb71da83597094", "url": "https://github.com/palantir/atlasdb/commit/e98b03d811d6ba5f3a34e5d399cb71da83597094", "message": "Add initial tests.", "committedDate": "2020-09-16T09:02:14Z", "type": "commit"}, {"oid": "de74c0f3634e1f2da2fa65ed917ace0802e15c77", "url": "https://github.com/palantir/atlasdb/commit/de74c0f3634e1f2da2fa65ed917ace0802e15c77", "message": "Fixup and final tests.", "committedDate": "2020-09-16T09:58:58Z", "type": "commit"}, {"oid": "e14aa54e6e12ab26821ccddfd9a718a0ce3996f0", "url": "https://github.com/palantir/atlasdb/commit/e14aa54e6e12ab26821ccddfd9a718a0ce3996f0", "message": "Add generated changelog entries", "committedDate": "2020-09-16T09:58:58Z", "type": "commit"}, {"oid": "de74c0f3634e1f2da2fa65ed917ace0802e15c77", "url": "https://github.com/palantir/atlasdb/commit/de74c0f3634e1f2da2fa65ed917ace0802e15c77", "message": "Fixup and final tests.", "committedDate": "2020-09-16T09:58:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzMDY4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489430687", "bodyText": "Actually this should take into account if they're thorough or not, gimme a sec...", "author": "jkozlowski", "createdAt": "2020-09-16T13:20:04Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -1629,13 +1635,13 @@ private void checkConstraints() {\n \n     private void commitWrites(TransactionService transactionService) {\n         if (!hasWrites()) {\n-            if (hasReads()) {\n+            if (hasReads() || hasAnyInvolvedTables()) {", "originalCommit": "e14aa54e6e12ab26821ccddfd9a718a0ce3996f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ1NjcwMg==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489456702", "bodyText": "Fixed", "author": "jkozlowski", "createdAt": "2020-09-16T13:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzMDY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "fc6150760459d9c147a07c919b1c5840f4665092", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\nindex ca770443aa..22d00ce557 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\n\n@@ -1641,7 +1637,7 @@ public class SnapshotTransaction extends AbstractTransaction implements Constrai\n \n                 // if there are no writes, we must still make sure the immutable timestamp lock is still valid,\n                 // to ensure that sweep hasn't thoroughly deleted cells we tried to read\n-                if (validationNecessaryForInvolvedTablesOnCommit() || (!hasReads() && hasAnyInvolvedTables())) {\n+                if (validationNecessaryForInvolvedTablesOnCommit(hasReads())) {\n                     throwIfImmutableTsOrCommitLocksExpired(null);\n                 }\n                 return;\n"}}, {"oid": "fc6150760459d9c147a07c919b1c5840f4665092", "url": "https://github.com/palantir/atlasdb/commit/fc6150760459d9c147a07c919b1c5840f4665092", "message": "Small tweak to account for thorough/not thorough + tests.", "committedDate": "2020-09-16T13:43:55Z", "type": "commit"}, {"oid": "d454acfe867d283ee999ef08948e09db2857f464", "url": "https://github.com/palantir/atlasdb/commit/d454acfe867d283ee999ef08948e09db2857f464", "message": "Fixup", "committedDate": "2020-09-16T14:13:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ1OTkwMw==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489459903", "bodyText": "Since this is private, do we really need the parameter? Seems like we should just call hasReads() in here", "author": "jeremyk-91", "createdAt": "2020-09-16T13:59:14Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -2384,13 +2386,22 @@ public void useTable(TableReference tableRef, ConstraintCheckable table) {\n     /** The similarly-named-and-intentioned useTable method is only called on writes.\n      *  This one is more comprehensive and covers read paths as well\n      * (necessary because we wish to get the sweep strategies of tables in read-only transactions)\n+     *\n+     * A table can be involved in a transaction, even if there were no reads done on it, see #markTableInvolved.\n      */\n     private void markTableAsInvolvedInThisTransaction(TableReference tableRef) {\n         involvedTables.add(tableRef);\n     }\n \n-    private boolean validationNecessaryForInvolvedTablesOnCommit() {\n-        return involvedTables.stream().anyMatch(this::isValidationNecessaryOnCommit);\n+    private boolean hasAnyInvolvedTables() {\n+        return !involvedTables.isEmpty();\n+    }\n+\n+    private boolean validationNecessaryForInvolvedTablesOnCommit(boolean hasReads) {", "originalCommit": "fc6150760459d9c147a07c919b1c5840f4665092", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUwMTA5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489501091", "bodyText": "ah, you fixed this", "author": "jeremyk-91", "createdAt": "2020-09-16T14:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ1OTkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk5MTU1MA==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489991550", "bodyText": "Yep, sorry checkstyle was complaining too...", "author": "jkozlowski", "createdAt": "2020-09-17T06:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ1OTkwMw=="}], "type": "inlineReview", "revised_code": {"commit": "d454acfe867d283ee999ef08948e09db2857f464", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\nindex 22d00ce557..438cd32dac 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\n\n@@ -2397,10 +2397,10 @@ public class SnapshotTransaction extends AbstractTransaction implements Constrai\n         return !involvedTables.isEmpty();\n     }\n \n-    private boolean validationNecessaryForInvolvedTablesOnCommit(boolean hasReads) {\n+    private boolean validationNecessaryForInvolvedTablesOnCommit() {\n         boolean anyTableRequiresImmutableTimestampLocking = involvedTables.stream().anyMatch(\n                 this::requiresImmutableTimestampLocking);\n-        boolean needsToValidate = !validateLocksOnReads || !hasReads;\n+        boolean needsToValidate = !validateLocksOnReads || !hasReads();\n         return anyTableRequiresImmutableTimestampLocking && needsToValidate;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NjY5Nw==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489486697", "bodyText": "So we validate if there's an interesting table AND either there were no reads (because lock watches), or validate locks on reads was false.\nThere are potentially cases where this might behave differently from the original:\nuser reads table A, checks lock\n<loses immutable timestamp lock>\nuser reads table B via notifications, marked B as used\ntxn.commit()\n\nThis would previously throw, but now reads the value from the cache, which is fine - the goal of the immutable timestamp lock is resilience against a delete clearing the value we want out from under us by Thorough Sweep.\nIs the above understanding correct? May be good to have a quick check with @gmaretic here", "author": "jeremyk-91", "createdAt": "2020-09-16T14:34:26Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -2384,13 +2386,22 @@ public void useTable(TableReference tableRef, ConstraintCheckable table) {\n     /** The similarly-named-and-intentioned useTable method is only called on writes.\n      *  This one is more comprehensive and covers read paths as well\n      * (necessary because we wish to get the sweep strategies of tables in read-only transactions)\n+     *\n+     * A table can be involved in a transaction, even if there were no reads done on it, see #markTableInvolved.\n      */\n     private void markTableAsInvolvedInThisTransaction(TableReference tableRef) {\n         involvedTables.add(tableRef);\n     }\n \n+    private boolean hasAnyInvolvedTables() {\n+        return !involvedTables.isEmpty();\n+    }\n+\n     private boolean validationNecessaryForInvolvedTablesOnCommit() {\n-        return involvedTables.stream().anyMatch(this::isValidationNecessaryOnCommit);\n+        boolean anyTableRequiresImmutableTimestampLocking = involvedTables.stream().anyMatch(\n+                this::requiresImmutableTimestampLocking);\n+        boolean needsToValidate = !validateLocksOnReads || !hasReads();\n+        return anyTableRequiresImmutableTimestampLocking && needsToValidate;", "originalCommit": "d454acfe867d283ee999ef08948e09db2857f464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk5NzkzNg==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r489997936", "bodyText": "Where would it throw? Let me clarify my understanding: I understand your timeline as \"table A read checks lock and still has it, but lock expires just afterwards\". With that:\nBefore my change the behavior would be to not throw: when A does the read, it checks the lock, then user does some reads from a cache (AtlasDB is not aware of those reads), and then user calls commit. Then #hasReads is true (because of the A read) so we recheck PreCommitCondition, but #validationNecessaryForInvolvedTablesOnCommit returns false, because #isValidationNecessaryOnCommit checks !validateLocksOnReads. And validateLocksOnReads is a preeety deep rabbit hole, but if you follow it it ultimately is set from TransactionManagers#validateLocksOnReads where the default is true.\nAfter my change, hasReads is true, so again we check PreCommitCondition, and then anyTableRequiresImmutableTimestampLocking is true, because I'm assuming that's what your example does, !validateLocksOnReads is false, but !hasReads() is true, so we do it. I guess I could add a recheck for !hasReads() && hasAnyInvolvedTables() just to be nice?\nUltimately, I think what I care about most is the PreCommitCondition check: the immutable timestamp lock, as you say, is just for TargetedSweep to not nuke the cells under us, but we kinda don't care (because we have them in-memory!). So if you think this is just too complicated I can ignore, but I think I'd rather have this behave roughly the same as the case of only cache reads (the only difference is that the immutable lock check will be checked at commit time).", "author": "jkozlowski", "createdAt": "2020-09-17T06:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA2MTQ4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r490061481", "bodyText": "In my post when I meant \"original\" I meant \"before lock watches even exist\", so the operation is reading A and then reading B - i.e. my concern is about the difference between\nuser reads table A, checks lock\n<loses immutable timestamp lock>\nuser reads table B without notifications (because they don't exist), checks lock, fails\n\nand\nuser reads table A, checks lock\n<loses immutable timestamp lock>\nuser reads table B via notifications, marked B as used\ntxn.commit()\n\nYep, I think the thing I wanted to verify was that this is only for sweep protection, which I believe is correct - if that's the case then I'm pretty sure this is fine", "author": "jeremyk-91", "createdAt": "2020-09-17T08:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NjYyNw==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r490146627", "bodyText": "Yep, discussed offline. I think we don't need to make it this strict, as long as there's a check during the transaction's lifetime, I think that's fine by me.", "author": "jkozlowski", "createdAt": "2020-09-17T10:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NjY5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5MTUyOA==", "url": "https://github.com/palantir/atlasdb/pull/4968#discussion_r490291528", "bodyText": "Just as a note for future awareness, we had a number of bad legacy users which did goofy things like read data read by a transaction (that was not the thing returned) outside of the scope of that transaction. Among other things, this is why we had to have the whole checkLocksOnReads true by default thing (and so \"check during the transaction's lifetime\" might actually not be sufficient in general - though I don't have concrete examples to hand), but within the parameters of our usage is definitely fine.", "author": "jeremyk-91", "createdAt": "2020-09-17T14:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ4NjY5Nw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "c9ea3174a7e477dc764173230f2102a6dad6c4aa", "url": "https://github.com/palantir/atlasdb/commit/c9ea3174a7e477dc764173230f2102a6dad6c4aa", "message": "Autorelease 0.247.1-rc1", "committedDate": "2020-09-17T06:31:12Z", "type": "commit"}, {"oid": "bd22b0b397e7caf436db8d343d3bb430b621de6d", "url": "https://github.com/palantir/atlasdb/commit/bd22b0b397e7caf436db8d343d3bb430b621de6d", "message": "Fixup changelog.", "committedDate": "2020-09-17T06:33:26Z", "type": "commit"}]}