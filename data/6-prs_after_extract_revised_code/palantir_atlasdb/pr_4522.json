{"pr_number": 4522, "pr_title": "Remove concept of namespaces and LogicalPersistentStore.", "pr_createdAt": "2020-01-20T13:13:48Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4522", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzNzMxMg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368637312", "bodyText": "I think it'll suffice to just call it Handle. Since we'll more often than not refer to it as PersistentStore.Handle which makes sense by itself.", "author": "felixdesouza", "createdAt": "2020-01-20T16:32:08Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    @Value.Immutable\n+    interface EntryFamilyHandle {", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY2NDEwNg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368664106", "bodyText": "Renamed to handle and added docs explaining usage, creation and what does it represent.", "author": "OStevan", "createdAt": "2020-01-20T17:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzNzMxMg=="}], "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex b1d6084961..a06891cdf3 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -28,64 +28,66 @@ import org.immutables.value.Value;\n import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n     @Value.Immutable\n-    interface EntryFamilyHandle {\n+    interface Handle {\n         UUID uniqueName();\n     }\n \n     /**\n      * Gets the value associated with the entry specified by {@code key}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n-     * @param key                entry key for which we want to retrieve the value\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n      * @return the {@link Optional} containing the value or empty if there is no associated value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n \n     /**\n      * Gets the values associated with the entries specified by {@code keys}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the values\n-     * @param keys               representing keys for which we want to retrieve the values\n+     * @param handle handle to the store space\n+     * @param keys   representing keys for which we want to retrieve the values\n      * @return a map from keys to values\n      */\n-    Map<K, V> get(EntryFamilyHandle entryFamilyHandle, List<K> keys);\n+    Map<K, V> get(PersistentStore.Handle handle, List<K> keys);\n \n     /**\n      * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n-     * {@code entryFamilyHandle}.\n+     * store space.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param key                entry key\n-     * @param value              entry value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle of the store to which we should store the entry\n+     * @param key    entry key\n+     * @param value  entry value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, @Nonnull K key, @Nonnull V value);\n+    void put(PersistentStore.Handle handle, @Nonnull K key, @Nonnull V value);\n \n     /**\n      * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param toWrite            entry pairs to write\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle  of the store space to which we should store the entry\n+     * @param toWrite entry pairs to write\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, Map<K, V> toWrite);\n+    void put(PersistentStore.Handle handle, Map<K, V> toWrite);\n \n     /**\n-     * Creates a handle of type {@link EntryFamilyHandle} to the underlying store. Each call returns a new {@link\n-     * EntryFamilyHandle}.\n+     * Creates a store space to be used to store key-value pairs. Each call creates a new store space.\n      *\n-     * @return {@link EntryFamilyHandle} which represents a handle to the created entry family\n+     * @return handle to the created store space.\n      */\n-    EntryFamilyHandle createEntryFamily();\n+    PersistentStore.Handle createSpace();\n \n     /**\n-     * Drops the entry family specified by the supplied handle. Dropping of a entry family may fail if there are\n-     * concurrent calls on the same entry family or if the entry family has already been dropped.\n+     * Drops the store spacey specified by the supplied handle. Dropping of a store space may fail if there are\n+     * concurrent calls on the same store space or if the store space has already been dropped.\n      *\n-     * @param entryFamilyHandle handle\n-     * @throws SafeIllegalArgumentException if the {@code entryFamilyHandle} does not exist\n+     * @param handle handle\n+     * @throws SafeIllegalArgumentException if the {@code handle} points to a non-existing store space\n      */\n-    void dropEntryFamily(EntryFamilyHandle entryFamilyHandle);\n+    void dropStoreSpace(PersistentStore.Handle handle);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzODAzMg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368638032", "bodyText": "Similar to how Map refers to Map.Entry within its class, you should refer to Handle as PersistentStore.Handle everywhere in this interface, and also in the implementations that have already had this.", "author": "felixdesouza", "createdAt": "2020-01-20T16:33:41Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    @Value.Immutable\n+    interface EntryFamilyHandle {\n+        UUID uniqueName();\n+    }\n+\n+    /**\n+     * Gets the value associated with the entry specified by {@code key}.\n+     *\n+     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n+     * @param key                entry key for which we want to retrieve the value\n+     * @return the {@link Optional} containing the value or empty if there is no associated value\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex b1d6084961..a06891cdf3 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -28,64 +28,66 @@ import org.immutables.value.Value;\n import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n     @Value.Immutable\n-    interface EntryFamilyHandle {\n+    interface Handle {\n         UUID uniqueName();\n     }\n \n     /**\n      * Gets the value associated with the entry specified by {@code key}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n-     * @param key                entry key for which we want to retrieve the value\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n      * @return the {@link Optional} containing the value or empty if there is no associated value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n \n     /**\n      * Gets the values associated with the entries specified by {@code keys}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the values\n-     * @param keys               representing keys for which we want to retrieve the values\n+     * @param handle handle to the store space\n+     * @param keys   representing keys for which we want to retrieve the values\n      * @return a map from keys to values\n      */\n-    Map<K, V> get(EntryFamilyHandle entryFamilyHandle, List<K> keys);\n+    Map<K, V> get(PersistentStore.Handle handle, List<K> keys);\n \n     /**\n      * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n-     * {@code entryFamilyHandle}.\n+     * store space.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param key                entry key\n-     * @param value              entry value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle of the store to which we should store the entry\n+     * @param key    entry key\n+     * @param value  entry value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, @Nonnull K key, @Nonnull V value);\n+    void put(PersistentStore.Handle handle, @Nonnull K key, @Nonnull V value);\n \n     /**\n      * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param toWrite            entry pairs to write\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle  of the store space to which we should store the entry\n+     * @param toWrite entry pairs to write\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, Map<K, V> toWrite);\n+    void put(PersistentStore.Handle handle, Map<K, V> toWrite);\n \n     /**\n-     * Creates a handle of type {@link EntryFamilyHandle} to the underlying store. Each call returns a new {@link\n-     * EntryFamilyHandle}.\n+     * Creates a store space to be used to store key-value pairs. Each call creates a new store space.\n      *\n-     * @return {@link EntryFamilyHandle} which represents a handle to the created entry family\n+     * @return handle to the created store space.\n      */\n-    EntryFamilyHandle createEntryFamily();\n+    PersistentStore.Handle createSpace();\n \n     /**\n-     * Drops the entry family specified by the supplied handle. Dropping of a entry family may fail if there are\n-     * concurrent calls on the same entry family or if the entry family has already been dropped.\n+     * Drops the store spacey specified by the supplied handle. Dropping of a store space may fail if there are\n+     * concurrent calls on the same store space or if the store space has already been dropped.\n      *\n-     * @param entryFamilyHandle handle\n-     * @throws SafeIllegalArgumentException if the {@code entryFamilyHandle} does not exist\n+     * @param handle handle\n+     * @throws SafeIllegalArgumentException if the {@code handle} points to a non-existing store space\n      */\n-    void dropEntryFamily(EntryFamilyHandle entryFamilyHandle);\n+    void dropStoreSpace(PersistentStore.Handle handle);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MDExNg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368640116", "bodyText": "This javadoc is somewhat roundabout and doesn't say anything that makes me understand what a handle is, and what calling `createHandle`` multiple times does internally. i.e. I can get multiple handles but are they to the same \"door\" so to speak? Or are they handles to different \"doors\". From earlier conversation it's the latter, but it's not super clear here.\nThe type is not relevant, you can see it in the method signature.\nMaybe something like: \"createSpace\" where space is described as a newly initialised place to put data or something along those lines, @gmaretic what do you think?", "author": "felixdesouza", "createdAt": "2020-01-20T16:38:03Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    @Value.Immutable\n+    interface EntryFamilyHandle {\n+        UUID uniqueName();\n+    }\n+\n+    /**\n+     * Gets the value associated with the entry specified by {@code key}.\n+     *\n+     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n+     * @param key                entry key for which we want to retrieve the value\n+     * @return the {@link Optional} containing the value or empty if there is no associated value\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);\n+\n+    /**\n+     * Gets the values associated with the entries specified by {@code keys}.\n+     *\n+     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the values\n+     * @param keys               representing keys for which we want to retrieve the values\n+     * @return a map from keys to values\n+     */\n+    Map<K, V> get(EntryFamilyHandle entryFamilyHandle, List<K> keys);\n+\n+    /**\n+     * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n+     * {@code entryFamilyHandle}.\n+     *\n+     * @param entryFamilyHandle of the store to which we should store the entry\n+     * @param key                entry key\n+     * @param value              entry value\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    void put(EntryFamilyHandle entryFamilyHandle, @Nonnull K key, @Nonnull V value);\n+\n+    /**\n+     * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n+     *\n+     * @param entryFamilyHandle of the store to which we should store the entry\n+     * @param toWrite            entry pairs to write\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    void put(EntryFamilyHandle entryFamilyHandle, Map<K, V> toWrite);\n+\n+    /**\n+     * Creates a handle of type {@link EntryFamilyHandle} to the underlying store. Each call returns a new {@link", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY3MDYyMA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368670620", "bodyText": "I implemented the Handle solution, if @gmaretic agrees we'll proceed with it.", "author": "OStevan", "createdAt": "2020-01-20T17:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MDExNg=="}], "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex b1d6084961..a06891cdf3 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -28,64 +28,66 @@ import org.immutables.value.Value;\n import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n     @Value.Immutable\n-    interface EntryFamilyHandle {\n+    interface Handle {\n         UUID uniqueName();\n     }\n \n     /**\n      * Gets the value associated with the entry specified by {@code key}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n-     * @param key                entry key for which we want to retrieve the value\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n      * @return the {@link Optional} containing the value or empty if there is no associated value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n \n     /**\n      * Gets the values associated with the entries specified by {@code keys}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the values\n-     * @param keys               representing keys for which we want to retrieve the values\n+     * @param handle handle to the store space\n+     * @param keys   representing keys for which we want to retrieve the values\n      * @return a map from keys to values\n      */\n-    Map<K, V> get(EntryFamilyHandle entryFamilyHandle, List<K> keys);\n+    Map<K, V> get(PersistentStore.Handle handle, List<K> keys);\n \n     /**\n      * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n-     * {@code entryFamilyHandle}.\n+     * store space.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param key                entry key\n-     * @param value              entry value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle of the store to which we should store the entry\n+     * @param key    entry key\n+     * @param value  entry value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, @Nonnull K key, @Nonnull V value);\n+    void put(PersistentStore.Handle handle, @Nonnull K key, @Nonnull V value);\n \n     /**\n      * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param toWrite            entry pairs to write\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle  of the store space to which we should store the entry\n+     * @param toWrite entry pairs to write\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, Map<K, V> toWrite);\n+    void put(PersistentStore.Handle handle, Map<K, V> toWrite);\n \n     /**\n-     * Creates a handle of type {@link EntryFamilyHandle} to the underlying store. Each call returns a new {@link\n-     * EntryFamilyHandle}.\n+     * Creates a store space to be used to store key-value pairs. Each call creates a new store space.\n      *\n-     * @return {@link EntryFamilyHandle} which represents a handle to the created entry family\n+     * @return handle to the created store space.\n      */\n-    EntryFamilyHandle createEntryFamily();\n+    PersistentStore.Handle createSpace();\n \n     /**\n-     * Drops the entry family specified by the supplied handle. Dropping of a entry family may fail if there are\n-     * concurrent calls on the same entry family or if the entry family has already been dropped.\n+     * Drops the store spacey specified by the supplied handle. Dropping of a store space may fail if there are\n+     * concurrent calls on the same store space or if the store space has already been dropped.\n      *\n-     * @param entryFamilyHandle handle\n-     * @throws SafeIllegalArgumentException if the {@code entryFamilyHandle} does not exist\n+     * @param handle handle\n+     * @throws SafeIllegalArgumentException if the {@code handle} points to a non-existing store space\n      */\n-    void dropEntryFamily(EntryFamilyHandle entryFamilyHandle);\n+    void dropStoreSpace(PersistentStore.Handle handle);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MDM3Ng==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368640376", "bodyText": "amend docs based on the above", "author": "felixdesouza", "createdAt": "2020-01-20T16:38:34Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    @Value.Immutable\n+    interface EntryFamilyHandle {\n+        UUID uniqueName();\n+    }\n+\n+    /**\n+     * Gets the value associated with the entry specified by {@code key}.\n+     *\n+     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n+     * @param key                entry key for which we want to retrieve the value\n+     * @return the {@link Optional} containing the value or empty if there is no associated value\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);\n+\n+    /**\n+     * Gets the values associated with the entries specified by {@code keys}.\n+     *\n+     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the values\n+     * @param keys               representing keys for which we want to retrieve the values\n+     * @return a map from keys to values\n+     */\n+    Map<K, V> get(EntryFamilyHandle entryFamilyHandle, List<K> keys);\n+\n+    /**\n+     * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n+     * {@code entryFamilyHandle}.\n+     *\n+     * @param entryFamilyHandle of the store to which we should store the entry\n+     * @param key                entry key\n+     * @param value              entry value\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    void put(EntryFamilyHandle entryFamilyHandle, @Nonnull K key, @Nonnull V value);\n+\n+    /**\n+     * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n+     *\n+     * @param entryFamilyHandle of the store to which we should store the entry\n+     * @param toWrite            entry pairs to write\n+     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     */\n+    void put(EntryFamilyHandle entryFamilyHandle, Map<K, V> toWrite);\n+\n+    /**\n+     * Creates a handle of type {@link EntryFamilyHandle} to the underlying store. Each call returns a new {@link\n+     * EntryFamilyHandle}.\n+     *\n+     * @return {@link EntryFamilyHandle} which represents a handle to the created entry family\n+     */\n+    EntryFamilyHandle createEntryFamily();\n+\n+    /**\n+     * Drops the entry family specified by the supplied handle. Dropping of a entry family may fail if there are", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY2NDIxOA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368664218", "bodyText": "Amended.", "author": "OStevan", "createdAt": "2020-01-20T17:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MDM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex b1d6084961..a06891cdf3 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -28,64 +28,66 @@ import org.immutables.value.Value;\n import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n     @Value.Immutable\n-    interface EntryFamilyHandle {\n+    interface Handle {\n         UUID uniqueName();\n     }\n \n     /**\n      * Gets the value associated with the entry specified by {@code key}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the value\n-     * @param key                entry key for which we want to retrieve the value\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n      * @return the {@link Optional} containing the value or empty if there is no associated value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    Optional<V> get(EntryFamilyHandle entryFamilyHandle, @Nonnull K key);\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n \n     /**\n      * Gets the values associated with the entries specified by {@code keys}.\n      *\n-     * @param entryFamilyHandle handle to the entry family from which we want to retrieve the values\n-     * @param keys               representing keys for which we want to retrieve the values\n+     * @param handle handle to the store space\n+     * @param keys   representing keys for which we want to retrieve the values\n      * @return a map from keys to values\n      */\n-    Map<K, V> get(EntryFamilyHandle entryFamilyHandle, List<K> keys);\n+    Map<K, V> get(PersistentStore.Handle handle, List<K> keys);\n \n     /**\n      * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n-     * {@code entryFamilyHandle}.\n+     * store space.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param key                entry key\n-     * @param value              entry value\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle of the store to which we should store the entry\n+     * @param key    entry key\n+     * @param value  entry value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, @Nonnull K key, @Nonnull V value);\n+    void put(PersistentStore.Handle handle, @Nonnull K key, @Nonnull V value);\n \n     /**\n      * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n      *\n-     * @param entryFamilyHandle of the store to which we should store the entry\n-     * @param toWrite            entry pairs to write\n-     * @throws SafeIllegalArgumentException when {@code entryFamilyHandle} is a handle to a non existing entry family\n+     * @param handle  of the store space to which we should store the entry\n+     * @param toWrite entry pairs to write\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n      */\n-    void put(EntryFamilyHandle entryFamilyHandle, Map<K, V> toWrite);\n+    void put(PersistentStore.Handle handle, Map<K, V> toWrite);\n \n     /**\n-     * Creates a handle of type {@link EntryFamilyHandle} to the underlying store. Each call returns a new {@link\n-     * EntryFamilyHandle}.\n+     * Creates a store space to be used to store key-value pairs. Each call creates a new store space.\n      *\n-     * @return {@link EntryFamilyHandle} which represents a handle to the created entry family\n+     * @return handle to the created store space.\n      */\n-    EntryFamilyHandle createEntryFamily();\n+    PersistentStore.Handle createSpace();\n \n     /**\n-     * Drops the entry family specified by the supplied handle. Dropping of a entry family may fail if there are\n-     * concurrent calls on the same entry family or if the entry family has already been dropped.\n+     * Drops the store spacey specified by the supplied handle. Dropping of a store space may fail if there are\n+     * concurrent calls on the same store space or if the store space has already been dropped.\n      *\n-     * @param entryFamilyHandle handle\n-     * @throws SafeIllegalArgumentException if the {@code entryFamilyHandle} does not exist\n+     * @param handle handle\n+     * @throws SafeIllegalArgumentException if the {@code handle} points to a non-existing store space\n      */\n-    void dropEntryFamily(EntryFamilyHandle entryFamilyHandle);\n+    void dropStoreSpace(PersistentStore.Handle handle);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MTkwNA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368641904", "bodyText": "nit: move this next to cacheDescriptor.currentSize...", "author": "felixdesouza", "createdAt": "2020-01-20T16:41:37Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -154,47 +156,45 @@ private static MetricName constructCacheMetricName(String metricSuffix) {\n                 .build();\n     }\n \n-    private static class WriteBatcher\n-            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+    private static class WriteBatcher implements CoalescingRequestFunction<Map.Entry<Long, Long>, Void> {\n         OffHeapTimestampCache offHeapTimestampCache;\n \n         WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n             this.offHeapTimestampCache = offHeapTimestampCache;\n         }\n \n         @Override\n-        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+        public Map<Map.Entry<Long, Long>, Void> apply(Set<Map.Entry<Long, Long>> request) {\n             CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             if (cacheDescriptor.currentSize().get() >= offHeapTimestampCache.maxSize.getAsLong()) {\n                 offHeapTimestampCache.taggedMetricRegistry.counter(CACHE_NUKE).inc();\n                 offHeapTimestampCache.clear();\n             }\n             cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n+                List<Long> toWrite = request.stream().map(Map.Entry::getKey).collect(Collectors.toList());\n                 Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(\n-                        cacheDescriptor.storeNamespace(),\n-                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n-\n-                Map<Long, Long> toWrite = ImmutableMap.copyOf(Sets.difference(request, response.entrySet()));\n-                offHeapTimestampCache.timestampStore.put(\n-                        cacheDescriptor.storeNamespace(),\n+                        cacheDescriptor.entryFamily(),\n                         toWrite);\n \n-                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+                int sizeIncrease = Sets.difference(request, response.entrySet()).size();\n+                offHeapTimestampCache.timestampStore.put(cacheDescriptor.entryFamily(), ImmutableMap.copyOf(request));", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY2NDM1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368664355", "bodyText": "I think I moved it to correct position. Please double check.", "author": "OStevan", "createdAt": "2020-01-20T17:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MTkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex c9137c0a23..2cabfbc0d8 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -173,21 +172,18 @@ public final class OffHeapTimestampCache implements TimestampCache {\n             cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n                 List<Long> toWrite = request.stream().map(Map.Entry::getKey).collect(Collectors.toList());\n-                Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(\n-                        cacheDescriptor.entryFamily(),\n-                        toWrite);\n+                Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(cacheDescriptor.handle(), toWrite);\n \n                 int sizeIncrease = Sets.difference(request, response.entrySet()).size();\n-                offHeapTimestampCache.timestampStore.put(cacheDescriptor.entryFamily(), ImmutableMap.copyOf(request));\n-\n                 cacheDescriptor.currentSize().addAndGet(sizeIncrease);\n+                offHeapTimestampCache.timestampStore.put(cacheDescriptor.handle(), ImmutableMap.copyOf(request));\n             } catch (SafeIllegalArgumentException exception) {\n                 // happens when a store is dropped by a concurrent call to clear\n                 log.warn(\"Clear called concurrently, writing failed\", exception);\n             } finally {\n                 offHeapTimestampCache.inflightRequests.clear();\n             }\n-            return KeyedStream.of(request.stream()).map(value -> (Void) null).collectToMap();\n+            return KeyedStream.of(request.stream()).<Void>map(value -> null).collectToMap();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MjE2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368642166", "bodyText": "curious whether\nKeyedStream.of(request.stream()).<Void>map(value -> null).collectToMap();\nworks?", "author": "felixdesouza", "createdAt": "2020-01-20T16:42:10Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -154,47 +156,45 @@ private static MetricName constructCacheMetricName(String metricSuffix) {\n                 .build();\n     }\n \n-    private static class WriteBatcher\n-            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+    private static class WriteBatcher implements CoalescingRequestFunction<Map.Entry<Long, Long>, Void> {\n         OffHeapTimestampCache offHeapTimestampCache;\n \n         WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n             this.offHeapTimestampCache = offHeapTimestampCache;\n         }\n \n         @Override\n-        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+        public Map<Map.Entry<Long, Long>, Void> apply(Set<Map.Entry<Long, Long>> request) {\n             CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             if (cacheDescriptor.currentSize().get() >= offHeapTimestampCache.maxSize.getAsLong()) {\n                 offHeapTimestampCache.taggedMetricRegistry.counter(CACHE_NUKE).inc();\n                 offHeapTimestampCache.clear();\n             }\n             cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n+                List<Long> toWrite = request.stream().map(Map.Entry::getKey).collect(Collectors.toList());\n                 Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(\n-                        cacheDescriptor.storeNamespace(),\n-                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n-\n-                Map<Long, Long> toWrite = ImmutableMap.copyOf(Sets.difference(request, response.entrySet()));\n-                offHeapTimestampCache.timestampStore.put(\n-                        cacheDescriptor.storeNamespace(),\n+                        cacheDescriptor.entryFamily(),\n                         toWrite);\n \n-                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+                int sizeIncrease = Sets.difference(request, response.entrySet()).size();\n+                offHeapTimestampCache.timestampStore.put(cacheDescriptor.entryFamily(), ImmutableMap.copyOf(request));\n+\n+                cacheDescriptor.currentSize().addAndGet(sizeIncrease);\n             } catch (SafeIllegalArgumentException exception) {\n                 // happens when a store is dropped by a concurrent call to clear\n                 log.warn(\"Clear called concurrently, writing failed\", exception);\n             } finally {\n                 offHeapTimestampCache.inflightRequests.clear();\n             }\n-            return KeyedStream.of(request.stream()).collectToMap();\n+            return KeyedStream.of(request.stream()).map(value -> (Void) null).collectToMap();", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex c9137c0a23..2cabfbc0d8 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -173,21 +172,18 @@ public final class OffHeapTimestampCache implements TimestampCache {\n             cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n                 List<Long> toWrite = request.stream().map(Map.Entry::getKey).collect(Collectors.toList());\n-                Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(\n-                        cacheDescriptor.entryFamily(),\n-                        toWrite);\n+                Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(cacheDescriptor.handle(), toWrite);\n \n                 int sizeIncrease = Sets.difference(request, response.entrySet()).size();\n-                offHeapTimestampCache.timestampStore.put(cacheDescriptor.entryFamily(), ImmutableMap.copyOf(request));\n-\n                 cacheDescriptor.currentSize().addAndGet(sizeIncrease);\n+                offHeapTimestampCache.timestampStore.put(cacheDescriptor.handle(), ImmutableMap.copyOf(request));\n             } catch (SafeIllegalArgumentException exception) {\n                 // happens when a store is dropped by a concurrent call to clear\n                 log.warn(\"Clear called concurrently, writing failed\", exception);\n             } finally {\n                 offHeapTimestampCache.inflightRequests.clear();\n             }\n-            return KeyedStream.of(request.stream()).map(value -> (Void) null).collectToMap();\n+            return KeyedStream.of(request.stream()).<Void>map(value -> null).collectToMap();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MzIyNA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368643224", "bodyText": "change the name of this class.", "author": "felixdesouza", "createdAt": "2020-01-20T16:44:31Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java", "diffHunk": "@@ -25,27 +25,29 @@\n import org.slf4j.LoggerFactory;\n \n import com.palantir.atlasdb.config.RocksDbPersistentStorageConfig;\n-import com.palantir.atlasdb.persistent.api.PhysicalPersistentStore;\n-import com.palantir.atlasdb.persistent.rocksdb.RocksDbPhysicalPersistentStore;\n+import com.palantir.atlasdb.persistent.api.PersistentStore;\n+import com.palantir.atlasdb.persistent.rocksdb.RocksDbPersistentStore;\n+\n+import okio.ByteString;\n \n /**\n- * Constructs a new {@link PhysicalPersistentStore} with new persistent storage connection on each call of\n+ * Constructs a new {@link PersistentStore} with new persistent storage connection on each call of\n  * {@link DefaultPhysicalPersistentStorageFactory#constructPersistentStore(RocksDbPersistentStorageConfig)}.\n  */\n public final class DefaultPhysicalPersistentStorageFactory implements PhysicalPersistentStorageFactory {", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPersistentStorageFactory.java\nsimilarity index 89%\nrename from atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java\nrename to atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPersistentStorageFactory.java\nindex e0849c6f60..e9ad7c41ce 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPersistentStorageFactory.java\n\n@@ -32,10 +32,10 @@ import okio.ByteString;\n \n /**\n  * Constructs a new {@link PersistentStore} with new persistent storage connection on each call of\n- * {@link DefaultPhysicalPersistentStorageFactory#constructPersistentStore(RocksDbPersistentStorageConfig)}.\n+ * {@link DefaultPersistentStorageFactory#constructPersistentStore(RocksDbPersistentStorageConfig)}.\n  */\n-public final class DefaultPhysicalPersistentStorageFactory implements PhysicalPersistentStorageFactory {\n-    private static final Logger log = LoggerFactory.getLogger(DefaultPhysicalPersistentStorageFactory.class);\n+public final class DefaultPersistentStorageFactory implements PersistentStorageFactory {\n+    private static final Logger log = LoggerFactory.getLogger(DefaultPersistentStorageFactory.class);\n \n     /**\n      * Constructs a {@link PersistentStore} from a {@link RocksDbPersistentStorageConfig}.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MzkzNA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368643934", "bodyText": "Can we just bite the bullet and call this rocks, either that or do the \"generification\" properly. The mix of the two is inconsistent and quite confusing. Probably a separate PR however.", "author": "felixdesouza", "createdAt": "2020-01-20T16:46:00Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java", "diffHunk": "@@ -25,27 +25,29 @@\n import org.slf4j.LoggerFactory;\n \n import com.palantir.atlasdb.config.RocksDbPersistentStorageConfig;\n-import com.palantir.atlasdb.persistent.api.PhysicalPersistentStore;\n-import com.palantir.atlasdb.persistent.rocksdb.RocksDbPhysicalPersistentStore;\n+import com.palantir.atlasdb.persistent.api.PersistentStore;\n+import com.palantir.atlasdb.persistent.rocksdb.RocksDbPersistentStore;\n+\n+import okio.ByteString;\n \n /**\n- * Constructs a new {@link PhysicalPersistentStore} with new persistent storage connection on each call of\n+ * Constructs a new {@link PersistentStore} with new persistent storage connection on each call of\n  * {@link DefaultPhysicalPersistentStorageFactory#constructPersistentStore(RocksDbPersistentStorageConfig)}.\n  */\n public final class DefaultPhysicalPersistentStorageFactory implements PhysicalPersistentStorageFactory {", "originalCommit": "edddbd03ec0aac82d9c219711529b71b0f282506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY2NDcyNA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368664724", "bodyText": "I would do the visitor pattern in a following PR and leave it as is for now.", "author": "OStevan", "createdAt": "2020-01-20T17:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MzkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPersistentStorageFactory.java\nsimilarity index 89%\nrename from atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java\nrename to atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPersistentStorageFactory.java\nindex e0849c6f60..e9ad7c41ce 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPhysicalPersistentStorageFactory.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/DefaultPersistentStorageFactory.java\n\n@@ -32,10 +32,10 @@ import okio.ByteString;\n \n /**\n  * Constructs a new {@link PersistentStore} with new persistent storage connection on each call of\n- * {@link DefaultPhysicalPersistentStorageFactory#constructPersistentStore(RocksDbPersistentStorageConfig)}.\n+ * {@link DefaultPersistentStorageFactory#constructPersistentStore(RocksDbPersistentStorageConfig)}.\n  */\n-public final class DefaultPhysicalPersistentStorageFactory implements PhysicalPersistentStorageFactory {\n-    private static final Logger log = LoggerFactory.getLogger(DefaultPhysicalPersistentStorageFactory.class);\n+public final class DefaultPersistentStorageFactory implements PersistentStorageFactory {\n+    private static final Logger log = LoggerFactory.getLogger(DefaultPersistentStorageFactory.class);\n \n     /**\n      * Constructs a {@link PersistentStore} from a {@link RocksDbPersistentStorageConfig}.\n"}}, {"oid": "4c6ea9f9295380e24b8e292b90222efd1f115906", "url": "https://github.com/palantir/atlasdb/commit/4c6ea9f9295380e24b8e292b90222efd1f115906", "message": "Simplifications and refactorings.", "committedDate": "2020-01-20T17:34:41Z", "type": "commit"}, {"oid": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "url": "https://github.com/palantir/atlasdb/commit/c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "message": "Remove a line.", "committedDate": "2020-01-20T17:34:41Z", "type": "commit"}, {"oid": "c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "url": "https://github.com/palantir/atlasdb/commit/c15e2a3796722aeb7e9b8d93b8614b77ce98fd36", "message": "Remove a line.", "committedDate": "2020-01-20T17:34:41Z", "type": "forcePushed"}, {"oid": "1160966ddc7f0c7d027cf6fc6a524353b34cbde9", "url": "https://github.com/palantir/atlasdb/commit/1160966ddc7f0c7d027cf6fc6a524353b34cbde9", "message": "Removed period.", "committedDate": "2020-01-20T17:41:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcxOTU2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368719567", "bodyText": "let's pair tomorrow, I'd like to clarify what this means", "author": "jeremyk-91", "createdAt": "2020-01-20T20:42:38Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.", "originalCommit": "1160966ddc7f0c7d027cf6fc6a524353b34cbde9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7a5b8e0c8de6ba98252261af9a95cd4ea7283c3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex 6b2e671274..6127f1fd63 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -29,7 +29,8 @@ import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n     /**\n-     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store\n+     * space.\n      */\n     @Value.Immutable\n     interface Handle {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcxOTY5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368719693", "bodyText": "nit: probably implied, but should say Keys which are not present in the store will not be included in the returned map.", "author": "jeremyk-91", "createdAt": "2020-01-20T20:43:14Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n+    @Value.Immutable\n+    interface Handle {\n+        UUID uniqueName();\n+    }\n+\n+    /**\n+     * Gets the value associated with the entry specified by {@code key}.\n+     *\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n+     * @return the {@link Optional} containing the value or empty if there is no associated value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n+\n+    /**\n+     * Gets the values associated with the entries specified by {@code keys}.", "originalCommit": "1160966ddc7f0c7d027cf6fc6a524353b34cbde9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7a5b8e0c8de6ba98252261af9a95cd4ea7283c3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex 6b2e671274..6127f1fd63 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -29,7 +29,8 @@ import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n     /**\n-     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store\n+     * space.\n      */\n     @Value.Immutable\n     interface Handle {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcxOTgzNQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368719835", "bodyText": "nit: spacey \ud83d\udc7d", "author": "jeremyk-91", "createdAt": "2020-01-20T20:43:39Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n+    @Value.Immutable\n+    interface Handle {\n+        UUID uniqueName();\n+    }\n+\n+    /**\n+     * Gets the value associated with the entry specified by {@code key}.\n+     *\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n+     * @return the {@link Optional} containing the value or empty if there is no associated value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n+\n+    /**\n+     * Gets the values associated with the entries specified by {@code keys}.\n+     *\n+     * @param handle handle to the store space\n+     * @param keys   representing keys for which we want to retrieve the values\n+     * @return a map from keys to values\n+     */\n+    Map<K, V> get(PersistentStore.Handle handle, List<K> keys);\n+\n+    /**\n+     * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n+     * store space.\n+     *\n+     * @param handle of the store to which we should store the entry\n+     * @param key    entry key\n+     * @param value  entry value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    void put(PersistentStore.Handle handle, @Nonnull K key, @Nonnull V value);\n+\n+    /**\n+     * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n+     *\n+     * @param handle  of the store space to which we should store the entry\n+     * @param toWrite entry pairs to write\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    void put(PersistentStore.Handle handle, Map<K, V> toWrite);\n+\n+    /**\n+     * Creates a store space to be used to store key-value pairs. Each call creates a new store space.\n+     *\n+     * @return handle to the created store space\n+     */\n+    PersistentStore.Handle createSpace();\n+\n+    /**\n+     * Drops the store spacey specified by the supplied handle. Dropping of a store space may fail if there are", "originalCommit": "1160966ddc7f0c7d027cf6fc6a524353b34cbde9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ0NjU0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369446545", "bodyText": "\ud83d\udc68\u200d\ud83d\ude80", "author": "OStevan", "createdAt": "2020-01-22T09:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcxOTgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a7a5b8e0c8de6ba98252261af9a95cd4ea7283c3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex 6b2e671274..6127f1fd63 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -29,7 +29,8 @@ import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n     /**\n-     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store\n+     * space.\n      */\n     @Value.Immutable\n     interface Handle {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcxOTk3MQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r368719971", "bodyText": "nit: We should probably be consistent with the way we're describing what the role of the handle is.", "author": "jeremyk-91", "createdAt": "2020-01-20T20:44:17Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public interface PersistentStore<K, V> extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     */\n+    @Value.Immutable\n+    interface Handle {\n+        UUID uniqueName();\n+    }\n+\n+    /**\n+     * Gets the value associated with the entry specified by {@code key}.\n+     *\n+     * @param handle handle to the store space from which we want to retrieve the value\n+     * @param key    entry key for which we want to retrieve the value\n+     * @return the {@link Optional} containing the value or empty if there is no associated value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    Optional<V> get(PersistentStore.Handle handle, @Nonnull K key);\n+\n+    /**\n+     * Gets the values associated with the entries specified by {@code keys}.\n+     *\n+     * @param handle handle to the store space\n+     * @param keys   representing keys for which we want to retrieve the values\n+     * @return a map from keys to values\n+     */\n+    Map<K, V> get(PersistentStore.Handle handle, List<K> keys);\n+\n+    /**\n+     * Stores the {@code value} for the associated {@code key} while overwriting the existing value in the specified\n+     * store space.\n+     *\n+     * @param handle of the store to which we should store the entry\n+     * @param key    entry key\n+     * @param value  entry value\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    void put(PersistentStore.Handle handle, @Nonnull K key, @Nonnull V value);\n+\n+    /**\n+     * Stores the entry pairs given in {@code toWrite}, overwriting the existing values.\n+     *\n+     * @param handle  of the store space to which we should store the entry\n+     * @param toWrite entry pairs to write\n+     * @throws SafeIllegalArgumentException when referencing a non existing store space\n+     */\n+    void put(PersistentStore.Handle handle, Map<K, V> toWrite);\n+\n+    /**\n+     * Creates a store space to be used to store key-value pairs. Each call creates a new store space.\n+     *\n+     * @return handle to the created store space\n+     */\n+    PersistentStore.Handle createSpace();\n+\n+    /**\n+     * Drops the store spacey specified by the supplied handle. Dropping of a store space may fail if there are\n+     * concurrent calls on the same store space or if the store space has already been dropped.\n+     *\n+     * @param handle handle", "originalCommit": "1160966ddc7f0c7d027cf6fc6a524353b34cbde9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a7a5b8e0c8de6ba98252261af9a95cd4ea7283c3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex 6b2e671274..6127f1fd63 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -29,7 +29,8 @@ import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n \n public interface PersistentStore<K, V> extends AutoCloseable {\n     /**\n-     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store space.\n+     * Represents a handle to the underlying space of key-value pairs. Handle is linked with one underlying store\n+     * space.\n      */\n     @Value.Immutable\n     interface Handle {\n"}}, {"oid": "a7a5b8e0c8de6ba98252261af9a95cd4ea7283c3", "url": "https://github.com/palantir/atlasdb/commit/a7a5b8e0c8de6ba98252261af9a95cd4ea7283c3", "message": "Small nits.", "committedDate": "2020-01-22T09:41:57Z", "type": "commit"}, {"oid": "085aa364b4bb06a617c499282c64980837a554a2", "url": "https://github.com/palantir/atlasdb/commit/085aa364b4bb06a617c499282c64980837a554a2", "message": "Remove generics.", "committedDate": "2020-01-22T11:19:57Z", "type": "commit"}, {"oid": "80535c665781bdb11a31e36d1ca407085fac504e", "url": "https://github.com/palantir/atlasdb/commit/80535c665781bdb11a31e36d1ca407085fac504e", "message": "Mapping tests.", "committedDate": "2020-01-22T13:58:47Z", "type": "commit"}, {"oid": "844630f9646451fe9c0315bdff615993d115c521", "url": "https://github.com/palantir/atlasdb/commit/844630f9646451fe9c0315bdff615993d115c521", "message": "Update docs.", "committedDate": "2020-01-22T15:17:49Z", "type": "commit"}, {"oid": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "url": "https://github.com/palantir/atlasdb/commit/e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "message": "Removed in-flight.", "committedDate": "2020-01-22T15:21:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNTg3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369635872", "bodyText": "typos", "author": "felixdesouza", "createdAt": "2020-01-22T15:40:50Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+import okio.ByteString;\n+\n+public interface PersistentStore extends AutoCloseable {", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex bd68374b56..3d14b2e64b 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -32,11 +32,15 @@ import okio.ByteString;\n public interface PersistentStore extends AutoCloseable {\n     /**\n      * Represents a handle to the underlying space of key-value pairs. A space of key-value pairs is analogous to a\n-     * PostgreSQL table of RocksdDb Column family. Handle is linked with one underlying store space.\n+     * PostgreSQL table or RocksdDb column family. Handle is linked with one underlying store space.\n      */\n     @Value.Immutable\n     interface Handle {\n-        UUID uniqueName();\n+        UUID id();\n+    }\n+\n+    static Handle buildHandle() {\n+        return ImmutableHandle.builder().id(UUID.randomUUID()).build();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNjM5OA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369636398", "bodyText": "put serde inside the thing that's actually talking to persistent store", "author": "felixdesouza", "createdAt": "2020-01-22T15:41:40Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -154,47 +152,49 @@ private static MetricName constructCacheMetricName(String metricSuffix) {\n                 .build();\n     }\n \n-    private static class WriteBatcher\n-            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+    private static class WriteBatcher implements CoalescingRequestFunction<Map.Entry<ByteString, ByteString>, Void> {\n         OffHeapTimestampCache offHeapTimestampCache;\n \n         WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n             this.offHeapTimestampCache = offHeapTimestampCache;\n         }\n \n         @Override\n-        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+        public Map<Map.Entry<ByteString, ByteString>, Void> apply(Set<Map.Entry<ByteString, ByteString>> request) {\n             CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             if (cacheDescriptor.currentSize().get() >= offHeapTimestampCache.maxSize.getAsLong()) {\n                 offHeapTimestampCache.taggedMetricRegistry.counter(CACHE_NUKE).inc();\n                 offHeapTimestampCache.clear();\n             }\n             cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n-                Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(\n-                        cacheDescriptor.storeNamespace(),\n-                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n-\n-                Map<Long, Long> toWrite = ImmutableMap.copyOf(Sets.difference(request, response.entrySet()));\n-                offHeapTimestampCache.timestampStore.put(\n-                        cacheDescriptor.storeNamespace(),\n-                        toWrite);\n-\n-                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+                List<ByteString> toWrite = request.stream()", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1NTAzMg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370055032", "bodyText": "Used inside.", "author": "OStevan", "createdAt": "2020-01-23T11:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNjM5OA=="}], "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex 73355b2011..4d05afb5b1 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -185,16 +185,18 @@ public final class OffHeapTimestampCache implements TimestampCache {\n         }\n     }\n \n-    interface EntryMapper {\n-        ByteString serializeKey(Long key);\n-        Long deserializeKey(ByteString key);\n-        ByteString serializeValue(Long key, Long value);\n-        Long deserializeValue(Long key, ByteString value);\n+    interface EntryMapper<K, V> {\n+        ByteString serializeKey(K key);\n+        K deserializeKey(ByteString key);\n+        ByteString serializeValue(K key, V value);\n+        K deserializeValue(ByteString key, ByteString value);\n     }\n+\n     @Value.Immutable\n     @Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n     interface CacheDescriptor {\n         AtomicInteger currentSize();\n         PersistentStore.Handle handle();\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNzI0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369637245", "bodyText": "Wasn't this class supposed to be generic? Bit confused here. Also deserializeValue key needs to be ByteString.", "author": "felixdesouza", "createdAt": "2020-01-22T15:43:02Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -154,47 +152,49 @@ private static MetricName constructCacheMetricName(String metricSuffix) {\n                 .build();\n     }\n \n-    private static class WriteBatcher\n-            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+    private static class WriteBatcher implements CoalescingRequestFunction<Map.Entry<ByteString, ByteString>, Void> {\n         OffHeapTimestampCache offHeapTimestampCache;\n \n         WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n             this.offHeapTimestampCache = offHeapTimestampCache;\n         }\n \n         @Override\n-        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+        public Map<Map.Entry<ByteString, ByteString>, Void> apply(Set<Map.Entry<ByteString, ByteString>> request) {\n             CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             if (cacheDescriptor.currentSize().get() >= offHeapTimestampCache.maxSize.getAsLong()) {\n                 offHeapTimestampCache.taggedMetricRegistry.counter(CACHE_NUKE).inc();\n                 offHeapTimestampCache.clear();\n             }\n             cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n-                Map<Long, Long> response = offHeapTimestampCache.timestampStore.get(\n-                        cacheDescriptor.storeNamespace(),\n-                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n-\n-                Map<Long, Long> toWrite = ImmutableMap.copyOf(Sets.difference(request, response.entrySet()));\n-                offHeapTimestampCache.timestampStore.put(\n-                        cacheDescriptor.storeNamespace(),\n-                        toWrite);\n-\n-                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+                List<ByteString> toWrite = request.stream()\n+                        .map(Map.Entry::getKey)\n+                        .collect(Collectors.toList());\n+                Map<ByteString, ByteString> response =\n+                        offHeapTimestampCache.persistentStore.get(cacheDescriptor.handle(), toWrite);\n+\n+                int sizeIncrease = Sets.difference(request, response.entrySet()).size();\n+                cacheDescriptor.currentSize().addAndGet(sizeIncrease);\n+                offHeapTimestampCache.persistentStore.put(cacheDescriptor.handle(), ImmutableMap.copyOf(request));\n             } catch (SafeIllegalArgumentException exception) {\n                 // happens when a store is dropped by a concurrent call to clear\n                 log.warn(\"Clear called concurrently, writing failed\", exception);\n-            } finally {\n-                offHeapTimestampCache.inflightRequests.clear();\n             }\n-            return KeyedStream.of(request.stream()).collectToMap();\n+            return KeyedStream.of(request.stream()).<Void>map(value -> null).collectToMap();\n         }\n     }\n \n+    interface EntryMapper {", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwOTczOA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370009738", "bodyText": "It is generic now.", "author": "OStevan", "createdAt": "2020-01-23T09:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNzI0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex 73355b2011..4d05afb5b1 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -185,16 +185,18 @@ public final class OffHeapTimestampCache implements TimestampCache {\n         }\n     }\n \n-    interface EntryMapper {\n-        ByteString serializeKey(Long key);\n-        Long deserializeKey(ByteString key);\n-        ByteString serializeValue(Long key, Long value);\n-        Long deserializeValue(Long key, ByteString value);\n+    interface EntryMapper<K, V> {\n+        ByteString serializeKey(K key);\n+        K deserializeKey(ByteString key);\n+        ByteString serializeValue(K key, V value);\n+        K deserializeValue(ByteString key, ByteString value);\n     }\n+\n     @Value.Immutable\n     @Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n     interface CacheDescriptor {\n         AtomicInteger currentSize();\n         PersistentStore.Handle handle();\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNzk1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369637955", "bodyText": "you probably want two separate things, one that's a ByteString-> Long entry mapper, and the other that's a Long,Long to Long,Long which \"deserialises\" the delta encoding.", "author": "felixdesouza", "createdAt": "2020-01-22T15:44:10Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/TimestampsEntryMapper.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.palantir.atlasdb.table.description.ValueType;\n+import com.palantir.logsafe.Preconditions;\n+\n+import okio.ByteString;\n+\n+/**\n+ * Stores timestamps using delta encoding for commit timestamp.\n+ */\n+public class TimestampsEntryMapper implements OffHeapTimestampCache.EntryMapper {", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAxMzQ1MA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370013450", "bodyText": "Separated.", "author": "OStevan", "createdAt": "2020-01-23T09:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNzk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/TimestampsEntryMapper.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/LongEntryMapper.java\nsimilarity index 86%\nrename from atlasdb-client/src/main/java/com/palantir/atlasdb/cache/TimestampsEntryMapper.java\nrename to atlasdb-client/src/main/java/com/palantir/atlasdb/cache/LongEntryMapper.java\nindex e2290c013c..92e0a4565e 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/TimestampsEntryMapper.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/LongEntryMapper.java\n\n@@ -23,10 +23,7 @@ import com.palantir.logsafe.Preconditions;\n \n import okio.ByteString;\n \n-/**\n- * Stores timestamps using delta encoding for commit timestamp.\n- */\n-public class TimestampsEntryMapper implements OffHeapTimestampCache.EntryMapper {\n+public class LongEntryMapper implements OffHeapTimestampCache.EntryMapper<Long, Long> {\n     @Override\n     public ByteString serializeKey(Long key) {\n         Preconditions.checkNotNull(key, \"Key should not be null\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MDMyNw==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369640327", "bodyText": "this should be a separate method, I initially thought this would be a thing that's called as a refreshable (which is weird). Then refer to it via a method reference.", "author": "felixdesouza", "createdAt": "2020-01-22T15:47:44Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -531,11 +532,15 @@ static TimestampCache timestampCache(\n             AtlasDbConfig config,\n             MetricsManager metricsManager,\n             Supplier<AtlasDbRuntimeConfig> runtimeConfig,\n-            Optional<PhysicalPersistentStore> timestampStore) {\n+            Optional<PersistentStore> timestampStore) {\n         LongSupplier cacheSize = () -> runtimeConfig.get().getTimestampCacheSize();\n         Supplier<TimestampCache> timestampCacheSupplier = () ->", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java\nindex ff23493c0f..64a00d2df7 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java\n\n@@ -535,24 +532,26 @@ public abstract class TransactionManagers {\n             Optional<PersistentStore> timestampStore) {\n         LongSupplier cacheSize = () -> runtimeConfig.get().getTimestampCacheSize();\n         Supplier<TimestampCache> timestampCacheSupplier = () ->\n-                timestampStore.map(store ->\n-                        OffHeapTimestampCache.create(\n-                                store,\n-                                new TimestampsEntryMapper(),\n-                                metricsManager.getTaggedRegistry(),\n-                                cacheSize))\n-                        .orElseGet(() -> new DefaultTimestampCache(metricsManager.getRegistry(), cacheSize));\n+                constructTimestampCacheFromConfig(metricsManager, timestampStore, cacheSize);\n \n         return config.timestampCache().orElseGet(timestampCacheSupplier);\n     }\n \n-    private static TimestampCache instrumentedTimestampCache(\n-            AtlasDbConfig config,\n+    private static TimestampCache constructTimestampCacheFromConfig(\n             MetricsManager metricsManager,\n-            Supplier<AtlasDbRuntimeConfig> runtimeConfig,\n-            Optional<PersistentStore> timestampStore) {\n-        TimestampCache timestampCache = timestampCache(config, metricsManager, runtimeConfig, timestampStore);\n+            Optional<PersistentStore> timestampStore,\n+            LongSupplier cacheSize) {\n+        return timestampStore.map(store ->\n+                OffHeapTimestampCache.create(\n+                        store,\n+                        metricsManager.getTaggedRegistry(),\n+                        cacheSize))\n+                .orElseGet(() -> new DefaultTimestampCache(metricsManager.getRegistry(), cacheSize));\n+    }\n \n+    private static TimestampCache instrumentTimestampCache(\n+            MetricsManager metricsManager,\n+            TimestampCache timestampCache) {\n         return AtlasDbMetrics.instrumentTimed(\n                 metricsManager.getRegistry(),\n                 TimestampCache.class,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MTAyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369641025", "bodyText": "just use id.", "author": "felixdesouza", "createdAt": "2020-01-22T15:48:46Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+import okio.ByteString;\n+\n+public interface PersistentStore extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. A space of key-value pairs is analogous to a\n+     * PostgreSQL table of RocksdDb Column family. Handle is linked with one underlying store space.\n+     */\n+    @Value.Immutable\n+    interface Handle {\n+        UUID uniqueName();", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MTU1NA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369641554", "bodyText": "also have a static method that creates a new Handle by generating a random uuid.", "author": "felixdesouza", "createdAt": "2020-01-22T15:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MTAyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwOTg1OA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370009858", "bodyText": "Added.", "author": "OStevan", "createdAt": "2020-01-23T09:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0MTAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex bd68374b56..3d14b2e64b 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -32,11 +32,15 @@ import okio.ByteString;\n public interface PersistentStore extends AutoCloseable {\n     /**\n      * Represents a handle to the underlying space of key-value pairs. A space of key-value pairs is analogous to a\n-     * PostgreSQL table of RocksdDb Column family. Handle is linked with one underlying store space.\n+     * PostgreSQL table or RocksdDb column family. Handle is linked with one underlying store space.\n      */\n     @Value.Immutable\n     interface Handle {\n-        UUID uniqueName();\n+        UUID id();\n+    }\n+\n+    static Handle buildHandle() {\n+        return ImmutableHandle.builder().id(UUID.randomUUID()).build();\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY0ODQ4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r369648485", "bodyText": "nit:\nassertThatNullPointerException()\n  .isThrownBy(() -> ...);\nreads a bit better from left to right top to bottom", "author": "felixdesouza", "createdAt": "2020-01-22T16:00:27Z", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/cache/TimestampsEntryMapperTests.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.table.description.ValueType;\n+import com.palantir.logsafe.exceptions.SafeNullPointerException;\n+\n+import okio.ByteString;\n+\n+public final class TimestampsEntryMapperTests {\n+    private static final ByteString KEY = ByteString.of(ValueType.VAR_LONG.convertFromJava(1L));\n+    private TimestampsEntryMapper timestampsEntryMapper = new TimestampsEntryMapper();\n+\n+    @Test\n+    public void keyCorrectlyMapped() {\n+        ByteString serializedKey = timestampsEntryMapper.serializeKey(1L);\n+        assertThat(serializedKey)\n+                .isEqualByComparingTo(KEY);\n+        assertThat(timestampsEntryMapper.deserializeKey(KEY))\n+                .isEqualTo(1L);\n+    }\n+\n+    @Test\n+    public void failsOnNulls() {\n+        assertThatThrownBy(() -> timestampsEntryMapper.deserializeKey(null))\n+                .isInstanceOf(SafeNullPointerException.class);", "originalCommit": "e2a9cc1e69fe17fb70dfba709e6113fbfe0b9dd9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "chunk": "diff --git a/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/TimestampsEntryMapperTests.java b/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/TimestampsEntryMapperTests.java\ndeleted file mode 100644\nindex 01d8274ae7..0000000000\n--- a/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/TimestampsEntryMapperTests.java\n+++ /dev/null\n\n@@ -1,58 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.atlasdb.cache;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-\n-import org.junit.Test;\n-\n-import com.palantir.atlasdb.table.description.ValueType;\n-import com.palantir.logsafe.exceptions.SafeNullPointerException;\n-\n-import okio.ByteString;\n-\n-public final class TimestampsEntryMapperTests {\n-    private static final ByteString KEY = ByteString.of(ValueType.VAR_LONG.convertFromJava(1L));\n-    private TimestampsEntryMapper timestampsEntryMapper = new TimestampsEntryMapper();\n-\n-    @Test\n-    public void keyCorrectlyMapped() {\n-        ByteString serializedKey = timestampsEntryMapper.serializeKey(1L);\n-        assertThat(serializedKey)\n-                .isEqualByComparingTo(KEY);\n-        assertThat(timestampsEntryMapper.deserializeKey(KEY))\n-                .isEqualTo(1L);\n-    }\n-\n-    @Test\n-    public void failsOnNulls() {\n-        assertThatThrownBy(() -> timestampsEntryMapper.deserializeKey(null))\n-                .isInstanceOf(SafeNullPointerException.class);\n-        assertThatThrownBy(() -> timestampsEntryMapper.deserializeValue(null, ByteString.encodeUtf8(\"bla\")))\n-                .isInstanceOf(SafeNullPointerException.class);\n-        assertThatThrownBy(() -> timestampsEntryMapper.deserializeValue(1L, null))\n-                .isInstanceOf(SafeNullPointerException.class);\n-    }\n-\n-    @Test\n-    public void deltaEncoded() {\n-        ByteString value = timestampsEntryMapper.serializeValue(1L, 3L);\n-        assertThat(timestampsEntryMapper.deserializeValue(2L, value))\n-                .isEqualTo(4L);\n-    }\n-}\n"}}, {"oid": "3ba5418bfb1f3439d5424d32c75954e0ce13e213", "url": "https://github.com/palantir/atlasdb/commit/3ba5418bfb1f3439d5424d32c75954e0ce13e213", "message": "First fixes.", "committedDate": "2020-01-23T09:30:44Z", "type": "commit"}, {"oid": "b9a8c57eb4fc6859524a8c74f6ab7532f6c8bfb8", "url": "https://github.com/palantir/atlasdb/commit/b9a8c57eb4fc6859524a8c74f6ab7532f6c8bfb8", "message": "Package visibility for handle impl.", "committedDate": "2020-01-23T09:33:32Z", "type": "commit"}, {"oid": "9e47c89cf005843d4b491865f7fbf65138ac6cd1", "url": "https://github.com/palantir/atlasdb/commit/9e47c89cf005843d4b491865f7fbf65138ac6cd1", "message": "Split encoding.", "committedDate": "2020-01-23T09:36:54Z", "type": "commit"}, {"oid": "f2245815646b0e9910789e1449307198e456d7ed", "url": "https://github.com/palantir/atlasdb/commit/f2245815646b0e9910789e1449307198e456d7ed", "message": "Removed new line.", "committedDate": "2020-01-23T10:48:37Z", "type": "commit"}, {"oid": "e758c1baa836bc01ba45c832c965b767ec05e6b2", "url": "https://github.com/palantir/atlasdb/commit/e758c1baa836bc01ba45c832c965b767ec05e6b2", "message": "Moved serialization to putter.", "committedDate": "2020-01-23T10:57:24Z", "type": "commit"}, {"oid": "4cb32f92e9d1dce3782a2c4e62c7d3023a8c6080", "url": "https://github.com/palantir/atlasdb/commit/4cb32f92e9d1dce3782a2c4e62c7d3023a8c6080", "message": "Fix error.", "committedDate": "2020-01-23T11:51:54Z", "type": "commit"}, {"oid": "58695d502f11ea1b06be3257ea0483dca0e005b0", "url": "https://github.com/palantir/atlasdb/commit/58695d502f11ea1b06be3257ea0483dca0e005b0", "message": "Fix naming.", "committedDate": "2020-01-23T12:32:17Z", "type": "commit"}, {"oid": "41a1bb4ee863be30da4a7cfce6c92f291933bb12", "url": "https://github.com/palantir/atlasdb/commit/41a1bb4ee863be30da4a7cfce6c92f291933bb12", "message": "Simplify.", "committedDate": "2020-01-23T12:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDEwMTQ0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370101442", "bodyText": "it's not sufficient to test it like this, because there's nothing that says that the delta encoding is correct, only that when you serialise and deserialise it's correct.\nYou want something along the lines of a mock of the LongEntryMapper which receives delta encoded inputs, etc.", "author": "felixdesouza", "createdAt": "2020-01-23T12:57:17Z", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/cache/DeltaEncodingTimestampEntryMapperTests.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatNullPointerException;\n+\n+import org.junit.Test;\n+\n+import com.palantir.atlasdb.table.description.ValueType;\n+\n+import okio.ByteString;\n+\n+public final class DeltaEncodingTimestampEntryMapperTests {\n+    private final OffHeapTimestampCache.EntryMapper<Long, Long> mapper =\n+            new DeltaEncodingTimestampEntryMapper(new LongEntryMapper());\n+\n+    @Test\n+    public void failsOnNulls() {\n+        assertThatNullPointerException()\n+                .isThrownBy(() -> mapper.deserializeKey(null));\n+        assertThatNullPointerException()\n+                .isThrownBy(() -> mapper.deserializeValue(null, toByteString(4L)));\n+        assertThatNullPointerException()\n+                .isThrownBy(() -> mapper.deserializeValue(toByteString(2L), null));\n+    }\n+\n+    @Test\n+    public void encodedValue() {", "originalCommit": "41a1bb4ee863be30da4a7cfce6c92f291933bb12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE4MDkyMg==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370180922", "bodyText": "Refactored tests.", "author": "OStevan", "createdAt": "2020-01-23T15:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDEwMTQ0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "8a6f1ff6b2424f25dc18b43d397de26590ec05be", "chunk": "diff --git a/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/DeltaEncodingTimestampEntryMapperTests.java b/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/DeltaEncodingTimestampEntryMapperTests.java\nindex c702461da2..7d33e480b9 100644\n--- a/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/DeltaEncodingTimestampEntryMapperTests.java\n+++ b/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/DeltaEncodingTimestampEntryMapperTests.java\n\n@@ -47,6 +47,18 @@ public final class DeltaEncodingTimestampEntryMapperTests {\n                 .isEqualTo(3L);\n     }\n \n+    @Test\n+    public void valueEncodedAsDelta() {\n+        assertThat(mapper.serializeValue(1L, 3L))\n+                .isEqualByComparingTo(toByteString(2L));\n+    }\n+\n+    @Test\n+    public void valueDecodedWithDelta() {\n+        assertThat(mapper.deserializeValue(toByteString(1L), toByteString(4L)))\n+                .isEqualTo(5L);\n+    }\n+\n     private static ByteString toByteString(long value) {\n         return ByteString.of(ValueType.VAR_LONG.convertFromJava(value));\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDExNzg1OA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370117858", "bodyText": "on second thought this is weird, a persistent store is a property of a particular timestamp cache, to get things setup correctly you have a weird ternary setup. If you're going to put the timestamp store through which requires manual wiring, then you might as well setup the timestamp cache properly.", "author": "felixdesouza", "createdAt": "2020-01-23T13:32:59Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java", "diffHunk": "@@ -535,24 +532,26 @@ static TimestampCache timestampCache(\n             Optional<PersistentStore> timestampStore) {", "originalCommit": "41a1bb4ee863be30da4a7cfce6c92f291933bb12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDEzMjc2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370132761", "bodyText": "Reverted to original logic for setting up the cache.", "author": "OStevan", "createdAt": "2020-01-23T14:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDExNzg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "bc1aeff8881634c4a01de6403c2e22554cd0c9af", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java\nindex 64a00d2df7..f11375fa11 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/TransactionManagers.java\n\n@@ -507,58 +495,6 @@ public abstract class TransactionManagers {\n         return transactionManager;\n     }\n \n-    @VisibleForTesting\n-    static Optional<PersistentStore> constructPersistentStoreIfConfigured(\n-            AtlasDbConfig config,\n-            PersistentStorageFactory persistentStorageFactory,\n-            @Output List<AutoCloseable> closeables) {\n-        return initializeCloseable(\n-                config.persistentStorage().map(storageConfig -> {\n-                    Preconditions.checkState(\n-                            storageConfig instanceof RocksDbPersistentStorageConfig,\n-                            \"Storage config is not RocksDbPersistentStorageConfig.\",\n-                            SafeArg.of(\"configClass\", storageConfig.getClass()));\n-                    return persistentStorageFactory\n-                            .constructPersistentStore((RocksDbPersistentStorageConfig) storageConfig);\n-                }),\n-                closeables);\n-    }\n-\n-    @VisibleForTesting\n-    static TimestampCache timestampCache(\n-            AtlasDbConfig config,\n-            MetricsManager metricsManager,\n-            Supplier<AtlasDbRuntimeConfig> runtimeConfig,\n-            Optional<PersistentStore> timestampStore) {\n-        LongSupplier cacheSize = () -> runtimeConfig.get().getTimestampCacheSize();\n-        Supplier<TimestampCache> timestampCacheSupplier = () ->\n-                constructTimestampCacheFromConfig(metricsManager, timestampStore, cacheSize);\n-\n-        return config.timestampCache().orElseGet(timestampCacheSupplier);\n-    }\n-\n-    private static TimestampCache constructTimestampCacheFromConfig(\n-            MetricsManager metricsManager,\n-            Optional<PersistentStore> timestampStore,\n-            LongSupplier cacheSize) {\n-        return timestampStore.map(store ->\n-                OffHeapTimestampCache.create(\n-                        store,\n-                        metricsManager.getTaggedRegistry(),\n-                        cacheSize))\n-                .orElseGet(() -> new DefaultTimestampCache(metricsManager.getRegistry(), cacheSize));\n-    }\n-\n-    private static TimestampCache instrumentTimestampCache(\n-            MetricsManager metricsManager,\n-            TimestampCache timestampCache) {\n-        return AtlasDbMetrics.instrumentTimed(\n-                metricsManager.getRegistry(),\n-                TimestampCache.class,\n-                timestampCache,\n-                MetricRegistry.name(timestampCache.getClass()));\n-    }\n-\n     private static Callback<TransactionManager> createClearsTable() {\n         TableReference clearsTableRef = TargetedSweepTableFactory.of().getTableClearsTable(null).getTableRef();\n         byte[] clearsTableMetadata = TargetedSweepSchema.INSTANCE.getLatestSchema()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDExODU0MA==", "url": "https://github.com/palantir/atlasdb/pull/4522#discussion_r370118540", "bodyText": "move it into Handle", "author": "felixdesouza", "createdAt": "2020-01-23T13:34:19Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.persistent.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.annotation.Nonnull;\n+\n+import org.immutables.value.Value;\n+\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+import okio.ByteString;\n+\n+public interface PersistentStore extends AutoCloseable {\n+    /**\n+     * Represents a handle to the underlying space of key-value pairs. A space of key-value pairs is analogous to a\n+     * PostgreSQL table or RocksdDb column family. Handle is linked with one underlying store space.\n+     */\n+    @Value.Immutable\n+    @Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n+    interface Handle {\n+        UUID id();\n+    }\n+\n+    static Handle buildHandle() {", "originalCommit": "41a1bb4ee863be30da4a7cfce6c92f291933bb12", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79be022f0f2d7958791fe72120d4178451a2e134", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\nindex 34ef3d7daf..d768b51e61 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/persistent/api/PersistentStore.java\n\n@@ -38,10 +38,10 @@ public interface PersistentStore extends AutoCloseable {\n     @Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n     interface Handle {\n         UUID id();\n-    }\n \n-    static Handle buildHandle() {\n-        return ImmutableHandle.builder().id(UUID.randomUUID()).build();\n+        static Handle newHandle() {\n+            return ImmutableHandle.builder().id(UUID.randomUUID()).build();\n+        }\n     }\n \n     /**\n"}}, {"oid": "bc1aeff8881634c4a01de6403c2e22554cd0c9af", "url": "https://github.com/palantir/atlasdb/commit/bc1aeff8881634c4a01de6403c2e22554cd0c9af", "message": "Remove code for automatic configuration.", "committedDate": "2020-01-23T13:44:43Z", "type": "commit"}, {"oid": "79be022f0f2d7958791fe72120d4178451a2e134", "url": "https://github.com/palantir/atlasdb/commit/79be022f0f2d7958791fe72120d4178451a2e134", "message": "Move build handle.", "committedDate": "2020-01-23T13:47:33Z", "type": "commit"}, {"oid": "8a6f1ff6b2424f25dc18b43d397de26590ec05be", "url": "https://github.com/palantir/atlasdb/commit/8a6f1ff6b2424f25dc18b43d397de26590ec05be", "message": "Added tests for delta encoding.", "committedDate": "2020-01-23T13:59:22Z", "type": "commit"}, {"oid": "f99d92a6c174e52321dd77a0693483f22a511abe", "url": "https://github.com/palantir/atlasdb/commit/f99d92a6c174e52321dd77a0693483f22a511abe", "message": "Better tests.", "committedDate": "2020-01-23T14:15:03Z", "type": "commit"}]}