{"pr_number": 4702, "pr_title": "[PDS-115789] API Contracts for Snapshot Transaction Methods", "pr_createdAt": "2020-04-08T18:07:11Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4702", "timeline": [{"oid": "aa0bf92ba103d621954de1f1f434994fc5060c93", "url": "https://github.com/palantir/atlasdb/commit/aa0bf92ba103d621954de1f1f434994fc5060c93", "message": "Transaction javadoc", "committedDate": "2020-04-08T17:45:33Z", "type": "commit"}, {"oid": "551203299cf154633e17b09fb9b0a5c965375b1e", "url": "https://github.com/palantir/atlasdb/commit/551203299cf154633e17b09fb9b0a5c965375b1e", "message": "Add generated changelog entries", "committedDate": "2020-04-08T17:45:33Z", "type": "commit"}, {"oid": "af970ff523f3e57f30bd9f52bdaf1645bdecb9c4", "url": "https://github.com/palantir/atlasdb/commit/af970ff523f3e57f30bd9f52bdaf1645bdecb9c4", "message": ".", "committedDate": "2020-04-09T08:44:34Z", "type": "commit"}, {"oid": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032", "url": "https://github.com/palantir/atlasdb/commit/d0e2b1bc200bc1bf428ef7c9a4978d9a21043032", "message": "Merge branch 'jkong/apis' of github.com:palantir/atlasdb into jkong/apis", "committedDate": "2020-04-09T08:45:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MzAwNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406173007", "bodyText": "@jkozlowski notes: does same elements here mean the same objects, or just arrays that are equal in terms of Arrays#equals()? I intended the former, historically the behaviour of getRowsColumnRange is as follows:\n    @Test\n    public void identity() {\n        txMgr.runTaskWithRetry((tx) -> {\n            put(tx, \"tom\", \"aaa\", \"42\");\n            return null;\n        });\n\n        txMgr.runTaskWithRetry((tx) -> {\n            byte[] b1 = PtBytes.toBytes(\"tom\");\n            Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> iterators = tx.getRowsColumnRange(TEST_TABLE,\n                    ImmutableList.of(b1),\n                    BatchColumnRangeSelection.create(PtBytes.EMPTY_BYTE_ARRAY, PtBytes.EMPTY_BYTE_ARRAY, 10));\n\n            byte[] b1v2 = PtBytes.toBytes(\"tom\");\n            assertThat(iterators.get(b1)).isNotNull(); // Passes\n            assertThat(iterators.get(b1v2)).isNotNull(); // Fails\n            return null;\n        });\n    }\n\nWe should probably be stricter/more explicit that the identity of the rows must be equal, will incorporate this.", "author": "jeremyk-91", "createdAt": "2020-04-09T12:37:02Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,92 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows},\n+     * even if there are rows where no columns match the predicate.", "originalCommit": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDg4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406174883", "bodyText": "To be clear, unless people feel strongly about this I have no intention of codifying the failure of the second assertion above - but will say that the map must be accessed by the original rows passed in, and using other rows (even if equal in terms of byte arrays to an original row) is undefined behaviour.", "author": "jeremyk-91", "createdAt": "2020-04-09T12:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MzAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwNDEzNA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406204134", "bodyText": "Yes, we should make it clear that pulling things out by the original byte arrays is fine.", "author": "jkozlowski", "createdAt": "2020-04-09T13:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MzAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM1MTY3MA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406351670", "bodyText": "Agreed. My point is also that pulling things out by means other than the byte arrays is a bad idea, though I don't want to guarantee that it will fail.", "author": "jeremyk-91", "createdAt": "2020-04-09T17:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MzAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "8e204f59ee8f5970ed48f27fb06128bddeccf02e", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 7b6dd307e9..5860cd31a9 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -46,7 +46,8 @@ public interface Transaction {\n      * columns according to the provided {@link ColumnSelection}.\n      *\n      * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n-     * {@code rows} is irrelevant.\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n      * {@link Map#keySet()} of the output map at all.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwNDY0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406204647", "bodyText": "For this one though, looking up in the returned SortedMap should obviously be allowed with the original byte array, as well as a new byte array with same contents.", "author": "jkozlowski", "createdAt": "2020-04-09T13:30:12Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,92 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(", "originalCommit": "d0e2b1bc200bc1bf428ef7c9a4978d9a21043032", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM1MjAyNg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r406352026", "bodyText": "Yep. Pretty sure that's the behaviour, this one is governed by UnsignedBytes.lexicographicalComparator. I can specify some of that.", "author": "jeremyk-91", "createdAt": "2020-04-09T17:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwNDY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8e204f59ee8f5970ed48f27fb06128bddeccf02e", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 7b6dd307e9..5860cd31a9 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -46,7 +46,8 @@ public interface Transaction {\n      * columns according to the provided {@link ColumnSelection}.\n      *\n      * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n-     * {@code rows} is irrelevant.\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n      * {@link Map#keySet()} of the output map at all.\n"}}, {"oid": "8e204f59ee8f5970ed48f27fb06128bddeccf02e", "url": "https://github.com/palantir/atlasdb/commit/8e204f59ee8f5970ed48f27fb06128bddeccf02e", "message": "Clarifications, plus a demonstrative test", "committedDate": "2020-04-15T18:54:03Z", "type": "commit"}, {"oid": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "url": "https://github.com/palantir/atlasdb/commit/53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "message": "wat", "committedDate": "2020-04-15T18:55:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1MTY3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419851672", "bodyText": "It's worth a test (array of tests) for this, I think. Specifically, what do I get back if I e.g. delete a cell in a txn and then read the row?", "author": "j-baker", "createdAt": "2020-05-05T04:01:18Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the", "originalCommit": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa54358395ca0845c8078be8b687232896499ddc", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 5860cd31a9..df222de3dc 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -37,6 +37,11 @@ import com.palantir.common.base.BatchingVisitable;\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDEwNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854107", "bodyText": "'with any byte array that is equivalent according to Arrays.equals(byte[], byte[])'.", "author": "j-baker", "createdAt": "2020-05-05T04:13:46Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte", "originalCommit": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMzc5NA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r420103794", "bodyText": "Yep, of course the same array is equal to itself!", "author": "jeremyk-91", "createdAt": "2020-05-05T13:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "fa54358395ca0845c8078be8b687232896499ddc", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 5860cd31a9..df222de3dc 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -37,6 +37,11 @@ import com.palantir.common.base.BatchingVisitable;\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDI3MA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854270", "bodyText": "of columns?", "author": "j-baker", "createdAt": "2020-05-05T04:14:30Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.", "originalCommit": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwNDk2OA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r420104968", "bodyText": "Yep, will state that explicitly.", "author": "jeremyk-91", "createdAt": "2020-05-05T13:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDI3MA=="}], "type": "inlineReview", "revised_code": {"commit": "fa54358395ca0845c8078be8b687232896499ddc", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 5860cd31a9..df222de3dc 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -37,6 +37,11 @@ import com.palantir.common.base.BatchingVisitable;\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDQ1MA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854450", "bodyText": "Can we tighten this up? It'd be easy to (under the hood) just wrap with an ImmutableSortedMap and so have a consistent contract between this and getRows.", "author": "j-baker", "createdAt": "2020-05-05T04:15:31Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.", "originalCommit": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDUzMQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419854531", "bodyText": "Like, arguably we should have a consistent contract between all our methods.", "author": "j-baker", "createdAt": "2020-05-05T04:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI0MjUwNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r420242507", "bodyText": "Yep, changed this (and added appropriate tests).", "author": "jeremyk-91", "createdAt": "2020-05-05T16:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NDQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "fa54358395ca0845c8078be8b687232896499ddc", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 5860cd31a9..df222de3dc 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -37,6 +37,11 @@ import com.palantir.common.base.BatchingVisitable;\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTI1OA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419855258", "bodyText": "Can we tighten this up as well? You're right, of course, but all hell breaks loose if this happens. So when you see something like this, I think it's on us to actually clean the contract. In this case, internally we should do ImmutableList.copyOf.", "author": "j-baker", "createdAt": "2020-05-05T04:19:25Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, behaviour is undefined.", "originalCommit": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTMzNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419855337", "bodyText": "(assuming that this is not lazy, in which case the contract might need tidying up).", "author": "j-baker", "createdAt": "2020-05-05T04:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI0Mjk0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r420242942", "bodyText": "Yeah, added an internal ImmutableList.copyOf, and also a funky test that actually gives unstable iteration order.", "author": "jeremyk-91", "createdAt": "2020-05-05T16:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa54358395ca0845c8078be8b687232896499ddc", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 5860cd31a9..df222de3dc 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -37,6 +37,11 @@ import com.palantir.common.base.BatchingVisitable;\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTU5OQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r419855599", "bodyText": "Likewise. Basically, if we get each method to the point where you can always lookup in the map via any equivalent byte array, then we can just shove it in a single comment at the top and avoid it on each method.", "author": "j-baker", "createdAt": "2020-05-05T04:20:55Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -41,25 +41,95 @@\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant. Access to the returned {@link SortedMap} is permitted both with the original byte\n+     * array, as well as with byte arrays that are equal in terms of {@link java.util.Arrays#equals(byte[], byte[])}.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate, sorted on\n+     * (ascending) byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, behaviour is undefined.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link Iterator}s are guaranteed to return cells matching the predicate, sorted on (ascending) byte\n+     * ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has the same elements as {@code rows} by\n+     * identity, even if there are rows where no columns match the predicate. Random access for the returned map\n+     * should ONLY be performed through the original byte arrays that were passed in.", "originalCommit": "53a4d0bbdfd9fe540e11ab0ec5f1e426e1bc9b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI0MzExMQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r420243111", "bodyText": "As above: this was done.", "author": "jeremyk-91", "createdAt": "2020-05-05T16:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg1NTU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa54358395ca0845c8078be8b687232896499ddc", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 5860cd31a9..df222de3dc 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -37,6 +37,11 @@ import com.palantir.common.base.BatchingVisitable;\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n"}}, {"oid": "fa54358395ca0845c8078be8b687232896499ddc", "url": "https://github.com/palantir/atlasdb/commit/fa54358395ca0845c8078be8b687232896499ddc", "message": "Add test and switch to ISM backing for iterator", "committedDate": "2020-05-05T14:28:01Z", "type": "commit"}, {"oid": "11c6ad653b62329f9f1cd1a83da74822c2ce67da", "url": "https://github.com/palantir/atlasdb/commit/11c6ad653b62329f9f1cd1a83da74822c2ce67da", "message": "Simpler docs changes", "committedDate": "2020-05-05T14:32:43Z", "type": "commit"}, {"oid": "00953384d9e9a7d129affd262178fda16f44c789", "url": "https://github.com/palantir/atlasdb/commit/00953384d9e9a7d129affd262178fda16f44c789", "message": "Patch tests", "committedDate": "2020-05-05T15:36:48Z", "type": "commit"}, {"oid": "7af6a2cfbf843a9c20d0a0f71b54e2834ba42e95", "url": "https://github.com/palantir/atlasdb/commit/7af6a2cfbf843a9c20d0a0f71b54e2834ba42e95", "message": "Avoid param reassignment", "committedDate": "2020-05-05T16:40:03Z", "type": "commit"}, {"oid": "3ee6cfb28b352e235933924f61adefaeae379f80", "url": "https://github.com/palantir/atlasdb/commit/3ee6cfb28b352e235933924f61adefaeae379f80", "message": "Define getRows semantics", "committedDate": "2020-05-05T17:58:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNzM1Nw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424237357", "bodyText": "nit: i think this is more clear as rowKey.clone()", "author": "j-baker", "createdAt": "2020-05-13T07:45:55Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java", "diffHunk": "@@ -1309,6 +1318,149 @@ public void testGetRangesPaging() {\n         verifyAllGetRangesImplsNumRanges(t, ranges, ImmutableList.of(\"v\"));\n     }\n \n+    @Test\n+    public void getRowsAccessibleThroughCopies() {\n+        Transaction t = startTransaction();\n+        byte[] rowKey = row(0);\n+        byte[] value = value(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(\n+                Cell.create(rowKey, column(0)), value));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> result =\n+                t.getRows(TEST_TABLE, ImmutableList.of(rowKey), ColumnSelection.all());\n+        assertThat(result.get(rowKey))\n+                .as(\"it should be possible to get a row from getRows with a passed-in byte array\")\n+                .isNotNull()\n+                .satisfies(rowResult ->\n+                        assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n+\n+        byte[] rowKeyCopy = row(0);", "originalCommit": "3ee6cfb28b352e235933924f61adefaeae379f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNzUwMA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424237500", "bodyText": "i suppose, same as in other places", "author": "j-baker", "createdAt": "2020-05-13T07:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwMDQ4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424600482", "bodyText": "Alright, yeah agree that reads better. Will change.", "author": "jeremyk-91", "createdAt": "2020-05-13T17:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNzM1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "cbc61866156c982708ed4a3776224501618692d6", "chunk": "diff --git a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\nindex 73d3571224..560a0f431b 100644\n--- a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\n+++ b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\n\n@@ -1336,7 +1336,7 @@ public abstract class AbstractTransactionTest extends TransactionTestSetup {\n                 .satisfies(rowResult ->\n                         assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n \n-        byte[] rowKeyCopy = row(0);\n+        byte[] rowKeyCopy = rowKey.clone();\n         assertThat(rowKeyCopy).isNotSameAs(rowKey);\n         assertThat(result.get(rowKeyCopy))\n                 .as(\"it should be possible to get a row from getRows with a copy of a passed-in byte array\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzODcxMw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424238713", "bodyText": "\ud83e\udd23", "author": "j-baker", "createdAt": "2020-05-13T07:48:18Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterable<T> implements Iterable<T> {", "originalCommit": "3ee6cfb28b352e235933924f61adefaeae379f80", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cbc61866156c982708ed4a3776224501618692d6", "chunk": "diff --git a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java\nindex e0eac69f54..b5fffa922e 100644\n--- a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java\n+++ b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java\n\n@@ -17,24 +17,27 @@\n package com.palantir.atlasdb.transaction.impl;\n \n import java.util.Collection;\n-import java.util.Collections;\n+import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n \n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Lists;\n+import com.google.common.collect.Collections2;\n+import com.google.common.collect.Iterables;\n \n public class UnstableOrderedIterable<T> implements Iterable<T> {\n-    private final List<T> underlying;\n+    private final Iterator<List<T>> orderingIterator;\n \n-    public UnstableOrderedIterable(Collection<T> underlying) {\n-        this.underlying = ImmutableList.copyOf(underlying);\n+    private UnstableOrderedIterable(Iterator<List<T>> orderingIterator) {\n+        this.orderingIterator = orderingIterator;\n+    }\n+\n+    public static <T> Iterable<T> create(Collection<T> underlying, Comparator<T> comparator) {\n+        return new UnstableOrderedIterable<T>(\n+                Iterables.cycle(Collections2.orderedPermutations(underlying, comparator)).iterator());\n     }\n \n     @Override\n     public Iterator<T> iterator() {\n-        List<T> copy = Lists.newArrayList(underlying);\n-        Collections.shuffle(copy);\n-        return copy.iterator();\n+        return orderingIterator.next().iterator();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzOTIwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424239205", "bodyText": "List iterationOrder = ImmutableList.copyOf(numbersIterable);\nList secondIterationOrder = ImmutableList.copyOf(numbersIterable);", "author": "j-baker", "createdAt": "2020-05-13T07:49:10Z", "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterableTest {\n+    @Test\n+    public void orderingIsUnstable() {\n+        // Strobes once in 1000000! times. We can live with that.\n+        List<Integer> numbers = IntStream.range(0, 1000000).boxed().collect(Collectors.toList());\n+        Iterable<Integer> numbersIterable = new UnstableOrderedIterable<>(numbers);\n+\n+        List<Integer> iterationOrder = Lists.newArrayList();\n+        numbersIterable.iterator().forEachRemaining(iterationOrder::add);\n+\n+        List<Integer> secondIterationOrder = Lists.newArrayList();\n+        numbersIterable.iterator().forEachRemaining(secondIterationOrder::add);", "originalCommit": "3ee6cfb28b352e235933924f61adefaeae379f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwNjQ5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424606493", "bodyText": "Will change (in the end followed your above outline). Nice", "author": "jeremyk-91", "createdAt": "2020-05-13T17:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzOTIwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "cbc61866156c982708ed4a3776224501618692d6", "chunk": "diff --git a/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java b/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java\nindex 1e02177acb..a15639ecbc 100644\n--- a/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java\n+++ b/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java\n\n@@ -18,31 +18,23 @@ package com.palantir.atlasdb.transaction.impl;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.Comparator;\n import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n \n import org.junit.Test;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n \n public class UnstableOrderedIterableTest {\n     @Test\n     public void orderingIsUnstable() {\n-        // Strobes once in 1000000! times. We can live with that.\n-        List<Integer> numbers = IntStream.range(0, 1000000).boxed().collect(Collectors.toList());\n-        Iterable<Integer> numbersIterable = new UnstableOrderedIterable<>(numbers);\n-\n-        List<Integer> iterationOrder = Lists.newArrayList();\n-        numbersIterable.iterator().forEachRemaining(iterationOrder::add);\n-\n-        List<Integer> secondIterationOrder = Lists.newArrayList();\n-        numbersIterable.iterator().forEachRemaining(secondIterationOrder::add);\n-\n-        assertThat(iterationOrder).isNotEqualTo(secondIterationOrder);\n-\n-        // hasSameElementsAs() etc. seem to be inefficient\n-        assertThat(ImmutableSet.copyOf(iterationOrder)).isEqualTo(ImmutableSet.copyOf(numbers));\n+        Iterable<Integer> numbers = UnstableOrderedIterable.create(ImmutableList.of(1, 2), Comparator.naturalOrder());\n+        assertThat(ImmutableList.copyOf(numbers)).containsExactly(1, 2);\n+        assertThat(ImmutableList.copyOf(numbers)).containsExactly(2, 1);\n+        assertThat(ImmutableList.copyOf(numbers)).containsExactly(1, 2);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MDEwNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424240107", "bodyText": "nope nope nope. Nondeterministic tests are bad. In this case you have to create 1 million objects.\nInstead, UnstableOrderedIterable should take as a field a Random, and you can instantiate that deterministically here, use the version of shuffle that takes a Random and guarantee it 100% of the time.", "author": "j-baker", "createdAt": "2020-05-13T07:50:38Z", "path": "atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterableTest {\n+    @Test\n+    public void orderingIsUnstable() {\n+        // Strobes once in 1000000! times. We can live with that.\n+        List<Integer> numbers = IntStream.range(0, 1000000).boxed().collect(Collectors.toList());", "originalCommit": "3ee6cfb28b352e235933924f61adefaeae379f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MDI1NA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424240254", "bodyText": "with 2 elements", "author": "j-baker", "createdAt": "2020-05-13T07:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MTk0MA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424241940", "bodyText": "Actually, you're doing shuffling here, instead you should have UnstableOrderedIterable return OrderedPermutations.\nthe test I'd like to see here is one that basically reads:\nIterable<Integer> numbers = new UnstableOrderedIterable<>(ImmutableList.of(1, 2));\nassertThat(ImmutableList.copyOf(numbers)).containsExactly(1, 2);\nassertThat(ImmutableList.copyOf(numbers)).containsExactly(2, 1);", "author": "j-baker", "createdAt": "2020-05-13T07:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MDEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "cbc61866156c982708ed4a3776224501618692d6", "chunk": "diff --git a/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java b/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java\nindex 1e02177acb..a15639ecbc 100644\n--- a/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java\n+++ b/atlasdb-tests-shared/src/test/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterableTest.java\n\n@@ -18,31 +18,23 @@ package com.palantir.atlasdb.transaction.impl;\n \n import static org.assertj.core.api.Assertions.assertThat;\n \n+import java.util.Comparator;\n import java.util.List;\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n \n import org.junit.Test;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n \n public class UnstableOrderedIterableTest {\n     @Test\n     public void orderingIsUnstable() {\n-        // Strobes once in 1000000! times. We can live with that.\n-        List<Integer> numbers = IntStream.range(0, 1000000).boxed().collect(Collectors.toList());\n-        Iterable<Integer> numbersIterable = new UnstableOrderedIterable<>(numbers);\n-\n-        List<Integer> iterationOrder = Lists.newArrayList();\n-        numbersIterable.iterator().forEachRemaining(iterationOrder::add);\n-\n-        List<Integer> secondIterationOrder = Lists.newArrayList();\n-        numbersIterable.iterator().forEachRemaining(secondIterationOrder::add);\n-\n-        assertThat(iterationOrder).isNotEqualTo(secondIterationOrder);\n-\n-        // hasSameElementsAs() etc. seem to be inefficient\n-        assertThat(ImmutableSet.copyOf(iterationOrder)).isEqualTo(ImmutableSet.copyOf(numbers));\n+        Iterable<Integer> numbers = UnstableOrderedIterable.create(ImmutableList.of(1, 2), Comparator.naturalOrder());\n+        assertThat(ImmutableList.copyOf(numbers)).containsExactly(1, 2);\n+        assertThat(ImmutableList.copyOf(numbers)).containsExactly(2, 1);\n+        assertThat(ImmutableList.copyOf(numbers)).containsExactly(1, 2);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MzQ1OA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424243458", "bodyText": "Recommend this, makes for an easier test and guarantees the property you want.\npublic class UnstableOrderedIterable<T extends Comparable<? super T>> implements Iterable<T> {\n    private final Iterator<ImmutableList<T>> underlying;\n\n    public UnstableOrderedIterable(Collection<T> underlying) {\n        this.underlying = Iterables.cycle(Collections2.orderedPermutations(underlying)).iterator();\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return underlying.next();\n    }\n}", "author": "j-baker", "createdAt": "2020-05-13T07:56:07Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.transaction.impl;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Lists;\n+\n+public class UnstableOrderedIterable<T> implements Iterable<T> {\n+    private final List<T> underlying;\n+\n+    public UnstableOrderedIterable(Collection<T> underlying) {\n+        this.underlying = ImmutableList.copyOf(underlying);\n+    }\n+\n+    @Override\n+    public Iterator<T> iterator() {", "originalCommit": "3ee6cfb28b352e235933924f61adefaeae379f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYwNjg0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424606841", "bodyText": "Yep, this is nice. I implemented this (some small changes to allow a Comparator, but the basic idea is what you've got).", "author": "jeremyk-91", "createdAt": "2020-05-13T17:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0MzQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "cbc61866156c982708ed4a3776224501618692d6", "chunk": "diff --git a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java\nindex e0eac69f54..b5fffa922e 100644\n--- a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java\n+++ b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/UnstableOrderedIterable.java\n\n@@ -17,24 +17,27 @@\n package com.palantir.atlasdb.transaction.impl;\n \n import java.util.Collection;\n-import java.util.Collections;\n+import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n \n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Lists;\n+import com.google.common.collect.Collections2;\n+import com.google.common.collect.Iterables;\n \n public class UnstableOrderedIterable<T> implements Iterable<T> {\n-    private final List<T> underlying;\n+    private final Iterator<List<T>> orderingIterator;\n \n-    public UnstableOrderedIterable(Collection<T> underlying) {\n-        this.underlying = ImmutableList.copyOf(underlying);\n+    private UnstableOrderedIterable(Iterator<List<T>> orderingIterator) {\n+        this.orderingIterator = orderingIterator;\n+    }\n+\n+    public static <T> Iterable<T> create(Collection<T> underlying, Comparator<T> comparator) {\n+        return new UnstableOrderedIterable<T>(\n+                Iterables.cycle(Collections2.orderedPermutations(underlying, comparator)).iterator());\n     }\n \n     @Override\n     public Iterator<T> iterator() {\n-        List<T> copy = Lists.newArrayList(underlying);\n-        Collections.shuffle(copy);\n-        return copy.iterator();\n+        return orderingIterator.next().iterator();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTg4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424245883", "bodyText": "and, just to make sure... do other Transaction implementations such as CachedTransaction obey these constraints? I know we have AbstractTransactionTests, do those get run on CachedTransactions? Personally I'd be minded to write a 'contract validating transaction' which we can wrap all transactions in that checks the properties (though not in this PR).", "author": "j-baker", "createdAt": "2020-05-13T08:00:18Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**", "originalCommit": "3ee6cfb28b352e235933924f61adefaeae379f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDM1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424674359", "bodyText": "Is AbstractTransactionTest run on CachingTransactions: good flag. Not previously, but now it is - we've tested for almost all of the contractual nuances by now, and it passed all of the tests.", "author": "jeremyk-91", "createdAt": "2020-05-13T19:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDgwMA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r424674800", "bodyText": "Most of the others just delegate (or in the case of ReadTransaction delegate the relevant things), from a quick pass.", "author": "jeremyk-91", "createdAt": "2020-05-13T19:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE1NDA2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r425154063", "bodyText": "(Turns out there are some weird CircleCI issues that I can't reproduce locally around TMs being shut. I wouldn't block on this currently)", "author": "jeremyk-91", "createdAt": "2020-05-14T13:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0NTg4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 247b7e47eb..9b8845919a 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -54,9 +54,9 @@ public interface Transaction {\n      * {@code rows} is irrelevant.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n-     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n-     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n-     * existing in the key value service) will be absent.\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n      *\n      * @param tableRef table to load rows from\n      * @param rows rows to be loaded\n"}}, {"oid": "cbc61866156c982708ed4a3776224501618692d6", "url": "https://github.com/palantir/atlasdb/commit/cbc61866156c982708ed4a3776224501618692d6", "message": "CR feedback", "committedDate": "2020-05-13T17:25:02Z", "type": "commit"}, {"oid": "6f405b0108ecefae862c0e0463dd88bdf8e8e4c9", "url": "https://github.com/palantir/atlasdb/commit/6f405b0108ecefae862c0e0463dd88bdf8e8e4c9", "message": "Ordering of map test", "committedDate": "2020-05-13T17:32:38Z", "type": "commit"}, {"oid": "93ce6cd1ba63a9933e89fcbfde32be2eaa81a387", "url": "https://github.com/palantir/atlasdb/commit/93ce6cd1ba63a9933e89fcbfde32be2eaa81a387", "message": "MCTT", "committedDate": "2020-05-13T17:34:53Z", "type": "commit"}, {"oid": "b6480a6dfe6655ad2f67d43743810db2c71997cf", "url": "https://github.com/palantir/atlasdb/commit/b6480a6dfe6655ad2f67d43743810db2c71997cf", "message": "baseline", "committedDate": "2020-05-13T19:16:20Z", "type": "commit"}, {"oid": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "url": "https://github.com/palantir/atlasdb/commit/81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "message": "remove bad test", "committedDate": "2020-05-14T14:10:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0NDE4NA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433744184", "bodyText": "I think \"local\" might be an overloaded term for this. I would also maybe not mention key value service.\nWhat about: \"this accounts for writes and deletes done in this transaction: a row written to in this transaction will be present, and a row which is deleted in this transaction will be absent\"", "author": "jkozlowski", "createdAt": "2020-06-02T09:30:00Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written", "originalCommit": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5ODA4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433798085", "bodyText": "Local is used in some of the internal methods, though yeah that's more of an internal implementation term, so will change to \"in this transaction\".", "author": "jeremyk-91", "createdAt": "2020-06-02T11:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0NDE4NA=="}], "type": "inlineReview", "revised_code": {"commit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 247b7e47eb..9b8845919a 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -54,9 +54,9 @@ public interface Transaction {\n      * {@code rows} is irrelevant.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n-     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n-     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n-     * existing in the key value service) will be absent.\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n      *\n      * @param tableRef table to load rows from\n      * @param rows rows to be loaded\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0Nzk5Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433747992", "bodyText": "nit: \"which may be thought of as iterators over columns\". Unclear of the value of putting this here? you are linking to the interface, perhaps the interface should have this sentence?", "author": "jkozlowski", "createdAt": "2020-06-02T09:36:08Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)", "originalCommit": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1MTI2OA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433751268", "bodyText": "Just an idea, so can be noop: perhaps you don't actually want to use \"BatchingVisitable\" of \"BatchColumnRangeSelection\" and explain it thus:\n\"Returns a mapping of requested rows to corresponding columns in this table. Only columns matching the column predicate will be returned.\" @Jolyon-S  can provide better english.\nMaybe this reads worse, hard to say.", "author": "jkozlowski", "createdAt": "2020-06-02T09:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0Nzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMjM1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433802356", "bodyText": "I think changing this to the version without the classes seems reasonable.", "author": "jeremyk-91", "createdAt": "2020-06-02T11:21:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0Nzk5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 247b7e47eb..9b8845919a 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -54,9 +54,9 @@ public interface Transaction {\n      * {@code rows} is irrelevant.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n-     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n-     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n-     * existing in the key value service) will be absent.\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n      *\n      * @param tableRef table to load rows from\n      * @param rows rows to be loaded\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDEwMg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433754102", "bodyText": "Why does iteration order of the passed iterable need to be stable? Can we not pick one format for the return order and stick to it?", "author": "jkozlowski", "createdAt": "2020-06-02T09:46:46Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a", "originalCommit": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTQ3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433801472", "bodyText": "The return order for the stable case has to be the same order as was passed in (this was the core issue in PDS-115789, where an internal user did getRowsColumnRange(table, [B, A], cols, batch) and expected the cells for B to come back first).\nGeneralising this to iterables without a consistent ordering seemed awkward. We could guarantee something stronger (i.e. if rows does not have a stable ordering, the returned iterator will return cell-value pairs where rows are sorted according to the order of the first iteration over it, and columns ...), but it seems like an implementation detail I wouldn't want users to rely on, and it seems easy to break inadvertently.", "author": "jeremyk-91", "createdAt": "2020-06-02T11:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNzI4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434117287", "bodyText": "How about saying \"Returned iterator is in the order of rows iterable then cells lexicographically. If your iterable does not have a stable iterator (i.e. iteration order can change between different calls to .iterator()) the cells are ordered lexicographically, but the order of rows is undefined.\"\nAs in I would put emphasis on the correct case, but explain that things will explode if that doesn't hold.\nAs a broader question: could we deprecate this method and automatically try to rewrite user's code (or rather suggest a rewritten version, to be reviewed by devs).", "author": "jkozlowski", "createdAt": "2020-06-02T19:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjYyNA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434442624", "bodyText": "First: Putting emphasis on the normal case makes sense.\nSecond question: I don't think so - this method is used in production in a number of places, and in some KVS implementations does something better than \"concat the iterators from the Map returning methods\"", "author": "jeremyk-91", "createdAt": "2020-06-03T09:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDEwMg=="}], "type": "inlineReview", "revised_code": {"commit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 247b7e47eb..9b8845919a 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -54,9 +54,9 @@ public interface Transaction {\n      * {@code rows} is irrelevant.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n-     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n-     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n-     * existing in the key value service) will be absent.\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n      *\n      * @param tableRef table to load rows from\n      * @param rows rows to be loaded\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTE2MA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433755160", "bodyText": "We don't return BatchingVisitable here?", "author": "jkozlowski", "createdAt": "2020-06-02T09:48:36Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, the returned iterator will return cell-value pairs that are ordered within a row - that is,\n+     * columns from the same row are always grouped together and are always sorted on byte ordering, but there are no\n+     * guarantees on the ordering of rows.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted", "originalCommit": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5OTQzNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433799437", "bodyText": "good spot, bad copy-paste here \ud83d\ude13", "author": "jeremyk-91", "createdAt": "2020-06-02T11:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NTE2MA=="}], "type": "inlineReview", "revised_code": {"commit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 247b7e47eb..9b8845919a 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -54,9 +54,9 @@ public interface Transaction {\n      * {@code rows} is irrelevant.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n-     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n-     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n-     * existing in the key value service) will be absent.\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n      *\n      * @param tableRef table to load rows from\n      * @param rows rows to be loaded\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NzUyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433757529", "bodyText": "Should this also have something around Cell lookup from this map? I guess that's implied because Cell has an #equals we control.", "author": "jkozlowski", "createdAt": "2020-06-02T09:52:41Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,124 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n+     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n+     * existing in the key value service) will be absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of rows to {@link BatchingVisitable}s (which may be thought of as iterators over columns)\n+     * within {@code tableRef} for the specified {@code rows}, where the columns fall within the provided\n+     * {@link BatchColumnRangeSelection}. The single provided {@link BatchColumnRangeSelection} applies to all of the\n+     * rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], BatchingVisitable<Map.Entry<Cell, byte[]>>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Returns a single iterator over the cell-value pairs in {@code tableRef} for the specified {@code rows}, where the\n+     * columns fall within the provided {@link ColumnRangeSelection}. The single provided {@link ColumnRangeSelection}\n+     * applies to all of the rows.\n+     *\n+     * If the provided {@link Iterable} of {@code rows} has a stable ordering, the returned iterator is guaranteed\n+     * to return cell-value pairs in a lexicographic ordering over rows and columns, where rows are sorted according to\n+     * the stable ordering of {@code rows}, and columns are sorted on byte ordering. If {@code rows} does not have a\n+     * stable ordering, the returned iterator will return cell-value pairs that are ordered within a row - that is,\n+     * columns from the same row are always grouped together and are always sorted on byte ordering, but there are no\n+     * guarantees on the ordering of rows.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns to load for each of the rows provided\n+     * @param batchHint number of columns that should be loaded from the underlying database at once\n+     * @return an iterator over cell-value pairs, guaranteed to follow the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Iterator<Map.Entry<Cell, byte[]>> getRowsColumnRange(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnRangeSelection columnRangeSelection,\n             int batchHint);\n \n+    /**\n+     * Returns a mapping of rows to {@link Iterator}s over cell-value pairs within {@code tableRef} for the specified\n+     * {@code rows}, where the columns fall within the provided {@link BatchColumnRangeSelection}. The single provided\n+     * {@link BatchColumnRangeSelection} applies to all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates\n+     */\n     @Idempotent\n     Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> getRowsColumnRangeIterator(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             BatchColumnRangeSelection columnRangeSelection);\n \n+    /**\n+     * Gets the values associated for each cell in {@code cells} from table specified by {@code tableRef}.\n+     *\n+     * @param tableRef the table from which to get the values", "originalCommit": "81fef421506cc5d8f0b286eb05eaf367c2a4f4e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5OTcxNA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r433799714", "bodyText": "I could add it, though yeah I didn't because Cell#equals() behaves predictably", "author": "jeremyk-91", "createdAt": "2020-06-02T11:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NzUyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 247b7e47eb..9b8845919a 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -54,9 +54,9 @@ public interface Transaction {\n      * {@code rows} is irrelevant.\n      *\n      * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n-     * {@link Map#keySet()} of the output map at all. This accounts for local writes and deletes: a row written\n-     * to locally (even if not persisted) will be present, and a row which is completely deleted locally (even if\n-     * existing in the key value service) will be absent.\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n      *\n      * @param tableRef table to load rows from\n      * @param rows rows to be loaded\n"}}, {"oid": "e73cd0863051faef64fee8332cfbe84151aff6e6", "url": "https://github.com/palantir/atlasdb/commit/e73cd0863051faef64fee8332cfbe84151aff6e6", "message": "CR feedback", "committedDate": "2020-06-02T17:54:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMjgwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434132801", "bodyText": "What does \"including via random access\" mean?", "author": "jkozlowski", "createdAt": "2020-06-02T19:41:44Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMzUxNA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434433514", "bodyText": "Random access here refers to get(x) though to be fair the next clause kind of renders this one redundant.", "author": "jeremyk-91", "createdAt": "2020-06-03T09:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMjgwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 9b8845919a..c81a8f5cde 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -39,7 +39,7 @@ import com.palantir.common.base.BatchingVisitable;\n  * Provides the methods for a transaction with the key-value store.\n  *\n  * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n- * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * they may be accessed via any byte array that is equivalent in terms of\n  * {@link java.util.Arrays#equals(byte[], byte[])}.\n  *\n  * @see TransactionManager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNDkzOA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434134938", "bodyText": "Meta comment: is this javadoc copied to the generated code? If not, this feels like nobody will actually read this and understand...", "author": "jkozlowski", "createdAt": "2020-06-02T19:45:52Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNDE2Ng==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434434166", "bodyText": "There'll be a next part to this. These comments were written more for AtlasDB devs than for users (so we won't think it's acceptable to e.g. change the order of rows)", "author": "jeremyk-91", "createdAt": "2020-06-03T09:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNDkzOA=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 9b8845919a..c81a8f5cde 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -39,7 +39,7 @@ import com.palantir.common.base.BatchingVisitable;\n  * Provides the methods for a transaction with the key-value store.\n  *\n  * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n- * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * they may be accessed via any byte array that is equivalent in terms of\n  * {@link java.util.Arrays#equals(byte[], byte[])}.\n  *\n  * @see TransactionManager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNjE4NA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434136184", "bodyText": "Sometimes you say \"sorted on the byte order\" and sometimes you add \"with ascending byte ordering\".", "author": "jkozlowski", "createdAt": "2020-06-02T19:48:13Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzNDUwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434434501", "bodyText": "I'll standardise to one of them", "author": "jeremyk-91", "createdAt": "2020-06-03T09:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNjE4NA=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 9b8845919a..c81a8f5cde 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -39,7 +39,7 @@ import com.palantir.common.base.BatchingVisitable;\n  * Provides the methods for a transaction with the key-value store.\n  *\n  * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n- * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * they may be accessed via any byte array that is equivalent in terms of\n  * {@link java.util.Arrays#equals(byte[], byte[])}.\n  *\n  * @see TransactionManager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzODYxNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434138617", "bodyText": "nit: I think in other places we use PtBytes#BYTES_COMPARATOR shim to this method. Just something I noticed.", "author": "jkozlowski", "createdAt": "2020-06-02T19:52:57Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -408,16 +409,16 @@ public void disableReadWriteConflictChecking(TableReference tableRef) {\n         hasReads = true;\n         Map<byte[], RowColumnRangeIterator> rawResults = keyValueService.getRowsColumnRange(tableRef, rows,\n                 columnRangeSelection, getStartTimestamp());\n-        Map<byte[], Iterator<Map.Entry<Cell, byte[]>>> postFilteredResults =\n-                Maps.newHashMapWithExpectedSize(rawResults.size());\n+        ImmutableSortedMap.Builder<byte[], Iterator<Map.Entry<Cell, byte[]>>> postFilteredResults =\n+                ImmutableSortedMap.orderedBy(UnsignedBytes.lexicographicalComparator());", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\nindex 34b4e7c5b1..1c35857e26 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java\n\n@@ -410,7 +410,7 @@ public class SnapshotTransaction extends AbstractTransaction implements Constrai\n         Map<byte[], RowColumnRangeIterator> rawResults = keyValueService.getRowsColumnRange(tableRef, rows,\n                 columnRangeSelection, getStartTimestamp());\n         ImmutableSortedMap.Builder<byte[], Iterator<Map.Entry<Cell, byte[]>>> postFilteredResults =\n-                ImmutableSortedMap.orderedBy(UnsignedBytes.lexicographicalComparator());\n+                ImmutableSortedMap.orderedBy(PtBytes.BYTES_COMPARATOR);\n         for (Map.Entry<byte[], RowColumnRangeIterator> e : rawResults.entrySet()) {\n             byte[] row = e.getKey();\n             RowColumnRangeIterator rawIterator = e.getValue();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzOTMxNA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434139314", "bodyText": "Iterables.isEmpty might create an iterator already. So I believe you need to create a copy before this if statement. But I'm not quite sure what inconsistent ordering for an iterator means, so not sure if this matters.", "author": "jkozlowski", "createdAt": "2020-06-02T19:54:17Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransaction.java", "diffHunk": "@@ -381,10 +381,11 @@ public void disableReadWriteConflictChecking(TableReference tableRef) {\n         if (Iterables.isEmpty(rows)) {", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0Mzk3NA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434443974", "bodyText": "You're right - it does. So if you give an inconsistent iterable we actually rely on the ordering we get the second time we get an iterator. We're saying the ordering doesn't matter in that case anyway, so this is fine for the guarantees we've given.", "author": "jeremyk-91", "createdAt": "2020-06-03T09:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzOTMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NTM2MA==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434595360", "bodyText": "Cool", "author": "jkozlowski", "createdAt": "2020-06-03T14:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzOTMxNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0MDI3NQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434140275", "bodyText": "What about duplicates here? Should we encode this behavior?", "author": "jkozlowski", "createdAt": "2020-06-02T19:56:08Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0ODk5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434448995", "bodyText": "I added a test, and noted that they are allowed but of course are only represented once in the returned mapping.", "author": "jeremyk-91", "createdAt": "2020-06-03T09:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0MDI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0OTM4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434449381", "bodyText": "I realise it's inconsistent with gRCR but can't guarantee we don't have users providing this", "author": "jeremyk-91", "createdAt": "2020-06-03T09:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0MDI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 9b8845919a..c81a8f5cde 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -39,7 +39,7 @@ import com.palantir.common.base.BatchingVisitable;\n  * Provides the methods for a transaction with the key-value store.\n  *\n  * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n- * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * they may be accessed via any byte array that is equivalent in terms of\n  * {@link java.util.Arrays#equals(byte[], byte[])}.\n  *\n  * @see TransactionManager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0NjIyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434146229", "bodyText": "Where is this checked in the code? And I assume there are tests for this behavior.", "author": "jkozlowski", "createdAt": "2020-06-02T20:08:07Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of requested {@code rows} to corresponding columns from the queried table.\n+     * Only columns matching the provided predicate will be returned, and the single predicate provided applies across\n+     * all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the\n+     * input {@code rows}, even if there are rows where no columns match the predicate.\n+     *\n+     * @param tableRef table to load values from\n+     * @param rows unique rows to apply the column range selection to\n+     * @param columnRangeSelection range of columns and batch size to load for each of the rows provided\n+     * @return a mapping of rows to cells matching the predicate in the row, following the ordering outlined above\n+     * @throws IllegalArgumentException if {@code rows} contains duplicates", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MjE0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434452142", "bodyText": "This is in the builder of the ImmutableSortedMap. I'm not sure if there are existing tests, I added one.", "author": "jeremyk-91", "createdAt": "2020-06-03T09:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0NjIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 9b8845919a..c81a8f5cde 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -39,7 +39,7 @@ import com.palantir.common.base.BatchingVisitable;\n  * Provides the methods for a transaction with the key-value store.\n  *\n  * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n- * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * they may be accessed via any byte array that is equivalent in terms of\n  * {@link java.util.Arrays#equals(byte[], byte[])}.\n  *\n  * @see TransactionManager\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0ODgzNQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434148835", "bodyText": "Maybe you want a separate scoped test for this, as opposed to putting this here?", "author": "jkozlowski", "createdAt": "2020-06-02T20:13:01Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java", "diffHunk": "@@ -698,12 +707,12 @@ public void testColumnRangePagingTransaction_batchingVisitable() {\n         verifyMatchingResult(expected, row, columnRange);\n \n         columnRange =\n-                t.getRowsColumnRange(TEST_TABLE, ImmutableList.of(row), BatchColumnRangeSelection.create(PtBytes.toBytes(\"col\"), PtBytes.EMPTY_BYTE_ARRAY, 1));\n+                t.getRowsColumnRange(TEST_TABLE, ImmutableList.of(PtBytes.toBytes(\"row1\")), BatchColumnRangeSelection.create(PtBytes.toBytes(\"col\"), PtBytes.EMPTY_BYTE_ARRAY, 1));", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1NjQ3NQ==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434456475", "bodyText": "Fair enough, added one.", "author": "jeremyk-91", "createdAt": "2020-06-03T10:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0ODgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\nindex b390382726..8b0134b98d 100644\n--- a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\n+++ b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\n\n@@ -707,7 +707,7 @@ public abstract class AbstractTransactionTest extends TransactionTestSetup {\n         verifyMatchingResult(expected, row, columnRange);\n \n         columnRange =\n-                t.getRowsColumnRange(TEST_TABLE, ImmutableList.of(PtBytes.toBytes(\"row1\")), BatchColumnRangeSelection.create(PtBytes.toBytes(\"col\"), PtBytes.EMPTY_BYTE_ARRAY, 1));\n+                t.getRowsColumnRange(TEST_TABLE, ImmutableList.of(row), BatchColumnRangeSelection.create(PtBytes.toBytes(\"col\"), PtBytes.EMPTY_BYTE_ARRAY, 1));\n         verifyMatchingResult(expected, row, columnRange);\n \n         columnRange =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjQzNw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434152437", "bodyText": "Do we test somewhere the ColumnSelection and ordering of columns?", "author": "jkozlowski", "createdAt": "2020-06-02T20:20:13Z", "path": "atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java", "diffHunk": "@@ -1309,6 +1318,165 @@ public void testGetRangesPaging() {\n         verifyAllGetRangesImplsNumRanges(t, ranges, ImmutableList.of(\"v\"));\n     }\n \n+    @Test\n+    public void getRowsAccessibleThroughCopies() {\n+        Transaction t = startTransaction();\n+        byte[] rowKey = row(0);\n+        byte[] value = value(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(\n+                Cell.create(rowKey, column(0)), value));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> result =\n+                t.getRows(TEST_TABLE, ImmutableList.of(rowKey), ColumnSelection.all());\n+        assertThat(result.get(rowKey))\n+                .as(\"it should be possible to get a row from getRows with a passed-in byte array\")\n+                .isNotNull()\n+                .satisfies(rowResult ->\n+                        assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n+\n+        byte[] rowKeyCopy = rowKey.clone();\n+        assertThat(rowKeyCopy).isNotSameAs(rowKey);\n+        assertThat(result.get(rowKeyCopy))\n+                .as(\"it should be possible to get a row from getRows with a copy of a passed-in byte array\")\n+                .isNotNull()\n+                .satisfies(rowResult ->\n+                        assertThat(rowResult.getOnlyColumnValue()).isEqualTo(value));\n+    }\n+\n+    @Test\n+    public void getRowsSortedByByteOrder() {\n+        Transaction t = startTransaction();\n+        byte[] row0 = row(0);\n+        byte[] row1 = row(1);\n+        byte[] col0 = column(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(Cell.create(row0, col0), value(0), Cell.create(row1, col0), value(1)));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> readRows =\n+                t.getRows(TEST_TABLE, ImmutableList.of(row0, row1), ColumnSelection.all());", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2MDE4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434460182", "bodyText": "Not that I'm aware of, I added one test.", "author": "jeremyk-91", "createdAt": "2020-06-03T10:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjQzNw=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\nindex b390382726..8b0134b98d 100644\n--- a/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\n+++ b/atlasdb-tests-shared/src/main/java/com/palantir/atlasdb/transaction/impl/AbstractTransactionTest.java\n\n@@ -1361,6 +1361,41 @@ public abstract class AbstractTransactionTest extends TransactionTestSetup {\n         assertThat(readRows.lastKey()).containsExactly(row1);\n     }\n \n+    @Test\n+    public void getRowsWithDuplicateQueries() {\n+        Transaction t = startTransaction();\n+        byte[] row0 = row(0);\n+        byte[] anotherRow0 = row(0);\n+        byte[] col0 = column(0);\n+        t.put(TEST_TABLE, ImmutableMap.of(Cell.create(row0, col0), value(0)));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> readRows =\n+                t.getRows(TEST_TABLE, ImmutableList.of(row0, anotherRow0), ColumnSelection.all());\n+        assertThat(readRows.firstKey()).containsExactly(row0);\n+        assertThat(readRows).hasSize(1);\n+    }\n+\n+    @Test\n+    public void getRowsAppliesColumnSelection() {\n+        Transaction t = startTransaction();\n+        byte[] row0 = row(0);\n+        byte[] col0 = column(0);\n+        byte[] col1 = column(1);\n+        t.put(TEST_TABLE, ImmutableMap.of(\n+                Cell.create(row0, col0), value(0),\n+                Cell.create(row0, col1), value(1)));\n+        t.commit();\n+\n+        t = startTransaction();\n+        SortedMap<byte[], RowResult<byte[]>> readRows =\n+                t.getRows(TEST_TABLE, ImmutableList.of(row0), ColumnSelection.create(ImmutableList.of(col0)));\n+        assertThat(readRows.firstKey()).containsExactly(row0);\n+        assertThat(readRows.get(row0).getColumns().keySet()).containsExactly(col0);\n+        assertThat(readRows.get(row0).getColumns().get(col0)).containsExactly(value(0));\n+    }\n+\n     @Test\n     public void getRowsIncludesLocalWrites() {\n         Transaction t = startTransaction();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzY4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434153683", "bodyText": "Is there a test for this behavior?", "author": "jkozlowski", "createdAt": "2020-06-02T20:22:48Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java", "diffHunk": "@@ -37,41 +37,123 @@\n \n /**\n  * Provides the methods for a transaction with the key-value store.\n+ *\n+ * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n+ * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * {@link java.util.Arrays#equals(byte[], byte[])}.\n+ *\n  * @see TransactionManager\n  */\n public interface Transaction {\n \n+    /**\n+     * Returns a mapping of rows to {@link RowResult}s within {@code tableRef} for the specified {@code rows}, loading\n+     * columns according to the provided {@link ColumnSelection}.\n+     *\n+     * The returned {@link SortedMap} is sorted on the byte order of row keys; the ordering of the input parameter\n+     * {@code rows} is irrelevant.\n+     *\n+     * If there are rows with no cells matching the provided {@link ColumnSelection}, they will not be present in the\n+     * {@link Map#keySet()} of the output map at all. This accounts for writes and deletes done in this transaction:\n+     * a row written to in this transaction will be present, and a row which is deleted in this transaction will be\n+     * absent.\n+     *\n+     * @param tableRef table to load rows from\n+     * @param rows rows to be loaded\n+     * @param columnSelection columns to load from the given rows\n+     * @return a mapping of rows to the columns matching the provided column selection\n+     */\n     @Idempotent\n     SortedMap<byte[], RowResult<byte[]>> getRows(\n             TableReference tableRef,\n             Iterable<byte[]> rows,\n             ColumnSelection columnSelection);\n \n+    /**\n+     * Returns a mapping of requested {@code rows} to corresponding columns from the queried table.\n+     * Only columns matching the provided predicate will be returned, and the single predicate provided applies across\n+     * all of the rows.\n+     *\n+     * The returned {@link BatchingVisitable}s are guaranteed to return cells matching the predicate. These are sorted\n+     * by column, with ascending byte ordering.\n+     *\n+     * It is guaranteed that the {@link Map#keySet()} of the returned map has a corresponding element for each of the", "originalCommit": "e73cd0863051faef64fee8332cfbe84151aff6e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2MzM5Ng==", "url": "https://github.com/palantir/atlasdb/pull/4702#discussion_r434463396", "bodyText": "There wasn't, now there is (also added one for the other Map-returning method)", "author": "jeremyk-91", "createdAt": "2020-06-03T10:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\nindex 9b8845919a..c81a8f5cde 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/Transaction.java\n\n@@ -39,7 +39,7 @@ import com.palantir.common.base.BatchingVisitable;\n  * Provides the methods for a transaction with the key-value store.\n  *\n  * In general: users may assume that if maps (including sorted maps) keyed on byte[] are returned to the user,\n- * they may be accessed, including via random access, via any byte array that is equivalent in terms of\n+ * they may be accessed via any byte array that is equivalent in terms of\n  * {@link java.util.Arrays#equals(byte[], byte[])}.\n  *\n  * @see TransactionManager\n"}}, {"oid": "9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "url": "https://github.com/palantir/atlasdb/commit/9bb44d9fe1695eb1c328062b8ea46ff79be66ee3", "message": "CR feedback, additional tests", "committedDate": "2020-06-03T10:18:54Z", "type": "commit"}, {"oid": "15ba58d44f753de441a668b83bfbea06883cafeb", "url": "https://github.com/palantir/atlasdb/commit/15ba58d44f753de441a668b83bfbea06883cafeb", "message": "restrict non-unique rows", "committedDate": "2020-06-03T13:56:25Z", "type": "commit"}]}