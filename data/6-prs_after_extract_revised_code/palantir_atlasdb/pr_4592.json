{"pr_number": 4592, "pr_title": "[LW] Snapshot Updates", "pr_createdAt": "2020-02-21T17:37:50Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4592", "timeline": [{"oid": "8740ab9b0eb8e8daf4d2d8152231738d07d4248e", "url": "https://github.com/palantir/atlasdb/commit/8740ab9b0eb8e8daf4d2d8152231738d07d4248e", "message": "Be better, one day at a time. Also fix nasty concurrency issue.", "committedDate": "2020-02-20T10:43:02Z", "type": "commit"}, {"oid": "2c3a9d273d2ff4ec589001af51cb408ed67b14fa", "url": "https://github.com/palantir/atlasdb/commit/2c3a9d273d2ff4ec589001af51cb408ed67b14fa", "message": "Rework lock watch updates and registration", "committedDate": "2020-02-21T16:58:50Z", "type": "commit"}, {"oid": "d311fef3558808de8fa7bf90975ff50d3b7115d7", "url": "https://github.com/palantir/atlasdb/commit/d311fef3558808de8fa7bf90975ff50d3b7115d7", "message": "Merge with develop", "committedDate": "2020-02-24T10:46:42Z", "type": "commit"}, {"oid": "121eada2e9528cbedc9c694d7067a0d8eea5421a", "url": "https://github.com/palantir/atlasdb/commit/121eada2e9528cbedc9c694d7067a0d8eea5421a", "message": "Do not filter unlocks for replayer", "committedDate": "2020-02-24T11:34:03Z", "type": "commit"}, {"oid": "413cc995a5ed5ff3de45629bf34f778e663e3be1", "url": "https://github.com/palantir/atlasdb/commit/413cc995a5ed5ff3de45629bf34f778e663e3be1", "message": "Add test for snapshot reflecting events logged during open locks calculation", "committedDate": "2020-02-24T11:44:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTI3OA==", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383929278", "bodyText": "Ideally would like some JavaDoc on what the updates mean here (success = you're current, snapshot = you're behind but here's the state of the world, failed = I couldn't get you a state of the world).", "author": "jeremyk-91", "createdAt": "2020-02-25T14:55:05Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java", "diffHunk": "@@ -17,53 +17,96 @@\n package com.palantir.lock.watch;\n \n import java.util.List;\n-import java.util.OptionalLong;\n+import java.util.Set;\n import java.util.UUID;\n \n import org.immutables.value.Value;\n \n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.google.common.collect.ImmutableList;\n-import com.palantir.logsafe.Preconditions;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n \n-@Value.Immutable\n-@Value.Style(visibility = Value.Style.ImplementationVisibility.PACKAGE)\n-@JsonSerialize(as = ImmutableLockWatchStateUpdate.class)\n-@JsonDeserialize(as = ImmutableLockWatchStateUpdate.class)\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+@JsonSubTypes({\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Failed.class, name = LockWatchStateUpdate.Failed.TYPE),\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Success.class, name = LockWatchStateUpdate.Success.TYPE),\n+        @JsonSubTypes.Type(value = LockWatchStateUpdate.Snapshot.class, name = LockWatchStateUpdate.Snapshot.TYPE)})\n public interface LockWatchStateUpdate {", "originalCommit": "413cc995a5ed5ff3de45629bf34f778e663e3be1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cd8d27ea941e103c42de38676dc595328baabdc", "chunk": "diff --git a/lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java b/lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java\nindex f0a3e6cb2d..cfca503efb 100644\n--- a/lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java\n+++ b/lock-api-objects/src/main/java/com/palantir/lock/watch/LockWatchStateUpdate.java\n\n@@ -39,15 +39,15 @@ public interface LockWatchStateUpdate {\n     UUID logId();\n     <T> T accept(Visitor<T> visitor);\n \n-    static LockWatchStateUpdate failure(UUID logId) {\n+    static Failed failed(UUID logId) {\n         return ImmutableFailed.builder().logId(logId).build();\n     }\n \n-    static LockWatchStateUpdate success(UUID logId, long version, List<LockWatchEvent> events) {\n+    static Success success(UUID logId, long version, List<LockWatchEvent> events) {\n         return ImmutableSuccess.builder().logId(logId).lastKnownVersion(version).events(events).build();\n     }\n \n-    static LockWatchStateUpdate snapshot(UUID logId, long version, Set<LockDescriptor> locked,\n+    static Snapshot snapshot(UUID logId, long version, Set<LockDescriptor> locked,\n             Set<LockWatchReference> lockWatches) {\n         return ImmutableSnapshot.builder()\n                 .logId(logId)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMDc4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383930785", "bodyText": "nit: just call lastVersion() here?", "author": "jeremyk-91", "createdAt": "2020-02-25T14:57:13Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java", "diffHunk": "@@ -74,21 +83,23 @@ public synchronized void add(LockWatchEvent.Builder eventBuilder) {\n      *      this method, that is no longer the case when the method returns.\n      */\n     public Optional<List<LockWatchEvent>> getFromVersion(long version) {\n-        long lastWrittenSequence = nextSequence - 1;\n+        return getFromTo(version, nextSequence - 1);", "originalCommit": "413cc995a5ed5ff3de45629bf34f778e663e3be1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cd8d27ea941e103c42de38676dc595328baabdc", "chunk": "diff --git a/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java b/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java\nindex f6aee4b756..cf72258086 100644\n--- a/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java\n+++ b/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/ArrayLockEventSlidingWindow.java\n\n@@ -83,7 +83,7 @@ public class ArrayLockEventSlidingWindow {\n      *      this method, that is no longer the case when the method returns.\n      */\n     public Optional<List<LockWatchEvent>> getFromVersion(long version) {\n-        return getFromTo(version, nextSequence - 1);\n+        return getFromTo(version, lastVersion());\n     }\n \n     public Optional<List<LockWatchEvent>> getFromTo(long startVersion, long endVersion) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzMjQ4OA==", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383932488", "bodyText": "please use heldLocksCollection or locksCollection, HeldLocks is a different object which made me find this section a bit confusing", "author": "jeremyk-91", "createdAt": "2020-02-25T14:59:32Z", "path": "timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java", "diffHunk": "@@ -16,38 +16,94 @@\n \n package com.palantir.atlasdb.timelock.lock.watch;\n \n+import java.util.HashSet;\n import java.util.List;\n import java.util.Optional;\n import java.util.OptionalLong;\n import java.util.Set;\n import java.util.UUID;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n \n+import com.google.common.collect.RangeSet;\n+import com.palantir.atlasdb.timelock.lock.AsyncLock;\n+import com.palantir.atlasdb.timelock.lock.HeldLocksCollection;\n import com.palantir.lock.LockDescriptor;\n import com.palantir.lock.v2.LockToken;\n import com.palantir.lock.watch.LockEvent;\n import com.palantir.lock.watch.LockWatchCreatedEvent;\n import com.palantir.lock.watch.LockWatchEvent;\n-import com.palantir.lock.watch.LockWatchOpenLocksEvent;\n-import com.palantir.lock.watch.LockWatchRequest;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n import com.palantir.lock.watch.LockWatchStateUpdate;\n import com.palantir.lock.watch.UnlockEvent;\n \n public class LockEventLogImpl implements LockEventLog {\n-    private final UUID leaderId = UUID.randomUUID();\n+    private final UUID logId = UUID.randomUUID();\n     private final ArrayLockEventSlidingWindow slidingWindow = new ArrayLockEventSlidingWindow(1000);\n+    private final Supplier<LockWatches> watchesSupplier;\n+    private final HeldLocksCollection heldLocks;", "originalCommit": "413cc995a5ed5ff3de45629bf34f778e663e3be1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5cd8d27ea941e103c42de38676dc595328baabdc", "chunk": "diff --git a/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java b/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java\nindex 89395e8c89..93994634e3 100644\n--- a/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java\n+++ b/timelock-impl/src/main/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImpl.java\n\n@@ -41,11 +41,11 @@ public class LockEventLogImpl implements LockEventLog {\n     private final UUID logId = UUID.randomUUID();\n     private final ArrayLockEventSlidingWindow slidingWindow = new ArrayLockEventSlidingWindow(1000);\n     private final Supplier<LockWatches> watchesSupplier;\n-    private final HeldLocksCollection heldLocks;\n+    private final HeldLocksCollection heldLocksCollection;\n \n-    public LockEventLogImpl(Supplier<LockWatches> watchesSupplier, HeldLocksCollection heldLocks) {\n+    public LockEventLogImpl(Supplier<LockWatches> watchesSupplier, HeldLocksCollection heldLocksCollection) {\n         this.watchesSupplier = watchesSupplier;\n-        this.heldLocks = heldLocks;\n+        this.heldLocksCollection = heldLocksCollection;\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkzODY1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r383938653", "bodyText": "nice!", "author": "jeremyk-91", "createdAt": "2020-02-25T15:08:48Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockEventLogImplTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.timelock.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.OptionalLong;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.RangeSet;\n+import com.google.common.collect.TreeRangeSet;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.atlasdb.keyvalue.api.TableReference;\n+import com.palantir.atlasdb.keyvalue.api.watch.LockWatchReferenceUtils;\n+import com.palantir.atlasdb.timelock.lock.AsyncLock;\n+import com.palantir.atlasdb.timelock.lock.ExclusiveLock;\n+import com.palantir.atlasdb.timelock.lock.HeldLocks;\n+import com.palantir.atlasdb.timelock.lock.HeldLocksCollection;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.LockEvent;\n+import com.palantir.lock.watch.LockWatchCreatedEvent;\n+import com.palantir.lock.watch.LockWatchReferences;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n+import com.palantir.lock.watch.LockWatchStateUpdate;\n+import com.palantir.lock.watch.UnlockEvent;\n+\n+public class LockEventLogImplTest {\n+    private final AtomicReference<LockWatches> lockWatches = new AtomicReference<>(LockWatches.create());\n+    private final HeldLocksCollection heldLocksCollection = mock(HeldLocksCollection.class);\n+    private final HeldLocks heldLocks = mock(HeldLocks.class);\n+    private final LockEventLog log = new LockEventLogImpl(lockWatches::get, heldLocksCollection);\n+\n+    private static final TableReference TABLE_REF = TableReference.createFromFullyQualifiedName(\"test.table\");\n+    private static final String TABLE = TABLE_REF.getQualifiedName();\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"1\"));\n+    private static final LockDescriptor DESCRIPTOR_2 = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"2\"));\n+    private static final LockDescriptor DESCRIPTOR_3 = AtlasRowLockDescriptor.of(TABLE, PtBytes.toBytes(\"3\"));\n+    private static final AsyncLock LOCK_2 = new ExclusiveLock(DESCRIPTOR_2);\n+    private static final AsyncLock LOCK_3 = new ExclusiveLock(DESCRIPTOR_3);\n+    private static final LockToken TOKEN = LockToken.of(UUID.randomUUID());\n+\n+    @Before\n+    public void setupMocks() {\n+        when(heldLocks.getLocks()).thenReturn(ImmutableSet.of(LOCK_2, LOCK_3));\n+        when(heldLocks.getToken()).thenReturn(TOKEN);\n+        when(heldLocksCollection.locksHeld()).thenReturn(ImmutableSet.of(heldLocks));\n+    }\n+\n+    @Test\n+    public void lockUpdateTest() {\n+        ImmutableSet<LockDescriptor> locks = ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2);\n+        log.logLock(locks, TOKEN);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(LockEvent.builder(locks, TOKEN).build(0L));\n+    }\n+\n+    @Test\n+    public void unlockUpdateTest() {\n+        ImmutableSet<LockDescriptor> locks = ImmutableSet.of(DESCRIPTOR, DESCRIPTOR_2);\n+        log.logUnlock(locks);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(UnlockEvent.builder(locks).build(0L));\n+    }\n+\n+    @Test\n+    public void createLockWatchUpdateTest() {\n+        LockWatchReference secondRowReference = LockWatchReferenceUtils.rowPrefix(TABLE_REF, PtBytes.toBytes(\"2\"));\n+        LockWatches newWatches = createWatchesFor(secondRowReference);\n+        log.logLockWatchCreated(newWatches);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(-1L));\n+\n+        LockWatchStateUpdate.Success success = UpdateVisitors.assertSuccess(update);\n+        assertThat(success.events()).containsExactly(\n+                LockWatchCreatedEvent.builder(\n+                        newWatches.references(),\n+                        ImmutableSet.of(DESCRIPTOR_2))\n+                        .build(0L));\n+    }\n+\n+    @Test\n+    public void noKnownVersionReturnsSnapshotContainingCurrentMatchingLocks() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.empty());\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(-1L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void snapshotIgnoresPreviousLogEntriesInLocksCalculation() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        log.logLock(ImmutableSet.of(DESCRIPTOR), TOKEN);\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.empty());\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(0L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void requestForTheFutureReturnsSnapshot() {\n+        LockWatchReference entireTable = LockWatchReferenceUtils.entireTable(TABLE_REF);\n+        lockWatches.set(createWatchesFor(entireTable));\n+\n+        LockWatchStateUpdate update = log.getLogDiff(OptionalLong.of(100L));\n+\n+        LockWatchStateUpdate.Snapshot snapshot = UpdateVisitors.assertSnapshot(update);\n+        assertThat(snapshot.lastKnownVersion()).isEqualTo(-1L);\n+        assertThat(snapshot.locked()).isEqualTo(ImmutableSet.of(DESCRIPTOR_2, DESCRIPTOR_3));\n+        assertThat(snapshot.lockWatches()).containsExactly(entireTable);\n+    }\n+\n+    @Test\n+    public void snapshotReflectsEventsOcurringDuringOpenLocksCalculation() {", "originalCommit": "413cc995a5ed5ff3de45629bf34f778e663e3be1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "5cd8d27ea941e103c42de38676dc595328baabdc", "url": "https://github.com/palantir/atlasdb/commit/5cd8d27ea941e103c42de38676dc595328baabdc", "message": "Address CR", "committedDate": "2020-02-25T16:42:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1ODI5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4592#discussion_r384058293", "bodyText": "yep, this is exactly what I was looking for. Thanks!", "author": "jeremyk-91", "createdAt": "2020-02-25T18:53:22Z", "path": "timelock-impl/src/test/java/com/palantir/atlasdb/timelock/lock/watch/LockWatchingServiceImplTest.java", "diffHunk": "@@ -105,6 +105,29 @@ public void registeringWatchWithWiderScopeLogsAlreadyWatchedLocksAgain() {\n         assertLoggedEvents(expectedEvents);\n     }\n \n+    @Test\n+    public void registeringWatchWithOverlappingScopeLogsAlreadyWatchedLocksInScopeAgain() {", "originalCommit": "5cd8d27ea941e103c42de38676dc595328baabdc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}