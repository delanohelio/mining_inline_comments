{"pr_number": 5105, "pr_title": "add cache warming option to ssm", "pr_createdAt": "2020-11-06T19:20:15Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5105", "timeline": [{"oid": "86cd9d783b15ffcc9082247995fe14f182793816", "url": "https://github.com/palantir/atlasdb/commit/86cd9d783b15ffcc9082247995fe14f182793816", "message": "Add generated changelog entries", "committedDate": "2020-11-06T19:22:33Z", "type": "forcePushed"}, {"oid": "c4d841b60769133ca5c7cad52afd42fd894bbe2f", "url": "https://github.com/palantir/atlasdb/commit/c4d841b60769133ca5c7cad52afd42fd894bbe2f", "message": "Add generated changelog entries", "committedDate": "2020-11-06T22:03:42Z", "type": "forcePushed"}, {"oid": "0c8ffccc03163ec45490e8ddd64528def1243081", "url": "https://github.com/palantir/atlasdb/commit/0c8ffccc03163ec45490e8ddd64528def1243081", "message": "add limited cache warming option to ssm\n\nAdds a CacheWarming option that can control how the SweepStrategyManager\ncache is warmed on initialization. The possible options are FULL,\nLIMITED, and NONE. FULL remains the default (so default behavior is not\nchanging). LIMITED causes only a max of 50 tables to be used for warming\nthe cache. NONE skips warming the cache.", "committedDate": "2020-11-06T22:10:15Z", "type": "commit"}, {"oid": "7925a61ccc2da46f102eaede70eddbeeefffd1d2", "url": "https://github.com/palantir/atlasdb/commit/7925a61ccc2da46f102eaede70eddbeeefffd1d2", "message": "Add generated changelog entries", "committedDate": "2020-11-06T22:10:15Z", "type": "commit"}, {"oid": "7925a61ccc2da46f102eaede70eddbeeefffd1d2", "url": "https://github.com/palantir/atlasdb/commit/7925a61ccc2da46f102eaede70eddbeeefffd1d2", "message": "Add generated changelog entries", "committedDate": "2020-11-06T22:10:15Z", "type": "forcePushed"}, {"oid": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "url": "https://github.com/palantir/atlasdb/commit/1c4c40ad591bfa0d6df700646e298c930ac4d383", "message": "fix limited metadata tests for cassandra\n\nThe Cassandra integration tests leave table metadata in an inconsistent\nstate which was causing the new test to fail. Adds a workaround where\nall tables are dropped at the start of this test.", "committedDate": "2020-11-07T00:08:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MTYzNA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520091634", "bodyText": "do we want a max size on this cache to limit memory footprint?", "author": "schlosna", "createdAt": "2020-11-09T20:13:04Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMjc5OA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520232798", "bodyText": "I don't think so, considering the default is to pre-warm the cache with all tables. The intended use case is that there won't be very many tables. If we had a max size here it seems like you could get very bad sweep perf once you have more than that amount of tables.", "author": "berler", "createdAt": "2020-11-10T01:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MTYzNA=="}], "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\nindex d75c0f9960..cc82b8f399 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\n\n@@ -56,7 +55,7 @@ public final class SweepStrategyManagers {\n                             .expireAfterAccess(1, TimeUnit.DAYS)\n                             .build(tableRef -> getSweepStrategy(kvs.getMetadataForTable(tableRef)));\n \n-                    // On async initialization, add a possibly limited number of tables to the cache.\n+                    // Possibly warm the cache.\n                     cache.putAll(getSweepStrategiesForWarmingCache(kvs, cacheWarming));\n \n                     return cache;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MjYzNA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520092634", "bodyText": "How much value is there in having a separate LIMITED mode between FULL and NONE? If we set to NONE and just let the cache warm up on its own based on requests, what behavior would we see? How did we pick 50? Are the first 50 tables actually the ones we want cached?", "author": "schlosna", "createdAt": "2020-11-09T20:14:49Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -84,9 +94,18 @@ public static SweepStrategyManager completelyConservative() {\n         return tableRef -> SweepStrategy.from(TableMetadataPersistence.SweepStrategy.CONSERVATIVE);\n     }\n \n-    private static Map<TableReference, SweepStrategy> getSweepStrategies(KeyValueService kvs) {\n-        return ImmutableMap.copyOf(\n-                Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy));\n+    private static Map<TableReference, SweepStrategy> getSweepStrategiesForWarmingCache(\n+            KeyValueService kvs, CacheWarming cacheWarming) {\n+        switch (cacheWarming) {\n+            case FULL:\n+                return Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy);\n+            case LIMITED:\n+                return Maps.transformValues(\n+                        kvs.getLimitedMetadataForTables(50), SweepStrategyManagers::getSweepStrategy);", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIzMzU2OA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520233568", "bodyText": "50 was recommended I believe by @jeremyk-91 when this was discussed a while ago internally", "author": "berler", "createdAt": "2020-11-10T01:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5MjYzNA=="}], "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\nindex d75c0f9960..cc82b8f399 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\n\n@@ -99,9 +98,6 @@ public final class SweepStrategyManagers {\n         switch (cacheWarming) {\n             case FULL:\n                 return Maps.transformValues(kvs.getMetadataForTables(), SweepStrategyManagers::getSweepStrategy);\n-            case LIMITED:\n-                return Maps.transformValues(\n-                        kvs.getLimitedMetadataForTables(50), SweepStrategyManagers::getSweepStrategy);\n             case NONE:\n             default:\n                 return Collections.emptyMap();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520094554", "bodyText": "Should this be a paged result? What is the epoch for concurrent consistency (e.g. tables created while this is executing)? What happens if one specifies various values for maxResults, say 0, -1, Integer.MAX_VALUE? I'm a little skeptical we even need these methods, but wondering if we actually do should instead consider something like Stream<TableReference> getTableNames() and let consumers filter/limit/transform/collect as desired.", "author": "schlosna", "createdAt": "2020-11-09T20:18:23Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -524,6 +524,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Set<TableReference> getAllTableNames();\n \n+    /**\n+     * Returns a list of up to {@code maxResults} tables stored in this key value service.\n+     *\n+     * This should be preferred over {@link #getAllTableNames()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Iterable<TableReference> getLimitedTableNames(int maxResults);", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE3MTY1Mg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520171652", "bodyText": "I was thinking about that, but it is significantly more complicated to implement correctly. Additionally the caller would need to call close() on the Stream, which is not something that is usually done in general (calling .collect() etc doesn't do it), so it would be really easy for people to leak resources if we made this a Stream.\nCloseableIterator or something similar might make more sense, but it would also be more complicated to implement.\nIn general I think we should be discouraging anything that would try to enumerate all tables in the system. Clients can only interact with tables if they know about some Schema, and clients should be using the Schema to know what tables it needs to care about.", "author": "berler", "createdAt": "2020-11-09T22:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMzUzNg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520423536", "bodyText": "The guarantees are exactly the same as with getAllTableNames, so I'm OK with that", "author": "gmaretic", "createdAt": "2020-11-10T09:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDU1NA=="}], "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java\nindex b1bf49033d..05d4b09aec 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java\n\n@@ -524,14 +524,6 @@ public interface KeyValueService extends AutoCloseable, AsyncKeyValueService {\n     @Idempotent\n     Set<TableReference> getAllTableNames();\n \n-    /**\n-     * Returns a list of up to {@code maxResults} tables stored in this key value service.\n-     *\n-     * This should be preferred over {@link #getAllTableNames()} if possible because the number of tables may be\n-     * unbounded.\n-     */\n-    Iterable<TableReference> getLimitedTableNames(int maxResults);\n-\n     /**\n      * Gets the metadata for a given table. Also useful for checking to see if a table exists.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NDY3Mg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520094672", "bodyText": "same comment as above", "author": "schlosna", "createdAt": "2020-11-09T20:18:39Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java", "diffHunk": "@@ -543,6 +551,14 @@ void deleteAllTimestamps(TableReference tableRef, Map<Cell, TimestampRangeDelete\n     @Idempotent\n     Map<TableReference, byte[]> getMetadataForTables();\n \n+    /**\n+     * Gets the metadata for up to {@code maxResults} tables.\n+     *\n+     * This should be preferred over {@link #getMetadataForTables()} if possible because the number of tables may be\n+     * unbounded.\n+     */\n+    Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults);", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java\nindex b1bf49033d..05d4b09aec 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/keyvalue/api/KeyValueService.java\n\n@@ -551,14 +543,6 @@ public interface KeyValueService extends AutoCloseable, AsyncKeyValueService {\n     @Idempotent\n     Map<TableReference, byte[]> getMetadataForTables();\n \n-    /**\n-     * Gets the metadata for up to {@code maxResults} tables.\n-     *\n-     * This should be preferred over {@link #getMetadataForTables()} if possible because the number of tables may be\n-     * unbounded.\n-     */\n-    Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults);\n-\n     @Idempotent\n     void putMetadataForTable(TableReference tableRef, byte[] metadata);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA5NTI2OQ==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520095269", "bodyText": "Similar to above, should these lines (same as in getAllTableNames())  be pulled out to a separate method that returns Stream<TableReference>?", "author": "schlosna", "createdAt": "2020-11-09T20:19:41Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -1481,6 +1481,16 @@ public void createTables(final Map<TableReference, byte[]> tablesToMetadata) {\n                 .collect(Collectors.toSet());\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        // Note: This is not optimal since getTableReferencesWithoutFiltering() loads *all* names, even though it\n+        // returns a Stream. Getting a partial list of table names might not be possible with cassandra thrift.\n+        return cassandraTables\n+                .getTableReferencesWithoutFiltering()\n+                .filter(tr -> !HiddenTables.isHidden(tr))", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex 709303814e..5065834655 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -1481,16 +1481,6 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n                 .collect(Collectors.toSet());\n     }\n \n-    @Override\n-    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n-        // Note: This is not optimal since getTableReferencesWithoutFiltering() loads *all* names, even though it\n-        // returns a Stream. Getting a partial list of table names might not be possible with cassandra thrift.\n-        return cassandraTables\n-                .getTableReferencesWithoutFiltering()\n-                .filter(tr -> !HiddenTables.isHidden(tr))\n-                .limit(maxResults)::iterator;\n-    }\n-\n     /**\n      * Gets the metadata for a given table. Also useful for checking to see if a table exists. Requires a quorum of\n      * Cassandra nodes to be reachable.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMDA1Mw==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520430053", "bodyText": "This comment seems to have been wron all along, has nothing to do with async initialisation?", "author": "gmaretic", "createdAt": "2020-11-10T09:53:09Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java", "diffHunk": "@@ -45,9 +56,8 @@ public static SweepStrategyManager createDefault(KeyValueService kvs) {\n                             .expireAfterAccess(1, TimeUnit.DAYS)\n                             .build(tableRef -> getSweepStrategy(kvs.getMetadataForTable(tableRef)));\n \n-                    // On async initialization, add all tables to optimize for cases when using mostly non-dynamic\n-                    // tables.\n-                    cache.putAll(getSweepStrategies(kvs));\n+                    // On async initialization, add a possibly limited number of tables to the cache.", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxOTIxNQ==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520919215", "bodyText": "things do init async -- this happens the first time it attempts to be used because this is inside a RecomputingSupplier", "author": "berler", "createdAt": "2020-11-10T22:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMDA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\nindex d75c0f9960..cc82b8f399 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/transaction/impl/SweepStrategyManagers.java\n\n@@ -56,7 +55,7 @@ public final class SweepStrategyManagers {\n                             .expireAfterAccess(1, TimeUnit.DAYS)\n                             .build(tableRef -> getSweepStrategy(kvs.getMetadataForTable(tableRef)));\n \n-                    // On async initialization, add a possibly limited number of tables to the cache.\n+                    // Possibly warm the cache.\n                     cache.putAll(getSweepStrategiesForWarmingCache(kvs, cacheWarming));\n \n                     return cache;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTY4OA==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520435688", "bodyText": "Any reason why not to slab on a \"LIMIT maxResults\"?", "author": "gmaretic", "createdAt": "2020-11-10T10:01:03Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1137,6 +1138,26 @@ public void createTable(TableReference tableRef, byte[] tableMetadata) {\n         });\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyList();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name FROM \" + config.metadataTable().getQualifiedName())) {", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTA1Mw==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520761053", "bodyText": "The limit syntax is completely different in postgres and oracle. We cannot just add a limit clause here unless we do something completely different for postgres and oracle.\nFrom a perf standpoint there shouldn't be very much difference between using a limit and only iterating through the ResultSet part way unless the configured prefetch is huge -- the AgnosticIterator impl in AgnosticLightResultSetImpl always sets the initial prefetch to 10, and doubles it (up to a max) after each batch is fetched.", "author": "berler", "createdAt": "2020-11-10T17:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTY4OA=="}], "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java b/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java\nindex 8bea503ba6..7d23b5a778 100644\n--- a/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java\n+++ b/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java\n\n@@ -1138,26 +1137,6 @@ public final class DbKvs extends AbstractKeyValueService {\n         });\n     }\n \n-    @Override\n-    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n-        if (maxResults <= 0) {\n-            return Collections.emptyList();\n-        }\n-        return run(conn -> {\n-            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n-                    \"SELECT table_name FROM \" + config.metadataTable().getQualifiedName())) {\n-                List<TableReference> ret = new ArrayList<>();\n-                for (AgnosticResultRow row : rows) {\n-                    ret.add(TableReference.createUnsafe(row.getString(\"table_name\")));\n-                    if (ret.size() >= maxResults) {\n-                        break;\n-                    }\n-                }\n-                return ret;\n-            }\n-        });\n-    }\n-\n     @Override\n     public byte[] getMetadataForTable(TableReference tableRef) {\n         return runMetadata(tableRef, DbMetadataTable::getMetadata);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNjI1OQ==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520436259", "bodyText": "Same as above", "author": "gmaretic", "createdAt": "2020-11-10T10:01:52Z", "path": "atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java", "diffHunk": "@@ -1163,6 +1184,26 @@ public void putMetadataForTable(TableReference tableRef, byte[] metadata) {\n         });\n     }\n \n+    @Override\n+    public Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults) {\n+        if (maxResults <= 0) {\n+            return Collections.emptyMap();\n+        }\n+        return run(conn -> {\n+            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n+                    \"SELECT table_name, value FROM \" + config.metadataTable().getQualifiedName())) {", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java b/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java\nindex 8bea503ba6..7d23b5a778 100644\n--- a/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java\n+++ b/atlasdb-dbkvs/src/main/java/com/palantir/atlasdb/keyvalue/dbkvs/impl/DbKvs.java\n\n@@ -1184,26 +1163,6 @@ public final class DbKvs extends AbstractKeyValueService {\n         });\n     }\n \n-    @Override\n-    public Map<TableReference, byte[]> getLimitedMetadataForTables(int maxResults) {\n-        if (maxResults <= 0) {\n-            return Collections.emptyMap();\n-        }\n-        return run(conn -> {\n-            try (AgnosticLightResultSet rows = conn.selectLightResultSetUnregisteredQuery(\n-                    \"SELECT table_name, value FROM \" + config.metadataTable().getQualifiedName())) {\n-                Map<TableReference, byte[]> ret = new HashMap<>();\n-                for (AgnosticResultRow row : rows) {\n-                    ret.put(TableReference.createUnsafe(row.getString(\"table_name\")), row.getBytes(\"value\"));\n-                    if (ret.size() >= maxResults) {\n-                        break;\n-                    }\n-                }\n-                return ret;\n-            }\n-        });\n-    }\n-\n     @Override\n     public void addGarbageCollectionSentinelValues(TableReference tableRef, Iterable<Cell> cells) {\n         runWrite(tableRef, (Function<DbWriteTable, Void>) table -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNzg3Mg==", "url": "https://github.com/palantir/atlasdb/pull/5105#discussion_r520437872", "bodyText": "Pretty clever \ud83d\udc4d", "author": "gmaretic", "createdAt": "2020-11-10T10:04:17Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java", "diffHunk": "@@ -195,6 +195,23 @@ public void dropTables(Set<TableReference> tableRefs) {\n         return ret;\n     }\n \n+    @Override\n+    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n+        Set<TableReference> ret = new HashSet<>();\n+        for (KeyValueService delegate : delegates) {\n+            // Note that this looks suboptimal, but there could be some overlap to the tables in each delegate.\n+            // If there is some overlap, we should at least reach maxResults (or the true total) by requesting\n+            // maxResults from each underlying KVS.\n+            for (TableReference tableRef : delegate.getLimitedTableNames(maxResults)) {", "originalCommit": "1c4c40ad591bfa0d6df700646e298c930ac4d383", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7ff34c808b6069446eaabd422d2e07232938aece", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java\nindex 5df9f20215..992c9f7a12 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/keyvalue/impl/TableSplittingKeyValueService.java\n\n@@ -195,23 +195,6 @@ public final class TableSplittingKeyValueService implements KeyValueService {\n         return ret;\n     }\n \n-    @Override\n-    public Iterable<TableReference> getLimitedTableNames(int maxResults) {\n-        Set<TableReference> ret = new HashSet<>();\n-        for (KeyValueService delegate : delegates) {\n-            // Note that this looks suboptimal, but there could be some overlap to the tables in each delegate.\n-            // If there is some overlap, we should at least reach maxResults (or the true total) by requesting\n-            // maxResults from each underlying KVS.\n-            for (TableReference tableRef : delegate.getLimitedTableNames(maxResults)) {\n-                ret.add(tableRef);\n-                if (ret.size() >= maxResults) {\n-                    return ret;\n-                }\n-            }\n-        }\n-        return ret;\n-    }\n-\n     @Override\n     public Multimap<Cell, Long> getAllTimestamps(TableReference tableRef, Set<Cell> cells, long timestamp) {\n         return getDelegate(tableRef).getAllTimestamps(tableRef, cells, timestamp);\n"}}, {"oid": "7ff34c808b6069446eaabd422d2e07232938aece", "url": "https://github.com/palantir/atlasdb/commit/7ff34c808b6069446eaabd422d2e07232938aece", "message": "remove getLimited versions of get tables/metadata\n\nTo avoid complexity, reducing change to just support FULL and NONE as\npossible options for cache warming. If desired we could implement\nlimited versions later with streams etc, but NONE should fix the\ninternal issue.", "committedDate": "2020-11-10T22:39:42Z", "type": "commit"}, {"oid": "7ff34c808b6069446eaabd422d2e07232938aece", "url": "https://github.com/palantir/atlasdb/commit/7ff34c808b6069446eaabd422d2e07232938aece", "message": "remove getLimited versions of get tables/metadata\n\nTo avoid complexity, reducing change to just support FULL and NONE as\npossible options for cache warming. If desired we could implement\nlimited versions later with streams etc, but NONE should fix the\ninternal issue.", "committedDate": "2020-11-10T22:39:42Z", "type": "forcePushed"}]}