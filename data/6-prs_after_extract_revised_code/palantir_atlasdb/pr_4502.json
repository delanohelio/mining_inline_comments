{"pr_number": 4502, "pr_title": "[LW] 2nd Prequel to Part 5: LockWatchStateUpdater", "pr_createdAt": "2020-01-10T14:53:57Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4502", "timeline": [{"oid": "382adf47b214e2ba7912b642f4e5312a8280d688", "url": "https://github.com/palantir/atlasdb/commit/382adf47b214e2ba7912b642f4e5312a8280d688", "message": "Get the trivial stuff out of the way", "committedDate": "2020-01-10T12:56:58Z", "type": "commit"}, {"oid": "060cefe0e90ae98736b388912e75a64f34329eb4", "url": "https://github.com/palantir/atlasdb/commit/060cefe0e90ae98736b388912e75a64f34329eb4", "message": "Add last update to VLWS, fix matchers in tests", "committedDate": "2020-01-10T13:17:16Z", "type": "commit"}, {"oid": "d09fc94b7458e44ab626d64d3b115cf99695225c", "url": "https://github.com/palantir/atlasdb/commit/d09fc94b7458e44ab626d64d3b115cf99695225c", "message": "Add LWSUpdater and tests", "committedDate": "2020-01-10T13:33:34Z", "type": "commit"}, {"oid": "db4861bb9579f9ca6769083da9b8cceef9537611", "url": "https://github.com/palantir/atlasdb/commit/db4861bb9579f9ca6769083da9b8cceef9537611", "message": "Merge with develop", "committedDate": "2020-01-13T10:51:46Z", "type": "commit"}, {"oid": "47d832221e40222602f5c66384422d45be3cc7cf", "url": "https://github.com/palantir/atlasdb/commit/47d832221e40222602f5c66384422d45be3cc7cf", "message": "Fix", "committedDate": "2020-01-13T10:53:25Z", "type": "commit"}, {"oid": "192c3cd5e231b3036c332428d0457e2398b073fe", "url": "https://github.com/palantir/atlasdb/commit/192c3cd5e231b3036c332428d0457e2398b073fe", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into lw/fragment2", "committedDate": "2020-02-03T10:39:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyOTE2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r374929161", "bodyText": "By this, do we mean that we make a new updater if we fall out of the window and/or there is a leader election?", "author": "jeremyk-91", "createdAt": "2020-02-04T21:20:25Z", "path": "lock-api/src/main/java/com/palantir/lock/watch/LockWatchStateUpdater.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import java.util.Map;\n+import java.util.OptionalLong;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+import com.google.common.collect.RangeSet;\n+import com.palantir.lock.LockDescriptor;\n+\n+@NotThreadSafe\n+public class LockWatchStateUpdater implements LockWatchEvent.Visitor<Void> {\n+    private final RangeSet<LockDescriptor> watches;\n+    private final Map<LockDescriptor, LockWatchInfo> lockWatchState;\n+    private final Set<UUID> unmatchedOpenLocksEvents;\n+\n+    /**\n+     * LockWatchStateUpdater is a LockWatchEvent visitor that updates the set of current lock watches, the state of\n+     * specific locks, and tracks the information on encountered open locks events. It is the responsibility of the\n+     * caller to visit lock watch events in the correct order as they occurred, without skipping events.", "originalCommit": "192c3cd5e231b3036c332428d0457e2398b073fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MTY1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r375191652", "bodyText": "Discussed offline: Usage is once per batch of updates, so that's ok - the calling class is responsible for invalidation in the election/too-much-lag cases.", "author": "jeremyk-91", "createdAt": "2020-02-05T11:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyOTE2MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMzM4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r374933381", "bodyText": "not sure how I feel about this test, it feels dependent on the contract of RangeSet (which is that it must coalesce) rather than anything we're doing in the code", "author": "jeremyk-91", "createdAt": "2020-02-04T21:29:36Z", "path": "lock-api/src/test/java/com/palantir/lock/watch/LockWatchStateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.watch;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+import static com.palantir.lock.watch.LockWatchInfo.State.LOCKED;\n+import static com.palantir.lock.watch.LockWatchInfo.State.UNLOCKED;\n+import static com.palantir.lock.watch.LockWatchReferences.TO_RANGES_VISITOR;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.OptionalLong;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+\n+import org.junit.Test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Range;\n+import com.google.common.collect.RangeSet;\n+import com.google.common.collect.TreeRangeSet;\n+import com.palantir.lock.AtlasCellLockDescriptor;\n+import com.palantir.lock.AtlasRowLockDescriptor;\n+import com.palantir.lock.LockDescriptor;\n+import com.palantir.lock.v2.LockToken;\n+import com.palantir.lock.watch.LockWatchReferences.LockWatchReference;\n+\n+public class LockWatchStateUpdaterTest {\n+    private static final String TABLE_NAME = \"test.table1\";\n+    private static final byte[] ROW = {1};\n+    private static final LockWatchReference TABLE_1 = LockWatchReferences.entireTable(TABLE_NAME);\n+    private static final LockWatchReference TABLE_2 = LockWatchReferences.entireTable(\"test.table2\");\n+    private static final LockWatchReference TABLE_3 = LockWatchReferences.entireTable(\"test.table3\");\n+    private static final LockWatchReference ROW_REF = LockWatchReferences.exactRow(TABLE_NAME, ROW);\n+    private static final LockDescriptor DESCRIPTOR = AtlasRowLockDescriptor.of(TABLE_NAME, ROW);\n+    private static final LockWatchEvent OPEN_LOCKS_EVENT = LockWatchOpenLocksEvent\n+            .builder(ImmutableSet.of(DESCRIPTOR), UUID.randomUUID())\n+            .build(1);\n+    private static final LockToken TOKEN = LockToken.of(UUID.randomUUID());\n+\n+    private final RangeSet<LockDescriptor> watches = TreeRangeSet.create();\n+    private final Map<LockDescriptor, LockWatchInfo> lockWatchState = new HashMap<>();\n+    private ConcurrentSkipListSet<UUID> unmatchedOpenLocksEvents = new ConcurrentSkipListSet<>();\n+    private final LockWatchStateUpdater updater = new LockWatchStateUpdater(watches, lockWatchState,\n+            unmatchedOpenLocksEvents);\n+\n+    @Test\n+    public void watchesAreUpdatedOnSingleEventWhenOpenLocksHappenedBefore() {\n+        UUID lockWatchId = UUID.randomUUID();\n+\n+        LockWatchEvent openLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(DESCRIPTOR), lockWatchId)\n+                .build(1);\n+        LockWatchEvent watchCreatedEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1, TABLE_3)), lockWatchId)\n+                .build(10);\n+\n+        openLocks.accept(updater);\n+        watchCreatedEvent.accept(updater);\n+        assertThat(watches.asRanges())\n+                .containsExactlyInAnyOrder(TABLE_1.accept(TO_RANGES_VISITOR), TABLE_3.accept(TO_RANGES_VISITOR));\n+    }\n+\n+    @Test\n+    public void watchesAreNotUpdatedOnSingleEventWhenOpenLocksHasNotHappenedWithSameId() {\n+        LockWatchEvent watchCreatedEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1, TABLE_3)), UUID.randomUUID())\n+                .build(10);\n+\n+        OPEN_LOCKS_EVENT.accept(updater);\n+        watchCreatedEvent.accept(updater);\n+        assertThat(watches.asRanges()).isEmpty();\n+    }\n+\n+    @Test\n+    public void watchesAreUpdatedOnMultipleEvents() {\n+        UUID first = UUID.randomUUID();\n+        UUID second = UUID.randomUUID();\n+\n+        LockWatchEvent firstOpenLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(DESCRIPTOR), first)\n+                .build(1);\n+        LockWatchEvent secondOpenLocks = LockWatchOpenLocksEvent\n+                .builder(ImmutableSet.of(), second)\n+                .build(2);\n+\n+        LockWatchEvent firstEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_1)), second).build(10);\n+        LockWatchEvent secondEvent = LockWatchCreatedEvent\n+                .builder(LockWatchRequest.of(ImmutableSet.of(TABLE_3)), first).build(20);\n+\n+        firstOpenLocks.accept(updater);\n+        secondOpenLocks.accept(updater);\n+        firstEvent.accept(updater);\n+        secondEvent.accept(updater);\n+\n+        assertThat(watches.asRanges())\n+                .containsExactlyInAnyOrder(TABLE_1.accept(TO_RANGES_VISITOR), TABLE_3.accept(TO_RANGES_VISITOR));\n+    }\n+\n+    @Test\n+    public void overlappingWatchesAreMergedOnUpdates() {", "originalCommit": "192c3cd5e231b3036c332428d0457e2398b073fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMDMyNA==", "url": "https://github.com/palantir/atlasdb/pull/4502#discussion_r375200324", "bodyText": "That's fair, but it's critical for us that re-registering watches does not blow up our ranges so I think it's fine to have this just to verify the invariant. Also, RangeSet is technically @Beta...", "author": "gmaretic", "createdAt": "2020-02-05T11:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMzM4MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "716fe6cc4063ee799e0701e0b745c928572eae75", "url": "https://github.com/palantir/atlasdb/commit/716fe6cc4063ee799e0701e0b745c928572eae75", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into lw/fragment2", "committedDate": "2020-02-05T11:25:02Z", "type": "commit"}]}