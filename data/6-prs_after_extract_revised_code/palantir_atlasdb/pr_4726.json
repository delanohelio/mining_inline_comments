{"pr_number": 4726, "pr_title": "[PaxosLog] Part 3: Namespacing SqlitePaxosStateLog", "pr_createdAt": "2020-04-21T21:08:37Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4726", "timeline": [{"oid": "32000580e250e84e5d55e0fc041ccf1e68dcde57", "url": "https://github.com/palantir/atlasdb/commit/32000580e250e84e5d55e0fc041ccf1e68dcde57", "message": "Namespaced paxos state log", "committedDate": "2020-04-21T20:49:49Z", "type": "commit"}, {"oid": "94948a9cdf6f488e11a2c60944469f13c70b4767", "url": "https://github.com/palantir/atlasdb/commit/94948a9cdf6f488e11a2c60944469f13c70b4767", "message": "Add test for namespacing", "committedDate": "2020-04-21T20:51:35Z", "type": "commit"}, {"oid": "284153aa386627da7334958bc7ad33edc59f1fff", "url": "https://github.com/palantir/atlasdb/commit/284153aa386627da7334958bc7ad33edc59f1fff", "message": "Wiring up learners to expose", "committedDate": "2020-04-21T20:59:53Z", "type": "commit"}, {"oid": "f6653971fd81dff19214223b2cff390bfc893263", "url": "https://github.com/palantir/atlasdb/commit/f6653971fd81dff19214223b2cff390bfc893263", "message": "Compile break", "committedDate": "2020-04-21T21:12:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMjEyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4726#discussion_r412522125", "bodyText": "Table per namespace, interesting.", "author": "jkozlowski", "createdAt": "2020-04-21T22:01:49Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -30,26 +30,34 @@\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n     private final Supplier<Connection> connectionSupplier;\n+    private final String logNamespace;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier) {\n+    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier, String logNamespace) {\n         this.connectionSupplier = connectionSupplier;\n+        this.logNamespace = logNamespace;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(Supplier<Connection> conn) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(\n+            Supplier<Connection> conn,\n+            String logNamespace) {\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn, logNamespace);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        executeVoid(\"CREATE TABLE IF NOT EXISTS paxosLog (seq BIGINT, val BLOB, CONSTRAINT pk_dual PRIMARY KEY (seq))\");\n+        executeVoid(\n+                String.format(\n+                        \"CREATE TABLE IF NOT EXISTS %s (seq BIGINT, val BLOB, CONSTRAINT pk_%s PRIMARY KEY (seq))\",", "originalCommit": "f6653971fd81dff19214223b2cff390bfc893263", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6df56e1cf70b66c17cbccd312929fac67ac6939e", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\nindex 447c0d75c7..b1e7053c4d 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\n\n@@ -16,113 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n-    private final String logNamespace;\n+    private final String namespace;\n+    private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier, String logNamespace) {\n-        this.connectionSupplier = connectionSupplier;\n-        this.logNamespace = logNamespace;\n+    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+        this.namespace = namespace;\n+        this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(\n-            Supplier<Connection> conn,\n-            String logNamespace) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn, logNamespace);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+            Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        executeVoid(\n-                String.format(\n-                        \"CREATE TABLE IF NOT EXISTS %s (seq BIGINT, val BLOB, CONSTRAINT pk_%s PRIMARY KEY (seq))\",\n-                        logNamespace,\n-                        logNamespace));\n+        execute(dao -> dao.createTable(namespace));\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        try {\n-            PreparedStatement preparedStatement = connectionSupplier.get().prepareStatement(\n-                    String.format(\"INSERT OR REPLACE INTO %s (seq, val) VALUES (?, ?)\", logNamespace));\n-            preparedStatement.setLong(1, seq);\n-            preparedStatement.setBytes(2, round.persistToBytes());\n-            preparedStatement.execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return executeStatement(String.format(\"SELECT val FROM %s WHERE seq = %s;\", logNamespace, seq))\n-                .map(SqlitePaxosStateLog::getByteArrayUnchecked)\n-                .orElse(null);\n+        return execute(dao -> dao.readRound(namespace, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return executeStatement(String.format(\"SELECT MIN(seq) FROM %s\", logNamespace))\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return executeStatement(String.format(\"SELECT MAX(seq) FROM %s\", logNamespace))\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        executeVoid(String.format(\"DELETE FROM %s WHERE seq <= %s\", logNamespace, toDeleteInclusive));\n+        execute(dao -> dao.truncate(namespace, toDeleteInclusive));\n     }\n \n-    private void executeVoid(String statement) {\n-        try {\n-            connectionSupplier.get().prepareStatement(statement).execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+    private <T> T execute(Function<Queries, T> call) {\n+        return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n-    private Optional<ResultSet> executeStatement(String statement) {\n-        try {\n-            ResultSet resultSet = connectionSupplier.get().prepareStatement(statement).executeQuery();\n-            return resultSet.isClosed() ? Optional.empty() : Optional.of(resultSet);\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n-    }\n+    public interface Queries {\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS <table> (seq BIGINT PRIMARY KEY, val BLOB)\")\n+        boolean createTable(@Define(\"table\") String table);\n \n-    private static long getLongResultUnchecked(ResultSet resultSet) {\n-        try {\n-            long candidate = resultSet.getLong(1);\n-            return resultSet.wasNull() ? PaxosAcceptor.NO_LOG_ENTRY : candidate;\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n-    }\n+        @SqlUpdate(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:seq, :value)\")\n+        boolean writeRound(@Define(\"table\") String table, @Bind(\"seq\") long seq, @Bind(\"value\") byte[] value);\n+\n+        @SqlQuery(\"SELECT val FROM <table> WHERE seq = :seq\")\n+        @SingleValue\n+        byte[] readRound(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+\n+        @SqlQuery(\"SELECT MIN(seq) FROM <table>\")\n+        OptionalLong getLeastLogEntry(@Define(\"table\") String table);\n+\n+        @SqlQuery(\"SELECT MAX(seq) FROM <table>\")\n+        OptionalLong getGreatestLogEntry(@Define(\"table\") String table);\n \n-    private static byte[] getByteArrayUnchecked(ResultSet resultSet) {\n-        try {\n-            return ByteStreams.toByteArray(resultSet.getBinaryStream(1));\n-        } catch (SQLException | IOException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        @SqlUpdate(\"DELETE FROM <table> WHERE seq <= :seq\")\n+        boolean truncate(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMjQwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4726#discussion_r412522401", "bodyText": "Can you create as many sqlite instances as you want if it's backed by the filesystem? Does it maintain some on-disk locks or something?", "author": "jkozlowski", "createdAt": "2020-04-21T22:02:26Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -30,26 +30,34 @@\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n     private final Supplier<Connection> connectionSupplier;\n+    private final String logNamespace;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier) {\n+    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier, String logNamespace) {\n         this.connectionSupplier = connectionSupplier;\n+        this.logNamespace = logNamespace;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(Supplier<Connection> conn) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(\n+            Supplier<Connection> conn,", "originalCommit": "f6653971fd81dff19214223b2cff390bfc893263", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6df56e1cf70b66c17cbccd312929fac67ac6939e", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\nindex 447c0d75c7..b1e7053c4d 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\n\n@@ -16,113 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n-    private final String logNamespace;\n+    private final String namespace;\n+    private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier, String logNamespace) {\n-        this.connectionSupplier = connectionSupplier;\n-        this.logNamespace = logNamespace;\n+    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+        this.namespace = namespace;\n+        this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(\n-            Supplier<Connection> conn,\n-            String logNamespace) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn, logNamespace);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+            Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        executeVoid(\n-                String.format(\n-                        \"CREATE TABLE IF NOT EXISTS %s (seq BIGINT, val BLOB, CONSTRAINT pk_%s PRIMARY KEY (seq))\",\n-                        logNamespace,\n-                        logNamespace));\n+        execute(dao -> dao.createTable(namespace));\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        try {\n-            PreparedStatement preparedStatement = connectionSupplier.get().prepareStatement(\n-                    String.format(\"INSERT OR REPLACE INTO %s (seq, val) VALUES (?, ?)\", logNamespace));\n-            preparedStatement.setLong(1, seq);\n-            preparedStatement.setBytes(2, round.persistToBytes());\n-            preparedStatement.execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return executeStatement(String.format(\"SELECT val FROM %s WHERE seq = %s;\", logNamespace, seq))\n-                .map(SqlitePaxosStateLog::getByteArrayUnchecked)\n-                .orElse(null);\n+        return execute(dao -> dao.readRound(namespace, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return executeStatement(String.format(\"SELECT MIN(seq) FROM %s\", logNamespace))\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return executeStatement(String.format(\"SELECT MAX(seq) FROM %s\", logNamespace))\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        executeVoid(String.format(\"DELETE FROM %s WHERE seq <= %s\", logNamespace, toDeleteInclusive));\n+        execute(dao -> dao.truncate(namespace, toDeleteInclusive));\n     }\n \n-    private void executeVoid(String statement) {\n-        try {\n-            connectionSupplier.get().prepareStatement(statement).execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+    private <T> T execute(Function<Queries, T> call) {\n+        return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n-    private Optional<ResultSet> executeStatement(String statement) {\n-        try {\n-            ResultSet resultSet = connectionSupplier.get().prepareStatement(statement).executeQuery();\n-            return resultSet.isClosed() ? Optional.empty() : Optional.of(resultSet);\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n-    }\n+    public interface Queries {\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS <table> (seq BIGINT PRIMARY KEY, val BLOB)\")\n+        boolean createTable(@Define(\"table\") String table);\n \n-    private static long getLongResultUnchecked(ResultSet resultSet) {\n-        try {\n-            long candidate = resultSet.getLong(1);\n-            return resultSet.wasNull() ? PaxosAcceptor.NO_LOG_ENTRY : candidate;\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n-    }\n+        @SqlUpdate(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:seq, :value)\")\n+        boolean writeRound(@Define(\"table\") String table, @Bind(\"seq\") long seq, @Bind(\"value\") byte[] value);\n+\n+        @SqlQuery(\"SELECT val FROM <table> WHERE seq = :seq\")\n+        @SingleValue\n+        byte[] readRound(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+\n+        @SqlQuery(\"SELECT MIN(seq) FROM <table>\")\n+        OptionalLong getLeastLogEntry(@Define(\"table\") String table);\n+\n+        @SqlQuery(\"SELECT MAX(seq) FROM <table>\")\n+        OptionalLong getGreatestLogEntry(@Define(\"table\") String table);\n \n-    private static byte[] getByteArrayUnchecked(ResultSet resultSet) {\n-        try {\n-            return ByteStreams.toByteArray(resultSet.getBinaryStream(1));\n-        } catch (SQLException | IOException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        @SqlUpdate(\"DELETE FROM <table> WHERE seq <= :seq\")\n+        boolean truncate(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyMzE4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4726#discussion_r412523185", "bodyText": "Do we need to enforce something about the logNamespace, I don't suspect sqlite likes any odd table names?", "author": "jkozlowski", "createdAt": "2020-04-21T22:03:59Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java", "diffHunk": "@@ -30,26 +30,34 @@\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n     private final Supplier<Connection> connectionSupplier;\n+    private final String logNamespace;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier) {\n+    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier, String logNamespace) {", "originalCommit": "f6653971fd81dff19214223b2cff390bfc893263", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6df56e1cf70b66c17cbccd312929fac67ac6939e", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\nindex 447c0d75c7..b1e7053c4d 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/SqlitePaxosStateLog.java\n\n@@ -16,113 +16,89 @@\n \n package com.palantir.paxos;\n \n-import java.io.IOException;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n import java.util.function.Supplier;\n \n-import com.google.common.io.ByteStreams;\n-import com.palantir.common.base.Throwables;\n+import org.jdbi.v3.core.Jdbi;\n+import org.jdbi.v3.sqlobject.SingleValue;\n+import org.jdbi.v3.sqlobject.SqlObjectPlugin;\n+import org.jdbi.v3.sqlobject.customizer.Bind;\n+import org.jdbi.v3.sqlobject.customizer.Define;\n+import org.jdbi.v3.sqlobject.statement.SqlQuery;\n+import org.jdbi.v3.sqlobject.statement.SqlUpdate;\n+\n import com.palantir.common.persist.Persistable;\n \n public final class SqlitePaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n-    private final Supplier<Connection> connectionSupplier;\n-    private final String logNamespace;\n+    private final String namespace;\n+    private final Jdbi jdbi;\n \n-    private SqlitePaxosStateLog(Supplier<Connection> connectionSupplier, String logNamespace) {\n-        this.connectionSupplier = connectionSupplier;\n-        this.logNamespace = logNamespace;\n+    private SqlitePaxosStateLog(String namespace, Jdbi jdbi) {\n+        this.namespace = namespace;\n+        this.jdbi = jdbi;\n     }\n \n-    public static <V extends Persistable & Versionable> PaxosStateLog<V> createInitialized(\n-            Supplier<Connection> conn,\n-            String logNamespace) {\n-        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(conn, logNamespace);\n+    public static <V extends Persistable & Versionable> PaxosStateLog<V> create(String namespace,\n+            Supplier<Connection> connectionSupplier) {\n+        Jdbi jdbi = Jdbi.create(connectionSupplier::get).installPlugin(new SqlObjectPlugin());\n+        SqlitePaxosStateLog<V> log = new SqlitePaxosStateLog<>(namespace, jdbi);\n         log.initialize();\n         return log;\n     }\n \n     private void initialize() {\n-        executeVoid(\n-                String.format(\n-                        \"CREATE TABLE IF NOT EXISTS %s (seq BIGINT, val BLOB, CONSTRAINT pk_%s PRIMARY KEY (seq))\",\n-                        logNamespace,\n-                        logNamespace));\n+        execute(dao -> dao.createTable(namespace));\n     }\n \n     @Override\n     public void writeRound(long seq, V round) {\n-        try {\n-            PreparedStatement preparedStatement = connectionSupplier.get().prepareStatement(\n-                    String.format(\"INSERT OR REPLACE INTO %s (seq, val) VALUES (?, ?)\", logNamespace));\n-            preparedStatement.setLong(1, seq);\n-            preparedStatement.setBytes(2, round.persistToBytes());\n-            preparedStatement.execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        execute(dao -> dao.writeRound(namespace, seq, round.persistToBytes()));\n     }\n \n     @Override\n     public byte[] readRound(long seq) {\n-        return executeStatement(String.format(\"SELECT val FROM %s WHERE seq = %s;\", logNamespace, seq))\n-                .map(SqlitePaxosStateLog::getByteArrayUnchecked)\n-                .orElse(null);\n+        return execute(dao -> dao.readRound(namespace, seq));\n     }\n \n     @Override\n     public long getLeastLogEntry() {\n-        return executeStatement(String.format(\"SELECT MIN(seq) FROM %s\", logNamespace))\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getLeastLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public long getGreatestLogEntry() {\n-        return executeStatement(String.format(\"SELECT MAX(seq) FROM %s\", logNamespace))\n-                .map(SqlitePaxosStateLog::getLongResultUnchecked)\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+        return execute(dao -> dao.getGreatestLogEntry(namespace)).orElse(PaxosAcceptor.NO_LOG_ENTRY);\n     }\n \n     @Override\n     public void truncate(long toDeleteInclusive) {\n-        executeVoid(String.format(\"DELETE FROM %s WHERE seq <= %s\", logNamespace, toDeleteInclusive));\n+        execute(dao -> dao.truncate(namespace, toDeleteInclusive));\n     }\n \n-    private void executeVoid(String statement) {\n-        try {\n-            connectionSupplier.get().prepareStatement(statement).execute();\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+    private <T> T execute(Function<Queries, T> call) {\n+        return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n-    private Optional<ResultSet> executeStatement(String statement) {\n-        try {\n-            ResultSet resultSet = connectionSupplier.get().prepareStatement(statement).executeQuery();\n-            return resultSet.isClosed() ? Optional.empty() : Optional.of(resultSet);\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n-    }\n+    public interface Queries {\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS <table> (seq BIGINT PRIMARY KEY, val BLOB)\")\n+        boolean createTable(@Define(\"table\") String table);\n \n-    private static long getLongResultUnchecked(ResultSet resultSet) {\n-        try {\n-            long candidate = resultSet.getLong(1);\n-            return resultSet.wasNull() ? PaxosAcceptor.NO_LOG_ENTRY : candidate;\n-        } catch (SQLException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n-    }\n+        @SqlUpdate(\"INSERT OR REPLACE INTO <table> (seq, val) VALUES (:seq, :value)\")\n+        boolean writeRound(@Define(\"table\") String table, @Bind(\"seq\") long seq, @Bind(\"value\") byte[] value);\n+\n+        @SqlQuery(\"SELECT val FROM <table> WHERE seq = :seq\")\n+        @SingleValue\n+        byte[] readRound(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n+\n+        @SqlQuery(\"SELECT MIN(seq) FROM <table>\")\n+        OptionalLong getLeastLogEntry(@Define(\"table\") String table);\n+\n+        @SqlQuery(\"SELECT MAX(seq) FROM <table>\")\n+        OptionalLong getGreatestLogEntry(@Define(\"table\") String table);\n \n-    private static byte[] getByteArrayUnchecked(ResultSet resultSet) {\n-        try {\n-            return ByteStreams.toByteArray(resultSet.getBinaryStream(1));\n-        } catch (SQLException | IOException e) {\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        @SqlUpdate(\"DELETE FROM <table> WHERE seq <= :seq\")\n+        boolean truncate(@Define(\"table\") String table, @Bind(\"seq\") long seq);\n     }\n }\n"}}, {"oid": "6df56e1cf70b66c17cbccd312929fac67ac6939e", "url": "https://github.com/palantir/atlasdb/commit/6df56e1cf70b66c17cbccd312929fac67ac6939e", "message": "Resolve merge conflicts", "committedDate": "2020-04-27T11:00:14Z", "type": "commit"}]}