{"pr_number": 4588, "pr_title": "Safer workflow for getting rows from CassandraKvs", "pr_createdAt": "2020-02-19T18:46:22Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4588", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNDQwNw==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381524407", "bodyText": "this is drafts, but I would put in normal review, I'll leave the other stuff out since you have todos on that.\nTo make tests a bit more readable, we typically get rid of the cruft by way of static functions e.g.\nprivate static Cell createCell(String row, String column) { ... }\nsince the PtBytes.toBytes is not important and is just cruft", "author": "felixdesouza", "createdAt": "2020-02-19T20:25:59Z", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\nindex e5fdfb25d9..b6829cdf6a 100644\n--- a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n+++ b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n\n@@ -323,16 +323,26 @@ public class CassandraKeyValueServiceIntegrationTest extends AbstractKeyValueSer\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 88L)));\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+//\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 93L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 95L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 99L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 91L)));\n \n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 100L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 101L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 102L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 103L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 104L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 105L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 106L)));\n \n \n         Iterable<byte[]> rows = new ArrayList() {{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzQ2NQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381527465", "bodyText": "do you want a containsOnly? that verifies you're skipping stuff?", "author": "felixdesouza", "createdAt": "2020-02-19T20:32:20Z", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{\n+           add(PtBytes.toBytes(\"row1\"));\n+            add(PtBytes.toBytes(\"row2\"));\n+            add(PtBytes.toBytes(\"row3\"));\n+            add(PtBytes.toBytes(\"row4\"));\n+            add(PtBytes.toBytes(\"row5\"));\n+\n+        }};\n+\n+        Map<Cell, Value> result = keyValueService.getRows(tableReference, rows, ColumnSelection.all(), STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsKeys(CELL_1, CELL_2, CELL_3, CELL_4, CELL_5);", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5ODU2MA==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381998560", "bodyText": "if I've understood correctly this should verify that the rows don't contain old timestamps?", "author": "felixdesouza", "createdAt": "2020-02-20T13:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyNzQ2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\nindex e5fdfb25d9..b6829cdf6a 100644\n--- a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n+++ b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n\n@@ -323,16 +323,26 @@ public class CassandraKeyValueServiceIntegrationTest extends AbstractKeyValueSer\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 88L)));\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+//\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 93L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 95L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 99L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 91L)));\n \n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 100L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 101L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 102L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 103L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 104L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 105L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 106L)));\n \n \n         Iterable<byte[]> rows = new ArrayList() {{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODY3Ng==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381528676", "bodyText": "similarly here, it's quite hard to see what's going on here, a nice helper method such as:\nprivate static Multimap<Cell, Value> cellWithValue(Cell cell, String data, long timestamp) {\n  return ImmutableListMultimap.of(cell, Value.create(PtBytes.toBytes(data), timestamp));\n}\nNot sure whether you wanted separate put's for any particular reason, but if not, make use of the ImmutableListMultimap.Builder\ne.g.\nprivate static Value value(String data, long timestamp) { ... }\n\nImmutableListMultimap.builder()\n  .putAll(CELL, value(\"data2\", 88L))\n  .putAll(CELL_1, value(\"moreData\", 80L), value(\"moreData\", 90L)\n  .putAll(CELL_2, valueWithTimestamps(\"moreData\", 73L, 75L, 60L))\n  ...\n  build();", "author": "felixdesouza", "createdAt": "2020-02-19T20:34:50Z", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5ODAyMw==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381998023", "bodyText": "if it's alright to put it into one, then I think the latter style works quite nicely i.e. single multimap with valueWithTimestamps method.", "author": "felixdesouza", "createdAt": "2020-02-20T13:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyODY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\nindex e5fdfb25d9..b6829cdf6a 100644\n--- a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n+++ b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n\n@@ -323,16 +323,26 @@ public class CassandraKeyValueServiceIntegrationTest extends AbstractKeyValueSer\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 88L)));\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+//\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 93L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 95L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 99L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 91L)));\n \n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 100L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 101L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 102L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 103L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 104L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 105L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 106L)));\n \n \n         Iterable<byte[]> rows = new ArrayList() {{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyOTY4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381529681", "bodyText": "use ImmutableList constructor: ImmutableList.of(PtBytes.toBytes(\"row1\"), ...).\nOne step further:\nprivate static Iterable<byte[]> rows(String... rowNames) {\n  return Arrays.stream(rowNames).map(PtBytes::toBytes).collect(Collectors.toList());\n}", "author": "felixdesouza", "createdAt": "2020-02-19T20:36:48Z", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+        byte[] data = PtBytes.toBytes(\"data\");\n+        byte[] moreData = PtBytes.toBytes(\"data2\");\n+\n+        Cell CELL_1 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_4 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column1\"));\n+        Cell CELL_5 = Cell.create(PtBytes.toBytes(\"row1\"), PtBytes.toBytes(\"column2\"));\n+\n+\n+        Cell CELL_2 = Cell.create(PtBytes.toBytes(\"row2\"), PtBytes.toBytes(\"column\"));\n+        Cell CELL_3 = Cell.create(PtBytes.toBytes(\"row3\"), PtBytes.toBytes(\"column\"));\n+\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(data, 8L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL, Value.create(moreData, 88L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+        Iterable<byte[]> rows = new ArrayList() {{", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5OTI4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381999285", "bodyText": "or better still, in order to not have to scroll up to figure out what row1 means, just use CELL.getRowName, or have the signature be Iterable<byte[]> rowNames(Cell... cells)", "author": "felixdesouza", "createdAt": "2020-02-20T13:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUyOTY4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\nindex e5fdfb25d9..b6829cdf6a 100644\n--- a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n+++ b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n\n@@ -323,16 +323,26 @@ public class CassandraKeyValueServiceIntegrationTest extends AbstractKeyValueSer\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 88L)));\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+//\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 93L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 95L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 99L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 91L)));\n \n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 100L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 101L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 102L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 103L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 104L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 105L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 106L)));\n \n \n         Iterable<byte[]> rows = new ArrayList() {{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMjAxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381532019", "bodyText": "what happens when this is null? how does it behave?", "author": "felixdesouza", "createdAt": "2020-02-19T20:41:34Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {\n+        if (columns.size() > 0) {\n+\n+            ColumnOrSuperColumn lastCol = columns.get(columns.size() - 1);\n+            Pair<byte[], Long> pair =  CassandraKeyValueServices.decompose(lastCol.getColumn().name);\n+\n+            return SlicePredicates.create(Range.of(CassandraKeyValueServices\n+                    .makeCompositeBuffer(RangeRequests.nextLexicographicName(pair.lhSide), Long.MAX_VALUE),\n+                    Range.UNBOUND_END), Limit.of(1));\n+        }\n+        return null;", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzM3Ng==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381533376", "bodyText": "should it fallback to what it was doing before?\nhow about this method return the KeyPredicate, so any null handling you have to do is within a function, if absolutely have to do any null handling.", "author": "felixdesouza", "createdAt": "2020-02-19T20:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMjAxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex b51212597c..4c8b9d9e73 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -633,34 +682,35 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> fetchAllColumnsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n-\n         final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n-        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n-        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult; //todo (Sudiksha) check null condition?\n \n-        //todo(Sudiksha): refactor\n-        while (!query.isEmpty()) {\n+        int magicBatchSize = 1;\n \n-            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n-            query.clear();\n+        SlicePredicate pred;\n+        List<ColumnOrSuperColumn> resultForRow;\n \n-            //todo refactor\n-            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+        for (byte[] row: rows) {\n+            pred = SlicePredicates.create(Range.ALL, Limit.of(magicBatchSize));\n \n-                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+            //todo(Sudiksha): refactor\n+            while (true) {\n+                partialResult = fetchColumnsInOneRequest(host, tableRef, ImmutableList.of(row), startTs, pred);\n \n-                if (!cells.isEmpty()) {\n-                    ByteBuffer row = cellsForRow.getKey();\n-                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n-                    query.add(new KeyPredicate()\n-                            .setKey(row)\n-                            .setPredicate(getSlicePredicate(cells)));\n-                }\n+                //todo refactor\n+                ByteBuffer row_buf = ByteBuffer.wrap(row);\n+                resultForRow = result.getOrDefault(row_buf, new ArrayList<>());\n+                resultForRow.addAll(partialResult.get(row_buf));\n+                result.put(row_buf, resultForRow);\n \n+                pred = getSlicePredicate(partialResult);\n+                if (partialResult.size() < magicBatchSize || pred == null) {\n+                    break;\n+                }\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTk5NzUwOA==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r381997508", "bodyText": "the deletion at this point isn't really important, in your test you have no deletion code anyway (not that I'm asking you to do so either), should name this along the lines of \"testGetRowsDoesNotReadOldData\" or something along those lines", "author": "felixdesouza", "createdAt": "2020-02-20T13:29:31Z", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +301,54 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRowsForDeletion() throws Exception {", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\nindex e5fdfb25d9..b6829cdf6a 100644\n--- a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n+++ b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n\n@@ -323,16 +323,26 @@ public class CassandraKeyValueServiceIntegrationTest extends AbstractKeyValueSer\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 80L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 85L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 89L)));\n+        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 88L)));\n \n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_4, Value.create(moreData, 95L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_5, Value.create(moreData, 98L)));\n         keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 90L)));\n+//\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 93L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 95L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 99L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 91L)));\n \n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 73L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 75L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_2, Value.create(moreData, 79L)));\n-        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_3, Value.create(moreData, 51L)));\n+\n+\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 100L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 101L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 102L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 103L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 104L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 105L)));\n+//        keyValueService.putWithTimestamps(tableReference, ImmutableListMultimap.of(CELL_1, Value.create(moreData, 106L)));\n \n \n         Iterable<byte[]> rows = new ArrayList() {{\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382001915", "bodyText": "this feels oddly similar to translateRowsToKeyPredicates", "author": "felixdesouza", "createdAt": "2020-02-20T13:37:30Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMzczNQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382003735", "bodyText": "perhaps instead of mutating the query, how about just setting it at the bottom? it would be nice to just make a new query object each time but we probably don't want recursion here.. so need some mutation somewhere.", "author": "felixdesouza", "createdAt": "2020-02-20T13:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDA3Nw==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382004077", "bodyText": "that way, I think you can reuse translateRowsToKeyPredicates, although I may be mistaken", "author": "felixdesouza", "createdAt": "2020-02-20T13:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwMTkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex b51212597c..4c8b9d9e73 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -633,34 +682,35 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> fetchAllColumnsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n-\n         final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n-        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n-        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult; //todo (Sudiksha) check null condition?\n \n-        //todo(Sudiksha): refactor\n-        while (!query.isEmpty()) {\n+        int magicBatchSize = 1;\n \n-            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n-            query.clear();\n+        SlicePredicate pred;\n+        List<ColumnOrSuperColumn> resultForRow;\n \n-            //todo refactor\n-            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+        for (byte[] row: rows) {\n+            pred = SlicePredicates.create(Range.ALL, Limit.of(magicBatchSize));\n \n-                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+            //todo(Sudiksha): refactor\n+            while (true) {\n+                partialResult = fetchColumnsInOneRequest(host, tableRef, ImmutableList.of(row), startTs, pred);\n \n-                if (!cells.isEmpty()) {\n-                    ByteBuffer row = cellsForRow.getKey();\n-                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n-                    query.add(new KeyPredicate()\n-                            .setKey(row)\n-                            .setPredicate(getSlicePredicate(cells)));\n-                }\n+                //todo refactor\n+                ByteBuffer row_buf = ByteBuffer.wrap(row);\n+                resultForRow = result.getOrDefault(row_buf, new ArrayList<>());\n+                resultForRow.addAll(partialResult.get(row_buf));\n+                result.put(row_buf, resultForRow);\n \n+                pred = getSlicePredicate(partialResult);\n+                if (partialResult.size() < magicBatchSize || pred == null) {\n+                    break;\n+                }\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNDc4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382004781", "bodyText": "just return  Maps.transformValues(...)", "author": "felixdesouza", "createdAt": "2020-02-20T13:42:37Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex b51212597c..4c8b9d9e73 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -633,34 +682,35 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> fetchAllColumnsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n-\n         final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n-        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n-        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult; //todo (Sudiksha) check null condition?\n \n-        //todo(Sudiksha): refactor\n-        while (!query.isEmpty()) {\n+        int magicBatchSize = 1;\n \n-            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n-            query.clear();\n+        SlicePredicate pred;\n+        List<ColumnOrSuperColumn> resultForRow;\n \n-            //todo refactor\n-            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+        for (byte[] row: rows) {\n+            pred = SlicePredicates.create(Range.ALL, Limit.of(magicBatchSize));\n \n-                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+            //todo(Sudiksha): refactor\n+            while (true) {\n+                partialResult = fetchColumnsInOneRequest(host, tableRef, ImmutableList.of(row), startTs, pred);\n \n-                if (!cells.isEmpty()) {\n-                    ByteBuffer row = cellsForRow.getKey();\n-                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n-                    query.add(new KeyPredicate()\n-                            .setKey(row)\n-                            .setPredicate(getSlicePredicate(cells)));\n-                }\n+                //todo refactor\n+                ByteBuffer row_buf = ByteBuffer.wrap(row);\n+                resultForRow = result.getOrDefault(row_buf, new ArrayList<>());\n+                resultForRow.addAll(partialResult.get(row_buf));\n+                result.put(row_buf, resultForRow);\n \n+                pred = getSlicePredicate(partialResult);\n+                if (partialResult.size() < magicBatchSize || pred == null) {\n+                    break;\n+                }\n             }\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAwNjIzMA==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382006230", "bodyText": "at some point, you want to comment on the optimisation is that you're doing, it's easy to get lost in CassandraKeyValueServiceImpl. If you're able to encode that in your method names, even better, but might make sense to just comment/javadoc.", "author": "felixdesouza", "createdAt": "2020-02-20T13:45:03Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +633,97 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n+        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+\n+        //todo(Sudiksha): refactor\n+        while (!query.isEmpty()) {\n+\n+            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n+            query.clear();\n+\n+            //todo refactor\n+            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+\n+                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+\n+                if (!cells.isEmpty()) {\n+                    ByteBuffer row = cellsForRow.getKey();\n+                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n+                    query.add(new KeyPredicate()\n+                            .setKey(row)\n+                            .setPredicate(getSlicePredicate(cells)));\n+                }\n+\n+            }\n+        }\n+\n+        Map<Cell, Value> ret = Maps.newHashMapWithExpectedSize(rows.size());\n+        new ValueExtractor(metricsManager, ret)\n+                .extractResults(result, startTs, ColumnSelection.all());\n+        return ret;\n+    }\n+\n+    //todo(Sudiksha): rename | refactor\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        //todo(Sudiksha): double check logging\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} {}starting at timestamp {} on {}\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"timestampClause\", \"\"),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+                        Map<ByteBuffer, List<ColumnOrSuperColumn>> aggregatedResults = Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+\n+                        return aggregatedResults;\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        //todo(Sudiksha): double check\n+                        return \"multiget_multislice(\" + host + \", \"\n+                                + query.size() + \" cells\" + \")\";\n+                    }\n+\n+                }\n+        );\n+    }\n+\n+    //todo(Sudiksha): refactor | names\n+    private static SlicePredicate getSlicePredicate(List<ColumnOrSuperColumn> columns) {", "originalCommit": "89973c53f510ea83b50253a27d8d9408518c535f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex b51212597c..4c8b9d9e73 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -633,34 +682,35 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> fetchAllColumnsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n-\n         final Map<ByteBuffer, List<ColumnOrSuperColumn>> result = Maps.newHashMap();\n-        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult;\n-        List<KeyPredicate> query = cellLoader.translateRowsToKeyPredicates(rows, config.fetchPerRowReadLimit());\n+        Map<ByteBuffer, List<ColumnOrSuperColumn>> partialResult; //todo (Sudiksha) check null condition?\n \n-        //todo(Sudiksha): refactor\n-        while (!query.isEmpty()) {\n+        int magicBatchSize = 1;\n \n-            partialResult = fetchCellsForKeyPredicates(host, tableRef, query, startTs);\n-            query.clear();\n+        SlicePredicate pred;\n+        List<ColumnOrSuperColumn> resultForRow;\n \n-            //todo refactor\n-            for(Entry<ByteBuffer, List<ColumnOrSuperColumn>> cellsForRow: partialResult.entrySet()) {\n+        for (byte[] row: rows) {\n+            pred = SlicePredicates.create(Range.ALL, Limit.of(magicBatchSize));\n \n-                List<ColumnOrSuperColumn> cells = cellsForRow.getValue();\n+            //todo(Sudiksha): refactor\n+            while (true) {\n+                partialResult = fetchColumnsInOneRequest(host, tableRef, ImmutableList.of(row), startTs, pred);\n \n-                if (!cells.isEmpty()) {\n-                    ByteBuffer row = cellsForRow.getKey();\n-                    result.getOrDefault(row, new ArrayList<>()).addAll(cells);\n-                    query.add(new KeyPredicate()\n-                            .setKey(row)\n-                            .setPredicate(getSlicePredicate(cells)));\n-                }\n+                //todo refactor\n+                ByteBuffer row_buf = ByteBuffer.wrap(row);\n+                resultForRow = result.getOrDefault(row_buf, new ArrayList<>());\n+                resultForRow.addAll(partialResult.get(row_buf));\n+                result.put(row_buf, resultForRow);\n \n+                pred = getSlicePredicate(partialResult);\n+                if (partialResult.size() < magicBatchSize || pred == null) {\n+                    break;\n+                }\n             }\n         }\n \n"}}, {"oid": "d51118f240929ff0f28e1137dfb03c7b7a9bd666", "url": "https://github.com/palantir/atlasdb/commit/d51118f240929ff0f28e1137dfb03c7b7a9bd666", "message": "Prototype", "committedDate": "2020-02-20T13:48:03Z", "type": "commit"}, {"oid": "4edea24dfd8d85378566856acaaf9f2b0d05bf9e", "url": "https://github.com/palantir/atlasdb/commit/4edea24dfd8d85378566856acaaf9f2b0d05bf9e", "message": "Minor changes.", "committedDate": "2020-02-20T13:48:03Z", "type": "commit"}, {"oid": "303a3aa59a02ed5761c403c6fc47ac1877287063", "url": "https://github.com/palantir/atlasdb/commit/303a3aa59a02ed5761c403c6fc47ac1877287063", "message": "Use multiget_multislice", "committedDate": "2020-02-20T13:48:04Z", "type": "commit"}, {"oid": "4f54abfce26d407df7acdbc58a2959e152652733", "url": "https://github.com/palantir/atlasdb/commit/4f54abfce26d407df7acdbc58a2959e152652733", "message": "Make read limit configurable + cleanup", "committedDate": "2020-02-20T13:48:04Z", "type": "commit"}, {"oid": "452e13d3c236f846b26ddbca60680936bd8f9b9b", "url": "https://github.com/palantir/atlasdb/commit/452e13d3c236f846b26ddbca60680936bd8f9b9b", "message": "Add todos", "committedDate": "2020-02-20T13:48:04Z", "type": "commit"}, {"oid": "452e13d3c236f846b26ddbca60680936bd8f9b9b", "url": "https://github.com/palantir/atlasdb/commit/452e13d3c236f846b26ddbca60680936bd8f9b9b", "message": "Add todos", "committedDate": "2020-02-20T13:48:04Z", "type": "forcePushed"}, {"oid": "1b2bbbe52453bac03a330e046979fb939448a043", "url": "https://github.com/palantir/atlasdb/commit/1b2bbbe52453bac03a330e046979fb939448a043", "message": "Test clean up", "committedDate": "2020-02-20T15:00:35Z", "type": "commit"}, {"oid": "4159d42ce6e7eb478dd922243a235d2331fbbb07", "url": "https://github.com/palantir/atlasdb/commit/4159d42ce6e7eb478dd922243a235d2331fbbb07", "message": "Bug Fix", "committedDate": "2020-02-20T15:01:42Z", "type": "commit"}, {"oid": "4381f0f8dbdd36f96fd91e5e52aa2a18a8549948", "url": "https://github.com/palantir/atlasdb/commit/4381f0f8dbdd36f96fd91e5e52aa2a18a8549948", "message": "Refactor | part 1", "committedDate": "2020-02-20T16:31:25Z", "type": "commit"}, {"oid": "cc068c8ba41a0782fd631edd68764cea0b59bc8b", "url": "https://github.com/palantir/atlasdb/commit/cc068c8ba41a0782fd631edd68764cea0b59bc8b", "message": "Refactor | credits - Felix", "committedDate": "2020-02-20T17:36:25Z", "type": "commit"}, {"oid": "7e381da52b91e7c24397ff47b5242c20ada6e629", "url": "https://github.com/palantir/atlasdb/commit/7e381da52b91e7c24397ff47b5242c20ada6e629", "message": "Minor refactor", "committedDate": "2020-02-20T17:38:33Z", "type": "commit"}, {"oid": "8046d3f51106b1002c3727fd5fe3590b33e16736", "url": "https://github.com/palantir/atlasdb/commit/8046d3f51106b1002c3727fd5fe3590b33e16736", "message": "Bug fix", "committedDate": "2020-02-20T17:42:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Njg2OQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382196869", "bodyText": "To be modified", "author": "sudiksha27", "createdAt": "2020-02-20T19:02:43Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java", "diffHunk": "@@ -64,6 +64,8 @@\n     // TODO (jkong): Review this limit, it seems like we are making very big requests to Cassandra even at this value\n     public static final int DEFAULT_SINGLE_QUERY_LOAD_BATCH_LIMIT = 50_000;\n \n+    public static final int DEFAULT_READ_LIMIT_PER_ROW = 200;\n+", "originalCommit": "8046d3f51106b1002c3727fd5fe3590b33e16736", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY1MTM2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r382651362", "bodyText": "Integer.MAX_VALUE for now as we want to maintain the existing behaviour.", "author": "sudiksha27", "createdAt": "2020-02-21T15:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Njg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b1531d39d1691d675a73607367f6412a07c1161e", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java\nindex 9112186539..3f3c681ae4 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraConstants.java\n\n@@ -64,7 +64,7 @@ public final class CassandraConstants {\n     // TODO (jkong): Review this limit, it seems like we are making very big requests to Cassandra even at this value\n     public static final int DEFAULT_SINGLE_QUERY_LOAD_BATCH_LIMIT = 50_000;\n \n-    public static final int DEFAULT_READ_LIMIT_PER_ROW = 200;\n+    public static final int DEFAULT_READ_LIMIT_PER_ROW = Integer.MAX_VALUE;\n \n     static final int DENSELY_ACCESSED_WIDE_ROWS_INDEX_INTERVAL = 1;\n     static final int DEFAULT_MIN_INDEX_INTERVAL = 128;\n"}}, {"oid": "a3b709048584523bf0e3282ed2441596ff6f70ab", "url": "https://github.com/palantir/atlasdb/commit/a3b709048584523bf0e3282ed2441596ff6f70ab", "message": "Remove unnecessary change", "committedDate": "2020-02-21T12:48:12Z", "type": "commit"}, {"oid": "9a88bfcb257f4a65e81b70c6422c760fefc1f158", "url": "https://github.com/palantir/atlasdb/commit/9a88bfcb257f4a65e81b70c6422c760fefc1f158", "message": "Address comments", "committedDate": "2020-02-21T17:02:40Z", "type": "commit"}, {"oid": "b1531d39d1691d675a73607367f6412a07c1161e", "url": "https://github.com/palantir/atlasdb/commit/b1531d39d1691d675a73607367f6412a07c1161e", "message": "Modify read limit", "committedDate": "2020-02-21T17:06:56Z", "type": "commit"}, {"oid": "d1f2bd4f9d7140bfa84b335df3c9e5eed45d4cf2", "url": "https://github.com/palantir/atlasdb/commit/d1f2bd4f9d7140bfa84b335df3c9e5eed45d4cf2", "message": "Test added", "committedDate": "2020-02-21T18:16:48Z", "type": "commit"}, {"oid": "3d83d0b4745028333f76c40566f673e74ce0d733", "url": "https://github.com/palantir/atlasdb/commit/3d83d0b4745028333f76c40566f673e74ce0d733", "message": "Minor test refactor", "committedDate": "2020-02-21T18:30:15Z", "type": "commit"}, {"oid": "34128de63695be16d801bcfcfb4fcb8564836ce9", "url": "https://github.com/palantir/atlasdb/commit/34128de63695be16d801bcfcfb4fcb8564836ce9", "message": "Add generated changelog entries", "committedDate": "2020-02-21T18:30:15Z", "type": "commit"}, {"oid": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "url": "https://github.com/palantir/atlasdb/commit/b4925c0ec513fd964411d9f6d3668f62c87cb989", "message": "Update pr-4588.v2.yml", "committedDate": "2020-02-21T18:52:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjA1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383322056", "bodyText": "This method is actually fetching the values as well, not just the cells. I would name it something like getAllCellsForRows", "author": "jeremyk-91", "createdAt": "2020-02-24T15:11:57Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,", "originalCommit": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "205a7246f2f210d37873e62ef149c57c92079daa", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex 52238e653c..50bd9335ac 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -634,7 +637,7 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> getAllCellsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNTA2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383325063", "bodyText": "as above, I'd prefer get instead of fetch because we are getting the values. Strictly speaking it should be getForCellsForKeyPredicates but I find that a bit clumsy, so would be ok with just changing the first word.", "author": "jeremyk-91", "createdAt": "2020-02-24T15:16:54Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,", "originalCommit": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "205a7246f2f210d37873e62ef149c57c92079daa", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex 52238e653c..50bd9335ac 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -634,7 +637,7 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> getAllCellsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjQyNg==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383326426", "bodyText": "nit: ... + \" cells)\"; rather than two separate strings", "author": "jeremyk-91", "createdAt": "2020-02-24T15:19:05Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java", "diffHunk": "@@ -652,6 +634,94 @@ public String toString() {\n         }\n     }\n \n+    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            final List<byte[]> rows,\n+            final long startTs) throws Exception {\n+\n+        final ListMultimap<ByteBuffer, ColumnOrSuperColumn> result = LinkedListMultimap.create();\n+\n+        List<KeyPredicate> query = rows.stream()\n+                .map(row -> keyPredicate(ByteBuffer.wrap(row), allPredicateWithLimit(config.fetchReadLimitPerRow())))\n+                .collect(Collectors.toList());\n+\n+        while (!query.isEmpty()) {\n+            ListMultimap<ByteBuffer, ColumnOrSuperColumn> partialResult = KeyedStream.stream(fetchCellsForKeyPredicates(host, tableRef, query, startTs))\n+                    .filter(cells -> !cells.isEmpty())\n+                    .flatMap(Collection::stream)\n+                    .collectToMultimap(LinkedListMultimap::create);\n+\n+            result.putAll(partialResult);\n+\n+            query = KeyedStream.stream(Multimaps.asMap(partialResult))\n+                    .map((row, cells) -> keyPredicate(row, getNextLexicographicalSlicePredicate(cells)))\n+                    .values()\n+                    .collect(Collectors.toList());\n+        }\n+\n+        ValueExtractor extractor = new ValueExtractor(metricsManager, Maps.newHashMapWithExpectedSize(result.size()));\n+        extractor.extractResults(Multimaps.asMap(result), startTs, ColumnSelection.all());\n+        return extractor.asMap();\n+    }\n+\n+    private static KeyPredicate keyPredicate(ByteBuffer row, SlicePredicate predicate) {\n+        return new KeyPredicate().setKey(row).setPredicate(predicate);\n+    }\n+\n+    private static SlicePredicate allPredicateWithLimit(int limit) {\n+        return SlicePredicates.create(Range.ALL, Limit.of(limit));\n+    }\n+\n+    private Map<ByteBuffer, List<ColumnOrSuperColumn>> fetchCellsForKeyPredicates(final InetSocketAddress host,\n+            final TableReference tableRef,\n+            List<KeyPredicate> query,\n+            final long startTs) throws Exception {\n+        return clientPool.runWithRetryOnHost(\n+                host,\n+                new FunctionCheckedException<CassandraClient, Map<ByteBuffer, List<ColumnOrSuperColumn>>, Exception>() {\n+                    @Override\n+                    public Map<ByteBuffer, List<ColumnOrSuperColumn>> apply(CassandraClient client) throws Exception {\n+\n+                        if (log.isTraceEnabled()) {\n+                            log.trace(\"Requesting {} cells from {} starting at timestamp {} on {} \"\n+                                            + \"as part of fetching cells for key predicates.\",\n+                                    SafeArg.of(\"cells\", query.size()),\n+                                    LoggingArgs.tableRef(tableRef),\n+                                    SafeArg.of(\"startTs\", startTs),\n+                                    SafeArg.of(\"host\", CassandraLogHelper.host(host)));\n+                        }\n+\n+                        Map<ByteBuffer, List<List<ColumnOrSuperColumn>>> results = wrappingQueryRunner.multiget_multislice(\n+                                \"getRows\", client, tableRef, query, readConsistency);\n+\n+                        return Maps.transformValues(results,\n+                                lists -> Lists.newArrayList(Iterables.concat(lists)));\n+                    }\n+\n+                    @Override\n+                    public String toString() {\n+                        return \"multiget_multislice(\" + host + \", \" + tableRef +\n+                                + query.size() + \" cells\" + \")\";", "originalCommit": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjcxMQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383326711", "bodyText": "And we probably want a comma before saying the number of cells. The idea is to get something like multiget_multislice(host, table, 1000 cells)", "author": "jeremyk-91", "createdAt": "2020-02-24T15:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjQyNg=="}], "type": "inlineReview", "revised_code": {"commit": "205a7246f2f210d37873e62ef149c57c92079daa", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\nindex 52238e653c..50bd9335ac 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceImpl.java\n\n@@ -634,7 +637,7 @@ public class CassandraKeyValueServiceImpl extends AbstractKeyValueService implem\n         }\n     }\n \n-    private Map<Cell, Value> fetchAllCellsForRows(final InetSocketAddress host,\n+    private Map<Cell, Value> getAllCellsForRows(final InetSocketAddress host,\n             final TableReference tableRef,\n             final List<byte[]> rows,\n             final long startTs) throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0MTI2OQ==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383341269", "bodyText": "Let's move this to the runtime config, so it can be reloaded more easily.", "author": "jeremyk-91", "createdAt": "2020-02-24T15:41:50Z", "path": "atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java", "diffHunk": "@@ -290,6 +290,11 @@ default int rangesConcurrency() {\n         return 32;\n     }\n \n+    @Value.Default\n+    default int fetchReadLimitPerRow() {\n+        return CassandraConstants.DEFAULT_READ_LIMIT_PER_ROW;\n+    }", "originalCommit": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "205a7246f2f210d37873e62ef149c57c92079daa", "chunk": "diff --git a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java\nindex fa0899a5a9..6317646bec 100644\n--- a/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java\n+++ b/atlasdb-cassandra/src/main/java/com/palantir/atlasdb/cassandra/CassandraKeyValueServiceConfig.java\n\n@@ -290,11 +290,6 @@ public interface CassandraKeyValueServiceConfig extends KeyValueServiceConfig {\n         return 32;\n     }\n \n-    @Value.Default\n-    default int fetchReadLimitPerRow() {\n-        return CassandraConstants.DEFAULT_READ_LIMIT_PER_ROW;\n-    }\n-\n     /**\n      * Obsolete value, replaced by {@link SweepConfig#readLimit}.\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM0NDQyMw==", "url": "https://github.com/palantir/atlasdb/pull/4588#discussion_r383344423", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();\n          \n      \n    \n    \n  \n\nIt's unused.", "author": "jeremyk-91", "createdAt": "2020-02-24T15:46:39Z", "path": "atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java", "diffHunk": "@@ -300,6 +306,66 @@ public void deletionTakesPlaceAtFreshTimestamp() throws Exception {\n         assertThat(results).doesNotContainKey(CELL);\n     }\n \n+    @Test\n+    public void testGetRows_highlyVersionedCells() {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+\n+        byte[] data = PtBytes.toBytes(\"data\");\n+\n+        Cell CELL_WITH_VERSIONS = Cell.create(row(1), column(1));\n+        Cell CELL_WITH_SAME_ROW = Cell.create(row(1), column(2));\n+\n+        ImmutableListMultimap<Cell, Value> tableValues = ImmutableListMultimap.<Cell, Value>builder()\n+                .putAll(CELL_WITH_VERSIONS, valueWithNumberOfTimestamps(data, 250L))\n+                .putAll(CELL_WITH_SAME_ROW, valueWithNumberOfTimestamps(data, 200L))\n+                .build();\n+\n+        keyValueService.putWithTimestamps(tableReference, tableValues);\n+\n+        Map<Cell, Value> result = keyValueService.getRows(\n+                tableReference,\n+                ImmutableList.of(CELL_WITH_VERSIONS.getRowName(), CELL_WITH_SAME_ROW.getRowName()),\n+                ColumnSelection.all(),\n+                STARTING_ATLAS_TIMESTAMP - 1);\n+\n+        assertThat(result).containsOnly(\n+                entry(CELL_WITH_VERSIONS, Value.create(data, 250L)),\n+                entry(CELL_WITH_SAME_ROW, Value.create(data, 200L)));\n+    }\n+\n+    @Test\n+    public void testGetRows_manyColumnRows() {\n+        TableReference tableReference =\n+                TableReference.createFromFullyQualifiedName(\"test.\" + RandomStringUtils.randomAlphanumeric(16));\n+        keyValueService.createTable(tableReference, AtlasDbConstants.GENERIC_TABLE_METADATA);\n+\n+        byte[] data = PtBytes.toBytes(\"data\");\n+\n+        ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();", "originalCommit": "b4925c0ec513fd964411d9f6d3668f62c87cb989", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "205a7246f2f210d37873e62ef149c57c92079daa", "chunk": "diff --git a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\nindex c241cf2efa..bbc6755fb5 100644\n--- a/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n+++ b/atlasdb-cassandra-integration-tests/src/test/java/com/palantir/atlasdb/keyvalue/cassandra/CassandraKeyValueServiceIntegrationTest.java\n\n@@ -343,8 +351,6 @@ public class CassandraKeyValueServiceIntegrationTest extends AbstractKeyValueSer\n \n         byte[] data = PtBytes.toBytes(\"data\");\n \n-        ImmutableListMultimap.Builder builder = ImmutableListMultimap.<Cell, Value>builder();\n-\n         IntStream stream = IntStream.rangeClosed(1, 1000);\n \n         byte[] row1 = row(1);\n"}}, {"oid": "205a7246f2f210d37873e62ef149c57c92079daa", "url": "https://github.com/palantir/atlasdb/commit/205a7246f2f210d37873e62ef149c57c92079daa", "message": "Address comments", "committedDate": "2020-02-24T16:26:23Z", "type": "commit"}, {"oid": "fdbe833301e3f4ecd681edb3b93fd87bcadba41c", "url": "https://github.com/palantir/atlasdb/commit/fdbe833301e3f4ecd681edb3b93fd87bcadba41c", "message": "Update pr-4588.v2.yml", "committedDate": "2020-02-24T16:38:01Z", "type": "commit"}, {"oid": "afebdf5ebbb9dc37b355862ed82a49437e1dccab", "url": "https://github.com/palantir/atlasdb/commit/afebdf5ebbb9dc37b355862ed82a49437e1dccab", "message": "Checkstyles", "committedDate": "2020-02-24T16:39:58Z", "type": "commit"}]}