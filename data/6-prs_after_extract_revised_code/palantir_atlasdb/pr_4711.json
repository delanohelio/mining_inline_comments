{"pr_number": 4711, "pr_title": "[ETE] Batching Txns, Attempt 2", "pr_createdAt": "2020-04-16T10:13:29Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4711", "timeline": [{"oid": "720aa3f84b14ed855dc7b53ad50e1e3d97434cc2", "url": "https://github.com/palantir/atlasdb/commit/720aa3f84b14ed855dc7b53ad50e1e3d97434cc2", "message": "wow this is a mess", "committedDate": "2020-04-15T14:40:39Z", "type": "commit"}, {"oid": "7538acafca7800e64f22cebc9ee8115af66d4ea5", "url": "https://github.com/palantir/atlasdb/commit/7538acafca7800e64f22cebc9ee8115af66d4ea5", "message": "more fixup", "committedDate": "2020-04-15T15:02:27Z", "type": "commit"}, {"oid": "c9106b2fd10913269fd80667dcb64321ef8afb91", "url": "https://github.com/palantir/atlasdb/commit/c9106b2fd10913269fd80667dcb64321ef8afb91", "message": "some more shimmy", "committedDate": "2020-04-16T09:06:34Z", "type": "commit"}, {"oid": "e288d0f1730e24fdaa8cd77e7b37c6ad62fd3eb4", "url": "https://github.com/palantir/atlasdb/commit/e288d0f1730e24fdaa8cd77e7b37c6ad62fd3eb4", "message": "re-jig a load of things", "committedDate": "2020-04-16T09:40:28Z", "type": "commit"}, {"oid": "7c82cbbaf24a7271bccbfc8276cfbb2af0bcf064", "url": "https://github.com/palantir/atlasdb/commit/7c82cbbaf24a7271bccbfc8276cfbb2af0bcf064", "message": "load more cleaning up I guess", "committedDate": "2020-04-16T10:06:14Z", "type": "commit"}, {"oid": "0eedf8ab5318fc7f55d961c0fba2e21f44262d16", "url": "https://github.com/palantir/atlasdb/commit/0eedf8ab5318fc7f55d961c0fba2e21f44262d16", "message": "add comment", "committedDate": "2020-04-16T10:19:21Z", "type": "commit"}, {"oid": "59f246f24630aecd97841ab1191cd73d8a76a2e1", "url": "https://github.com/palantir/atlasdb/commit/59f246f24630aecd97841ab1191cd73d8a76a2e1", "message": "Undo crazy aggressive formatting", "committedDate": "2020-04-16T10:23:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ0OTU4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r409449586", "bodyText": "This class is copied from bottom of SnapshotTransactionManager - probably want to merge the two (if I can find a place where it makes sense to live in the project hierarchy).", "author": "Jolyon-S", "createdAt": "2020-04-16T10:26:15Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/v2/ExceptionHandlingRunner.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.v2;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+\n+public final class ExceptionHandlingRunner implements AutoCloseable {", "originalCommit": "59f246f24630aecd97841ab1191cd73d8a76a2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f9c20aeccaf67369513132f46c4dddcab1543e8e", "chunk": "diff --git a/lock-api-objects/src/main/java/com/palantir/lock/v2/ExceptionHandlingRunner.java b/atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java\nsimilarity index 86%\nrename from lock-api-objects/src/main/java/com/palantir/lock/v2/ExceptionHandlingRunner.java\nrename to atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java\nindex 659c431a6a..6d099ddb71 100644\n--- a/lock-api-objects/src/main/java/com/palantir/lock/v2/ExceptionHandlingRunner.java\n+++ b/atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java\n\n@@ -14,14 +14,18 @@\n  * limitations under the License.\n  */\n \n-package com.palantir.lock.v2;\n+package com.palantir.util;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Optional;\n import java.util.function.Supplier;\n \n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n \n+/**\n+ * Some more java doc. Blah\n+ */\n public final class ExceptionHandlingRunner implements AutoCloseable {\n     private final List<Throwable> failures = new ArrayList<>();\n \n"}}, {"oid": "27f3e9ce14063f2009d3da8fb12eaa26bc2178c9", "url": "https://github.com/palantir/atlasdb/commit/27f3e9ce14063f2009d3da8fb12eaa26bc2178c9", "message": "remove batch manager", "committedDate": "2020-04-16T10:26:40Z", "type": "commit"}, {"oid": "fd559d34b3508f8d60707bb338666e299b5ee5dd", "url": "https://github.com/palantir/atlasdb/commit/fd559d34b3508f8d60707bb338666e299b5ee5dd", "message": "undo more formatting", "committedDate": "2020-04-16T10:29:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1NDkwNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r409454904", "bodyText": "I need to spend a bit of time confirming what these do and determine the most efficient way to do this.", "author": "Jolyon-S", "createdAt": "2020-04-16T10:35:15Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java", "diffHunk": "@@ -78,6 +89,21 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n         return timestampContainer;\n     }\n \n+    // pretty weird, I haven't put much effort into this, just to plug the gap really\n+    private <T, R> T checkAndUpdateLowerBoundBatch(Supplier<T> timestampContainerSupplier,\n+            Function<T, List<R>> responseExtractor,\n+            ToLongFunction<R> lowerBoundExtractor,\n+            ToLongFunction<R> upperBoundExtractor) {\n+        long threadLocalLowerBound = lowerBound.get();\n+        T timestampContainers = timestampContainerSupplier.get();\n+        List<R> responses = responseExtractor.apply(timestampContainers);\n+        responses.forEach(timestampContainer -> {\n+            checkTimestamp(threadLocalLowerBound, lowerBoundExtractor.applyAsLong(timestampContainer));\n+            updateLowerBound(upperBoundExtractor.applyAsLong(timestampContainer));", "originalCommit": "fd559d34b3508f8d60707bb338666e299b5ee5dd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e08ab50545dd61aeb40a499e9bedb016c1271993", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\nindex 674aa61422..7221613aa0 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\n\n@@ -89,21 +93,6 @@ public final class TimestampCorroboratingTimelockService implements AutoDelegate\n         return timestampContainer;\n     }\n \n-    // pretty weird, I haven't put much effort into this, just to plug the gap really\n-    private <T, R> T checkAndUpdateLowerBoundBatch(Supplier<T> timestampContainerSupplier,\n-            Function<T, List<R>> responseExtractor,\n-            ToLongFunction<R> lowerBoundExtractor,\n-            ToLongFunction<R> upperBoundExtractor) {\n-        long threadLocalLowerBound = lowerBound.get();\n-        T timestampContainers = timestampContainerSupplier.get();\n-        List<R> responses = responseExtractor.apply(timestampContainers);\n-        responses.forEach(timestampContainer -> {\n-            checkTimestamp(threadLocalLowerBound, lowerBoundExtractor.applyAsLong(timestampContainer));\n-            updateLowerBound(upperBoundExtractor.applyAsLong(timestampContainer));\n-        });\n-        return timestampContainers;\n-    }\n-\n     private static void checkTimestamp(long timestampLowerBound, long freshTimestamp) {\n         if (freshTimestamp <= timestampLowerBound) {\n             throw clocksWentBackwards(timestampLowerBound, freshTimestamp);\n"}}, {"oid": "04826a2d5c5cbde41cebe0f7deb0f1d6f6d82dfa", "url": "https://github.com/palantir/atlasdb/commit/04826a2d5c5cbde41cebe0f7deb0f1d6f6d82dfa", "message": "cleanup autobatcher", "committedDate": "2020-04-16T12:08:33Z", "type": "commit"}, {"oid": "26320aa39011fdb69889bcb1cc3d410ba2f1233a", "url": "https://github.com/palantir/atlasdb/commit/26320aa39011fdb69889bcb1cc3d410ba2f1233a", "message": "Don't auto format....", "committedDate": "2020-04-16T12:09:00Z", "type": "commit"}, {"oid": "e08ab50545dd61aeb40a499e9bedb016c1271993", "url": "https://github.com/palantir/atlasdb/commit/e08ab50545dd61aeb40a499e9bedb016c1271993", "message": "Clean up method in corrobating timelock service", "committedDate": "2020-04-16T12:19:47Z", "type": "commit"}, {"oid": "a33bd09307a5ae7d7bd0d3b50ab7d0f3432d14da", "url": "https://github.com/palantir/atlasdb/commit/a33bd09307a5ae7d7bd0d3b50ab7d0f3432d14da", "message": "Improve the batch code significantly", "committedDate": "2020-04-16T12:36:40Z", "type": "commit"}, {"oid": "9e54c2b1bb79dddd3ef889298202e790af45a995", "url": "https://github.com/palantir/atlasdb/commit/9e54c2b1bb79dddd3ef889298202e790af45a995", "message": "Register locks in a batch", "committedDate": "2020-04-16T12:41:53Z", "type": "commit"}, {"oid": "f9c20aeccaf67369513132f46c4dddcab1543e8e", "url": "https://github.com/palantir/atlasdb/commit/f9c20aeccaf67369513132f46c4dddcab1543e8e", "message": "Move and further cleaning", "committedDate": "2020-04-16T12:53:09Z", "type": "commit"}, {"oid": "670687d377e83ad92f8cb1fc14e19003e48db17c", "url": "https://github.com/palantir/atlasdb/commit/670687d377e83ad92f8cb1fc14e19003e48db17c", "message": "Move and further cleaning", "committedDate": "2020-04-16T12:55:29Z", "type": "commit"}, {"oid": "1453b54c8b9b8b2f37c9e8a74044af66a9c4088e", "url": "https://github.com/palantir/atlasdb/commit/1453b54c8b9b8b2f37c9e8a74044af66a9c4088e", "message": "Remove unused import", "committedDate": "2020-04-16T13:05:28Z", "type": "commit"}, {"oid": "ce6bdcbe612ea10db4c6e45f86c087e723483659", "url": "https://github.com/palantir/atlasdb/commit/ce6bdcbe612ea10db4c6e45f86c087e723483659", "message": "Rewrite java doc", "committedDate": "2020-04-16T13:37:50Z", "type": "commit"}, {"oid": "6515aa215db4bcd9f5dc02fafaa0a4205c104405", "url": "https://github.com/palantir/atlasdb/commit/6515aa215db4bcd9f5dc02fafaa0a4205c104405", "message": "Add test for exceptionHandlingRunner", "committedDate": "2020-04-16T13:55:08Z", "type": "commit"}, {"oid": "1a629cb8a74f2c969ed14039ad734497acf342e6", "url": "https://github.com/palantir/atlasdb/commit/1a629cb8a74f2c969ed14039ad734497acf342e6", "message": "Remove SnapshotTransactionManager's private shutdown runner", "committedDate": "2020-04-16T13:56:32Z", "type": "commit"}, {"oid": "91a210f4f490aed49fed05e0872be29a8aad88c8", "url": "https://github.com/palantir/atlasdb/commit/91a210f4f490aed49fed05e0872be29a8aad88c8", "message": "Add test to TimestampCorrobatingTimelockServiceTest", "committedDate": "2020-04-16T14:02:52Z", "type": "commit"}, {"oid": "107b08a8e31864fea19d96a88f811292c9064f17", "url": "https://github.com/palantir/atlasdb/commit/107b08a8e31864fea19d96a88f811292c9064f17", "message": "Add SnapshotTransactionManager test", "committedDate": "2020-04-16T14:29:07Z", "type": "commit"}, {"oid": "07a56a9c69cac73bfe20387f74798bfde6967ffb", "url": "https://github.com/palantir/atlasdb/commit/07a56a9c69cac73bfe20387f74798bfde6967ffb", "message": "Add line to hit the batch part in profilling timelock service test", "committedDate": "2020-04-16T14:36:03Z", "type": "commit"}, {"oid": "9b007048b7f5d4dd340c010e06484aad2b5cc43e", "url": "https://github.com/palantir/atlasdb/commit/9b007048b7f5d4dd340c010e06484aad2b5cc43e", "message": "Add batch test to TransactionStarter", "committedDate": "2020-04-16T15:03:13Z", "type": "commit"}, {"oid": "bd91381447e811bd9154a7f6209a254db3d0f5fd", "url": "https://github.com/palantir/atlasdb/commit/bd91381447e811bd9154a7f6209a254db3d0f5fd", "message": "Fix some checkstyle", "committedDate": "2020-04-17T08:10:45Z", "type": "commit"}, {"oid": "0e708dc67a87d4a16606a6fb40576efd62044e17", "url": "https://github.com/palantir/atlasdb/commit/0e708dc67a87d4a16606a6fb40576efd62044e17", "message": "Rename argument", "committedDate": "2020-04-17T08:12:27Z", "type": "commit"}, {"oid": "0fcda8cb6c02188ae333a3f95619fd3e7a9ce477", "url": "https://github.com/palantir/atlasdb/commit/0fcda8cb6c02188ae333a3f95619fd3e7a9ce477", "message": "Fix further checkstyles", "committedDate": "2020-04-17T08:13:28Z", "type": "commit"}, {"oid": "e7840a561b60d4abb3f16747e9fbcbf253d75eee", "url": "https://github.com/palantir/atlasdb/commit/e7840a561b60d4abb3f16747e9fbcbf253d75eee", "message": "Add extra close call in case of empty responses", "committedDate": "2020-04-17T08:20:43Z", "type": "commit"}, {"oid": "c232d369b2adae5168a9ed5ede1851000fa964fe", "url": "https://github.com/palantir/atlasdb/commit/c232d369b2adae5168a9ed5ede1851000fa964fe", "message": "Merge branch 'develop' into fork-batch-txns", "committedDate": "2020-04-17T08:28:54Z", "type": "commit"}, {"oid": "50971350ec6a3b166f2b236c02bbb44809a06256", "url": "https://github.com/palantir/atlasdb/commit/50971350ec6a3b166f2b236c02bbb44809a06256", "message": "Factor out shutdown runner", "committedDate": "2020-04-17T08:37:31Z", "type": "commit"}, {"oid": "65df14408e6d004599712b74029fc0f310249372", "url": "https://github.com/palantir/atlasdb/commit/65df14408e6d004599712b74029fc0f310249372", "message": "Add generated changelog entries", "committedDate": "2020-04-17T08:37:31Z", "type": "commit"}, {"oid": "034408c8d419931c04d1200a003cb6ad0b36719a", "url": "https://github.com/palantir/atlasdb/commit/034408c8d419931c04d1200a003cb6ad0b36719a", "message": "Merge branch 'extract-exception-handler' into fork-batch-txns\n\n# Conflicts:\n#\tatlasdb-commons/src/test/java/com/palantir/util/ExceptionHandlingRunnerTests.java", "committedDate": "2020-04-17T08:43:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5NDA1OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r410094059", "bodyText": "We can probably optimise this in the batched case (only update once), if that is a performance concern.", "author": "Jolyon-S", "createdAt": "2020-04-17T09:09:18Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch responses =\n+                timelockService.startIdentifiedAtlasDbTransactionsBatch(conditions.size())) {\n+            if (responses.size() != conditions.size()) {\n+                throw new TransactionBatchFailedRetriableException(\n+                        \"The number of transactions started does not match the size of the batch.\");\n+            }\n+\n+            List<TransactionAndImmutableTsLock> transactions = Streams.zip(\n+                    responses.getResponses().stream(),\n+                    conditions.stream(),\n+                    (response, condition) -> wrapResponse(condition, response)).collect(Collectors.toList());\n+            return responses.successful(transactions);\n+        }\n+    }\n+\n+    private TransactionAndImmutableTsLock wrapResponse(PreCommitCondition condition,\n+            StartIdentifiedAtlasDbTransactionResponse transactionResponse) {\n+        LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n+        long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n+        recordImmutableTimestamp(immutableTs);", "originalCommit": "034408c8d419931c04d1200a003cb6ad0b36719a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MTg3NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413081874", "bodyText": "@jeremyk-91 to help verify; also probably need metrics to help answer this", "author": "jkozlowski", "createdAt": "2020-04-22T15:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5NDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxOTY5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413219691", "bodyText": "Hard to say: this does a single atomic CAS so it shouldn't be too bad. Maybe just have a method wrapResponses that does the atomic update just once (with either the max of the immutable timestamps across the list, if we choose to be defensive, or the first element, if we want to rely on how creating batches normally goes)?", "author": "jeremyk-91", "createdAt": "2020-04-22T18:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA5NDA1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex cb64965f64..99a5cffe6a 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,14 +168,8 @@ import com.palantir.util.ExceptionHandlingRunner;\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n-        try {\n-            return wrapResponse(condition, transactionResponse);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        // I am reluctant to remove outright\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n     }\n \n     @Override\n"}}, {"oid": "8c616629f5c7011f455ad4b4c729020cd59e521d", "url": "https://github.com/palantir/atlasdb/commit/8c616629f5c7011f455ad4b4c729020cd59e521d", "message": "Change to use AtlasFutures", "committedDate": "2020-04-17T10:00:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1NDgwNg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413054806", "bodyText": "What does \"for the tasks\" mean?", "author": "jkozlowski", "createdAt": "2020-04-22T14:54:29Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n+    /**\n+     * This method exposes the ability to start a batch of transactions with pre-commit conditions in a single call.\n+     * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n+     * the code has been specifically optimised with respect to batching and error handling.\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks for the tasks", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MzExNg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r415653116", "bodyText": "Read the javadoc for the old method - was simply mirroring what was said there but in plural form.", "author": "Jolyon-S", "createdAt": "2020-04-27T09:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA1NDgwNg=="}], "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\nindex 2b9533d57f..4bf04ac91d 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n\n@@ -439,8 +439,11 @@ public interface TransactionManager extends AutoCloseable {\n      * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n      * the code has been specifically optimised with respect to batching and error handling.\n      *\n-     * @return a list of transactions and their associated immutable timestamp locks for the tasks\n+     * @deprecated Similar functionality will exist, but this method is likely to change in the future\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks\n      */\n+    @Deprecated\n     @Timed\n     List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n             List<PreCommitCondition> condition);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA2Nzc2Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413067762", "bodyText": "Refactor this check to a method.", "author": "jkozlowski", "createdAt": "2020-04-22T15:09:28Z", "path": "atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java", "diffHunk": "@@ -86,11 +89,31 @@ private static ThreadFactory createThreadFactory(String safeLoggablePurpose) {\n     public ListenableFuture<R> apply(T argument) {\n         Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n-        buffer.publishEvent((refresh, sequence) -> {\n+        buffer.publishEvent(createTranslator(argument, result));\n+        return result;\n+    }\n+\n+    public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n+        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java b/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\nindex f9debd824c..e8a43fece7 100644\n--- a/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\n+++ b/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\n\n@@ -87,14 +87,14 @@ public final class DisruptorAutobatcher<T, R>\n \n     @Override\n     public ListenableFuture<R> apply(T argument) {\n-        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        checkClosed();\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n         buffer.publishEvent(createTranslator(argument, result));\n         return result;\n     }\n \n     public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n-        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        checkClosed();\n         List<ListenableFuture<R>> results = new ArrayList<>();\n \n         EventTranslator<DefaultBatchElement<T, R>>[] translators = arguments.stream().map(argument -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA2ODkwMA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413068900", "bodyText": "Tests for this method, and I suppose for this whole class? The batching code is tricky, so definitely need tests for batching code.", "author": "jkozlowski", "createdAt": "2020-04-22T15:10:50Z", "path": "atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java", "diffHunk": "@@ -86,11 +89,31 @@ private static ThreadFactory createThreadFactory(String safeLoggablePurpose) {\n     public ListenableFuture<R> apply(T argument) {\n         Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n-        buffer.publishEvent((refresh, sequence) -> {\n+        buffer.publishEvent(createTranslator(argument, result));\n+        return result;\n+    }\n+\n+    public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n+        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        List<ListenableFuture<R>> results = new ArrayList<>();\n+\n+        EventTranslator<DefaultBatchElement<T, R>>[] translators = arguments.stream().map(argument -> {\n+            DisruptorFuture<R> result = new DisruptorFuture<>(safeLoggablePurpose);\n+            EventTranslator<DefaultBatchElement<T, R>> translator = createTranslator(argument, result);\n+            results.add(result);\n+            return translator;\n+        }).toArray(EventTranslator[]::new);\n+\n+        buffer.publishEvents(translators);\n+\n+        return results;", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java b/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\nindex f9debd824c..e8a43fece7 100644\n--- a/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\n+++ b/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\n\n@@ -87,14 +87,14 @@ public final class DisruptorAutobatcher<T, R>\n \n     @Override\n     public ListenableFuture<R> apply(T argument) {\n-        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        checkClosed();\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n         buffer.publishEvent(createTranslator(argument, result));\n         return result;\n     }\n \n     public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n-        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        checkClosed();\n         List<ListenableFuture<R>> results = new ArrayList<>();\n \n         EventTranslator<DefaultBatchElement<T, R>>[] translators = arguments.stream().map(argument -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3MTA5OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413071099", "bodyText": "Would it be a lot of overhead for removing the non-batched method here?", "author": "jkozlowski", "createdAt": "2020-04-22T15:13:28Z", "path": "atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java", "diffHunk": "@@ -86,11 +89,31 @@ private static ThreadFactory createThreadFactory(String safeLoggablePurpose) {\n     public ListenableFuture<R> apply(T argument) {\n         Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n-        buffer.publishEvent((refresh, sequence) -> {\n+        buffer.publishEvent(createTranslator(argument, result));\n+        return result;\n+    }\n+\n+    public List<ListenableFuture<R>> applyBatch(List<T> arguments) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1NDQxNw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r415654417", "bodyText": "I think so - it is used in quite a few places.\nWe could instead just have apply call applyBatch instead.", "author": "Jolyon-S", "createdAt": "2020-04-27T09:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3MTA5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java b/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\nindex f9debd824c..e8a43fece7 100644\n--- a/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\n+++ b/atlasdb-autobatch/src/main/java/com/palantir/atlasdb/autobatch/DisruptorAutobatcher.java\n\n@@ -87,14 +87,14 @@ public final class DisruptorAutobatcher<T, R>\n \n     @Override\n     public ListenableFuture<R> apply(T argument) {\n-        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        checkClosed();\n         DisruptorFuture<R> result = new DisruptorFuture<R>(safeLoggablePurpose);\n         buffer.publishEvent(createTranslator(argument, result));\n         return result;\n     }\n \n     public List<ListenableFuture<R>> applyBatch(List<T> arguments) {\n-        Preconditions.checkState(!closed, \"Autobatcher is already shut down\");\n+        checkClosed();\n         List<ListenableFuture<R>> results = new ArrayList<>();\n \n         EventTranslator<DefaultBatchElement<T, R>>[] translators = arguments.stream().map(argument -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3MTUxOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413071518", "bodyText": "Again, would it make sense to only keep the batched method? count=1 should be simple to handle.", "author": "jkozlowski", "createdAt": "2020-04-22T15:13:58Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java", "diffHunk": "@@ -67,6 +68,13 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n                 r -> r.startTimestampAndPartition().timestamp());\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\nindex 90dc094f51..5fe73d971e 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\n\n@@ -62,17 +64,16 @@ public final class TimestampCorroboratingTimelockService implements AutoDelegate\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return checkAndUpdateLowerBound(delegate::startIdentifiedAtlasDbTransaction,\n-                r -> r.startTimestampAndPartition().timestamp(),\n-                r -> r.startTimestampAndPartition().timestamp());\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        return checkAndUpdateLowerBound(() -> delegate.startIdentifiedAtlasDbTransactionBatch(count),\n+                responses -> Collections.min(getTimestampsFromResponses(responses)),\n+                responses -> Collections.max(getTimestampsFromResponses(responses)));\n     }\n \n-    @Override\n-    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        return checkAndUpdateLowerBound(() -> delegate.startIdentifiedAtlasDbTransactionsBatch(count),\n-                StartIdentifiedAtlasDbTransactionResponseBatch::getMinTimestamp,\n-                StartIdentifiedAtlasDbTransactionResponseBatch::getMaxTimestamp);\n+    private List<Long> getTimestampsFromResponses(List<StartIdentifiedAtlasDbTransactionResponse> responses) {\n+        return responses.stream().map(\n+                response -> response.immutableTimestamp().getImmutableTimestamp()).collect(\n+                Collectors.toList());\n     }\n \n     private <T> T checkAndUpdateLowerBound(Supplier<T> timestampContainerSupplier,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3NjQyOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413076429", "bodyText": "Running close should be enforced to only ever happen once. Also you should probably not allow adding more callbacks after close is called.", "author": "jkozlowski", "createdAt": "2020-04-22T15:20:00Z", "path": "atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import com.palantir.logsafe.exceptions.SafeRuntimeException;\n+\n+/**\n+ * Runs runnables and suppliers that may throw exceptions, and swallows those exceptions until later. Can be used as a\n+ * resource in a try block, or delegated to by another resource.\n+ */\n+public final class ExceptionHandlingRunner implements AutoCloseable {\n+    private final List<Throwable> failures = new ArrayList<>();\n+\n+    public ExceptionHandlingRunner() {}\n+\n+    /**\n+     * Instantiates the runner with a throwable that has already been caught, to be rethrown when close is complete.\n+     */\n+    public ExceptionHandlingRunner(Throwable t) {\n+        failures.add(t);\n+    }\n+\n+    public void runSafely(Runnable shutdownCallback) {\n+        try {\n+            shutdownCallback.run();\n+        } catch (Throwable throwable) {\n+            failures.add(throwable);\n+        }\n+    }\n+\n+    public <T> Optional<T> supplySafely(Supplier<T> shutdownCallback) {\n+        try {\n+            return Optional.of(shutdownCallback.get());\n+        } catch (Throwable throwable) {\n+            failures.add(throwable);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Calling close with no failures should be a no-op; equally, calling close multiple times will re-throw a runtime\n+     * exception with the same suppressed errors (plus any additional errors suppressed since the last close call).\n+     */\n+    @Override\n+    public void close() {\n+        if (!failures.isEmpty()) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "chunk": "diff --git a/atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java b/atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java\nindex 550648a012..f258be4699 100644\n--- a/atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java\n+++ b/atlasdb-commons/src/main/java/com/palantir/util/ExceptionHandlingRunner.java\n\n@@ -18,9 +18,8 @@ package com.palantir.util;\n \n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Supplier;\n \n+import com.palantir.logsafe.Preconditions;\n import com.palantir.logsafe.exceptions.SafeRuntimeException;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3NzYxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413077619", "bodyText": "2 arguments of the same type, wink wink \ud83d\ude09", "author": "jkozlowski", "createdAt": "2020-04-22T15:21:26Z", "path": "atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java", "diffHunk": "@@ -67,6 +68,13 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n                 r -> r.startTimestampAndPartition().timestamp());\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        return checkAndUpdateLowerBound(() -> delegate.startIdentifiedAtlasDbTransactionsBatch(count),\n+                StartIdentifiedAtlasDbTransactionResponseBatch::getMinTimestamp,\n+                StartIdentifiedAtlasDbTransactionResponseBatch::getMaxTimestamp);\n+    }\n+\n     private <T> T checkAndUpdateLowerBound(Supplier<T> timestampContainerSupplier,\n             ToLongFunction<T> lowerBoundExtractor,", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "chunk": "diff --git a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\nindex 90dc094f51..5fe73d971e 100644\n--- a/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\n+++ b/atlasdb-config/src/main/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockService.java\n\n@@ -62,17 +64,16 @@ public final class TimestampCorroboratingTimelockService implements AutoDelegate\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return checkAndUpdateLowerBound(delegate::startIdentifiedAtlasDbTransaction,\n-                r -> r.startTimestampAndPartition().timestamp(),\n-                r -> r.startTimestampAndPartition().timestamp());\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        return checkAndUpdateLowerBound(() -> delegate.startIdentifiedAtlasDbTransactionBatch(count),\n+                responses -> Collections.min(getTimestampsFromResponses(responses)),\n+                responses -> Collections.max(getTimestampsFromResponses(responses)));\n     }\n \n-    @Override\n-    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        return checkAndUpdateLowerBound(() -> delegate.startIdentifiedAtlasDbTransactionsBatch(count),\n-                StartIdentifiedAtlasDbTransactionResponseBatch::getMinTimestamp,\n-                StartIdentifiedAtlasDbTransactionResponseBatch::getMaxTimestamp);\n+    private List<Long> getTimestampsFromResponses(List<StartIdentifiedAtlasDbTransactionResponse> responses) {\n+        return responses.stream().map(\n+                response -> response.immutableTimestamp().getImmutableTimestamp()).collect(\n+                Collectors.toList());\n     }\n \n     private <T> T checkAndUpdateLowerBound(Supplier<T> timestampContainerSupplier,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA3ODk1OA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413078958", "bodyText": "Generally it's nicer to allow fall through like this (so allow empty list), I think this is what the usage of this in internal ski product assumed.", "author": "jkozlowski", "createdAt": "2020-04-22T15:23:05Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex cb64965f64..99a5cffe6a 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,14 +168,8 @@ import com.palantir.util.ExceptionHandlingRunner;\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n-        try {\n-            return wrapResponse(condition, transactionResponse);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        // I am reluctant to remove outright\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MDYwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413080605", "bodyText": "This feels like a weird thing to check, the method you call should not return you a small response, that doesn't feel like a great API.", "author": "jkozlowski", "createdAt": "2020-04-22T15:25:03Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch responses =\n+                timelockService.startIdentifiedAtlasDbTransactionsBatch(conditions.size())) {\n+            if (responses.size() != conditions.size()) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex cb64965f64..99a5cffe6a 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,14 +168,8 @@ import com.palantir.util.ExceptionHandlingRunner;\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n-        try {\n-            return wrapResponse(condition, transactionResponse);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        // I am reluctant to remove outright\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MTIwMA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413081200", "bodyText": "Shouldn't this method or something lower from here retry this instead? Feels like a bad thing to ask the users of this API to handle.", "author": "jkozlowski", "createdAt": "2020-04-22T15:25:44Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        Preconditions.checkArgument(!conditions.isEmpty(), \"Trying to start an empty batch\");\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch responses =\n+                timelockService.startIdentifiedAtlasDbTransactionsBatch(conditions.size())) {\n+            if (responses.size() != conditions.size()) {\n+                throw new TransactionBatchFailedRetriableException(", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyNzcwNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413127705", "bodyText": "Either I'm missing something, or we don't currently perform any retries in the old method - I was following suit in this one (but that can be changed if that is our desired behaviour, i.e. to retry on certain exceptions).", "author": "Jolyon-S", "createdAt": "2020-04-22T16:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MTIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex cb64965f64..99a5cffe6a 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,14 +168,8 @@ import com.palantir.util.ExceptionHandlingRunner;\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n-        try {\n-            return wrapResponse(condition, transactionResponse);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        // I am reluctant to remove outright\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MzUxOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413083519", "bodyText": "Thoughts on returning something like TransactionAndImmutableTsLock, but that additionally has some sort of close method that users of this can call instead of using #finishRunTaskWithLockThrowOnConflict?", "author": "jkozlowski", "createdAt": "2020-04-22T15:28:31Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);\n         } catch (Throwable e) {\n             timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n             throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI3OTQ5OA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417279498", "bodyText": "I think I won't do that in this PR - we can maybe do that improvement in a separate task.", "author": "Jolyon-S", "createdAt": "2020-04-29T12:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4MzUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex cb64965f64..99a5cffe6a 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,14 +168,8 @@ import com.palantir.util.ExceptionHandlingRunner;\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n-        try {\n-            return wrapResponse(condition, transactionResponse);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        // I am reluctant to remove outright\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NDI4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413084285", "bodyText": "Should be @deprecated", "author": "jkozlowski", "createdAt": "2020-04-22T15:29:23Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n+    /**\n+     * This method exposes the ability to start a batch of transactions with pre-commit conditions in a single call.\n+     * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n+     * the code has been specifically optimised with respect to batching and error handling.\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks for the tasks\n+     */\n+    @Timed\n+    List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\nindex 2b9533d57f..4bf04ac91d 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n\n@@ -439,8 +439,11 @@ public interface TransactionManager extends AutoCloseable {\n      * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n      * the code has been specifically optimised with respect to batching and error handling.\n      *\n-     * @return a list of transactions and their associated immutable timestamp locks for the tasks\n+     * @deprecated Similar functionality will exist, but this method is likely to change in the future\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks\n      */\n+    @Deprecated\n     @Timed\n     List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n             List<PreCommitCondition> condition);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NDY4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413084689", "bodyText": "Please document that PreCommitConditions do not get cleaned up on errors.", "author": "jkozlowski", "createdAt": "2020-04-22T15:29:51Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n+    /**\n+     * This method exposes the ability to start a batch of transactions with pre-commit conditions in a single call.\n+     * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n+     * the code has been specifically optimised with respect to batching and error handling.", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\nindex 2b9533d57f..4bf04ac91d 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n\n@@ -439,8 +439,11 @@ public interface TransactionManager extends AutoCloseable {\n      * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n      * the code has been specifically optimised with respect to batching and error handling.\n      *\n-     * @return a list of transactions and their associated immutable timestamp locks for the tasks\n+     * @deprecated Similar functionality will exist, but this method is likely to change in the future\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks\n      */\n+    @Deprecated\n     @Timed\n     List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n             List<PreCommitCondition> condition);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NjAwNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413086004", "bodyText": "We need to remove this method, since it is only supposed to be used by internal ski product.", "author": "jkozlowski", "createdAt": "2020-04-22T15:31:21Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -433,6 +434,17 @@ default LockWatchManager getLockWatchManager() {\n     @Timed\n     TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\nindex 2b9533d57f..4bf04ac91d 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n\n@@ -439,8 +439,11 @@ public interface TransactionManager extends AutoCloseable {\n      * The result is similar to calling {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}, except\n      * the code has been specifically optimised with respect to batching and error handling.\n      *\n-     * @return a list of transactions and their associated immutable timestamp locks for the tasks\n+     * @deprecated Similar functionality will exist, but this method is likely to change in the future\n+     *\n+     * @return a list of transactions and their associated immutable timestamp locks\n      */\n+    @Deprecated\n     @Timed\n     List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n             List<PreCommitCondition> condition);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4NzYwMQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413087601", "bodyText": "Please check that this code you're moving is covered by extensive tests first, especially around resource cleanup on errors.", "author": "jkozlowski", "createdAt": "2020-04-22T15:33:18Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -166,26 +169,50 @@ public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(Pr\n         StartIdentifiedAtlasDbTransactionResponse transactionResponse\n                 = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+            return wrapResponse(condition, transactionResponse);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex cb64965f64..99a5cffe6a 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,14 +168,8 @@ import com.palantir.util.ExceptionHandlingRunner;\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n-        try {\n-            return wrapResponse(condition, transactionResponse);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n-        }\n+        // I am reluctant to remove outright\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4OTQwNw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413089407", "bodyText": "Again, how bad would it be to only have the batched method?", "author": "jkozlowski", "createdAt": "2020-04-22T15:35:30Z", "path": "lock-api/src/main/java/com/palantir/lock/client/LockRefresher.java", "diffHunk": "@@ -85,6 +85,10 @@ public void registerLock(LockToken token) {\n         tokensToRefresh.add(token);\n     }\n \n+    public void registerLocks(Collection<LockToken> tokens) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NDQ4Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418554482", "bodyText": "Checked that no one uses this", "author": "jeremyk-91", "createdAt": "2020-05-01T14:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA4OTQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/LockRefresher.java b/lock-api/src/main/java/com/palantir/lock/client/LockRefresher.java\nindex bec82a5a84..c86450581f 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/LockRefresher.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/LockRefresher.java\n\n@@ -81,6 +81,7 @@ public class LockRefresher implements AutoCloseable {\n         }\n     }\n \n+    // Remove in the real version (left here for tests)\n     public void registerLock(LockToken token) {\n         tokensToRefresh.add(token);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MDMyNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413090324", "bodyText": "Batched method only.", "author": "jkozlowski", "createdAt": "2020-04-22T15:36:38Z", "path": "lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java", "diffHunk": "@@ -116,6 +117,12 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n         return runTaskTimed(\"startIdentifiedAtlasDbTransaction\", delegate::startIdentifiedAtlasDbTransaction);\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        return runTaskTimed(\"startIdentifiedAtlasDbTransactionsBatch\",", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java b/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java\nindex b2cbe705b0..ab498582b7 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java\n\n@@ -113,15 +113,15 @@ public class ProfilingTimelockService implements AutoCloseable, TimelockService\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return runTaskTimed(\"startIdentifiedAtlasDbTransaction\", delegate::startIdentifiedAtlasDbTransaction);\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        return runTaskTimed(\"startIdentifiedAtlasDbTransaction\", () -> delegate.startIdentifiedAtlasDbTransactionBatch(1));\n     }\n \n-    @Override\n-    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        return runTaskTimed(\"startIdentifiedAtlasDbTransactionsBatch\",\n-                () -> delegate.startIdentifiedAtlasDbTransactionsBatch(count));\n-    }\n+//    @Override\n+//    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionBatch(int count) {\n+//        return runTaskTimed(\"startIdentifiedAtlasDbTransactionBatch\",\n+//                () -> delegate.startIdentifiedAtlasDbTransactionBatch(count));\n+//    }\n \n     @Override\n     public long getImmutableTimestamp() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTI3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413091272", "bodyText": "Only batched method", "author": "jkozlowski", "createdAt": "2020-04-22T15:37:48Z", "path": "lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java", "diffHunk": "@@ -123,6 +125,21 @@ public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransacti\n         }\n     }\n \n+    @Override\n+    public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNzAzNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413107034", "bodyText": "Oh wait this is legacy; @jeremyk-91 this is mostly unused now right so don't need to worry about perf?", "author": "jkozlowski", "createdAt": "2020-04-22T15:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1NzU3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413157572", "bodyText": "Fine by me: this is largely used in embedded contexts. There is large internal product, but in any case the algorithm here is not really worse than what people will probably end up writing anyway", "author": "jeremyk-91", "createdAt": "2020-04-22T17:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e121494be4138788db21c4511f9837eb8feabb6b", "chunk": "diff --git a/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java b/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java\nindex 19cdb0ecd7..d216c50e22 100644\n--- a/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java\n+++ b/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java\n\n@@ -127,17 +128,14 @@ public class LegacyTimelockService implements TimelockService {\n \n     @Override\n     public StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        // Going to implement this naively for now, and can always revisit it a bit later\n-        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n-                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n-            IntStream.range(0, count).forEach($ -> batchBuilder.safeAddToBatch(() ->\n-                    // given that #getFreshTimestamps is a thing, I think we'll want to use that\n-                    // if we want this to be properly efficient, but not doing so for now\n-                    StartIdentifiedAtlasDbTransactionResponse.of(lockImmutableTimestamp(),\n-                            TimestampAndPartition.of(getFreshTimestamp(), 0))));\n-            return batchBuilder.build();\n-        }\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = IntStream.range(0, count).mapToObj(\n+                $ -> StartIdentifiedAtlasDbTransactionResponse.of(\n+                        lockImmutableTimestamp(), TimestampAndPartition.of(getFreshTimestamp(), 0))).collect(\n+                Collectors.toList());\n+\n+        return new StartIdentifiedAtlasDbTransactionResponseBatch(responses,\n+                () -> unlock(responses.stream().map(response -> response.immutableTimestamp().getLock()).collect(\n+                        Collectors.toSet())));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MjcyNA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413092724", "bodyText": "Batched only.", "author": "jkozlowski", "createdAt": "2020-04-22T15:39:35Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e121494be4138788db21c4511f9837eb8feabb6b", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 17ec1d67df..d7be8f70c9 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -71,18 +71,18 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+        return Iterables.getOnlyElement(AtlasFutures.getUnchecked(autobatcher.apply(1)));\n+        //        return AtlasFutures.getUnchecked(autobatcher.apply(1));\n     }\n \n     StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n-                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n-            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n-            autobatcher.applyBatch(inputs).forEach(\n-                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n-            return batchBuilder.build();\n-        }\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = AtlasFutures.getUnchecked(autobatcher.apply(count));\n+        Set<LockToken> immutableTimestampLocks = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getLock())\n+                .collect(Collectors.toSet());\n+\n+        return new StartIdentifiedAtlasDbTransactionResponseBatch(responses, () -> unlock(immutableTimestampLocks));\n     }\n \n     Set<LockToken> refreshLockLeases(Set<LockToken> tokens) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413095160", "bodyText": "Can someone explain why do we have this bizarre interface here with passing nulls?", "author": "jkozlowski", "createdAt": "2020-04-22T15:42:32Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NzQ1Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413097456", "bodyText": "Hmm, I guess we sometimes need to pass an actual argument here.", "author": "jkozlowski", "createdAt": "2020-04-22T15:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwMjQ0Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413102446", "bodyText": "I think there's an argument for rewriting this to pass actual number of requested transactions to start? So that internal ski product's disruptors would actually become extremely tiny! Then the batch processor could just count number of transactions requested across the batch and send that to timelock?\n\nwe would save on a bunch of allocations for futures and lists for args here\nWe would get rid of the weird \"null\" passing of arguments?\n\n@jeremyk-91 interested in your thoughts", "author": "jkozlowski", "createdAt": "2020-04-22T15:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyMzk1NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413123955", "bodyText": "Would you mean that, instead of passing null, you pass in say count, and then the autobatcher batches several counts together into a larger batch and fans those out? If so, that would definitely reduce the size of the autobatcher (or at least, the ring buffer underneath).", "author": "Jolyon-S", "createdAt": "2020-04-22T16:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5MjExOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413192119", "bodyText": "Rewriting to add numbers makes sense - as noted null is just because we need to pass something. This isn't really a thing raw AtlasDB users would think about as much, but I see how it's useful in ski product (though let's do that in a separate self-contained piece please)", "author": "jeremyk-91", "createdAt": "2020-04-22T17:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTE2MA=="}], "type": "inlineReview", "revised_code": {"commit": "e121494be4138788db21c4511f9837eb8feabb6b", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 17ec1d67df..d7be8f70c9 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -71,18 +71,18 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+        return Iterables.getOnlyElement(AtlasFutures.getUnchecked(autobatcher.apply(1)));\n+        //        return AtlasFutures.getUnchecked(autobatcher.apply(1));\n     }\n \n     StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n-                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n-            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n-            autobatcher.applyBatch(inputs).forEach(\n-                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n-            return batchBuilder.build();\n-        }\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = AtlasFutures.getUnchecked(autobatcher.apply(count));\n+        Set<LockToken> immutableTimestampLocks = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getLock())\n+                .collect(Collectors.toSet());\n+\n+        return new StartIdentifiedAtlasDbTransactionResponseBatch(responses, () -> unlock(immutableTimestampLocks));\n     }\n \n     Set<LockToken> refreshLockLeases(Set<LockToken> tokens) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwMjc2MA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413102760", "bodyText": "Yeah, this is hopefully unnecessary.", "author": "jkozlowski", "createdAt": "2020-04-22T15:51:49Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n+                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n+                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n+            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e121494be4138788db21c4511f9837eb8feabb6b", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 17ec1d67df..d7be8f70c9 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -71,18 +71,18 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+        return Iterables.getOnlyElement(AtlasFutures.getUnchecked(autobatcher.apply(1)));\n+        //        return AtlasFutures.getUnchecked(autobatcher.apply(1));\n     }\n \n     StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n-                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n-            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n-            autobatcher.applyBatch(inputs).forEach(\n-                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n-            return batchBuilder.build();\n-        }\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = AtlasFutures.getUnchecked(autobatcher.apply(count));\n+        Set<LockToken> immutableTimestampLocks = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getLock())\n+                .collect(Collectors.toSet());\n+\n+        return new StartIdentifiedAtlasDbTransactionResponseBatch(responses, () -> unlock(immutableTimestampLocks));\n     }\n \n     Set<LockToken> refreshLockLeases(Set<LockToken> tokens) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413105389", "bodyText": "So in this class we call #getStartTransactionResponses which is obviously already batched. But it's implementation can call timelock multiple times, without any cleanup of resources between calls: @jeremyk-91 does StartIdentifiedAtlasDbTransactionResponse not require any cleanup if we fail mid batch in this method?", "author": "jkozlowski", "createdAt": "2020-04-22T15:55:15Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n+                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n+                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n+            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n+            autobatcher.applyBatch(inputs).forEach(\n+                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n+            return batchBuilder.build();", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyMTkyMw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413121923", "bodyText": "The purpose of the Batch class is that if this does fail midway, we will call unlock (hence the passing in of the closing callback on line 80), unless you are referring to something else?", "author": "Jolyon-S", "createdAt": "2020-04-22T16:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIzMDExMA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413230110", "bodyText": "The timestamps are safe to drop on the floor, so the main thing we'd need to worry about here is the immutable timestamp lock, which you've handled.\nI think @jkozlowski is asking about the impl of the existing getStartTransactionResponses method.\nThis is a good spot, and a bit of a spicy one: that method has a bug, though it is mostly benign. It does forget to unlock locks it may have taken on its way to completion, but as it is is unlikely to actively cause problems beyond delaying targeted sweep by 20 seconds. The failure mode is of course batch 1 succeeding but not having enough transactions, and batch 2 failing. In this case we still hold the locks, but they haven't been registered in the lock refresher yet so they go away after the lock timeout (20 seconds).\nSo this should be fixed, and it's probably an interesting one to do separately, but probably not a massive priority.", "author": "jeremyk-91", "createdAt": "2020-04-22T18:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMTQ4Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413731483", "bodyText": "Cool, I added tracking for this, we'll fix this next.", "author": "jkozlowski", "createdAt": "2020-04-23T11:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTM4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e121494be4138788db21c4511f9837eb8feabb6b", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 17ec1d67df..d7be8f70c9 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -71,18 +71,18 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+        return Iterables.getOnlyElement(AtlasFutures.getUnchecked(autobatcher.apply(1)));\n+        //        return AtlasFutures.getUnchecked(autobatcher.apply(1));\n     }\n \n     StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n-                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n-            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n-            autobatcher.applyBatch(inputs).forEach(\n-                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n-            return batchBuilder.build();\n-        }\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = AtlasFutures.getUnchecked(autobatcher.apply(count));\n+        Set<LockToken> immutableTimestampLocks = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getLock())\n+                .collect(Collectors.toSet());\n+\n+        return new StartIdentifiedAtlasDbTransactionResponseBatch(responses, () -> unlock(immutableTimestampLocks));\n     }\n \n     Set<LockToken> refreshLockLeases(Set<LockToken> tokens) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNTg5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413105893", "bodyText": "Again, batched only.", "author": "jkozlowski", "createdAt": "2020-04-22T15:55:50Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/v2/TimelockService.java", "diffHunk": "@@ -53,6 +53,8 @@ default boolean isInitialized() {\n \n     WaitForLocksResponse waitForLocks(WaitForLocksRequest request);\n \n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "chunk": "diff --git a/lock-api-objects/src/main/java/com/palantir/lock/v2/TimelockService.java b/lock-api-objects/src/main/java/com/palantir/lock/v2/TimelockService.java\nindex 617c4d1185..e9e9226562 100644\n--- a/lock-api-objects/src/main/java/com/palantir/lock/v2/TimelockService.java\n+++ b/lock-api-objects/src/main/java/com/palantir/lock/v2/TimelockService.java\n\n@@ -45,7 +46,7 @@ public interface TimelockService {\n     // TODO (jkong): Can this be deprecated? Are there users outside of Atlas transactions?\n     LockImmutableTimestampResponse lockImmutableTimestamp();\n \n-    StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction();\n+    List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count);\n \n     long getImmutableTimestamp();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwNzU1NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413107554", "bodyText": "What's the cost of this #unlock call here, should it be batched?", "author": "jkozlowski", "createdAt": "2020-04-22T15:57:55Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -70,12 +71,17 @@ static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEve\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n+        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+    }\n+\n+    StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n+        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n+                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n+                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e121494be4138788db21c4511f9837eb8feabb6b", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 17ec1d67df..d7be8f70c9 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -71,18 +71,18 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return AtlasFutures.getUnchecked(autobatcher.apply(null));\n+        return Iterables.getOnlyElement(AtlasFutures.getUnchecked(autobatcher.apply(1)));\n+        //        return AtlasFutures.getUnchecked(autobatcher.apply(1));\n     }\n \n     StartIdentifiedAtlasDbTransactionResponseBatch startIdentifiedAtlasDbTransactionsBatch(int count) {\n-        try (StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder(response ->\n-                        unlock(ImmutableSet.of(response.immutableTimestamp().getLock())))) {\n-            List<Void> inputs = IntStream.range(0, count).mapToObj($ -> (Void) null).collect(Collectors.toList());\n-            autobatcher.applyBatch(inputs).forEach(\n-                    response -> batchBuilder.safeAddToBatch(() -> AtlasFutures.getUnchecked(response)));\n-            return batchBuilder.build();\n-        }\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = AtlasFutures.getUnchecked(autobatcher.apply(count));\n+        Set<LockToken> immutableTimestampLocks = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getLock())\n+                .collect(Collectors.toSet());\n+\n+        return new StartIdentifiedAtlasDbTransactionResponseBatch(responses, () -> unlock(immutableTimestampLocks));\n     }\n \n     Set<LockToken> refreshLockLeases(Set<LockToken> tokens) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDU0Nw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413730547", "bodyText": "This isn't entirely safe implementation: if someone later decides to add something other than the response.ifPresent below here, you'll leak. You should somehow tie the below line to the supplySafely", "author": "jkozlowski", "createdAt": "2020-04-23T11:18:40Z", "path": "lock-api-objects/src/main/java/com/palantir/lock/v2/StartIdentifiedAtlasDbTransactionResponseBatch.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.lock.v2;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import com.palantir.logsafe.Preconditions;\n+import com.palantir.util.ExceptionHandlingRunner;\n+\n+public final class StartIdentifiedAtlasDbTransactionResponseBatch implements AutoCloseable {\n+\n+    private final List<StartIdentifiedAtlasDbTransactionResponse> responses;\n+    private final Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner;\n+    private boolean closed;\n+    private final long minTimestamp;\n+    private final long maxTimestamp;\n+\n+    private StartIdentifiedAtlasDbTransactionResponseBatch(List<StartIdentifiedAtlasDbTransactionResponse> responses,\n+            Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner) {\n+        // This will only be called if the builder is built without any attempts at adding responses\n+        Preconditions.checkState(!responses.isEmpty(),\n+                \"Batch created with no transaction responses - something has gone wrong\");\n+        this.responses = responses;\n+        this.cleaner = cleaner;\n+        this.closed = false;\n+        List<Long> timestamps = responses\n+                .stream()\n+                .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n+                .collect(Collectors.toList());\n+        this.minTimestamp = Collections.min(timestamps);\n+        this.maxTimestamp = Collections.max(timestamps);\n+    }\n+\n+    public int size() {\n+        return responses.size();\n+    }\n+\n+    public List<StartIdentifiedAtlasDbTransactionResponse> getResponses() {\n+        return responses;\n+    }\n+\n+    public <R> R successful(R value) {\n+        closed = true;\n+        return value;\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (!closed) {\n+            try (ExceptionHandlingRunner closer = new ExceptionHandlingRunner()) {\n+                responses.forEach(resource -> closer.runSafely(() -> cleaner.accept(resource)));\n+            }\n+        }\n+    }\n+\n+    public long getMinTimestamp() {\n+        return minTimestamp;\n+    }\n+\n+    public long getMaxTimestamp() {\n+        return maxTimestamp;\n+    }\n+\n+    public static class Builder implements AutoCloseable {\n+        private final List<StartIdentifiedAtlasDbTransactionResponse> responses = new ArrayList<>();\n+        private final ExceptionHandlingRunner runner = new ExceptionHandlingRunner();\n+        private final Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner;\n+\n+        public Builder(Consumer<StartIdentifiedAtlasDbTransactionResponse> cleaner) {\n+            this.cleaner = cleaner;\n+        }\n+\n+        public void safeAddToBatch(\n+                Supplier<StartIdentifiedAtlasDbTransactionResponse> supplier) {\n+            Optional<StartIdentifiedAtlasDbTransactionResponse> response = runner.supplySafely(supplier);", "originalCommit": "8c616629f5c7011f455ad4b4c729020cd59e521d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc1OTgzOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r413759838", "bodyText": "As in:\nrunner.runSafely(() -> { BlahResponse x = supplier.get(); responses.add(x); });?", "author": "Jolyon-S", "createdAt": "2020-04-23T12:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDU0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "chunk": "diff --git a/lock-api-objects/src/main/java/com/palantir/lock/v2/StartIdentifiedAtlasDbTransactionResponseBatch.java b/lock-api-objects/src/main/java/com/palantir/lock/v2/StartIdentifiedAtlasDbTransactionResponseBatch.java\nindex 6235d9af9b..7d68e13113 100644\n--- a/lock-api-objects/src/main/java/com/palantir/lock/v2/StartIdentifiedAtlasDbTransactionResponseBatch.java\n+++ b/lock-api-objects/src/main/java/com/palantir/lock/v2/StartIdentifiedAtlasDbTransactionResponseBatch.java\n\n@@ -92,8 +92,10 @@ public final class StartIdentifiedAtlasDbTransactionResponseBatch implements Aut\n \n         public void safeAddToBatch(\n                 Supplier<StartIdentifiedAtlasDbTransactionResponse> supplier) {\n-            Optional<StartIdentifiedAtlasDbTransactionResponse> response = runner.supplySafely(supplier);\n-            response.ifPresent(responses::add);\n+            runner.runSafely(() -> {\n+                StartIdentifiedAtlasDbTransactionResponse response = supplier.get();\n+                responses.add(response);\n+            });\n         }\n \n         public StartIdentifiedAtlasDbTransactionResponseBatch build() {\n"}}, {"oid": "9156f1ebdbdcfd0c72ddf066c5a6554dda67a867", "url": "https://github.com/palantir/atlasdb/commit/9156f1ebdbdcfd0c72ddf066c5a6554dda67a867", "message": "Merge branch 'develop' into fork-batch-txns", "committedDate": "2020-04-24T12:51:08Z", "type": "commit"}, {"oid": "d120274e287339ea54e597fd651295877fed39cf", "url": "https://github.com/palantir/atlasdb/commit/d120274e287339ea54e597fd651295877fed39cf", "message": "ga", "committedDate": "2020-04-27T09:10:48Z", "type": "commit"}, {"oid": "6a02f39ddcdb8c42096bc40565dd04254a9370dd", "url": "https://github.com/palantir/atlasdb/commit/6a02f39ddcdb8c42096bc40565dd04254a9370dd", "message": "perform some cleanup", "committedDate": "2020-04-27T09:26:15Z", "type": "commit"}, {"oid": "e121494be4138788db21c4511f9837eb8feabb6b", "url": "https://github.com/palantir/atlasdb/commit/e121494be4138788db21c4511f9837eb8feabb6b", "message": "move in right direction", "committedDate": "2020-04-28T09:58:31Z", "type": "commit"}, {"oid": "45f48e328d044b8d31779b9af4a4d37e38cdd179", "url": "https://github.com/palantir/atlasdb/commit/45f48e328d044b8d31779b9af4a4d37e38cdd179", "message": "change everything", "committedDate": "2020-04-28T13:45:06Z", "type": "commit"}, {"oid": "d0107d6a57b2bb4aacf42fbfcf99ce74342fcd09", "url": "https://github.com/palantir/atlasdb/commit/d0107d6a57b2bb4aacf42fbfcf99ce74342fcd09", "message": "sort of works", "committedDate": "2020-04-28T14:13:11Z", "type": "commit"}, {"oid": "888ccfd9638a9e56fb458677e18a683725c674b0", "url": "https://github.com/palantir/atlasdb/commit/888ccfd9638a9e56fb458677e18a683725c674b0", "message": "considerable cleanup", "committedDate": "2020-04-28T14:43:33Z", "type": "commit"}, {"oid": "7ac1892cf5f0d36a6347e54e18442b6be74fff69", "url": "https://github.com/palantir/atlasdb/commit/7ac1892cf5f0d36a6347e54e18442b6be74fff69", "message": "remove imports on test", "committedDate": "2020-04-28T14:44:14Z", "type": "commit"}, {"oid": "87d34e92bb5d5939222674ecdba17f309e065903", "url": "https://github.com/palantir/atlasdb/commit/87d34e92bb5d5939222674ecdba17f309e065903", "message": "Re-tidy the javadoc", "committedDate": "2020-04-28T14:47:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NjA1MQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417156051", "bodyText": "Test, will fixup later.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:41:36Z", "path": "atlasdb-config/src/test/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockServiceTest.java", "diffHunk": "@@ -71,14 +72,28 @@ public void getFreshTimestampsShouldFail() {\n     @Test\n     public void startIdentifiedAtlasDbTransactionShouldFail() {\n         StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransactionResponse =\n-                StartIdentifiedAtlasDbTransactionResponse.of(LOCK_IMMUTABLE_TIMESTAMP_RESPONSE,\n-                        TimestampAndPartition.of(1L, 0));\n+                makeResponse(1L);\n \n-        when(rawTimelockService.startIdentifiedAtlasDbTransaction())\n-                .thenReturn(startIdentifiedAtlasDbTransactionResponse);\n+        when(rawTimelockService.startIdentifiedAtlasDbTransactionBatch(1))\n+                .thenReturn(ImmutableList.of(startIdentifiedAtlasDbTransactionResponse));\n \n-        assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransaction());\n+        assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransactionBatch(1));\n     }\n+//", "originalCommit": "87d34e92bb5d5939222674ecdba17f309e065903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5567bfe2179f26c218bf3e47b3e6a116b3d8cc70", "chunk": "diff --git a/atlasdb-config/src/test/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockServiceTest.java b/atlasdb-config/src/test/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockServiceTest.java\nindex ecffdf13b1..0f46e2e33e 100644\n--- a/atlasdb-config/src/test/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockServiceTest.java\n+++ b/atlasdb-config/src/test/java/com/palantir/atlasdb/factory/timelock/TimestampCorroboratingTimelockServiceTest.java\n\n@@ -79,21 +80,16 @@ public class TimestampCorroboratingTimelockServiceTest {\n \n         assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransactionBatch(1));\n     }\n-//\n-//    @Test\n-//    public void startIdentifiedAtlasDbTransactionBatchShouldFail() {\n-//        StartIdentifiedAtlasDbTransactionResponseBatch.Builder batchBuilder =\n-//                new StartIdentifiedAtlasDbTransactionResponseBatch.Builder($ -> { });\n-//\n-//        batchBuilder.safeAddToBatch(() -> makeResponse(1L));\n-//        batchBuilder.safeAddToBatch(() -> makeResponse(2L));\n-//        batchBuilder.safeAddToBatch(() -> makeResponse(3L));\n-//        StartIdentifiedAtlasDbTransactionResponseBatch batch = batchBuilder.build();\n-//\n-//        when(rawTimelockService.startIdentifiedAtlasDbTransactionBatch(eq(3))).thenReturn(batch);\n-//\n-//        assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransactionBatch(3));\n-//    }\n+\n+    @Test\n+    public void startIdentifiedAtlasDbTransactionBatchShouldFail() {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                ImmutableList.of(makeResponse(1L), makeResponse(2L), makeResponse(3L));\n+\n+        when(rawTimelockService.startIdentifiedAtlasDbTransactionBatch(3)).thenReturn(responses);\n+\n+        assertThrowsOnSecondCall(() -> timelockService.startIdentifiedAtlasDbTransactionBatch(3));\n+    }\n \n     @Test\n     public void resilientUnderMultipleThreads() throws InterruptedException {\n"}}, {"oid": "02037f646df11b598a216b87c26e980b37f82713", "url": "https://github.com/palantir/atlasdb/commit/02037f646df11b598a216b87c26e980b37f82713", "message": "Remove old method", "committedDate": "2020-04-29T08:43:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1ODQyNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417158425", "bodyText": "The interesting thing here is that I've moved away from doing the approach requiring a specialised object, and I believe the reason it is OK to do so is:\n\nThe batch will either be in one piece from TransactionStarter or it won't (and therefore will have thrown itself);\nIf we fail mid-batch, we still unlock all of them - and there is only a single call, so we don't have to handle cases where the closing itself fails midway, because it either fails or succeeds.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:45:29Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -163,29 +168,52 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n \n     @Override\n     public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n+        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n+    }\n+\n+    @Override\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n-            recordImmutableTimestamp(immutableTs);\n-\n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n+            return wrapResponseBatch(conditions, responses);\n+        } catch (Throwable t) {\n+            timelockService.tryUnlock(\n+                    responses.stream()\n+                            .map(response -> response.immutableTimestamp().getLock())\n+                            .collect(Collectors.toSet()));\n+            throw Throwables.rewrapAndThrowUncheckedException(t);", "originalCommit": "87d34e92bb5d5939222674ecdba17f309e065903", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5d9751180ad9c90656bbc59275048234162816c1", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex 53bf8306e8..c55aa7096b 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -166,18 +167,35 @@ import com.palantir.timestamp.TimestampService;\n         }\n     }\n \n-    @Override\n-    public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        return Iterables.getOnlyElement(setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition)));\n-    }\n-\n     @Override\n     public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n             List<PreCommitCondition> conditions) {\n         List<StartIdentifiedAtlasDbTransactionResponse> responses =\n                 timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            return wrapResponseBatch(conditions, responses);\n+            long immutableTs = Collections.max(responses.stream()\n+                    .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n+                    .collect(Collectors.toList()));\n+            recordImmutableTimestamp(immutableTs);\n+\n+            return Streams.zip(\n+                    responses.stream(),\n+                    conditions.stream(),\n+                    (response, condition) -> {\n+                        LockToken immutableTsLock = response.immutableTimestamp().getLock();\n+                        cleaner.punch(response.startTimestampAndPartition().timestamp());\n+                        Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n+                                response.startTimestampAndPartition().timestamp());\n+\n+                        Transaction transaction = createTransaction(\n+                                immutableTs,\n+                                startTimestampSupplier,\n+                                immutableTsLock,\n+                                condition);\n+\n+                        return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+                    }\n+            ).collect(Collectors.toList());\n         } catch (Throwable t) {\n             timelockService.tryUnlock(\n                     responses.stream()\n"}}, {"oid": "5d9751180ad9c90656bbc59275048234162816c1", "url": "https://github.com/palantir/atlasdb/commit/5d9751180ad9c90656bbc59275048234162816c1", "message": "Remove old method", "committedDate": "2020-04-29T08:46:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTM2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417161363", "bodyText": "This code is a bit messy, for sure - but more a proof of concept of how it would work.\nShould definitely go in its own PR.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:50:26Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -138,16 +131,21 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n+    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.size();\n+            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n \n             List<StartIdentifiedAtlasDbTransactionResponse> startTransactionResponses =\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n-            for (int i = 0; i < numTransactions; i++) {\n-                batch.get(i).result().set(startTransactionResponses.get(i));\n+            int start = 0;\n+            int end;\n+            for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n+                    : batch) {\n+                end = start + batchElement.argument();\n+                batchElement.result().set(startTransactionResponses.subList(start, end));\n+                start = end;", "originalCommit": "5d9751180ad9c90656bbc59275048234162816c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex a3e9a39880..4c9c2883d9 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -140,10 +140,9 @@ final class TransactionStarter implements AutoCloseable {\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n             int start = 0;\n-            int end;\n             for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n                     : batch) {\n-                end = start + batchElement.argument();\n+                int end = start + batchElement.argument();\n                 batchElement.result().set(startTransactionResponses.subList(start, end));\n                 start = end;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2MTk4Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417161986", "bodyText": "Again, this is now a single call, so there is no handling for what happens if there is a failure half-way through closing, as such a failure cannot occur.", "author": "Jolyon-S", "createdAt": "2020-04-29T08:51:27Z", "path": "lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java", "diffHunk": "@@ -107,15 +109,17 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        LockImmutableTimestampResponse immutableTimestamp = lockImmutableTimestamp();\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = new ArrayList<>();\n         try {\n-            return StartIdentifiedAtlasDbTransactionResponse.of(\n-                    immutableTimestamp,\n-                    TimestampAndPartition.of(getFreshTimestamp(), 0));\n+            IntStream.range(0, count).forEach(\n+                    $ -> responses.add(StartIdentifiedAtlasDbTransactionResponse.of(lockImmutableTimestamp(),\n+                            TimestampAndPartition.of(getFreshTimestamp(), 0))));\n+            return responses;\n         } catch (RuntimeException | Error throwable) {\n             try {\n-                unlock(ImmutableSet.of(immutableTimestamp.getLock()));\n+                unlock(responses.stream().map(response -> response.immutableTimestamp().getLock()).collect(\n+                        Collectors.toSet()));", "originalCommit": "5d9751180ad9c90656bbc59275048234162816c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8fb4294b079544e18d053327970bdf337fcfc799", "chunk": "diff --git a/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java b/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java\nindex 8130f8c91f..aa49370a73 100644\n--- a/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java\n+++ b/lock-impl/src/main/java/com/palantir/lock/impl/LegacyTimelockService.java\n\n@@ -110,15 +110,21 @@ public class LegacyTimelockService implements TimelockService {\n \n     @Override\n     public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        // Track these separately in the case that getFreshTimestamp fails but lockImmutableTimestamp succeeds\n+        List<LockImmutableTimestampResponse> immutableTimestampLocks = new ArrayList<>();\n         List<StartIdentifiedAtlasDbTransactionResponse> responses = new ArrayList<>();\n         try {\n             IntStream.range(0, count).forEach(\n-                    $ -> responses.add(StartIdentifiedAtlasDbTransactionResponse.of(lockImmutableTimestamp(),\n-                            TimestampAndPartition.of(getFreshTimestamp(), 0))));\n+                    $ -> {\n+                        LockImmutableTimestampResponse immutableTimestamp = lockImmutableTimestamp();\n+                        immutableTimestampLocks.add(immutableTimestamp);\n+                        responses.add(StartIdentifiedAtlasDbTransactionResponse.of(immutableTimestamp,\n+                                TimestampAndPartition.of(getFreshTimestamp(), 0)));\n+                    });\n             return responses;\n         } catch (RuntimeException | Error throwable) {\n             try {\n-                unlock(responses.stream().map(response -> response.immutableTimestamp().getLock()).collect(\n+                unlock(immutableTimestampLocks.stream().map(LockImmutableTimestampResponse::getLock).collect(\n                         Collectors.toSet()));\n             } catch (Throwable unlockThrowable) {\n                 throwable.addSuppressed(unlockThrowable);\n"}}, {"oid": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "url": "https://github.com/palantir/atlasdb/commit/dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "message": "Small cleanup", "committedDate": "2020-04-29T10:40:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTI5Ng==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417239296", "bodyText": "Haven't looked at puncher in a while, so unclear if you can do this once for the whole batch same as immutable timestamp.", "author": "jkozlowski", "createdAt": "2020-04-29T11:17:37Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -162,27 +168,40 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n     }\n \n     @Override\n-    public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n+            long immutableTs = Collections.max(responses.stream()\n+                    .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n+                    .collect(Collectors.toList()));\n             recordImmutableTimestamp(immutableTs);\n \n-            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n-            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                    transactionResponse.startTimestampAndPartition().timestamp());\n-\n-            Transaction transaction = createTransaction(\n-                    immutableTs,\n-                    startTimestampSupplier,\n-                    immutableTsLock,\n-                    condition);\n-            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n-        } catch (Throwable e) {\n-            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n-            throw Throwables.rewrapAndThrowUncheckedException(e);\n+            return Streams.zip(\n+                    responses.stream(),\n+                    conditions.stream(),\n+                    (response, condition) -> {\n+                        LockToken immutableTsLock = response.immutableTimestamp().getLock();\n+                        cleaner.punch(response.startTimestampAndPartition().timestamp());", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4MzUxNw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417283517", "bodyText": "From the javadoc:\n * Indicate that the given timestamp has just been created. This must be called frequently\n * (preferably on each transaction commit) so that the Cleaner can keep track of the\n * wall-clock/timestamp mapping. If it is never called, semantically nothing goes wrong, but the\n * sweeper won't sweep, since it cannot know what things are old enough to be swept.\n\nI interpret this as something we could conceivably do once per batch. @jeremyk-91 to sanity check that.", "author": "Jolyon-S", "createdAt": "2020-04-29T12:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MjUwMw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418552503", "bodyText": "Once per batch is fine, yep. Right now this is being called on every element right? I'd suggest we move it out and stick it next to the recordImmutableTimestamp", "author": "jeremyk-91", "createdAt": "2020-05-01T13:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "46d18f17206d8bb6faf4a365c1da9e3de0ff6dc9", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex c55aa7096b..c73cb77928 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -170,6 +170,10 @@ import com.palantir.timestamp.TimestampService;\n     @Override\n     public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n             List<PreCommitCondition> conditions) {\n+        if(conditions.isEmpty()) {\n+            return ImmutableList.of();\n+        }\n+\n         List<StartIdentifiedAtlasDbTransactionResponse> responses =\n                 timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzOTcyOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417239728", "bodyText": "I quite like this, it's just an unwrapping and you're done. You could have a private method for setup*, but I'm not fussed either way.", "author": "jkozlowski", "createdAt": "2020-04-29T11:18:27Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -153,7 +158,8 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n         checkOpen();\n         try {\n             TransactionAndImmutableTsLock txAndLock =\n-                    runTimed(() -> setupRunTaskWithConditionThrowOnConflict(condition), \"setupTask\");\n+                    runTimed(() -> Iterables.getOnlyElement(\n+                            setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition))), \"setupTask\");", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex c55aa7096b..4e6645c4fc 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -158,8 +153,7 @@ import com.palantir.timestamp.TimestampService;\n         checkOpen();\n         try {\n             TransactionAndImmutableTsLock txAndLock =\n-                    runTimed(() -> Iterables.getOnlyElement(\n-                            setupRunTaskBatchWithConditionThrowOnConflict(ImmutableList.of(condition))), \"setupTask\");\n+                    runTimed(() -> setupRunTaskWithConditionThrowOnConflict(condition), \"setupTask\");\n             return finishRunTaskWithLockThrowOnConflict(txAndLock,\n                     transaction -> task.execute(transaction, condition));\n         } finally {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MDI4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417240285", "bodyText": "You need to propagate the count?", "author": "jkozlowski", "createdAt": "2020-04-29T11:19:35Z", "path": "lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java", "diffHunk": "@@ -112,8 +113,8 @@ public LockImmutableTimestampResponse lockImmutableTimestamp() {\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        return runTaskTimed(\"startIdentifiedAtlasDbTransaction\", delegate::startIdentifiedAtlasDbTransaction);\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        return runTaskTimed(\"startIdentifiedAtlasDbTransactionBatch\", () -> delegate.startIdentifiedAtlasDbTransactionBatch(1));", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI5OTM4NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417299384", "bodyText": "Good catch - autoreplaced the code and I obviously missed this.", "author": "Jolyon-S", "createdAt": "2020-04-29T13:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MDI4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0499cf880c992e6f31d37fed6fb46f356085fa47", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java b/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java\nindex 7e66d41de1..820b87e996 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/ProfilingTimelockService.java\n\n@@ -114,7 +114,8 @@ public class ProfilingTimelockService implements AutoCloseable, TimelockService\n \n     @Override\n     public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n-        return runTaskTimed(\"startIdentifiedAtlasDbTransactionBatch\", () -> delegate.startIdentifiedAtlasDbTransactionBatch(1));\n+        return runTaskTimed(\"startIdentifiedAtlasDbTransactionBatch\",\n+                () -> delegate.startIdentifiedAtlasDbTransactionBatch(count));\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MTU3NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417241574", "bodyText": "You're relying on this not throwing. I think it's fine in this refactoring, but need to track fixing this, same as the other bug.", "author": "jkozlowski", "createdAt": "2020-04-29T11:22:14Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java", "diffHunk": "@@ -88,16 +91,19 @@ public TimestampRange getFreshTimestamps(int numTimestampsRequested) {\n     @Override\n     public LockImmutableTimestampResponse lockImmutableTimestamp() {\n         LockImmutableTimestampResponse response = executeOnTimeLock(delegate::lockImmutableTimestamp);\n-        lockRefresher.registerLock(response.getLock());\n+        lockRefresher.registerLocks(ImmutableList.of(response.getLock()));\n         return response;\n     }\n \n     @Override\n-    public StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        StartIdentifiedAtlasDbTransactionResponse response = executeOnTimeLock(\n-                delegate::startIdentifiedAtlasDbTransaction);\n-        lockRefresher.registerLock(response.immutableTimestamp().getLock());\n-        return response;\n+    public List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = executeOnTimeLock(\n+                () -> delegate.startIdentifiedAtlasDbTransactionBatch(count));\n+        lockRefresher.registerLocks(responses", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwMTI1Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417301253", "bodyText": "Either the whole batch will return OK, or will throw as a whole - because of how the delegate does so. So yes, there is an outcome where half of the batch completes before throwing, and thus we have locks that we have not registeredor unlocked, but as noted above that is a separate issue.", "author": "Jolyon-S", "createdAt": "2020-04-29T13:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MTU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2b21adc878d5b6cf5b8f6e2dad881ad1b51873b1", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java b/lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java\nindex 48a475bb74..f1639a48e8 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TimeLockClient.java\n\n@@ -91,7 +91,7 @@ public class TimeLockClient implements AutoCloseable, TimelockService {\n     @Override\n     public LockImmutableTimestampResponse lockImmutableTimestamp() {\n         LockImmutableTimestampResponse response = executeOnTimeLock(delegate::lockImmutableTimestamp);\n-        lockRefresher.registerLocks(ImmutableList.of(response.getLock()));\n+        lockRefresher.registerLocks(ImmutableSet.of(response.getLock()));\n         return response;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NDU4MA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417244580", "bodyText": "This is a bit sucky, since we're having to allocate Integers, while disruptor is optimised for that and reuses the actual instances of arguments, but I don't think it's worth obsessing about this. @jeremyk-91", "author": "jkozlowski", "createdAt": "2020-04-29T11:28:31Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -45,38 +44,32 @@\n  * A service responsible for coalescing multiple start transaction calls into a single start transactions call. This\n  * service also handles creating {@link LockTokenShare}'s to enable multiple transactions sharing a single immutable\n  * timestamp.\n- *\n+ * <p>\n  * Callers of this class should use {@link #unlock(Set)} and {@link #refreshLockLeases(Set)} for returned lock tokens,\n  * rather than directly calling delegate lock service.\n  */\n final class TransactionStarter implements AutoCloseable {\n-    private final DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher;\n+    private final DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher;", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1NTM3Mg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418555372", "bodyText": "fair enough. I think we have metrics for this? If we look at the delta between the rpc clients and setupRunTask... and that explodes that should give us a hint that this might be relevant.", "author": "jeremyk-91", "createdAt": "2020-05-01T14:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NDU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "b665cf78fc6b33d4ef3f0a2aed301a955c410548", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 4c9c2883d9..25cb607a2f 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -39,6 +39,7 @@ import com.palantir.lock.v2.PartitionedTimestamps;\n import com.palantir.lock.v2.StartIdentifiedAtlasDbTransactionResponse;\n import com.palantir.lock.v2.TimestampAndPartition;\n import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.logsafe.Preconditions;\n \n /**\n  * A service responsible for coalescing multiple start transaction calls into a single start transactions call. This\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NTY0NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417245645", "bodyText": "Probably want a test what happens when you push 0 here. Also should throw on negative.", "author": "jkozlowski", "createdAt": "2020-04-29T11:30:48Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -45,38 +44,32 @@\n  * A service responsible for coalescing multiple start transaction calls into a single start transactions call. This\n  * service also handles creating {@link LockTokenShare}'s to enable multiple transactions sharing a single immutable\n  * timestamp.\n- *\n+ * <p>\n  * Callers of this class should use {@link #unlock(Set)} and {@link #refreshLockLeases(Set)} for returned lock tokens,\n  * rather than directly calling delegate lock service.\n  */\n final class TransactionStarter implements AutoCloseable {\n-    private final DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher;\n+    private final DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher;\n     private final LockLeaseService lockLeaseService;\n \n     private TransactionStarter(\n-            DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher,\n+            DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher,\n             LockLeaseService lockLeaseService) {\n         this.autobatcher = autobatcher;\n         this.lockLeaseService = lockLeaseService;\n     }\n \n     static TransactionStarter create(LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n-        DisruptorAutobatcher<Void, StartIdentifiedAtlasDbTransactionResponse> autobatcher = Autobatchers\n+        DisruptorAutobatcher<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> autobatcher = Autobatchers\n                 .independent(consumer(lockLeaseService, lockWatchEventCache))\n                 .safeLoggablePurpose(\"transaction-starter\")\n                 .build();\n         return new TransactionStarter(autobatcher,\n                 lockLeaseService);\n     }\n \n-    StartIdentifiedAtlasDbTransactionResponse startIdentifiedAtlasDbTransaction() {\n-        try {\n-            return autobatcher.apply(null).get();\n-        } catch (ExecutionException e) {\n-            throw Throwables.throwUncheckedException(e.getCause());\n-        } catch (Throwable t) {\n-            throw Throwables.throwUncheckedException(t);\n-        }\n+    List<StartIdentifiedAtlasDbTransactionResponse> startIdentifiedAtlasDbTransactionBatch(int count) {", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b665cf78fc6b33d4ef3f0a2aed301a955c410548", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 4c9c2883d9..25cb607a2f 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -39,6 +39,7 @@ import com.palantir.lock.v2.PartitionedTimestamps;\n import com.palantir.lock.v2.StartIdentifiedAtlasDbTransactionResponse;\n import com.palantir.lock.v2.TimestampAndPartition;\n import com.palantir.lock.watch.LockWatchEventCache;\n+import com.palantir.logsafe.Preconditions;\n \n /**\n  * A service responsible for coalescing multiple start transaction calls into a single start transactions call. This\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjMyMQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417246321", "bodyText": "Hmm, just think very carefully about what this subList does here. @jeremyk-91", "author": "jkozlowski", "createdAt": "2020-04-29T11:32:04Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -138,16 +131,20 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n+    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.size();\n+            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n \n             List<StartIdentifiedAtlasDbTransactionResponse> startTransactionResponses =\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n-            for (int i = 0; i < numTransactions; i++) {\n-                batch.get(i).result().set(startTransactionResponses.get(i));\n+            int start = 0;\n+            for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n+                    : batch) {\n+                int end = start + batchElement.argument();\n+                batchElement.result().set(startTransactionResponses.subList(start, end));", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMxODM2MQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417318361", "bodyText": "Yes, since all of the returned lists are a view of the original list startTransactionResponses, we can get ConcurrentModificationExceptions or other such things if the lists returned are abused (i.e. elements are removed). I don't think this will be a problem given that we don't do that, but we could change this to return a fresh list for each result if it is a concern.", "author": "Jolyon-S", "createdAt": "2020-04-29T13:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjMyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4Njk1NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418586954", "bodyText": "@Jolyon-S The tricky thing here is that subList keeps a reference to the original list, so the entire response will remain live in terms of memory as long as any consumer keeps a reference to their chunk of the list. This looks like it would probably be safe from tracing through the code, but I'd prefer to just create a new list in case there's something silly around threads contending over updateAndGet() or things like that.", "author": "jeremyk-91", "createdAt": "2020-05-01T15:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 4c9c2883d9..c981f96753 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -131,36 +134,39 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n+    Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n+            int numTransactions = batch.size();\n \n             List<StartIdentifiedAtlasDbTransactionResponse> startTransactionResponses =\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n-            int start = 0;\n-            for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n-                    : batch) {\n-                int end = start + batchElement.argument();\n-                batchElement.result().set(startTransactionResponses.subList(start, end));\n-                start = end;\n+            for (int i = 0; i < numTransactions; i++) {\n+                batch.get(i).result().set(startTransactionResponses.get(i));\n             }\n         };\n     }\n \n-    private static List<StartIdentifiedAtlasDbTransactionResponse> getStartTransactionResponses(\n+    private List<StartIdentifiedAtlasDbTransactionResponse> getStartTransactionResponses(\n             LockLeaseService lockLeaseService,\n             LockWatchEventCache lockWatchEventCache,\n             int numberOfTransactions) {\n         List<StartIdentifiedAtlasDbTransactionResponse> result = new ArrayList<>();\n         while (result.size() < numberOfTransactions) {\n-            ConjureStartTransactionsResponse response = lockLeaseService.startTransactionsWithWatches(\n-                    lockWatchEventCache.lastKnownVersion().version(), numberOfTransactions - result.size());\n-            lockWatchEventCache.processStartTransactionsUpdate(\n-                    response.getTimestamps().stream().boxed().collect(Collectors.toSet()),\n-                    response.getLockWatchUpdate());\n-            result.addAll(split(response));\n+            try {\n+                ConjureStartTransactionsResponse response = lockLeaseService.startTransactionsWithWatches(\n+                        lockWatchEventCache.lastKnownVersion().version(), numberOfTransactions - result.size());\n+                lockWatchEventCache.processStartTransactionsUpdate(\n+                        response.getTimestamps().stream().boxed().collect(Collectors.toSet()),\n+                        response.getLockWatchUpdate());\n+                result.addAll(split(response));\n+            } catch (Throwable t) {\n+                unlock(result.stream()\n+                        .map(response -> response.immutableTimestamp().getLock())\n+                        .collect(Collectors.toSet()));\n+                throw Throwables.throwUncheckedException(t);\n+            }\n         }\n         return result;\n     }\n"}}, {"oid": "51247c4974389fcc607ea4d59310e5167c5037f7", "url": "https://github.com/palantir/atlasdb/commit/51247c4974389fcc607ea4d59310e5167c5037f7", "message": "Fix javadoc", "committedDate": "2020-04-29T12:30:47Z", "type": "commit"}, {"oid": "5567bfe2179f26c218bf3e47b3e6a116b3d8cc70", "url": "https://github.com/palantir/atlasdb/commit/5567bfe2179f26c218bf3e47b3e6a116b3d8cc70", "message": "Fix batching case in TimestampCorroboratingTimelockServiceTest", "committedDate": "2020-04-29T12:33:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4NjY1NA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r417286654", "bodyText": "Just want to check that this simple substitution still makes sense in the context above.", "author": "Jolyon-S", "createdAt": "2020-04-29T12:46:55Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/service/WriteBatchingTransactionService.java", "diffHunk": "@@ -123,7 +123,7 @@ public void close() {\n      *\n      * Retrying does theoretically mean that in the worst case with N transactions in our batch, we may actually\n      * require N calls to the database, though this is extremely unlikely especially because of the semantics of\n-     * {@link TimelockService#startIdentifiedAtlasDbTransaction()}.\n+     * {@link TimelockService#startIdentifiedAtlasDbTransactionBatch(int)}.", "originalCommit": "dd3f34c50b9fe549b1ca67fe1c4be3a361686af7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzkwOQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418553909", "bodyText": "Yep, still correct.", "author": "jeremyk-91", "createdAt": "2020-05-01T14:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4NjY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/service/WriteBatchingTransactionService.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/service/WriteBatchingTransactionService.java\nindex 9afb789c3b..e5d15a3503 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/service/WriteBatchingTransactionService.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/service/WriteBatchingTransactionService.java\n\n@@ -123,7 +123,7 @@ public final class WriteBatchingTransactionService implements TransactionService\n      *\n      * Retrying does theoretically mean that in the worst case with N transactions in our batch, we may actually\n      * require N calls to the database, though this is extremely unlikely especially because of the semantics of\n-     * {@link TimelockService#startIdentifiedAtlasDbTransactionBatch(int)}.\n+     * {@link TimelockService#startIdentifiedAtlasDbTransaction()}.\n      * Alternatives considered included failing out all requests (which is likely to be inefficient and lead to\n      * spurious retries on requests that actually committed), and re-submitting requests other than the failed one\n      * for consideration in the next batch (which may achieve higher throughput, but could lead to starvation of old\n"}}, {"oid": "46d18f17206d8bb6faf4a365c1da9e3de0ff6dc9", "url": "https://github.com/palantir/atlasdb/commit/46d18f17206d8bb6faf4a365c1da9e3de0ff6dc9", "message": "Continue fixing up tests", "committedDate": "2020-04-29T13:02:27Z", "type": "commit"}, {"oid": "59ffc1087acd754fad98efa60b7b4867c064c7bb", "url": "https://github.com/palantir/atlasdb/commit/59ffc1087acd754fad98efa60b7b4867c064c7bb", "message": "Cleanup lock refresher test", "committedDate": "2020-04-29T13:06:42Z", "type": "commit"}, {"oid": "0499cf880c992e6f31d37fed6fb46f356085fa47", "url": "https://github.com/palantir/atlasdb/commit/0499cf880c992e6f31d37fed6fb46f356085fa47", "message": "Properly propogate the param", "committedDate": "2020-04-29T13:07:52Z", "type": "commit"}, {"oid": "b665cf78fc6b33d4ef3f0a2aed301a955c410548", "url": "https://github.com/palantir/atlasdb/commit/b665cf78fc6b33d4ef3f0a2aed301a955c410548", "message": "Fixup tests", "committedDate": "2020-04-29T13:46:51Z", "type": "commit"}, {"oid": "2388c8cee27ad91f59615ca624b7c3b5a3bb8905", "url": "https://github.com/palantir/atlasdb/commit/2388c8cee27ad91f59615ca624b7c3b5a3bb8905", "message": "Remove nullable", "committedDate": "2020-04-29T13:47:31Z", "type": "commit"}, {"oid": "6f30fb495021baa63f8a8545ab020081fd5a7fe5", "url": "https://github.com/palantir/atlasdb/commit/6f30fb495021baa63f8a8545ab020081fd5a7fe5", "message": "Update to use new method", "committedDate": "2020-04-29T13:48:43Z", "type": "commit"}, {"oid": "be8d3608c8ecc887c1db055b6f971edf3cd40951", "url": "https://github.com/palantir/atlasdb/commit/be8d3608c8ecc887c1db055b6f971edf3cd40951", "message": "Improve testing", "committedDate": "2020-04-29T13:58:38Z", "type": "commit"}, {"oid": "2b21adc878d5b6cf5b8f6e2dad881ad1b51873b1", "url": "https://github.com/palantir/atlasdb/commit/2b21adc878d5b6cf5b8f6e2dad881ad1b51873b1", "message": "Remove another non-batched endpoint", "committedDate": "2020-04-29T14:06:11Z", "type": "commit"}, {"oid": "65a20ac51ffa1f1425ee280d5db66fae718ab517", "url": "https://github.com/palantir/atlasdb/commit/65a20ac51ffa1f1425ee280d5db66fae718ab517", "message": "Yet another aggressive auto format on this particular paragraph", "committedDate": "2020-04-29T14:06:44Z", "type": "commit"}, {"oid": "6935f4685d406b497ec0cd97cd24ced3883da29c", "url": "https://github.com/palantir/atlasdb/commit/6935f4685d406b497ec0cd97cd24ced3883da29c", "message": "merge in develop", "committedDate": "2020-04-30T08:17:37Z", "type": "commit"}, {"oid": "efffdec6af871ab339e4255a17b74e43609d3703", "url": "https://github.com/palantir/atlasdb/commit/efffdec6af871ab339e4255a17b74e43609d3703", "message": "style", "committedDate": "2020-04-30T08:19:37Z", "type": "commit"}, {"oid": "f8178f966f1cafe5d1a34998460775eb5f4e1f4e", "url": "https://github.com/palantir/atlasdb/commit/f8178f966f1cafe5d1a34998460775eb5f4e1f4e", "message": "Checkstyle", "committedDate": "2020-04-30T09:18:06Z", "type": "commit"}, {"oid": "740679248ef4216ce1659287f686d6612efb579d", "url": "https://github.com/palantir/atlasdb/commit/740679248ef4216ce1659287f686d6612efb579d", "message": "Get start timestamp instead of immutable timestamp", "committedDate": "2020-04-30T09:22:22Z", "type": "commit"}, {"oid": "8fb4294b079544e18d053327970bdf337fcfc799", "url": "https://github.com/palantir/atlasdb/commit/8fb4294b079544e18d053327970bdf337fcfc799", "message": "Fix small bug in unlocking in legacy timelock service", "committedDate": "2020-04-30T09:45:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MDAzNQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418550035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * be vvalid, the transaction must be committed, preferably by calling\n          \n          \n            \n                 * be valid, the transaction must be committed, preferably by calling", "author": "jeremyk-91", "createdAt": "2020-05-01T13:52:50Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -418,24 +419,24 @@ default LockWatchManager getLockWatchManager() {\n     void registerClosingCallback(Runnable closingCallback);\n \n     /**\n-     * This method can be used for direct control of a transaction's life cycle. For example, if the work done in\n-     * the transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of time, this method\n-     * allows for a long lived transaction object. For the any data read or written to the transaction to be valid,\n-     * the transaction must be committed, preferably by calling\n+     * This method can be used for direct control over the lifecycle of a batch of transactions. For example, if the\n+     * work done in each given transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of\n+     * time, this method allows for a long lived transaction object. For any data read or written to the transaction to\n+     * be vvalid, the transaction must be committed, preferably by calling", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\nindex f04fa2ea5a..7bed4e4c05 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n\n@@ -419,24 +418,24 @@ public interface TransactionManager extends AutoCloseable {\n     void registerClosingCallback(Runnable closingCallback);\n \n     /**\n-     * This method can be used for direct control over the lifecycle of a batch of transactions. For example, if the\n-     * work done in each given transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of\n-     * time, this method allows for a long lived transaction object. For any data read or written to the transaction to\n-     * be vvalid, the transaction must be committed, preferably by calling\n+     * This method can be used for direct control of a transaction's life cycle. For example, if the work done in\n+     * the transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of time, this method\n+     * allows for a long lived transaction object. For the any data read or written to the transaction to be valid,\n+     * the transaction must be committed, preferably by calling\n      * {@link #finishRunTaskWithLockThrowOnConflict(TransactionAndImmutableTsLock, TransactionTask)} to also perform\n-     * additional cleanup. Note that this does not clean up the pre commit condition associated with that task.\n+     * additional cleanup.\n      *\n-     * @return a batch of transactions with associated immutable timestamp locks\n      * @deprecated Similar functionality will exist, but this method is likely to change in the future\n+     *\n+     * @return the transaction and associated immutable timestamp lock for the task\n      */\n     @Deprecated\n     @Timed\n-    List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n-            List<PreCommitCondition> condition);\n+    TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n     /**\n      * Runs a provided task, commits the transaction, and performs cleanup associated with a transaction created by\n-     * {@link #setupRunTaskBatchWithConditionThrowOnConflict(List)}. If no further work needs to be done with\n+     * {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}. If no further work needs to be done with\n      * the transaction, a no-op task can be passed in.\n      *\n      * @deprecated Similar functionality will exist, but this method is likely to change in the future\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418551418", "bodyText": "Are there any conditions on the ordering of transactions responses returned? Might be good to say what's allowed/not in case downstream users decide that looking at the first or last entry in the list to find some information", "author": "jeremyk-91", "createdAt": "2020-05-01T13:55:56Z", "path": "atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java", "diffHunk": "@@ -418,24 +419,24 @@ default LockWatchManager getLockWatchManager() {\n     void registerClosingCallback(Runnable closingCallback);\n \n     /**\n-     * This method can be used for direct control of a transaction's life cycle. For example, if the work done in\n-     * the transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of time, this method\n-     * allows for a long lived transaction object. For the any data read or written to the transaction to be valid,\n-     * the transaction must be committed, preferably by calling\n+     * This method can be used for direct control over the lifecycle of a batch of transactions. For example, if the\n+     * work done in each given transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of\n+     * time, this method allows for a long lived transaction object. For any data read or written to the transaction to\n+     * be vvalid, the transaction must be committed, preferably by calling\n      * {@link #finishRunTaskWithLockThrowOnConflict(TransactionAndImmutableTsLock, TransactionTask)} to also perform\n-     * additional cleanup.\n+     * additional cleanup. Note that this does not clean up the pre commit condition associated with that task.\n      *\n+     * @return a batch of transactions with associated immutable timestamp locks\n      * @deprecated Similar functionality will exist, but this method is likely to change in the future\n-     *\n-     * @return the transaction and associated immutable timestamp lock for the task\n      */\n     @Deprecated\n     @Timed\n-    TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n+    List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU5MjQ0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418592443", "bodyText": "hmmm, feels to me the interface is pretty simple, the ordering should absolutely match; so at index 1, returned transaction should be matched to the precondition at index 1 in the request list.", "author": "jkozlowski", "createdAt": "2020-05-01T15:29:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0OTM2Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420049363", "bodyText": "I think I meant more in terms of the timestamps (e.g. can you assume response[0].getTimestamp() is the min?)", "author": "jeremyk-91", "createdAt": "2020-05-05T11:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA1MzU4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420053585", "bodyText": "Ah, I see what you mean. I don't think we should make that assumption anywhere (although I suspect, looking through the code at TransactionStarter, that it is the case anyway). Perhaps a bit of additional javadoc would cover this?", "author": "Jolyon-S", "createdAt": "2020-05-05T11:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2MTEzOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420061138", "bodyText": "Yeah, let's say that we can't assume that then", "author": "jeremyk-91", "createdAt": "2020-05-05T12:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MTQxOA=="}], "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\nindex f04fa2ea5a..7bed4e4c05 100644\n--- a/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n+++ b/atlasdb-api/src/main/java/com/palantir/atlasdb/transaction/api/TransactionManager.java\n\n@@ -419,24 +418,24 @@ public interface TransactionManager extends AutoCloseable {\n     void registerClosingCallback(Runnable closingCallback);\n \n     /**\n-     * This method can be used for direct control over the lifecycle of a batch of transactions. For example, if the\n-     * work done in each given transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of\n-     * time, this method allows for a long lived transaction object. For any data read or written to the transaction to\n-     * be vvalid, the transaction must be committed, preferably by calling\n+     * This method can be used for direct control of a transaction's life cycle. For example, if the work done in\n+     * the transaction is interactive and cannot be expressed as a {@link TransactionTask} ahead of time, this method\n+     * allows for a long lived transaction object. For the any data read or written to the transaction to be valid,\n+     * the transaction must be committed, preferably by calling\n      * {@link #finishRunTaskWithLockThrowOnConflict(TransactionAndImmutableTsLock, TransactionTask)} to also perform\n-     * additional cleanup. Note that this does not clean up the pre commit condition associated with that task.\n+     * additional cleanup.\n      *\n-     * @return a batch of transactions with associated immutable timestamp locks\n      * @deprecated Similar functionality will exist, but this method is likely to change in the future\n+     *\n+     * @return the transaction and associated immutable timestamp lock for the task\n      */\n     @Deprecated\n     @Timed\n-    List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n-            List<PreCommitCondition> condition);\n+    TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition);\n \n     /**\n      * Runs a provided task, commits the transaction, and performs cleanup associated with a transaction created by\n-     * {@link #setupRunTaskBatchWithConditionThrowOnConflict(List)}. If no further work needs to be done with\n+     * {@link #setupRunTaskWithConditionThrowOnConflict(PreCommitCondition)}. If no further work needs to be done with\n      * the transaction, a no-op task can be passed in.\n      *\n      * @deprecated Similar functionality will exist, but this method is likely to change in the future\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzQ5NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418553495", "bodyText": "I guess this is fine - but depends on implementation, most of the time they are all going to be the same I think?", "author": "jeremyk-91", "createdAt": "2020-05-01T14:00:56Z", "path": "atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java", "diffHunk": "@@ -162,27 +168,43 @@ protected boolean shouldStopRetrying(int numTimesFailed) {\n     }\n \n     @Override\n-    public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n-        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n-                = timelockService.startIdentifiedAtlasDbTransaction();\n+    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n+            List<PreCommitCondition> conditions) {\n+        if (conditions.isEmpty()) {\n+            return ImmutableList.of();\n+        }\n+\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n         try {\n-            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n-            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n+            long immutableTs = Collections.max(responses.stream()\n+                    .map(response -> response.immutableTimestamp().getImmutableTimestamp())", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxMjgwNg==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r419312806", "bodyText": "I was assuming that it is possible for the batch to be made out of several ConjureStartTransactionsResponses, and therefore there being a possibility that the immutable timestamp differs, but if it is not a problem then we could equally just take the first element's value.", "author": "Jolyon-S", "createdAt": "2020-05-04T09:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NDAyOA==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r420064028", "bodyText": "Makes sense, let's just stick with this. We don't actually need the most up to date value for the tracker here (it's only for metrics), a good approximation is fine, but there isn't a regression here.", "author": "jeremyk-91", "createdAt": "2020-05-05T12:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1MzQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\nindex a9b5b5bb64..4e6645c4fc 100644\n--- a/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n+++ b/atlasdb-impl-shared/src/main/java/com/palantir/atlasdb/transaction/impl/SnapshotTransactionManager.java\n\n@@ -168,43 +162,27 @@ import com.palantir.timestamp.TimestampService;\n     }\n \n     @Override\n-    public List<TransactionAndImmutableTsLock> setupRunTaskBatchWithConditionThrowOnConflict(\n-            List<PreCommitCondition> conditions) {\n-        if (conditions.isEmpty()) {\n-            return ImmutableList.of();\n-        }\n-\n-        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n-                timelockService.startIdentifiedAtlasDbTransactionBatch(conditions.size());\n+    public TransactionAndImmutableTsLock setupRunTaskWithConditionThrowOnConflict(PreCommitCondition condition) {\n+        StartIdentifiedAtlasDbTransactionResponse transactionResponse\n+                = timelockService.startIdentifiedAtlasDbTransaction();\n         try {\n-            long immutableTs = Collections.max(responses.stream()\n-                    .map(response -> response.immutableTimestamp().getImmutableTimestamp())\n-                    .collect(Collectors.toList()));\n+            LockToken immutableTsLock = transactionResponse.immutableTimestamp().getLock();\n+            long immutableTs = transactionResponse.immutableTimestamp().getImmutableTimestamp();\n             recordImmutableTimestamp(immutableTs);\n \n-            return Streams.zip(\n-                    responses.stream(),\n-                    conditions.stream(),\n-                    (response, condition) -> {\n-                        LockToken immutableTsLock = response.immutableTimestamp().getLock();\n-                        cleaner.punch(response.startTimestampAndPartition().timestamp());\n-                        Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n-                                response.startTimestampAndPartition().timestamp());\n-\n-                        Transaction transaction = createTransaction(\n-                                immutableTs,\n-                                startTimestampSupplier,\n-                                immutableTsLock,\n-                                condition);\n-\n-                        return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n-                    }).collect(Collectors.toList());\n-        } catch (Throwable t) {\n-            timelockService.tryUnlock(\n-                    responses.stream()\n-                            .map(response -> response.immutableTimestamp().getLock())\n-                            .collect(Collectors.toSet()));\n-            throw Throwables.rewrapAndThrowUncheckedException(t);\n+            cleaner.punch(transactionResponse.startTimestampAndPartition().timestamp());\n+            Supplier<Long> startTimestampSupplier = Suppliers.ofInstance(\n+                    transactionResponse.startTimestampAndPartition().timestamp());\n+\n+            Transaction transaction = createTransaction(\n+                    immutableTs,\n+                    startTimestampSupplier,\n+                    immutableTsLock,\n+                    condition);\n+            return TransactionAndImmutableTsLock.of(transaction, immutableTsLock);\n+        } catch (Throwable e) {\n+            timelockService.tryUnlock(ImmutableSet.of(transactionResponse.immutableTimestamp().getLock()));\n+            throw Throwables.rewrapAndThrowUncheckedException(e);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU1Njg5Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418556893", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n          \n          \n            \n                        int numTransactions = batch.stream().mapToInt(BatchElement::argument).reduce(0, Integer::sum);\n          \n      \n    \n    \n  \n\nThis does a bunch of unnecessary boxing. I think you can do mapToInt(BatchElement::argument) instead of just map().", "author": "jeremyk-91", "createdAt": "2020-05-01T14:09:13Z", "path": "lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java", "diffHunk": "@@ -138,16 +133,20 @@ public void close() {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n+    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.size();\n+            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\nindex 22db5e201c..c981f96753 100644\n--- a/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n+++ b/lock-api/src/main/java/com/palantir/lock/client/TransactionStarter.java\n\n@@ -133,36 +134,39 @@ final class TransactionStarter implements AutoCloseable {\n     }\n \n     @VisibleForTesting\n-    static Consumer<List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>>> consumer(\n+    Consumer<List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>>> consumer(\n             LockLeaseService lockLeaseService, LockWatchEventCache lockWatchEventCache) {\n         return batch -> {\n-            int numTransactions = batch.stream().map(BatchElement::argument).reduce(0, Integer::sum);\n+            int numTransactions = batch.size();\n \n             List<StartIdentifiedAtlasDbTransactionResponse> startTransactionResponses =\n                     getStartTransactionResponses(lockLeaseService, lockWatchEventCache, numTransactions);\n \n-            int start = 0;\n-            for (BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>> batchElement\n-                    : batch) {\n-                int end = start + batchElement.argument();\n-                batchElement.result().set(startTransactionResponses.subList(start, end));\n-                start = end;\n+            for (int i = 0; i < numTransactions; i++) {\n+                batch.get(i).result().set(startTransactionResponses.get(i));\n             }\n         };\n     }\n \n-    private static List<StartIdentifiedAtlasDbTransactionResponse> getStartTransactionResponses(\n+    private List<StartIdentifiedAtlasDbTransactionResponse> getStartTransactionResponses(\n             LockLeaseService lockLeaseService,\n             LockWatchEventCache lockWatchEventCache,\n             int numberOfTransactions) {\n         List<StartIdentifiedAtlasDbTransactionResponse> result = new ArrayList<>();\n         while (result.size() < numberOfTransactions) {\n-            ConjureStartTransactionsResponse response = lockLeaseService.startTransactionsWithWatches(\n-                    lockWatchEventCache.lastKnownVersion().version(), numberOfTransactions - result.size());\n-            lockWatchEventCache.processStartTransactionsUpdate(\n-                    response.getTimestamps().stream().boxed().collect(Collectors.toSet()),\n-                    response.getLockWatchUpdate());\n-            result.addAll(split(response));\n+            try {\n+                ConjureStartTransactionsResponse response = lockLeaseService.startTransactionsWithWatches(\n+                        lockWatchEventCache.lastKnownVersion().version(), numberOfTransactions - result.size());\n+                lockWatchEventCache.processStartTransactionsUpdate(\n+                        response.getTimestamps().stream().boxed().collect(Collectors.toSet()),\n+                        response.getLockWatchUpdate());\n+                result.addAll(split(response));\n+            } catch (Throwable t) {\n+                unlock(result.stream()\n+                        .map(response -> response.immutableTimestamp().getLock())\n+                        .collect(Collectors.toSet()));\n+                throw Throwables.throwUncheckedException(t);\n+            }\n         }\n         return result;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4NzU0Mw==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418587543", "bodyText": "\u2764\ufe0f Nice!", "author": "jeremyk-91", "createdAt": "2020-05-01T15:18:26Z", "path": "lock-api/src/test/java/com/palantir/lock/client/TransactionStarterTest.java", "diffHunk": "@@ -98,49 +101,99 @@ public void after() {\n     public void shouldDeriveStartTransactionResponseFromBatchedResponse_singleTransaction() {\n         ConjureStartTransactionsResponse startTransactionResponse = getStartTransactionResponse(12, 1);\n \n-        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 1))\n-                .thenReturn(startTransactionResponse);\n-        StartIdentifiedAtlasDbTransactionResponse response = transactionStarter.startIdentifiedAtlasDbTransaction();\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 1)).thenReturn(startTransactionResponse);\n+        StartIdentifiedAtlasDbTransactionResponse response =\n+                Iterables.getOnlyElement(transactionStarter.startIdentifiedAtlasDbTransactionBatch(1));\n \n         assertDerivableFromBatchedResponse(response, startTransactionResponse);\n     }\n \n+    @Test\n+    public void shouldDeriveStartTransactionResponseBatchFromBatchedResponse_multipleTransactions() {\n+        ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(12, 5);\n+\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 5)).thenReturn(batchResponse);\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                transactionStarter.startIdentifiedAtlasDbTransactionBatch(5);\n+\n+        assertThat(responses)\n+                .satisfies(TransactionStarterTest::assertThatStartTransactionResponsesAreUnique)\n+                .hasSize(5)\n+                .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse, batchResponse));\n+    }\n+\n+    @Test\n+    public void shouldThrowWhenTryingToStartIllegalNumberOfTransactions() {\n+        assertThatThrownBy(() -> transactionStarter.startIdentifiedAtlasDbTransactionBatch(0))\n+                .isInstanceOf(SafeIllegalArgumentException.class)\n+                .hasMessage(\"Cannot start 0 or fewer transactions\");\n+    }\n+\n     @Test\n     public void shouldDeriveStartTransactionResponseFromBatchedResponse_multipleTransactions() {\n         ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(40, 3);\n         when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 3))\n                 .thenReturn(batchResponse);\n \n-        List<StartIdentifiedAtlasDbTransactionResponse> responses = requestBatches(3);\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = requestSingularBatches(3);\n         assertThat(responses)\n                 .satisfies(TransactionStarterTest::assertThatStartTransactionResponsesAreUnique)\n                 .hasSize(3)\n                 .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse, batchResponse));\n     }\n \n+    @Test\n+    public void shouldDeriveStartTransactionResponseFromBatchedResponse_nonTrivialBatchSize() {\n+        ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(40, 10);\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 10))\n+                .thenReturn(batchResponse);\n+\n+        ImmutableList<Integer> sizes = ImmutableList.of(2, 3, 4, 1);\n+        List<List<StartIdentifiedAtlasDbTransactionResponse>> responses = requestBatches(sizes);\n+        Streams.forEachPair(responses.stream(), sizes.stream(),\n+                (response, size) -> assertThat(response)\n+                        .hasSize(size)\n+                        .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse,\n+                                batchResponse)));\n+\n+        assertThat(flattenResponses(responses)).satisfies(\n+                TransactionStarterTest::assertThatStartTransactionResponsesAreUnique);\n+    }", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/lock-api/src/test/java/com/palantir/lock/client/TransactionStarterTest.java b/lock-api/src/test/java/com/palantir/lock/client/TransactionStarterTest.java\nindex f451177583..5a5deb4847 100644\n--- a/lock-api/src/test/java/com/palantir/lock/client/TransactionStarterTest.java\n+++ b/lock-api/src/test/java/com/palantir/lock/client/TransactionStarterTest.java\n\n@@ -101,99 +98,49 @@ public class TransactionStarterTest {\n     public void shouldDeriveStartTransactionResponseFromBatchedResponse_singleTransaction() {\n         ConjureStartTransactionsResponse startTransactionResponse = getStartTransactionResponse(12, 1);\n \n-        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 1)).thenReturn(startTransactionResponse);\n-        StartIdentifiedAtlasDbTransactionResponse response =\n-                Iterables.getOnlyElement(transactionStarter.startIdentifiedAtlasDbTransactionBatch(1));\n+        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 1))\n+                .thenReturn(startTransactionResponse);\n+        StartIdentifiedAtlasDbTransactionResponse response = transactionStarter.startIdentifiedAtlasDbTransaction();\n \n         assertDerivableFromBatchedResponse(response, startTransactionResponse);\n     }\n \n-    @Test\n-    public void shouldDeriveStartTransactionResponseBatchFromBatchedResponse_multipleTransactions() {\n-        ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(12, 5);\n-\n-        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 5)).thenReturn(batchResponse);\n-        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n-                transactionStarter.startIdentifiedAtlasDbTransactionBatch(5);\n-\n-        assertThat(responses)\n-                .satisfies(TransactionStarterTest::assertThatStartTransactionResponsesAreUnique)\n-                .hasSize(5)\n-                .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse, batchResponse));\n-    }\n-\n-    @Test\n-    public void shouldThrowWhenTryingToStartIllegalNumberOfTransactions() {\n-        assertThatThrownBy(() -> transactionStarter.startIdentifiedAtlasDbTransactionBatch(0))\n-                .isInstanceOf(SafeIllegalArgumentException.class)\n-                .hasMessage(\"Cannot start 0 or fewer transactions\");\n-    }\n-\n     @Test\n     public void shouldDeriveStartTransactionResponseFromBatchedResponse_multipleTransactions() {\n         ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(40, 3);\n         when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 3))\n                 .thenReturn(batchResponse);\n \n-        List<StartIdentifiedAtlasDbTransactionResponse> responses = requestSingularBatches(3);\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses = requestBatches(3);\n         assertThat(responses)\n                 .satisfies(TransactionStarterTest::assertThatStartTransactionResponsesAreUnique)\n                 .hasSize(3)\n                 .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse, batchResponse));\n     }\n \n-    @Test\n-    public void shouldDeriveStartTransactionResponseFromBatchedResponse_nonTrivialBatchSize() {\n-        ConjureStartTransactionsResponse batchResponse = getStartTransactionResponse(40, 10);\n-        when(lockLeaseService.startTransactionsWithWatches(Optional.empty(), 10))\n-                .thenReturn(batchResponse);\n-\n-        ImmutableList<Integer> sizes = ImmutableList.of(2, 3, 4, 1);\n-        List<List<StartIdentifiedAtlasDbTransactionResponse>> responses = requestBatches(sizes);\n-        Streams.forEachPair(responses.stream(), sizes.stream(),\n-                (response, size) -> assertThat(response)\n-                        .hasSize(size)\n-                        .allSatisfy(startTxnResponse -> assertDerivableFromBatchedResponse(startTxnResponse,\n-                                batchResponse)));\n-\n-        assertThat(flattenResponses(responses)).satisfies(\n-                TransactionStarterTest::assertThatStartTransactionResponsesAreUnique);\n-    }\n-\n     @Test\n     public void shouldCallTimelockMultipleTimesUntilCollectsAllRequiredTimestampsAndProcessUpdates() {\n         when(lockLeaseService.startTransactionsWithWatches(any(Optional.class), anyInt()))\n                 .thenReturn(getStartTransactionResponse(40, 2))\n                 .thenReturn(getStartTransactionResponse(100, 1));\n \n-        requestSingularBatches(3);\n+        requestBatches(3);\n         verify(lockLeaseService).startTransactionsWithWatches(Optional.empty(), 3);\n         verify(lockLeaseService).startTransactionsWithWatches(Optional.empty(), 1);\n         verify(lockWatchEventCache).processStartTransactionsUpdate(ImmutableSet.of(40L, 56L), UPDATE);\n     }\n \n-    private List<List<StartIdentifiedAtlasDbTransactionResponse>> requestBatches(List<Integer> counts) {\n-        List<BatchElement<Integer, List<StartIdentifiedAtlasDbTransactionResponse>>> elements = counts.stream()\n-                .map(count ->\n-                        ImmutableTestBatchElement.builder()\n-                                .argument(count)\n-                                .result(new DisruptorAutobatcher.DisruptorFuture<>(\"test\"))\n-                                .build())\n+    private List<StartIdentifiedAtlasDbTransactionResponse> requestBatches(int size) {\n+        List<BatchElement<Void, StartIdentifiedAtlasDbTransactionResponse>> elements = IntStream.range(0, size)\n+                .mapToObj(unused -> ImmutableTestBatchElement.builder()\n+                        .argument(null)\n+                        .result(new DisruptorAutobatcher.DisruptorFuture<>(\"test\"))\n+                        .build())\n                 .collect(toList());\n-\n-        TransactionStarter.consumer(lockLeaseService, lockWatchEventCache).accept(elements);\n+        transactionStarter.consumer(lockLeaseService, lockWatchEventCache).accept(elements);\n         return Futures.getUnchecked(Futures.allAsList(Lists.transform(elements, BatchElement::result)));\n     }\n \n-    private List<StartIdentifiedAtlasDbTransactionResponse> requestSingularBatches(int size) {\n-        return flattenResponses(requestBatches(IntStream.range(0, size).mapToObj($ -> 1).collect(toList())));\n-    }\n-\n-    private List<StartIdentifiedAtlasDbTransactionResponse> flattenResponses(\n-            List<List<StartIdentifiedAtlasDbTransactionResponse>> responses) {\n-        return responses.stream().flatMap(List::stream).collect(toList());\n-    }\n-\n     private static void assertThatStartTransactionResponsesAreUnique(\n             List<? extends StartIdentifiedAtlasDbTransactionResponse> responses) {\n         assertThat(responses)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU4ODA4NQ==", "url": "https://github.com/palantir/atlasdb/pull/4711#discussion_r418588085", "bodyText": "good reuse here :)", "author": "jeremyk-91", "createdAt": "2020-05-01T15:19:36Z", "path": "timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/AsyncTimelockServiceIntegrationTest.java", "diffHunk": "@@ -458,44 +458,49 @@ public void waitForLockRequestsAreIdempotent() {\n     @Test\n     public void startIdentifiedAtlasDbTransactionGivesUsTimestampsInSequence() {\n         StartIdentifiedAtlasDbTransactionResponse firstResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n         StartIdentifiedAtlasDbTransactionResponse secondResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n \n-        // Note that we technically cannot guarantee an ordering between the fresh timestamp on response 1 and the\n-        // immutable timestamp on response 2. Most of the time, we will have IT on response 2 = IT on response 1\n-        // < FT on response 1, as the lock token on response 1 has not expired yet. However, if we sleep for long\n-        // enough between the first and second call that the immutable timestamp lock expires, then\n-        // IT on response 2 > FT on response 1.\n-        assertThat(ImmutableList.of(\n-                firstResponse.immutableTimestamp().getImmutableTimestamp(),\n-                firstResponse.startTimestampAndPartition().timestamp(),\n-                secondResponse.startTimestampAndPartition().timestamp())).isSorted();\n-        assertThat(ImmutableList.of(\n-                firstResponse.immutableTimestamp().getImmutableTimestamp(),\n-                secondResponse.immutableTimestamp().getImmutableTimestamp(),\n-                secondResponse.startTimestampAndPartition().timestamp())).isSorted();\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSequence(firstResponse, secondResponse);\n+    }\n+\n+    @Test\n+    public void startIdentifiedAtlasDbTransactionBatchGivesUsTimestampsInSequence() {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                namespace.timelockService().startIdentifiedAtlasDbTransactionBatch(2);\n+\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSequence(responses.get(0), responses.get(1));\n     }\n \n     @Test\n     public void startIdentifiedAtlasDbTransactionGivesUsStartTimestampsInTheSamePartition() {\n         StartIdentifiedAtlasDbTransactionResponse firstResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n         StartIdentifiedAtlasDbTransactionResponse secondResponse =\n-                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n+                startSingleTransaction(namespace.timelockService());\n \n-        assertThat(firstResponse.startTimestampAndPartition().partition())\n-                .isEqualTo(secondResponse.startTimestampAndPartition().partition());\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSamePartition(firstResponse, secondResponse);\n+    }\n+\n+    @Test\n+    public void startIdentifiedAtlasDbTransactionBatchGivesUsStartTimestampsInTheSamePartition() {\n+        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n+                namespace.timelockService().startIdentifiedAtlasDbTransactionBatch(2);\n+\n+        assertThatStartIdentifiedTransactionResponseTimestampsInSamePartition(responses.get(0), responses.get(1));", "originalCommit": "8fb4294b079544e18d053327970bdf337fcfc799", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "chunk": "diff --git a/timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/AsyncTimelockServiceIntegrationTest.java b/timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/AsyncTimelockServiceIntegrationTest.java\nindex 136e7211d6..c17de09b46 100644\n--- a/timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/AsyncTimelockServiceIntegrationTest.java\n+++ b/timelock-server/src/integTest/java/com/palantir/atlasdb/timelock/AsyncTimelockServiceIntegrationTest.java\n\n@@ -458,49 +458,44 @@ public class AsyncTimelockServiceIntegrationTest extends AbstractAsyncTimelockSe\n     @Test\n     public void startIdentifiedAtlasDbTransactionGivesUsTimestampsInSequence() {\n         StartIdentifiedAtlasDbTransactionResponse firstResponse =\n-                startSingleTransaction(namespace.timelockService());\n+                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n         StartIdentifiedAtlasDbTransactionResponse secondResponse =\n-                startSingleTransaction(namespace.timelockService());\n+                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n \n-        assertThatStartIdentifiedTransactionResponseTimestampsInSequence(firstResponse, secondResponse);\n-    }\n-\n-    @Test\n-    public void startIdentifiedAtlasDbTransactionBatchGivesUsTimestampsInSequence() {\n-        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n-                namespace.timelockService().startIdentifiedAtlasDbTransactionBatch(2);\n-\n-        assertThatStartIdentifiedTransactionResponseTimestampsInSequence(responses.get(0), responses.get(1));\n+        // Note that we technically cannot guarantee an ordering between the fresh timestamp on response 1 and the\n+        // immutable timestamp on response 2. Most of the time, we will have IT on response 2 = IT on response 1\n+        // < FT on response 1, as the lock token on response 1 has not expired yet. However, if we sleep for long\n+        // enough between the first and second call that the immutable timestamp lock expires, then\n+        // IT on response 2 > FT on response 1.\n+        assertThat(ImmutableList.of(\n+                firstResponse.immutableTimestamp().getImmutableTimestamp(),\n+                firstResponse.startTimestampAndPartition().timestamp(),\n+                secondResponse.startTimestampAndPartition().timestamp())).isSorted();\n+        assertThat(ImmutableList.of(\n+                firstResponse.immutableTimestamp().getImmutableTimestamp(),\n+                secondResponse.immutableTimestamp().getImmutableTimestamp(),\n+                secondResponse.startTimestampAndPartition().timestamp())).isSorted();\n     }\n \n     @Test\n     public void startIdentifiedAtlasDbTransactionGivesUsStartTimestampsInTheSamePartition() {\n         StartIdentifiedAtlasDbTransactionResponse firstResponse =\n-                startSingleTransaction(namespace.timelockService());\n+                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n         StartIdentifiedAtlasDbTransactionResponse secondResponse =\n-                startSingleTransaction(namespace.timelockService());\n+                namespace.timelockService().startIdentifiedAtlasDbTransaction();\n \n-        assertThatStartIdentifiedTransactionResponseTimestampsInSamePartition(firstResponse, secondResponse);\n-    }\n-\n-    @Test\n-    public void startIdentifiedAtlasDbTransactionBatchGivesUsStartTimestampsInTheSamePartition() {\n-        List<StartIdentifiedAtlasDbTransactionResponse> responses =\n-                namespace.timelockService().startIdentifiedAtlasDbTransactionBatch(2);\n-\n-        assertThatStartIdentifiedTransactionResponseTimestampsInSamePartition(responses.get(0), responses.get(1));\n+        assertThat(firstResponse.startTimestampAndPartition().partition())\n+                .isEqualTo(secondResponse.startTimestampAndPartition().partition());\n     }\n \n     @Test\n     public void temporalOrderingIsPreservedWhenMixingStandardTimestampAndIdentifiedTimestampRequests() {\n         List<Long> temporalSequence = ImmutableList.of(\n                 namespace.getFreshTimestamp(),\n-                startSingleTransaction(namespace.timelockService())\n-                        .startTimestampAndPartition()\n+                namespace.timelockService().startIdentifiedAtlasDbTransaction().startTimestampAndPartition()\n                         .timestamp(),\n                 namespace.getFreshTimestamp(),\n-                startSingleTransaction(namespace.timelockService())\n-                        .startTimestampAndPartition()\n+                namespace.timelockService().startIdentifiedAtlasDbTransaction().startTimestampAndPartition()\n                         .timestamp(),\n                 namespace.getFreshTimestamp());\n \n"}}, {"oid": "d0a5f0b201eee2a13121ebec5862eff042d5b4df", "url": "https://github.com/palantir/atlasdb/commit/d0a5f0b201eee2a13121ebec5862eff042d5b4df", "message": "Add unlock if failing mid-way through starting txns", "committedDate": "2020-05-01T15:25:38Z", "type": "commit"}, {"oid": "fd01a34f0fd44a7b497d99dd155b7ee8b87fdf7f", "url": "https://github.com/palantir/atlasdb/commit/fd01a34f0fd44a7b497d99dd155b7ee8b87fdf7f", "message": "Remove unused param", "committedDate": "2020-05-04T08:56:51Z", "type": "commit"}, {"oid": "9258d3b49ade78b5f409e45693f75a886db6c10c", "url": "https://github.com/palantir/atlasdb/commit/9258d3b49ade78b5f409e45693f75a886db6c10c", "message": "Fix method args", "committedDate": "2020-05-04T09:12:40Z", "type": "commit"}, {"oid": "b6dc3021301f1e55f115408138eab0e6de662c34", "url": "https://github.com/palantir/atlasdb/commit/b6dc3021301f1e55f115408138eab0e6de662c34", "message": "Nits from review", "committedDate": "2020-05-04T09:29:49Z", "type": "commit"}, {"oid": "012a0061912546ad0c09e8ce4925197a3d5b865a", "url": "https://github.com/palantir/atlasdb/commit/012a0061912546ad0c09e8ce4925197a3d5b865a", "message": "Add generated changelog entries", "committedDate": "2020-05-04T09:29:49Z", "type": "commit"}, {"oid": "aedfe92cdd40a18073233d403489e54ca3efdc63", "url": "https://github.com/palantir/atlasdb/commit/aedfe92cdd40a18073233d403489e54ca3efdc63", "message": "Fix bug when fail to register lock", "committedDate": "2020-05-04T10:43:43Z", "type": "commit"}, {"oid": "d3f0fe2ec976c34422f2bc5ba45b1dbe85ef12a2", "url": "https://github.com/palantir/atlasdb/commit/d3f0fe2ec976c34422f2bc5ba45b1dbe85ef12a2", "message": "Remove unnecessary diff", "committedDate": "2020-05-04T10:48:14Z", "type": "commit"}, {"oid": "a83408a2948cac9a8c9ce323154ca568843c8da1", "url": "https://github.com/palantir/atlasdb/commit/a83408a2948cac9a8c9ce323154ca568843c8da1", "message": "merge in fix-start-txn bug", "committedDate": "2020-05-04T12:37:14Z", "type": "commit"}, {"oid": "f159470ff8e11f9ee9eff7f837de49cd9c28456c", "url": "https://github.com/palantir/atlasdb/commit/f159470ff8e11f9ee9eff7f837de49cd9c28456c", "message": "merge in transaction starter fix", "committedDate": "2020-05-04T12:41:54Z", "type": "commit"}, {"oid": "5b12874f48c177cfbc9f47d9ad78de79ef734ec2", "url": "https://github.com/palantir/atlasdb/commit/5b12874f48c177cfbc9f47d9ad78de79ef734ec2", "message": "Merge branch 'develop' into fork-batch-txns", "committedDate": "2020-05-05T09:19:22Z", "type": "commit"}, {"oid": "00892feb28a67db48749bb287ed353046e5c2cd1", "url": "https://github.com/palantir/atlasdb/commit/00892feb28a67db48749bb287ed353046e5c2cd1", "message": "fix merge conflicts", "committedDate": "2020-05-05T09:25:59Z", "type": "commit"}, {"oid": "2bee6ba068054e2586147d8efab8f4a59aed06db", "url": "https://github.com/palantir/atlasdb/commit/2bee6ba068054e2586147d8efab8f4a59aed06db", "message": "Remove unused import", "committedDate": "2020-05-05T10:42:49Z", "type": "commit"}, {"oid": "4aeb3d2fa61c220c6a9be709b6b8c42813a96b8f", "url": "https://github.com/palantir/atlasdb/commit/4aeb3d2fa61c220c6a9be709b6b8c42813a96b8f", "message": "Add additional javadoc clarification", "committedDate": "2020-05-05T13:50:03Z", "type": "commit"}]}