{"pr_number": 5078, "pr_title": "[TimeLock Corruption] | Implement progress tracker", "pr_createdAt": "2020-10-22T17:14:09Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5078", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0MjUzMg==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510942532", "bodyText": "IntelliJ is telling me many things in this class don't have to be public - can you make those package-private or private?", "author": "Jolyon-S", "createdAt": "2020-10-23T14:56:11Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ProgressComponents;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex a47376048f..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.ProgressComponents;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    public static final int MAX_ROWS_ALLOWED = 500;\n-\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n-        return SequenceBounds.builder()\n-                .lower(progress.seq())\n-                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n-                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n-    }\n-\n-    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressComponents(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n-        long lastVerifiedSequence = value.upper();\n-\n-        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n-        resetIfRequired(key, value, currentProgressState)\n-                .orElseGet(\n-                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n-    }\n-\n-    private ProgressComponents updateProgressInDbThroughCache(\n-            NamespaceAndUseCase key,\n-            SequenceBounds value,\n-            long lastVerifiedSequence,\n-            ProgressComponents progressComponents) {\n-        ProgressComponents progressState = ProgressComponents.builder()\n-                .progressLimit(progressComponents.progressLimit())\n-                .seq(value.upper())\n-                .build();\n-        verificationProgressStateCache.put(key, progressState);\n-        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private Optional<ProgressComponents> resetIfRequired(\n-            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents progressComponents) {\n-        if (value.upper() <= progressComponents.progressLimit()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(verificationProgressStateCache.put(\n-                key,\n-                logVerificationProgressState.resetProgressState(\n-                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n-    }\n-\n-    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0MjY4MQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510942681", "bodyText": "replace with method reference", "author": "Jolyon-S", "createdAt": "2020-10-23T14:56:24Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ProgressComponents;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {\n+    public static final int MAX_ROWS_ALLOWED = 500;\n+\n+    private final LogVerificationProgressState logVerificationProgressState;\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+\n+    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n+\n+    public PaxosLogHistoryProgressTracker(\n+            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n+        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n+        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n+    }\n+\n+    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n+        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n+        return SequenceBounds.builder()\n+                .lower(progress.seq())\n+                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n+                .build();\n+    }\n+\n+    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n+        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n+                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex a47376048f..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.ProgressComponents;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    public static final int MAX_ROWS_ALLOWED = 500;\n-\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n-        return SequenceBounds.builder()\n-                .lower(progress.seq())\n-                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n-                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n-    }\n-\n-    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressComponents(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n-        long lastVerifiedSequence = value.upper();\n-\n-        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n-        resetIfRequired(key, value, currentProgressState)\n-                .orElseGet(\n-                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n-    }\n-\n-    private ProgressComponents updateProgressInDbThroughCache(\n-            NamespaceAndUseCase key,\n-            SequenceBounds value,\n-            long lastVerifiedSequence,\n-            ProgressComponents progressComponents) {\n-        ProgressComponents progressState = ProgressComponents.builder()\n-                .progressLimit(progressComponents.progressLimit())\n-                .seq(value.upper())\n-                .build();\n-        verificationProgressStateCache.put(key, progressState);\n-        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private Optional<ProgressComponents> resetIfRequired(\n-            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents progressComponents) {\n-        if (value.upper() <= progressComponents.progressLimit()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(verificationProgressStateCache.put(\n-                key,\n-                logVerificationProgressState.resetProgressState(\n-                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n-    }\n-\n-    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0NTQwMA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510945400", "bodyText": "As far as I can tell, you only ever put or get from this cache (i.e. never delete). I don't have full context on this piece of work, but I wonder if it is possible to OOM yourself? How many entries do you expect to be present in this cache?", "author": "Jolyon-S", "createdAt": "2020-10-23T15:00:16Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ProgressComponents;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {\n+    public static final int MAX_ROWS_ALLOWED = 500;\n+\n+    private final LogVerificationProgressState logVerificationProgressState;\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+\n+    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwMjM0NA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511002344", "bodyText": "The size would be bounded by |NamespaceAndUseCase| which would generally be around 1000, so I think this is fine. (Good flag though!)", "author": "jeremyk-91", "createdAt": "2020-10-23T16:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0NTQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex a47376048f..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,111 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.ProgressComponents;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    public static final int MAX_ROWS_ALLOWED = 500;\n-\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n-        return SequenceBounds.builder()\n-                .lower(progress.seq())\n-                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n-                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n-    }\n-\n-    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressComponents(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n-        long lastVerifiedSequence = value.upper();\n-\n-        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n-        resetIfRequired(key, value, currentProgressState)\n-                .orElseGet(\n-                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n-    }\n-\n-    private ProgressComponents updateProgressInDbThroughCache(\n-            NamespaceAndUseCase key,\n-            SequenceBounds value,\n-            long lastVerifiedSequence,\n-            ProgressComponents progressComponents) {\n-        ProgressComponents progressState = ProgressComponents.builder()\n-                .progressLimit(progressComponents.progressLimit())\n-                .seq(value.upper())\n-                .build();\n-        verificationProgressStateCache.put(key, progressState);\n-        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private Optional<ProgressComponents> resetIfRequired(\n-            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents progressComponents) {\n-        if (value.upper() <= progressComponents.progressLimit()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(verificationProgressStateCache.put(\n-                key,\n-                logVerificationProgressState.resetProgressState(\n-                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n-    }\n-\n-    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0NjczMQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510946731", "bodyText": "I think these immutables are fine, but if you really want to avoid crossed wires, you can try a staged builder: https://immutables.github.io/immutable.html#staged-builder\n(I appreciate not everyone likes them, but I do!)", "author": "Jolyon-S", "createdAt": "2020-10-23T15:02:08Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ProgressComponents {", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\ndeleted file mode 100644\nindex 0717a4c540..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\n+++ /dev/null\n\n@@ -1,32 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface ProgressComponents {\n-    @Value.Parameter\n-    long seq();\n-\n-    @Value.Parameter\n-    long progressLimit();\n-\n-    static ImmutableProgressComponents.Builder builder() {\n-        return ImmutableProgressComponents.builder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0OTY0Mw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510949643", "bodyText": "I'm not a huge fan - KeyedStream.of(historyQueries).mapKeys(...).map(...) gets you most of the way, although I'll confess that I'm not sure how to do the merging resolution in KeyedStream (although you can always collect to multimap).", "author": "Jolyon-S", "createdAt": "2020-10-23T15:06:38Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java", "diffHunk": "@@ -36,8 +38,11 @@ private HistoryLoaderAndTransformer() {\n \n     public static List<LogsForNamespaceAndUseCase> getLogsForHistoryQueries(\n             LocalHistoryLoader localHistoryLoader, List<HistoryQuery> historyQueries) {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = historyQueries.stream()\n-                .collect(Collectors.toMap(HistoryQuery::getNamespaceAndUseCase, HistoryQuery::getSeq, Math::min));\n+        Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences = historyQueries.stream()\n+                .collect(Collectors.toMap(", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0OTU4NA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511949584", "bodyText": "I think what we have now is more readable", "author": "sudiksha27", "createdAt": "2020-10-26T13:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0OTY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java\nindex aef3e4b6e0..adf69ed991 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java\n\n@@ -38,11 +36,8 @@ public final class HistoryLoaderAndTransformer {\n \n     public static List<LogsForNamespaceAndUseCase> getLogsForHistoryQueries(\n             LocalHistoryLoader localHistoryLoader, List<HistoryQuery> historyQueries) {\n-        Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences = historyQueries.stream()\n-                .collect(Collectors.toMap(\n-                        HistoryQuery::getNamespaceAndUseCase,\n-                        HistoryLoaderAndTransformer::sequenceBounds,\n-                        HistoryLoaderAndTransformer::seqBoundsCollisionResolver));\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = historyQueries.stream()\n+                .collect(Collectors.toMap(HistoryQuery::getNamespaceAndUseCase, HistoryQuery::getSeq, Math::min));\n \n         PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1MDg2OA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510950868", "bodyText": "Speaking of sanity checks, is this:\n(100 - lastVerified) + 1\nOR\n100 - (lastVerified + 1)?\nI assume the latter, although I'm never certain on how it determines this - so maybe bracket it?", "author": "Jolyon-S", "createdAt": "2020-10-23T15:08:33Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java", "diffHunk": "@@ -73,11 +73,12 @@ public void setup() {\n     public void canFetchLogsForQuery() {\n         writeToLogs(1, 100);\n         int lastVerified = 27;\n-        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(NAMESPACE_AND_USE_CASE, lastVerified));\n+        List<HistoryQuery> historyQueries =\n+                ImmutableList.of(HistoryQuery.of(NAMESPACE_AND_USE_CASE, lastVerified, lastVerified + 500));\n         List<LogsForNamespaceAndUseCase> paxosHistory =\n                 HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n \n-        sanityCheckLoadedHistory(paxosHistory, 100 - lastVerified);\n+        sanityCheckLoadedHistory(paxosHistory, 100 - lastVerified + 1);", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java\nindex 921607bbbc..64aa09fb95 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java\n\n@@ -73,12 +73,11 @@ public class HistoryLoaderAndTransformerTest {\n     public void canFetchLogsForQuery() {\n         writeToLogs(1, 100);\n         int lastVerified = 27;\n-        List<HistoryQuery> historyQueries =\n-                ImmutableList.of(HistoryQuery.of(NAMESPACE_AND_USE_CASE, lastVerified, lastVerified + 500));\n+        List<HistoryQuery> historyQueries = ImmutableList.of(HistoryQuery.of(NAMESPACE_AND_USE_CASE, lastVerified));\n         List<LogsForNamespaceAndUseCase> paxosHistory =\n                 HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n \n-        sanityCheckLoadedHistory(paxosHistory, 100 - lastVerified + 1);\n+        sanityCheckLoadedHistory(paxosHistory, 100 - lastVerified);\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkyNDMxOA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510924318", "bodyText": "nit: could we have docs on what this means?", "author": "jeremyk-91", "createdAt": "2020-10-23T14:29:43Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ProgressComponents {\n+    @Value.Parameter\n+    long seq();\n+\n+    @Value.Parameter\n+    long progressLimit();", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\ndeleted file mode 100644\nindex 0717a4c540..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\n+++ /dev/null\n\n@@ -1,32 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface ProgressComponents {\n-    @Value.Parameter\n-    long seq();\n-\n-    @Value.Parameter\n-    long progressLimit();\n-\n-    static ImmutableProgressComponents.Builder builder() {\n-        return ImmutableProgressComponents.builder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2MDY2Mw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510960663", "bodyText": "nit: let's give this a more descriptive name? minimalLowerBoundResolver or something like that?", "author": "jeremyk-91", "createdAt": "2020-10-23T15:23:41Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java", "diffHunk": "@@ -47,6 +52,17 @@ private HistoryLoaderAndTransformer() {\n                 .collect(Collectors.toList());\n     }\n \n+    private static SequenceBounds seqBoundsCollisionResolver(SequenceBounds bound1, SequenceBounds bound2) {", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java\nindex aef3e4b6e0..adf69ed991 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/remote/HistoryLoaderAndTransformer.java\n\n@@ -52,17 +47,6 @@ public final class HistoryLoaderAndTransformer {\n                 .collect(Collectors.toList());\n     }\n \n-    private static SequenceBounds seqBoundsCollisionResolver(SequenceBounds bound1, SequenceBounds bound2) {\n-        return bound1.lower() < bound2.lower() ? bound1 : bound2;\n-    }\n-\n-    private static ImmutableSequenceBounds sequenceBounds(HistoryQuery query) {\n-        return SequenceBounds.builder()\n-                .lower(query.getLowerBound())\n-                .upper(query.getUpperBound())\n-                .build();\n-    }\n-\n     private static Map.Entry<NamespaceAndUseCase, LogsForNamespaceAndUseCase> processHistory(\n             NamespaceAndUseCase namespaceAndUseCase, LearnerAndAcceptorRecords records) {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2NDUxOA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510964518", "bodyText": "can we reference this 500 constant somewhere?", "author": "jeremyk-91", "createdAt": "2020-10-23T15:27:56Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java", "diffHunk": "@@ -87,13 +88,13 @@ public void canHandleDuplicateQueries() {\n \n         List<HistoryQuery> queries = IntStream.range(0, 10)\n                 .boxed()\n-                .map(idx -> HistoryQuery.of(NAMESPACE_AND_USE_CASE, minLastVerified + idx))\n+                .map(idx -> HistoryQuery.of(NAMESPACE_AND_USE_CASE, minLastVerified + idx, minLastVerified + 500))", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2NzgzNw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510967837", "bodyText": "actually, see later comment: would prefer this to have a factory for generating unbounded ends", "author": "jeremyk-91", "createdAt": "2020-10-23T15:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2NDUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java\nindex 921607bbbc..64aa09fb95 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/HistoryLoaderAndTransformerTest.java\n\n@@ -88,13 +87,13 @@ public class HistoryLoaderAndTransformerTest {\n \n         List<HistoryQuery> queries = IntStream.range(0, 10)\n                 .boxed()\n-                .map(idx -> HistoryQuery.of(NAMESPACE_AND_USE_CASE, minLastVerified + idx, minLastVerified + 500))\n+                .map(idx -> HistoryQuery.of(NAMESPACE_AND_USE_CASE, minLastVerified + idx))\n                 .collect(Collectors.toList());\n \n         List<LogsForNamespaceAndUseCase> paxosHistory =\n                 HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, queries);\n \n-        sanityCheckLoadedHistory(paxosHistory, 100 - minLastVerified + 1);\n+        sanityCheckLoadedHistory(paxosHistory, 100 - minLastVerified);\n     }\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2NzIxNg==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510967216", "bodyText": "Maybe just have an unbounded end factory in HistoryQuery, it looks like this is causing a lot of friction", "author": "jeremyk-91", "createdAt": "2020-10-23T15:31:16Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java", "diffHunk": "@@ -95,8 +95,8 @@ public void canFetchAndCombineHistoriesForLocalAndRemote() {\n \n         int lastVerified = -1;\n \n-        List<HistoryQuery> historyQueries =\n-                ImmutableList.of(HistoryQuery.of(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n+        List<HistoryQuery> historyQueries = ImmutableList.of(\n+                HistoryQuery.of(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified, lastVerified + 500));", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java\nindex 33ebbc362b..05e93afd5e 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/PaxosLogHistoryProviderTest.java\n\n@@ -95,8 +95,8 @@ public class PaxosLogHistoryProviderTest {\n \n         int lastVerified = -1;\n \n-        List<HistoryQuery> historyQueries = ImmutableList.of(\n-                HistoryQuery.of(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified, lastVerified + 500));\n+        List<HistoryQuery> historyQueries =\n+                ImmutableList.of(HistoryQuery.of(ImmutableNamespaceAndUseCase.of(CLIENT, USE_CASE), lastVerified));\n \n         List<LogsForNamespaceAndUseCase> remoteHistory =\n                 HistoryLoaderAndTransformer.getLogsForHistoryQueries(history, historyQueries);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2OTMzNg==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r510969336", "bodyText": "I'd recommend being explicit about the edges of the range here: lowerInclusive but upperExclusive?", "author": "jeremyk-91", "createdAt": "2020-10-23T15:34:44Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface SequenceBounds {\n+    @Value.Parameter\n+    long lower();\n+\n+    @Value.Parameter\n+    long upper();", "originalCommit": "c217e97b996017b80a8ac17437c8260635acb03d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMTU1MQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511021551", "bodyText": "Actually, I would strongly prefer for us to use inclusive ranges. A lot of the lastVerified stuff is misleading because upper() is not actually verified.", "author": "jeremyk-91", "createdAt": "2020-10-23T17:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2OTMzNg=="}], "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java\ndeleted file mode 100644\nindex 44cffe36d6..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java\n+++ /dev/null\n\n@@ -1,32 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface SequenceBounds {\n-    @Value.Parameter\n-    long lower();\n-\n-    @Value.Parameter\n-    long upper();\n-\n-    static ImmutableSequenceBounds.Builder builder() {\n-        return ImmutableSequenceBounds.builder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNTg0NA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511005844", "bodyText": "nit: name this getLatestLearnedSequence...\nI think this makes sense, just it looks a bit suspicious", "author": "jeremyk-91", "createdAt": "2020-10-23T16:36:52Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.models.ProgressComponents;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {\n+    public static final int MAX_ROWS_ALLOWED = 500;\n+\n+    private final LogVerificationProgressState logVerificationProgressState;\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+\n+    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n+\n+    public PaxosLogHistoryProgressTracker(\n+            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n+        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n+        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n+    }\n+\n+    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n+        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n+        return SequenceBounds.builder()\n+                .lower(progress.seq())\n+                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n+                .build();\n+    }\n+\n+    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n+        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n+                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n+    }\n+\n+    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n+        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n+    }\n+\n+    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n+        Client client = namespaceAndUseCase.namespace();\n+        String useCase = namespaceAndUseCase.useCase();\n+\n+        return logVerificationProgressState\n+                .getProgressComponents(client, useCase)\n+                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n+                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n+    }\n+\n+    @VisibleForTesting\n+    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n+        long lastVerifiedSequence = value.upper();\n+\n+        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n+        resetIfRequired(key, value, currentProgressState)\n+                .orElseGet(\n+                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n+    }\n+\n+    private ProgressComponents updateProgressInDbThroughCache(\n+            NamespaceAndUseCase key,\n+            SequenceBounds value,\n+            long lastVerifiedSequence,\n+            ProgressComponents progressComponents) {\n+        ProgressComponents progressState = ProgressComponents.builder()\n+                .progressLimit(progressComponents.progressLimit())\n+                .seq(value.upper())\n+                .build();\n+        verificationProgressStateCache.put(key, progressState);\n+        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n+        return progressState;\n+    }\n+\n+    private Optional<ProgressComponents> resetIfRequired(\n+            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents currentProgressState) {\n+        if (value.upper() <= currentProgressState.progressLimit()) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(verificationProgressStateCache.put(\n+                key,\n+                logVerificationProgressState.resetProgressState(\n+                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n+    }\n+\n+    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n+        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n+                namespaceAndUseCase.namespace(), LearnerUseCase.createLearnerUseCase(namespaceAndUseCase.useCase()));", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex 2198de9d59..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.models.ProgressComponents;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    public static final int MAX_ROWS_ALLOWED = 500;\n-\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n-        return SequenceBounds.builder()\n-                .lower(progress.seq())\n-                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n-                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n-    }\n-\n-    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressComponents(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n-        long lastVerifiedSequence = value.upper();\n-\n-        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n-        resetIfRequired(key, value, currentProgressState)\n-                .orElseGet(\n-                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n-    }\n-\n-    private ProgressComponents updateProgressInDbThroughCache(\n-            NamespaceAndUseCase key,\n-            SequenceBounds value,\n-            long lastVerifiedSequence,\n-            ProgressComponents progressComponents) {\n-        ProgressComponents progressState = ProgressComponents.builder()\n-                .progressLimit(progressComponents.progressLimit())\n-                .seq(value.upper())\n-                .build();\n-        verificationProgressStateCache.put(key, progressState);\n-        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private Optional<ProgressComponents> resetIfRequired(\n-            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents currentProgressState) {\n-        if (value.upper() <= currentProgressState.progressLimit()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(verificationProgressStateCache.put(\n-                key,\n-                logVerificationProgressState.resetProgressState(\n-                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n-    }\n-\n-    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), LearnerUseCase.createLearnerUseCase(namespaceAndUseCase.useCase()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNTkxMA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511015910", "bodyText": "This might have been missed the first time around, but please name all tests consistent with the classes being tested. It's a bit jarring to look for LogVerificationProgressStateTest and not find it because the class is named this way instead.", "author": "jeremyk-91", "createdAt": "2020-10-23T16:55:45Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/LogVerificationStateTest.java", "diffHunk": "@@ -20,6 +20,7 @@\n \n import com.palantir.paxos.Client;", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/LogVerificationStateTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/LogVerificationStateTest.java\nindex 41c94494af..ebd1e33364 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/LogVerificationStateTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/LogVerificationStateTest.java\n\n@@ -20,7 +20,6 @@ import static org.assertj.core.api.Assertions.assertThat;\n \n import com.palantir.paxos.Client;\n import com.palantir.paxos.SqliteConnections;\n-import com.palantir.timelock.history.models.ProgressComponents;\n import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n import javax.sql.DataSource;\n import org.junit.Before;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNjg0Mg==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511016842", "bodyText": "I'd name this differently, maybe ProgressState or something like that?", "author": "jeremyk-91", "createdAt": "2020-10-23T16:57:29Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ProgressComponents {", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\ndeleted file mode 100644\nindex 0717a4c540..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\n+++ /dev/null\n\n@@ -1,32 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface ProgressComponents {\n-    @Value.Parameter\n-    long seq();\n-\n-    @Value.Parameter\n-    long progressLimit();\n-\n-    static ImmutableProgressComponents.Builder builder() {\n-        return ImmutableProgressComponents.builder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzA2Ng==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511017066", "bodyText": "lastVerifiedSeq? This makes it sound similar to the Paxos constructs when it's really not", "author": "jeremyk-91", "createdAt": "2020-10-23T16:57:55Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface ProgressComponents {\n+    @Value.Parameter\n+    long seq();", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\ndeleted file mode 100644\nindex 0717a4c540..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/ProgressComponents.java\n+++ /dev/null\n\n@@ -1,32 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface ProgressComponents {\n-    @Value.Parameter\n-    long seq();\n-\n-    @Value.Parameter\n-    long progressLimit();\n-\n-    static ImmutableProgressComponents.Builder builder() {\n-        return ImmutableProgressComponents.builder();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyMjMyNA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511022324", "bodyText": "See discussion elsewhere: I think I'd have a strong preference for having inclusive ranges here, because we've used terminology like latestVerified through many other parts of the code, which are not strictly correct when the upper bound has actually not been verified.", "author": "jeremyk-91", "createdAt": "2020-10-23T17:07:52Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java", "diffHunk": "@@ -82,16 +96,20 @@ public LearnerAndAcceptorRecords getLearnerAndAcceptorLogsSince(\n         //         revisit this once we have the remote history providers set up. Also, we may have to make it\n         // configurable to\n         //         accommodate the rate at which logs are being published.\n-        @SqlQuery(\"SELECT seq, val FROM paxosLog \"\n-                + \"WHERE namespace = :namespace.value AND useCase = :useCase AND seq > :seq \"\n-                + \"ORDER BY seq ASC LIMIT 500\")\n-        Map<Long, PaxosValue> getLearnerLogsSince(\n-                @BindPojo(\"namespace\") Client namespace, @Bind(\"useCase\") String useCase, @Bind(\"seq\") long seq);\n+        @SqlQuery(\"SELECT seq, val FROM paxosLog WHERE namespace = :namespace.value AND useCase = :useCase AND seq >=\"\n+                + \" :lowerBound AND seq < :upperBound\")\n+        Map<Long, PaxosValue> getLearnerLogsInRange(\n+                @BindPojo(\"namespace\") Client namespace,\n+                @Bind(\"useCase\") String useCase,\n+                @Bind(\"lowerBound\") long lowerBound,\n+                @Bind(\"upperBound\") long upperBound);\n \n-        @SqlQuery(\"SELECT seq, val FROM paxosLog \"\n-                + \"WHERE namespace = :namespace.value AND useCase = :useCase AND seq > :seq \"\n-                + \"ORDER BY seq ASC LIMIT 500\")\n-        Map<Long, PaxosAcceptorData> getAcceptorLogsSince(\n-                @BindPojo(\"namespace\") Client namespace, @Bind(\"useCase\") String useCase, @Bind(\"seq\") long seq);\n+        @SqlQuery(\"SELECT seq, val FROM paxosLog WHERE namespace = :namespace.value AND useCase = :useCase AND seq >=\"\n+                + \" :lowerBound AND seq < :upperBound\")", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java\nindex 7e5953c92c..6e099996dc 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java\n\n@@ -96,20 +82,16 @@ public final class SqlitePaxosStateLogHistory {\n         //         revisit this once we have the remote history providers set up. Also, we may have to make it\n         // configurable to\n         //         accommodate the rate at which logs are being published.\n-        @SqlQuery(\"SELECT seq, val FROM paxosLog WHERE namespace = :namespace.value AND useCase = :useCase AND seq >=\"\n-                + \" :lowerBound AND seq < :upperBound\")\n-        Map<Long, PaxosValue> getLearnerLogsInRange(\n-                @BindPojo(\"namespace\") Client namespace,\n-                @Bind(\"useCase\") String useCase,\n-                @Bind(\"lowerBound\") long lowerBound,\n-                @Bind(\"upperBound\") long upperBound);\n+        @SqlQuery(\"SELECT seq, val FROM paxosLog \"\n+                + \"WHERE namespace = :namespace.value AND useCase = :useCase AND seq > :seq \"\n+                + \"ORDER BY seq ASC LIMIT 500\")\n+        Map<Long, PaxosValue> getLearnerLogsSince(\n+                @BindPojo(\"namespace\") Client namespace, @Bind(\"useCase\") String useCase, @Bind(\"seq\") long seq);\n \n-        @SqlQuery(\"SELECT seq, val FROM paxosLog WHERE namespace = :namespace.value AND useCase = :useCase AND seq >=\"\n-                + \" :lowerBound AND seq < :upperBound\")\n-        Map<Long, PaxosAcceptorData> getAcceptorLogsInRange(\n-                @BindPojo(\"namespace\") Client namespace,\n-                @Bind(\"useCase\") String useCase,\n-                @Bind(\"lowerBound\") long lowerBound,\n-                @Bind(\"upperBound\") long upperBound);\n+        @SqlQuery(\"SELECT seq, val FROM paxosLog \"\n+                + \"WHERE namespace = :namespace.value AND useCase = :useCase AND seq > :seq \"\n+                + \"ORDER BY seq ASC LIMIT 500\")\n+        Map<Long, PaxosAcceptorData> getAcceptorLogsSince(\n+                @BindPojo(\"namespace\") Client namespace, @Bind(\"useCase\") String useCase, @Bind(\"seq\") long seq);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAyNzY5Nw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511027697", "bodyText": "This is an exclusive bound, so it is not the last verified sequence (see comment on my thoughts on SequenceBound).", "author": "jeremyk-91", "createdAt": "2020-10-23T17:18:21Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.models.ProgressComponents;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {\n+    public static final int MAX_ROWS_ALLOWED = 500;\n+\n+    private final LogVerificationProgressState logVerificationProgressState;\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+\n+    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n+\n+    public PaxosLogHistoryProgressTracker(\n+            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n+        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n+        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n+    }\n+\n+    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n+        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n+        return SequenceBounds.builder()\n+                .lower(progress.seq())\n+                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n+                .build();\n+    }\n+\n+    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n+        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n+                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n+    }\n+\n+    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n+        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n+    }\n+\n+    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n+        Client client = namespaceAndUseCase.namespace();\n+        String useCase = namespaceAndUseCase.useCase();\n+\n+        return logVerificationProgressState\n+                .getProgressComponents(client, useCase)\n+                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n+                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n+    }\n+\n+    @VisibleForTesting\n+    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n+        long lastVerifiedSequence = value.upper();", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex 2198de9d59..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.models.ProgressComponents;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    public static final int MAX_ROWS_ALLOWED = 500;\n-\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n-        return SequenceBounds.builder()\n-                .lower(progress.seq())\n-                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n-                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n-    }\n-\n-    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressComponents(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n-        long lastVerifiedSequence = value.upper();\n-\n-        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n-        resetIfRequired(key, value, currentProgressState)\n-                .orElseGet(\n-                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n-    }\n-\n-    private ProgressComponents updateProgressInDbThroughCache(\n-            NamespaceAndUseCase key,\n-            SequenceBounds value,\n-            long lastVerifiedSequence,\n-            ProgressComponents progressComponents) {\n-        ProgressComponents progressState = ProgressComponents.builder()\n-                .progressLimit(progressComponents.progressLimit())\n-                .seq(value.upper())\n-                .build();\n-        verificationProgressStateCache.put(key, progressState);\n-        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private Optional<ProgressComponents> resetIfRequired(\n-            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents currentProgressState) {\n-        if (value.upper() <= currentProgressState.progressLimit()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(verificationProgressStateCache.put(\n-                key,\n-                logVerificationProgressState.resetProgressState(\n-                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n-    }\n-\n-    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), LearnerUseCase.createLearnerUseCase(namespaceAndUseCase.useCase()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAzMDUyNw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r511030527", "bodyText": "This doesn't behave the way I think is intended: your seeding of the bound in getLatestSequence is inclusive, however your use of value here is exclusive. This means that even if there are no new entries, the validation task will repeatedly cycle over the entries (e.g. of an inactive client), which I doubt is intended.", "author": "jeremyk-91", "createdAt": "2020-10-23T17:23:58Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.models.ProgressComponents;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {\n+    public static final int MAX_ROWS_ALLOWED = 500;\n+\n+    private final LogVerificationProgressState logVerificationProgressState;\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+\n+    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n+\n+    public PaxosLogHistoryProgressTracker(\n+            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n+        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n+        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n+    }\n+\n+    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n+        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n+        return SequenceBounds.builder()\n+                .lower(progress.seq())\n+                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n+                .build();\n+    }\n+\n+    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n+        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n+                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n+    }\n+\n+    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n+        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n+    }\n+\n+    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n+        Client client = namespaceAndUseCase.namespace();\n+        String useCase = namespaceAndUseCase.useCase();\n+\n+        return logVerificationProgressState\n+                .getProgressComponents(client, useCase)\n+                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n+                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n+    }\n+\n+    @VisibleForTesting\n+    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n+        long lastVerifiedSequence = value.upper();\n+\n+        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n+        resetIfRequired(key, value, currentProgressState)\n+                .orElseGet(\n+                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n+    }\n+\n+    private ProgressComponents updateProgressInDbThroughCache(\n+            NamespaceAndUseCase key,\n+            SequenceBounds value,\n+            long lastVerifiedSequence,\n+            ProgressComponents progressComponents) {\n+        ProgressComponents progressState = ProgressComponents.builder()\n+                .progressLimit(progressComponents.progressLimit())\n+                .seq(value.upper())\n+                .build();\n+        verificationProgressStateCache.put(key, progressState);\n+        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n+        return progressState;\n+    }\n+\n+    private Optional<ProgressComponents> resetIfRequired(\n+            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents currentProgressState) {\n+        if (value.upper() <= currentProgressState.progressLimit()) {\n+            return Optional.empty();\n+        }", "originalCommit": "e33b3cb0066a1bb61e81f1aba3f05cb75dd4992c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex 2198de9d59..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,112 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.models.ProgressComponents;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    public static final int MAX_ROWS_ALLOWED = 500;\n-\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressComponents> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressComponents progress = getOrPopulateProgressComponents(namespaceAndUseCase);\n-        return SequenceBounds.builder()\n-                .lower(progress.seq())\n-                .upper(progress.seq() + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach((namespaceAndUseCase, bounds) ->\n-                updateProgressStateForNamespaceAndUseCase(namespaceAndUseCase, bounds));\n-    }\n-\n-    private ProgressComponents getOrPopulateProgressComponents(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressComponents getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressComponents(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase key, SequenceBounds value) {\n-        long lastVerifiedSequence = value.upper();\n-\n-        ProgressComponents currentProgressState = getOrPopulateProgressComponents(key);\n-        resetIfRequired(key, value, currentProgressState)\n-                .orElseGet(\n-                        () -> updateProgressInDbThroughCache(key, value, lastVerifiedSequence, currentProgressState));\n-    }\n-\n-    private ProgressComponents updateProgressInDbThroughCache(\n-            NamespaceAndUseCase key,\n-            SequenceBounds value,\n-            long lastVerifiedSequence,\n-            ProgressComponents progressComponents) {\n-        ProgressComponents progressState = ProgressComponents.builder()\n-                .progressLimit(progressComponents.progressLimit())\n-                .seq(value.upper())\n-                .build();\n-        verificationProgressStateCache.put(key, progressState);\n-        logVerificationProgressState.updateProgress(key.namespace(), key.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private Optional<ProgressComponents> resetIfRequired(\n-            NamespaceAndUseCase key, SequenceBounds value, ProgressComponents currentProgressState) {\n-        if (value.upper() <= currentProgressState.progressLimit()) {\n-            return Optional.empty();\n-        }\n-        return Optional.of(verificationProgressStateCache.put(\n-                key,\n-                logVerificationProgressState.resetProgressState(\n-                        key.namespace(), key.useCase(), getLatestSequenceForNamespaceAndUseCase(key))));\n-    }\n-\n-    private long getLatestSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), LearnerUseCase.createLearnerUseCase(namespaceAndUseCase.useCase()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI0ODg4OA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512248888", "bodyText": "sanity check: this has never been wired up right?", "author": "jeremyk-91", "createdAt": "2020-10-26T20:31:04Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/LogVerificationProgressState.java", "diffHunk": "@@ -49,38 +50,52 @@ private void initialize() {\n         execute(LogVerificationProgressState.Queries::createVerificationProgressStateTable);\n     }\n \n-    public void updateProgress(Client client, String useCase, long seq) {\n-        execute(dao -> dao.updateProgress(client, useCase, seq));\n-    }\n-\n-    public long getLastVerifiedSeq(Client client, String useCase) {\n+    public ProgressState resetProgressState(Client client, String useCase, long greatestLogSeq) {\n         return execute(dao -> {\n-            OptionalLong lastVerifiedSeq = dao.getLastVerifiedSeq(client, useCase);\n-            return lastVerifiedSeq.orElseGet(() -> setInitialProgress(client, useCase));\n+            dao.updateProgressStateAndGreatestSeqNumberToBeVerified(client, useCase, INITIAL_PROGRESS, greatestLogSeq);\n+            return ProgressState.builder()\n+                    .lastVerifiedSeq(INITIAL_PROGRESS)\n+                    .greatestSeqNumberToBeVerified(greatestLogSeq)\n+                    .build();\n         });\n     }\n \n-    private long setInitialProgress(Client client, String useCase) {\n-        updateProgress(client, useCase, INITIAL_PROGRESS);\n-        return INITIAL_PROGRESS;\n+    public void updateProgress(Client client, String useCase, long lastVerifiedSeq) {\n+        execute(dao -> dao.updateProgress(client, useCase, lastVerifiedSeq));\n+    }\n+\n+    public Optional<ProgressState> getProgressState(Client client, String useCase) {\n+        return execute(dao -> dao.getProgressState(client, useCase));\n     }\n \n     private <T> T execute(Function<LogVerificationProgressState.Queries, T> call) {\n         return jdbi.withExtension(LogVerificationProgressState.Queries.class, call::apply);\n     }\n \n     public interface Queries {\n-        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS logVerificationProgress (namespace TEXT, useCase TEXT, seq BIGINT,\"\n-                + \"PRIMARY KEY(namespace, useCase))\")\n+        @SqlUpdate(\"CREATE TABLE IF NOT EXISTS logVerificationProgress (namespace TEXT, useCase TEXT, lastVerifiedSeq\"\n+                + \" BIGINT, greatestSeqNumberToBeVerified BIGINT, PRIMARY KEY(namespace, useCase))\")", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzMTA0Mg==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512531042", "bodyText": "This will break since #5071 merged, my bad, I will fix this.", "author": "sudiksha27", "createdAt": "2020-10-27T09:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI0ODg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/LogVerificationProgressState.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/LogVerificationProgressState.java\nindex 757a49f8ef..bd6f2b88ac 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/LogVerificationProgressState.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/LogVerificationProgressState.java\n\n@@ -50,22 +49,20 @@ public final class LogVerificationProgressState {\n         execute(LogVerificationProgressState.Queries::createVerificationProgressStateTable);\n     }\n \n-    public ProgressState resetProgressState(Client client, String useCase, long greatestLogSeq) {\n-        return execute(dao -> {\n-            dao.updateProgressStateAndGreatestSeqNumberToBeVerified(client, useCase, INITIAL_PROGRESS, greatestLogSeq);\n-            return ProgressState.builder()\n-                    .lastVerifiedSeq(INITIAL_PROGRESS)\n-                    .greatestSeqNumberToBeVerified(greatestLogSeq)\n-                    .build();\n-        });\n+    public void updateProgress(Client client, String useCase, long seq) {\n+        execute(dao -> dao.updateProgress(client, useCase, seq));\n     }\n \n-    public void updateProgress(Client client, String useCase, long lastVerifiedSeq) {\n-        execute(dao -> dao.updateProgress(client, useCase, lastVerifiedSeq));\n+    public long getLastVerifiedSeq(Client client, String useCase) {\n+        return execute(dao -> {\n+            OptionalLong lastVerifiedSeq = dao.getLastVerifiedSeq(client, useCase);\n+            return lastVerifiedSeq.orElseGet(() -> setInitialProgress(client, useCase));\n+        });\n     }\n \n-    public Optional<ProgressState> getProgressState(Client client, String useCase) {\n-        return execute(dao -> dao.getProgressState(client, useCase));\n+    private long setInitialProgress(Client client, String useCase) {\n+        updateProgress(client, useCase, INITIAL_PROGRESS);\n+        return INITIAL_PROGRESS;\n     }\n \n     private <T> T execute(Function<LogVerificationProgressState.Queries, T> call) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1NDAwMQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512254001", "bodyText": "I'd suggest maintaining lowerBoundInclusive and upperBoundInclusive through the parameters in the call stack when making these queries", "author": "jeremyk-91", "createdAt": "2020-10-26T20:40:07Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java", "diffHunk": "@@ -62,17 +63,30 @@ public static SqlitePaxosStateLogHistory create(DataSource dataSource) {\n         return execute(Queries::getAllNamespaceAndUseCaseTuples);\n     }\n \n-    public LearnerAndAcceptorRecords getLearnerAndAcceptorLogsSince(\n-            Client namespace, LearnerUseCase learnerUseCase, AcceptorUseCase acceptorUseCase, long seq) {\n+    public LearnerAndAcceptorRecords getLearnerAndAcceptorLogsInRange(\n+            Client namespace,\n+            LearnerUseCase learnerUseCase,\n+            AcceptorUseCase acceptorUseCase,\n+            long lowerBound,\n+            long upperBound) {", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java\nindex c730f2c7b9..6e099996dc 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/sqlite/SqlitePaxosStateLogHistory.java\n\n@@ -63,30 +62,17 @@ public final class SqlitePaxosStateLogHistory {\n         return execute(Queries::getAllNamespaceAndUseCaseTuples);\n     }\n \n-    public LearnerAndAcceptorRecords getLearnerAndAcceptorLogsInRange(\n-            Client namespace,\n-            LearnerUseCase learnerUseCase,\n-            AcceptorUseCase acceptorUseCase,\n-            long lowerBound,\n-            long upperBound) {\n+    public LearnerAndAcceptorRecords getLearnerAndAcceptorLogsSince(\n+            Client namespace, LearnerUseCase learnerUseCase, AcceptorUseCase acceptorUseCase, long seq) {\n         return execute(dao -> ImmutableLearnerAndAcceptorRecords.of(\n-                dao.getLearnerLogsInRange(namespace, learnerUseCase.value(), lowerBound, upperBound),\n-                dao.getAcceptorLogsInRange(namespace, acceptorUseCase.value(), lowerBound, upperBound)));\n-    }\n-\n-    public long getGreatestLogEntry(Client client, LearnerUseCase useCase) {\n-        return executeSqlitePaxosStateLogQuery(dao -> dao.getGreatestLogEntry(client, useCase.value()))\n-                .orElse(PaxosAcceptor.NO_LOG_ENTRY);\n+                dao.getLearnerLogsSince(namespace, learnerUseCase.value(), seq),\n+                dao.getAcceptorLogsSince(namespace, acceptorUseCase.value(), seq)));\n     }\n \n     private <T> T execute(Function<Queries, T> call) {\n         return jdbi.withExtension(Queries.class, call::apply);\n     }\n \n-    private <T> T executeSqlitePaxosStateLogQuery(Function<SqlitePaxosStateLog.Queries, T> call) {\n-        return jdbi.withExtension(SqlitePaxosStateLog.Queries.class, call::apply);\n-    }\n-\n     public interface Queries {\n         @SqlQuery(\"SELECT DISTINCT namespace, useCase FROM paxosLog\")\n         Set<NamespaceAndUseCase> getAllNamespaceAndUseCaseTuples();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI1OTUwOQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512259509", "bodyText": "This variable name is misleading. These bounds are not verified at the time this call is made - they are the candidates you want to verify. In the previous model it was correct (because that's where you start the query from).", "author": "jeremyk-91", "createdAt": "2020-10-26T20:50:27Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -67,15 +65,10 @@ public PaxosLogHistoryProvider(DataSource dataSource, List<TimeLockPaxosHistoryP\n                 .collect(Collectors.toSet());\n     }\n \n-    private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCase) {\n-        return logVerificationProgressState.getLastVerifiedSeq(\n-                namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n-    }\n-\n     //     TODO(snanda): Refactor the two parts on translating PaxosHistoryOnRemote to\n     //      CompletePaxosHistoryForNamespaceAndUseCase to a separate component\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+        Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java\nindex ccdc70e56c..38c8a2d141 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java\n\n@@ -65,10 +67,15 @@ public class PaxosLogHistoryProvider {\n                 .collect(Collectors.toSet());\n     }\n \n+    private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCase) {\n+        return logVerificationProgressState.getLastVerifiedSeq(\n+                namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase());\n+    }\n+\n     //     TODO(snanda): Refactor the two parts on translating PaxosHistoryOnRemote to\n     //      CompletePaxosHistoryForNamespaceAndUseCase to a separate component\n     public List<CompletePaxosHistoryForNamespaceAndUseCase> getHistory() {\n-        Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n+        Map<NamespaceAndUseCase, Long> lastVerifiedSequences = getNamespaceAndUseCaseToLastVerifiedSeqMap();\n \n         PaxosHistoryOnSingleNode localPaxosHistory = localHistoryLoader.getLocalPaxosHistory(lastVerifiedSequences);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU3MA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512261570", "bodyText": "The name is no longer correct.", "author": "jeremyk-91", "createdAt": "2020-10-26T20:54:12Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/LocalHistoryLoader.java", "diffHunk": "@@ -39,19 +40,21 @@ public static LocalHistoryLoader create(SqlitePaxosStateLogHistory sqlitePaxosSt\n         return new LocalHistoryLoader(sqlitePaxosStateLogHistory);\n     }\n \n-    public PaxosHistoryOnSingleNode getLocalPaxosHistory(Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n+    public PaxosHistoryOnSingleNode getLocalPaxosHistory(\n+            Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences) {", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/LocalHistoryLoader.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/LocalHistoryLoader.java\nindex b0207c6341..19b6049858 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/LocalHistoryLoader.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/LocalHistoryLoader.java\n\n@@ -40,21 +39,19 @@ public final class LocalHistoryLoader {\n         return new LocalHistoryLoader(sqlitePaxosStateLogHistory);\n     }\n \n-    public PaxosHistoryOnSingleNode getLocalPaxosHistory(\n-            Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences) {\n+    public PaxosHistoryOnSingleNode getLocalPaxosHistory(Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n         return ImmutablePaxosHistoryOnSingleNode.of(KeyedStream.stream(lastVerifiedSequences)\n                 .map(this::loadLocalHistory)\n                 .collectToMap());\n     }\n \n     @VisibleForTesting\n-    LearnerAndAcceptorRecords loadLocalHistory(NamespaceAndUseCase namespaceAndUseCase, SequenceBounds bounds) {\n+    LearnerAndAcceptorRecords loadLocalHistory(NamespaceAndUseCase namespaceAndUseCase, Long seq) {\n         String paxosUseCasePrefix = namespaceAndUseCase.useCase();\n-        return sqlitePaxosStateLogHistory.getLearnerAndAcceptorLogsInRange(\n+        return sqlitePaxosStateLogHistory.getLearnerAndAcceptorLogsSince(\n                 namespaceAndUseCase.namespace(),\n                 LearnerUseCase.createLearnerUseCase(paxosUseCasePrefix),\n                 AcceptorUseCase.createAcceptorUseCase(paxosUseCasePrefix),\n-                bounds.lowerInclusive(),\n-                bounds.upperInclusive());\n+                seq);\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2Mjc3Nw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512262777", "bodyText": "nit: The name of this method is no longer correct though. As a user who's not familiar, how do I know what the elements of SequenceBounds are?", "author": "jeremyk-91", "createdAt": "2020-10-26T20:56:15Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java", "diffHunk": "@@ -114,17 +111,16 @@ private Long getOrInsertVerificationState(NamespaceAndUseCase namespaceAndUseCas\n     }\n \n     private List<HistoryQuery> getHistoryQueryListForRemoteServers(\n-            Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n+            Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences) {\n         return KeyedStream.stream(lastVerifiedSequences)\n                 .mapEntries(this::buildHistoryQuery)\n                 .values()\n                 .collect(Collectors.toList());\n     }\n \n-    private Map<NamespaceAndUseCase, Long> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n+    private Map<NamespaceAndUseCase, SequenceBounds> getNamespaceAndUseCaseToLastVerifiedSeqMap() {", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java\nindex ccdc70e56c..38c8a2d141 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProvider.java\n\n@@ -111,16 +114,17 @@ public class PaxosLogHistoryProvider {\n     }\n \n     private List<HistoryQuery> getHistoryQueryListForRemoteServers(\n-            Map<NamespaceAndUseCase, SequenceBounds> lastVerifiedSequences) {\n+            Map<NamespaceAndUseCase, Long> lastVerifiedSequences) {\n         return KeyedStream.stream(lastVerifiedSequences)\n                 .mapEntries(this::buildHistoryQuery)\n                 .values()\n                 .collect(Collectors.toList());\n     }\n \n-    private Map<NamespaceAndUseCase, SequenceBounds> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n+    private Map<NamespaceAndUseCase, Long> getNamespaceAndUseCaseToLastVerifiedSeqMap() {\n         return KeyedStream.of(getNamespaceAndUseCaseTuples().stream())\n-                .map(progressTracker::getPaxosLogSequenceBounds)\n+                .map(namespaceAndUseCase -> verificationProgressStateCache.computeIfAbsent(\n+                        namespaceAndUseCase, this::getOrInsertVerificationState))\n                 .collectToMap();\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NDEwMQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512264101", "bodyText": "What does this mean?\nI might be missing something, but I'm starting to be convinced that this class has no reason to exist: we should just operate on HistoryQuery objects.", "author": "jeremyk-91", "createdAt": "2020-10-26T20:58:46Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface SequenceBounds {\n+    int MAX_ROWS_ALLOWED = 500;\n+\n+    @Value.Parameter\n+    long lowerInclusive();\n+\n+    @Value.Parameter\n+    long upperInclusive();\n+\n+    static ImmutableSequenceBounds.Builder builder() {\n+        return ImmutableSequenceBounds.builder();\n+    }\n+\n+    static SequenceBounds getBoundsSinceLastVerified(long lastVerified) {", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java\ndeleted file mode 100644\nindex b4e24fe523..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface SequenceBounds {\n-    int MAX_ROWS_ALLOWED = 500;\n-\n-    @Value.Parameter\n-    long lowerInclusive();\n-\n-    @Value.Parameter\n-    long upperInclusive();\n-\n-    static ImmutableSequenceBounds.Builder builder() {\n-        return ImmutableSequenceBounds.builder();\n-    }\n-\n-    static SequenceBounds getBoundsSinceLastVerified(long lastVerified) {\n-        return SequenceBounds.builder()\n-                .lowerInclusive(lastVerified + 1)\n-                .upperInclusive(lastVerified + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NDQzMQ==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512264431", "bodyText": "What does this method name mean? (It gets the bounds for the next history query; is there a reason the progress tracker shouldn't be creating history queries in and of itself?)", "author": "jeremyk-91", "createdAt": "2020-10-26T20:59:26Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.models.ProgressState;\n+import com.palantir.timelock.history.models.SequenceBounds;\n+import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import javax.sql.DataSource;\n+\n+public class PaxosLogHistoryProgressTracker {\n+    private final LogVerificationProgressState logVerificationProgressState;\n+    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n+\n+    private Map<NamespaceAndUseCase, ProgressState> verificationProgressStateCache = new ConcurrentHashMap<>();\n+\n+    public PaxosLogHistoryProgressTracker(\n+            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n+        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n+        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n+    }\n+\n+    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\ndeleted file mode 100644\nindex 7af35b5159..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/PaxosLogHistoryProgressTracker.java\n+++ /dev/null\n\n@@ -1,102 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.models.LearnerUseCase;\n-import com.palantir.timelock.history.models.ProgressState;\n-import com.palantir.timelock.history.models.SequenceBounds;\n-import com.palantir.timelock.history.sqlite.LogVerificationProgressState;\n-import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import javax.sql.DataSource;\n-\n-public class PaxosLogHistoryProgressTracker {\n-    private final LogVerificationProgressState logVerificationProgressState;\n-    private final SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory;\n-\n-    private Map<NamespaceAndUseCase, ProgressState> verificationProgressStateCache = new ConcurrentHashMap<>();\n-\n-    public PaxosLogHistoryProgressTracker(\n-            DataSource dataSource, SqlitePaxosStateLogHistory sqlitePaxosStateLogHistory) {\n-        this.logVerificationProgressState = LogVerificationProgressState.create(dataSource);\n-        this.sqlitePaxosStateLogHistory = sqlitePaxosStateLogHistory;\n-    }\n-\n-    public SequenceBounds getPaxosLogSequenceBounds(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressState progressState = getOrPopulateProgressState(namespaceAndUseCase);\n-\n-        if (progressState.shouldResetProgressState()) {\n-            progressState = resetProgressState(namespaceAndUseCase);\n-        }\n-\n-        return SequenceBounds.getBoundsSinceLastVerified(progressState.lastVerifiedSeq());\n-    }\n-\n-    public void updateProgressState(Map<NamespaceAndUseCase, SequenceBounds> namespaceAndUseCaseSequenceBoundsMap) {\n-        namespaceAndUseCaseSequenceBoundsMap.forEach(this::updateProgressStateForNamespaceAndUseCase);\n-    }\n-\n-    private ProgressState getOrPopulateProgressState(NamespaceAndUseCase namespaceAndUseCase) {\n-        return verificationProgressStateCache.computeIfAbsent(namespaceAndUseCase, this::getLastVerifiedSeqFromLogs);\n-    }\n-\n-    private ProgressState getLastVerifiedSeqFromLogs(NamespaceAndUseCase namespaceAndUseCase) {\n-        Client client = namespaceAndUseCase.namespace();\n-        String useCase = namespaceAndUseCase.useCase();\n-\n-        return logVerificationProgressState\n-                .getProgressState(client, useCase)\n-                .orElseGet(() -> logVerificationProgressState.resetProgressState(\n-                        client, useCase, getLatestLearnedSequenceForNamespaceAndUseCase(namespaceAndUseCase)));\n-    }\n-\n-    @VisibleForTesting\n-    void updateProgressStateForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase, SequenceBounds bounds) {\n-        updateProgressInDbThroughCache(\n-                namespaceAndUseCase, bounds.upperInclusive(), getOrPopulateProgressState(namespaceAndUseCase));\n-    }\n-\n-    private ProgressState updateProgressInDbThroughCache(\n-            NamespaceAndUseCase namespaceAndUseCase, long lastVerifiedSequence, ProgressState state) {\n-        ProgressState progressState = ProgressState.builder()\n-                .greatestSeqNumberToBeVerified(state.greatestSeqNumberToBeVerified())\n-                .lastVerifiedSeq(lastVerifiedSequence)\n-                .build();\n-        verificationProgressStateCache.put(namespaceAndUseCase, progressState);\n-        logVerificationProgressState.updateProgress(\n-                namespaceAndUseCase.namespace(), namespaceAndUseCase.useCase(), lastVerifiedSequence);\n-        return progressState;\n-    }\n-\n-    private ProgressState resetProgressState(NamespaceAndUseCase namespaceAndUseCase) {\n-        ProgressState resetProgressState = logVerificationProgressState.resetProgressState(\n-                namespaceAndUseCase.namespace(),\n-                namespaceAndUseCase.useCase(),\n-                getLatestLearnedSequenceForNamespaceAndUseCase(namespaceAndUseCase));\n-        verificationProgressStateCache.put(namespaceAndUseCase, resetProgressState);\n-        return resetProgressState;\n-    }\n-\n-    private long getLatestLearnedSequenceForNamespaceAndUseCase(NamespaceAndUseCase namespaceAndUseCase) {\n-        return sqlitePaxosStateLogHistory.getGreatestLogEntry(\n-                namespaceAndUseCase.namespace(), LearnerUseCase.createLearnerUseCase(namespaceAndUseCase.useCase()));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTYzNA==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512265634", "bodyText": "It feels kind of dubious that this is here; it seems this is just a history query without a namespace and use case. If possible I'd urge you to try and kill this class altogether, but if that's not possible I would strongly prefer naming this class so that it's obvious that it is specific to history queries (e.g. HistoryQuerySequenceRange).", "author": "jeremyk-91", "createdAt": "2020-10-26T21:01:37Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.models;\n+\n+import org.immutables.value.Value;\n+\n+@Value.Immutable\n+public interface SequenceBounds {\n+    int MAX_ROWS_ALLOWED = 500;", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java\ndeleted file mode 100644\nindex b4e24fe523..0000000000\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/history/models/SequenceBounds.java\n+++ /dev/null\n\n@@ -1,41 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.models;\n-\n-import org.immutables.value.Value;\n-\n-@Value.Immutable\n-public interface SequenceBounds {\n-    int MAX_ROWS_ALLOWED = 500;\n-\n-    @Value.Parameter\n-    long lowerInclusive();\n-\n-    @Value.Parameter\n-    long upperInclusive();\n-\n-    static ImmutableSequenceBounds.Builder builder() {\n-        return ImmutableSequenceBounds.builder();\n-    }\n-\n-    static SequenceBounds getBoundsSinceLastVerified(long lastVerified) {\n-        return SequenceBounds.builder()\n-                .lowerInclusive(lastVerified + 1)\n-                .upperInclusive(lastVerified + MAX_ROWS_ALLOWED)\n-                .build();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTkwMw==", "url": "https://github.com/palantir/atlasdb/pull/5078#discussion_r512265903", "bodyText": "nit: the standard form for factory classes of this kind is the plural of the class name i.e. HistoryQueries", "author": "jeremyk-91", "createdAt": "2020-10-26T21:02:09Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueryUtils.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.history.utils;\n+\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.NamespaceAndUseCase;\n+import com.palantir.timelock.history.HistoryQuery;\n+\n+public class HistoryQueryUtils {", "originalCommit": "d04722965a9d78ce271465401eb5fe595717862c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "chunk": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueryUtils.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueryUtils.java\ndeleted file mode 100644\nindex 2c19fdba9b..0000000000\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/history/utils/HistoryQueryUtils.java\n+++ /dev/null\n\n@@ -1,38 +0,0 @@\n-/*\n- * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.palantir.timelock.history.utils;\n-\n-import com.palantir.paxos.Client;\n-import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n-import com.palantir.paxos.NamespaceAndUseCase;\n-import com.palantir.timelock.history.HistoryQuery;\n-\n-public class HistoryQueryUtils {\n-    public static final Client DEFAULT_CLIENT = Client.of(\"client\");\n-    public static final String DEFAULT_USE_CASE = \"useCase\";\n-    public static final NamespaceAndUseCase DEFAULT_NAMESPACE_AND_USE_CASE =\n-            ImmutableNamespaceAndUseCase.of(DEFAULT_CLIENT, DEFAULT_USE_CASE);\n-\n-    public static HistoryQuery unboundedHistoryQuerySinceSeq(long seqLowerBound) {\n-        return unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(DEFAULT_NAMESPACE_AND_USE_CASE, seqLowerBound);\n-    }\n-\n-    public static HistoryQuery unboundedHistoryQuerySinceSeqForNamespaceAndUseCase(\n-            NamespaceAndUseCase namespaceAndUseCase, long seqLowerBound) {\n-        return HistoryQuery.of(namespaceAndUseCase, seqLowerBound, seqLowerBound + 10001);\n-    }\n-}\n"}}, {"oid": "7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "url": "https://github.com/palantir/atlasdb/commit/7023d19adc7367ee7e1bdaccb908bbc4ecca64d8", "message": "Wire through - part 1", "committedDate": "2020-10-27T20:46:53Z", "type": "commit"}, {"oid": "190b0dc2a19f7e4031f9a61165e3c19abee8a15d", "url": "https://github.com/palantir/atlasdb/commit/190b0dc2a19f7e4031f9a61165e3c19abee8a15d", "message": "WIP", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "7e3c8f34f77868c87cbffdee32134ea1cdc392e3", "url": "https://github.com/palantir/atlasdb/commit/7e3c8f34f77868c87cbffdee32134ea1cdc392e3", "message": "Wire", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "551a265966675658792484909f2b8910010497cf", "url": "https://github.com/palantir/atlasdb/commit/551a265966675658792484909f2b8910010497cf", "message": "WIP", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "ae2e8a8ad1d322f9d2833e3f0929340345b1734e", "url": "https://github.com/palantir/atlasdb/commit/ae2e8a8ad1d322f9d2833e3f0929340345b1734e", "message": "Tests", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "063a326e1d6fa3761c1b1c1123be0256a7750570", "url": "https://github.com/palantir/atlasdb/commit/063a326e1d6fa3761c1b1c1123be0256a7750570", "message": "Refactor", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "a9a28c3f63a8549d0dc0f2fb45ec66d0d3ee6cc5", "url": "https://github.com/palantir/atlasdb/commit/a9a28c3f63a8549d0dc0f2fb45ec66d0d3ee6cc5", "message": "Remove redundant", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "d82ae18587b47395406b9b3d669bc59a04e3d303", "url": "https://github.com/palantir/atlasdb/commit/d82ae18587b47395406b9b3d669bc59a04e3d303", "message": "Major bux fix", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "35539e8af20328e9f16d07914e694f3956a3fb7b", "url": "https://github.com/palantir/atlasdb/commit/35539e8af20328e9f16d07914e694f3956a3fb7b", "message": "Refactor - 1", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "4c33745c6cb8543c8a675586faebb9eef58476d6", "url": "https://github.com/palantir/atlasdb/commit/4c33745c6cb8543c8a675586faebb9eef58476d6", "message": "Modify algo - 1", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "fbfe19353797ff539f44de0765382519169ae093", "url": "https://github.com/palantir/atlasdb/commit/fbfe19353797ff539f44de0765382519169ae093", "message": "Unit tests", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "ced25a3f81c5f3eedfa5486fdca5deac6d129965", "url": "https://github.com/palantir/atlasdb/commit/ced25a3f81c5f3eedfa5486fdca5deac6d129965", "message": "Address comments - 2", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "f751e77075e33c3ee56a5fb7b256bd2d56c9444e", "url": "https://github.com/palantir/atlasdb/commit/f751e77075e33c3ee56a5fb7b256bd2d56c9444e", "message": "Test refactor", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "dbc61010cfa63663574ae0b47ddaea228c0b35e9", "url": "https://github.com/palantir/atlasdb/commit/dbc61010cfa63663574ae0b47ddaea228c0b35e9", "message": "Format", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "0bd6e8e1cb533b4f413a4275a86fe7d46b3d3567", "url": "https://github.com/palantir/atlasdb/commit/0bd6e8e1cb533b4f413a4275a86fe7d46b3d3567", "message": "Fix broken tests", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "6369d99b74129ed2838c721e92ec653563f06f68", "url": "https://github.com/palantir/atlasdb/commit/6369d99b74129ed2838c721e92ec653563f06f68", "message": "Refactor", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "31ee4ae9c02a286c758aacc7ede6d0e7e786d61d", "url": "https://github.com/palantir/atlasdb/commit/31ee4ae9c02a286c758aacc7ede6d0e7e786d61d", "message": "Bug fix", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "64d39bfe67e083c17b310c65dd6dfb430e01d66b", "url": "https://github.com/palantir/atlasdb/commit/64d39bfe67e083c17b310c65dd6dfb430e01d66b", "message": "Small", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "2b259f1a242c38a7ccf49dbb8b0f1aaa26a2de03", "url": "https://github.com/palantir/atlasdb/commit/2b259f1a242c38a7ccf49dbb8b0f1aaa26a2de03", "message": "Let's start reverting messy changes - 1", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "721f851f6e612f4dc7cd3df627c66145bfebb12a", "url": "https://github.com/palantir/atlasdb/commit/721f851f6e612f4dc7cd3df627c66145bfebb12a", "message": "SequenceBounds -> HistoryQuerySequenceBounds", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "01963c9012c7c40db1314e8b34c2af5d952b8b11", "url": "https://github.com/palantir/atlasdb/commit/01963c9012c7c40db1314e8b34c2af5d952b8b11", "message": "Name correction - 1", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "e61dd2ace0717006ea7d44bbeb7163d0df757cf0", "url": "https://github.com/palantir/atlasdb/commit/e61dd2ace0717006ea7d44bbeb7163d0df757cf0", "message": "Refactor", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "b4b291a1623cf572ea6c1b24fdb18273fd28727d", "url": "https://github.com/palantir/atlasdb/commit/b4b291a1623cf572ea6c1b24fdb18273fd28727d", "message": "Refactor", "committedDate": "2020-10-27T20:56:00Z", "type": "commit"}, {"oid": "17ab35ec023b1b16aebb9ab016c55cc864cb1d4a", "url": "https://github.com/palantir/atlasdb/commit/17ab35ec023b1b16aebb9ab016c55cc864cb1d4a", "message": "Add generated changelog entries", "committedDate": "2020-10-27T16:25:33Z", "type": "commit"}, {"oid": "b4b291a1623cf572ea6c1b24fdb18273fd28727d", "url": "https://github.com/palantir/atlasdb/commit/b4b291a1623cf572ea6c1b24fdb18273fd28727d", "message": "Refactor", "committedDate": "2020-10-27T20:56:00Z", "type": "forcePushed"}, {"oid": "56b8050ba9c9ad811e30cc1b2887c4be1cde6a2f", "url": "https://github.com/palantir/atlasdb/commit/56b8050ba9c9ad811e30cc1b2887c4be1cde6a2f", "message": "Fix build", "committedDate": "2020-10-28T09:18:04Z", "type": "commit"}, {"oid": "b091297e3e12e7e06f7efd0d5deb5b73de25796f", "url": "https://github.com/palantir/atlasdb/commit/b091297e3e12e7e06f7efd0d5deb5b73de25796f", "message": "Fix build - attempt II", "committedDate": "2020-10-28T09:34:12Z", "type": "commit"}, {"oid": "d42c4c3577b0f508c66ebb306a56f0659bc719ca", "url": "https://github.com/palantir/atlasdb/commit/d42c4c3577b0f508c66ebb306a56f0659bc719ca", "message": "This should not break my build", "committedDate": "2020-10-28T10:02:50Z", "type": "commit"}]}