{"pr_number": 5057, "pr_title": "[TimeLock corruption detection] | Timestamp corruption checks", "pr_createdAt": "2020-10-20T15:09:10Z", "pr_url": "https://github.com/palantir/atlasdb/pull/5057", "timeline": [{"oid": "cd3a6bc64312db14acd4de45d156a05ed82bed71", "url": "https://github.com/palantir/atlasdb/commit/cd3a6bc64312db14acd4de45d156a05ed82bed71", "message": "Minor cleanup", "committedDate": "2020-10-20T15:19:27Z", "type": "forcePushed"}, {"oid": "ce6197e3e8e44f7000bbf8f4cbd647bd86294242", "url": "https://github.com/palantir/atlasdb/commit/ce6197e3e8e44f7000bbf8f4cbd647bd86294242", "message": "WIP", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "2aacd4c61abb7e955bf659b949eb69ca0e4fad6f", "url": "https://github.com/palantir/atlasdb/commit/2aacd4c61abb7e955bf659b949eb69ca0e4fad6f", "message": "WIP", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "aa56b4c9490c001675420f46b547cbc748959718", "url": "https://github.com/palantir/atlasdb/commit/aa56b4c9490c001675420f46b547cbc748959718", "message": "Minor cleanup", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "ed0360860d2a36ed5fbf9771e077508d8c8c034b", "url": "https://github.com/palantir/atlasdb/commit/ed0360860d2a36ed5fbf9771e077508d8c8c034b", "message": "Remove redundant changes", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "6275567d73edd1c703728409673d336d73201c00", "url": "https://github.com/palantir/atlasdb/commit/6275567d73edd1c703728409673d336d73201c00", "message": "Minor refactor", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "cfeb521e3c8671c1b078663570bedde6b5ce5f32", "url": "https://github.com/palantir/atlasdb/commit/cfeb521e3c8671c1b078663570bedde6b5ce5f32", "message": "Refine", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "9625b497fed5eacb49e6bac482ab5437921a0759", "url": "https://github.com/palantir/atlasdb/commit/9625b497fed5eacb49e6bac482ab5437921a0759", "message": "Fix", "committedDate": "2020-10-21T13:10:37Z", "type": "commit"}, {"oid": "9625b497fed5eacb49e6bac482ab5437921a0759", "url": "https://github.com/palantir/atlasdb/commit/9625b497fed5eacb49e6bac482ab5437921a0759", "message": "Fix", "committedDate": "2020-10-21T13:10:37Z", "type": "forcePushed"}, {"oid": "0174e6e7ca771943ba587d1f35485d98eda28f95", "url": "https://github.com/palantir/atlasdb/commit/0174e6e7ca771943ba587d1f35485d98eda28f95", "message": "Fix test build", "committedDate": "2020-10-21T13:24:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwMjMwMQ==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509402301", "bodyText": "Let's not return boolean: would be good to have some kind of wrapper type", "author": "jeremyk-91", "createdAt": "2020-10-21T15:49:31Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.PaxosAcceptorData;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+\n+public final class HistoryAnalyzer {\n+\n+    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {", "originalCommit": "0174e6e7ca771943ba587d1f35485d98eda28f95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\nindex 8fa0429778..26121f9f75 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n\n@@ -16,65 +16,74 @@\n \n package com.palantir.timelock.corruption.detection;\n \n-\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Iterables;\n import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.logsafe.Preconditions;\n import com.palantir.paxos.PaxosValue;\n import com.palantir.timelock.history.PaxosAcceptorData;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n public final class HistoryAnalyzer {\n \n-    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return verifyLearnersHaveLearnedSameValues(history)\n-        && verifyLearnedValueWasAcceptedByQuorum(history)\n-        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    public static List<CorruptionStatus> corruptionStateForNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return Stream.of(learnersHaveLearnedSameValues(history),\n+                learnedValueWasAcceptedByQuorum(history),\n+                learnedValueIsGreatestAcceptedValue(history))\n+                .filter(status -> status != CorruptionStatus.HEALTHY)\n+                .collect(Collectors.toList());\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n                 .allMatch(seq -> {\n                     Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n                     return learnedValuesForRound.size() <= 1;\n-                });\n+                }) ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         int quorum = getQuorumSize(records);\n \n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> {\n-                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n-                    if(!optionalLearnedValue.isPresent()) {\n-                        return true;\n-                    }\n-\n-                    PaxosValue learnedValue = optionalLearnedValue.get();\n-                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n-                    return acceptedValues.size() >= quorum;\n-                });\n+                .allMatch(seq -> isLearnedValueAcceptecByQuorum(records, quorum, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.VALUE_LEARNED_WITHOUT_QUORUM;\n+    }\n+\n+    private static boolean isLearnedValueAcceptecByQuorum(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records,\n+            int quorum, Long seq) {\n+        Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+        if (!optionalLearnedValue.isPresent()) {\n+            return true;\n+        }\n+\n+        PaxosValue learnedValue = optionalLearnedValue.get();\n+        List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+        return acceptedValues.size() >= quorum;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq));\n+                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     private static boolean learnedValueIsGreatestAcceptedValue(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwMzY5MQ==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509403691", "bodyText": "I'd extract a method for this. Depending on taste, you could also process the stream more aggressively and/or use keyed-streams", "author": "jeremyk-91", "createdAt": "2020-10-21T15:51:17Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.PaxosAcceptorData;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+\n+public final class HistoryAnalyzer {\n+\n+    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return verifyLearnersHaveLearnedSameValues(history)\n+        && verifyLearnedValueWasAcceptedByQuorum(history)\n+        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> {\n+                    Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n+                    return learnedValuesForRound.size() <= 1;\n+                });\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        int quorum = getQuorumSize(records);\n+\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> {\n+                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+                    if(!optionalLearnedValue.isPresent()) {\n+                        return true;\n+                    }\n+\n+                    PaxosValue learnedValue = optionalLearnedValue.get();\n+                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+                    return acceptedValues.size() >= quorum;", "originalCommit": "0174e6e7ca771943ba587d1f35485d98eda28f95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\nindex 8fa0429778..26121f9f75 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n\n@@ -16,65 +16,74 @@\n \n package com.palantir.timelock.corruption.detection;\n \n-\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Iterables;\n import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.logsafe.Preconditions;\n import com.palantir.paxos.PaxosValue;\n import com.palantir.timelock.history.PaxosAcceptorData;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n public final class HistoryAnalyzer {\n \n-    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return verifyLearnersHaveLearnedSameValues(history)\n-        && verifyLearnedValueWasAcceptedByQuorum(history)\n-        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    public static List<CorruptionStatus> corruptionStateForNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return Stream.of(learnersHaveLearnedSameValues(history),\n+                learnedValueWasAcceptedByQuorum(history),\n+                learnedValueIsGreatestAcceptedValue(history))\n+                .filter(status -> status != CorruptionStatus.HEALTHY)\n+                .collect(Collectors.toList());\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n                 .allMatch(seq -> {\n                     Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n                     return learnedValuesForRound.size() <= 1;\n-                });\n+                }) ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         int quorum = getQuorumSize(records);\n \n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> {\n-                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n-                    if(!optionalLearnedValue.isPresent()) {\n-                        return true;\n-                    }\n-\n-                    PaxosValue learnedValue = optionalLearnedValue.get();\n-                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n-                    return acceptedValues.size() >= quorum;\n-                });\n+                .allMatch(seq -> isLearnedValueAcceptecByQuorum(records, quorum, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.VALUE_LEARNED_WITHOUT_QUORUM;\n+    }\n+\n+    private static boolean isLearnedValueAcceptecByQuorum(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records,\n+            int quorum, Long seq) {\n+        Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+        if (!optionalLearnedValue.isPresent()) {\n+            return true;\n+        }\n+\n+        PaxosValue learnedValue = optionalLearnedValue.get();\n+        List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+        return acceptedValues.size() >= quorum;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq));\n+                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     private static boolean learnedValueIsGreatestAcceptedValue(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwMzk3OQ==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509403979", "bodyText": "if this is a bug in atlas code we should probably throw a SafeIllegalStateException", "author": "jeremyk-91", "createdAt": "2020-10-21T15:51:41Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.PaxosAcceptorData;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+\n+public final class HistoryAnalyzer {\n+\n+    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return verifyLearnersHaveLearnedSameValues(history)\n+        && verifyLearnedValueWasAcceptedByQuorum(history)\n+        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> {\n+                    Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n+                    return learnedValuesForRound.size() <= 1;\n+                });\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        int quorum = getQuorumSize(records);\n+\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> {\n+                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+                    if(!optionalLearnedValue.isPresent()) {\n+                        return true;\n+                    }\n+\n+                    PaxosValue learnedValue = optionalLearnedValue.get();\n+                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+                    return acceptedValues.size() >= quorum;\n+                });\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq));\n+    }\n+\n+    private static boolean learnedValueIsGreatestAcceptedValue(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records, Long seq) {\n+        byte[] learnedValueData = getPaxosValueData(getLearnedValue(records, seq));\n+        if (learnedValueData == null) {\n+            return true;\n+        }\n+\n+        byte[] greatestAcceptedValueData = getPaxosValueData(getGreatestAcceptedValueAtSequence(records, seq));\n+        if (greatestAcceptedValueData == null) {\n+            // should not reach here\n+            return false;", "originalCommit": "0174e6e7ca771943ba587d1f35485d98eda28f95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\nindex 8fa0429778..26121f9f75 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n\n@@ -16,65 +16,74 @@\n \n package com.palantir.timelock.corruption.detection;\n \n-\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Iterables;\n import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.logsafe.Preconditions;\n import com.palantir.paxos.PaxosValue;\n import com.palantir.timelock.history.PaxosAcceptorData;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n public final class HistoryAnalyzer {\n \n-    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return verifyLearnersHaveLearnedSameValues(history)\n-        && verifyLearnedValueWasAcceptedByQuorum(history)\n-        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    public static List<CorruptionStatus> corruptionStateForNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return Stream.of(learnersHaveLearnedSameValues(history),\n+                learnedValueWasAcceptedByQuorum(history),\n+                learnedValueIsGreatestAcceptedValue(history))\n+                .filter(status -> status != CorruptionStatus.HEALTHY)\n+                .collect(Collectors.toList());\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n                 .allMatch(seq -> {\n                     Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n                     return learnedValuesForRound.size() <= 1;\n-                });\n+                }) ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         int quorum = getQuorumSize(records);\n \n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> {\n-                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n-                    if(!optionalLearnedValue.isPresent()) {\n-                        return true;\n-                    }\n-\n-                    PaxosValue learnedValue = optionalLearnedValue.get();\n-                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n-                    return acceptedValues.size() >= quorum;\n-                });\n+                .allMatch(seq -> isLearnedValueAcceptecByQuorum(records, quorum, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.VALUE_LEARNED_WITHOUT_QUORUM;\n+    }\n+\n+    private static boolean isLearnedValueAcceptecByQuorum(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records,\n+            int quorum, Long seq) {\n+        Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+        if (!optionalLearnedValue.isPresent()) {\n+            return true;\n+        }\n+\n+        PaxosValue learnedValue = optionalLearnedValue.get();\n+        List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+        return acceptedValues.size() >= quorum;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq));\n+                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     private static boolean learnedValueIsGreatestAcceptedValue(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwNTkyMg==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509405922", "bodyText": "Let's have a comment here that this should only be used for timestamp bound checks: this would behave strangely if we did it on leader election based checks, because there is a semantic difference between null and no agreement because paxos phase two didn't happen", "author": "jeremyk-91", "createdAt": "2020-10-21T15:54:18Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Iterables;\n+import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.timelock.history.PaxosAcceptorData;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+\n+public final class HistoryAnalyzer {\n+\n+    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return verifyLearnersHaveLearnedSameValues(history)\n+        && verifyLearnedValueWasAcceptedByQuorum(history)\n+        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> {\n+                    Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n+                    return learnedValuesForRound.size() <= 1;\n+                });\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        int quorum = getQuorumSize(records);\n+\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> {\n+                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+                    if(!optionalLearnedValue.isPresent()) {\n+                        return true;\n+                    }\n+\n+                    PaxosValue learnedValue = optionalLearnedValue.get();\n+                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+                    return acceptedValues.size() >= quorum;\n+                });\n+    }\n+\n+    @VisibleForTesting\n+    static boolean verifyLearnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        return history.getAllSequenceNumbers()\n+                .stream()\n+                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq));\n+    }\n+\n+    private static boolean learnedValueIsGreatestAcceptedValue(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records, Long seq) {\n+        byte[] learnedValueData = getPaxosValueData(getLearnedValue(records, seq));\n+        if (learnedValueData == null) {\n+            return true;\n+        }\n+\n+        byte[] greatestAcceptedValueData = getPaxosValueData(getGreatestAcceptedValueAtSequence(records, seq));\n+        if (greatestAcceptedValueData == null) {\n+            // should not reach here\n+            return false;\n+        }\n+        return PtBytes.toLong(greatestAcceptedValueData) <= PtBytes.toLong(learnedValueData);\n+    }\n+\n+    private static Optional<PaxosValue> getLearnedValue(List<ConsolidatedLearnerAndAcceptorRecord> recordList, Long seq) {\n+        Set<PaxosValue> values = getLearnedValuesForRound(recordList, seq);\n+        return values.isEmpty() ? Optional.empty() : Optional.of(Iterables.getOnlyElement(values));\n+    }\n+\n+    private static Set<PaxosValue> getLearnedValuesForRound(List<ConsolidatedLearnerAndAcceptorRecord> recordList,\n+            Long seq) {\n+        return recordList.stream()\n+                .map(consolidatedLearnerAndAcceptorRecord ->\n+                        consolidatedLearnerAndAcceptorRecord.get(seq).learnedValue())\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private static int getQuorumSize(List<ConsolidatedLearnerAndAcceptorRecord> records) {\n+        return records.size() / 2 + 1;\n+    }\n+\n+    private static List<PaxosValue> getAcceptedValues(List<ConsolidatedLearnerAndAcceptorRecord> records, Long seq,\n+            PaxosValue learnedValue) {\n+        return records.stream()\n+                .map(record -> record.get(seq)\n+                        .acceptedValue()\n+                        .map(PaxosAcceptorData::getLastAcceptedValue)\n+                        .orElseGet(Optional::empty))\n+                .filter(optionalPaxosValue ->\n+                        optionalPaxosValue.isPresent() && optionalPaxosValue.get().equals(learnedValue))\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static Optional<PaxosValue> getGreatestAcceptedValueAtSequence(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records, long seq) {\n+        return records.stream()\n+                .map(record -> record.get(seq)\n+                        .acceptedValue()\n+                        .map(PaxosAcceptorData::getLastAcceptedValue)\n+                        .orElseGet(Optional::empty))\n+                .filter(paxosValue -> getPaxosValueData(paxosValue) != null)\n+                .map(Optional::get)\n+                .max(Comparator.comparingLong(paxosValue ->  PtBytes.toLong(paxosValue.getData())));\n+    }\n+\n+\n+    private static byte[] getPaxosValueData(Optional<PaxosValue> learnedValue) {\n+        return learnedValue.map(PaxosValue::getData).orElse(null);", "originalCommit": "0174e6e7ca771943ba587d1f35485d98eda28f95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\nindex 8fa0429778..26121f9f75 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n\n@@ -16,65 +16,74 @@\n \n package com.palantir.timelock.corruption.detection;\n \n-\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Iterables;\n import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.logsafe.Preconditions;\n import com.palantir.paxos.PaxosValue;\n import com.palantir.timelock.history.PaxosAcceptorData;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n public final class HistoryAnalyzer {\n \n-    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return verifyLearnersHaveLearnedSameValues(history)\n-        && verifyLearnedValueWasAcceptedByQuorum(history)\n-        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    public static List<CorruptionStatus> corruptionStateForNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return Stream.of(learnersHaveLearnedSameValues(history),\n+                learnedValueWasAcceptedByQuorum(history),\n+                learnedValueIsGreatestAcceptedValue(history))\n+                .filter(status -> status != CorruptionStatus.HEALTHY)\n+                .collect(Collectors.toList());\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n                 .allMatch(seq -> {\n                     Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n                     return learnedValuesForRound.size() <= 1;\n-                });\n+                }) ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         int quorum = getQuorumSize(records);\n \n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> {\n-                    Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n-                    if(!optionalLearnedValue.isPresent()) {\n-                        return true;\n-                    }\n-\n-                    PaxosValue learnedValue = optionalLearnedValue.get();\n-                    List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n-                    return acceptedValues.size() >= quorum;\n-                });\n+                .allMatch(seq -> isLearnedValueAcceptecByQuorum(records, quorum, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.VALUE_LEARNED_WITHOUT_QUORUM;\n+    }\n+\n+    private static boolean isLearnedValueAcceptecByQuorum(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records,\n+            int quorum, Long seq) {\n+        Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n+        if (!optionalLearnedValue.isPresent()) {\n+            return true;\n+        }\n+\n+        PaxosValue learnedValue = optionalLearnedValue.get();\n+        List<PaxosValue> acceptedValues = getAcceptedValues(records, seq, learnedValue);\n+        return acceptedValues.size() >= quorum;\n     }\n \n     @VisibleForTesting\n-    static boolean verifyLearnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionStatus learnedValueIsGreatestAcceptedValue(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         return history.getAllSequenceNumbers()\n                 .stream()\n-                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq));\n+                .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq))\n+                ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n     }\n \n     private static boolean learnedValueIsGreatestAcceptedValue(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQwNjI3Nw==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509406277", "bodyText": "\ud83d\ude05", "author": "jeremyk-91", "createdAt": "2020-10-21T15:54:47Z", "path": "timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.timelock.corruption.detection;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.sql.DataSource;\n+\n+import org.immutables.value.Value;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.palantir.paxos.Client;\n+import com.palantir.paxos.ImmutableNamespaceAndUseCase;\n+import com.palantir.paxos.PaxosAcceptorState;\n+import com.palantir.paxos.PaxosStateLog;\n+import com.palantir.paxos.PaxosValue;\n+import com.palantir.paxos.SqliteConnections;\n+import com.palantir.paxos.SqlitePaxosStateLog;\n+import com.palantir.timelock.history.LocalHistoryLoader;\n+import com.palantir.timelock.history.PaxosLogHistoryProvider;\n+import com.palantir.timelock.history.TimeLockPaxosHistoryProvider;\n+import com.palantir.timelock.history.models.AcceptorUseCase;\n+import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n+import com.palantir.timelock.history.models.LearnerUseCase;\n+import com.palantir.timelock.history.remote.TimeLockPaxosHistoryProviderResource;\n+import com.palantir.timelock.history.sqlite.SqlitePaxosStateLogHistory;\n+import com.palantir.timelock.history.utils.PaxosSerializationTestUtils;\n+\n+public class HistoryAnalyzerTest {\n+    @Rule\n+    public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+    private static final Client CLIENT = Client.of(\"client\");\n+    private static final String USE_CASE = \"useCase\";\n+    private static final String USE_CASE_LEARNER = LearnerUseCase.createLearnerUseCase(USE_CASE).value();\n+    private static final String USE_CASE_ACCEPTOR = AcceptorUseCase.createAcceptorUseCase(USE_CASE).value();\n+\n+    private StateLogComponents localStateLogComponents;\n+    private List<StateLogComponents> remoteStateLogComponents;\n+    PaxosLogHistoryProvider paxosLogHistoryProvider;\n+\n+    @Before\n+    public void setup() throws IOException {\n+        localStateLogComponents = createShitForServer(\"randomFile1\");", "originalCommit": "0174e6e7ca771943ba587d1f35485d98eda28f95", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "chunk": "diff --git a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\nindex aac7743014..094b6fa79a 100644\n--- a/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n+++ b/timelock-corruption-detection/src/test/java/com/palantir/timelock/corruption/detection/HistoryAnalyzerTest.java\n\n@@ -66,10 +66,10 @@ public class HistoryAnalyzerTest {\n \n     @Before\n     public void setup() throws IOException {\n-        localStateLogComponents = createShitForServer(\"randomFile1\");\n+        localStateLogComponents = createLogComponentsForServer(\"randomFile1\");\n         remoteStateLogComponents = ImmutableList.of(\n-                createShitForServer(\"randomFile2\"),\n-                createShitForServer(\"randomFile3\"));\n+                createLogComponentsForServer(\"randomFile2\"),\n+                createLogComponentsForServer(\"randomFile3\"));\n         paxosLogHistoryProvider = new PaxosLogHistoryProvider(localStateLogComponents.dataSource(),\n                 remoteStateLogComponents.stream()\n                         .map(StateLogComponents::serverHistoryProvider)\n"}}, {"oid": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "url": "https://github.com/palantir/atlasdb/commit/267c859a3440507b06b3a6856f0f5cfc132f7c6d", "message": "Address comments - 1", "committedDate": "2020-10-21T16:07:35Z", "type": "commit"}, {"oid": "6b03c1e6872f3c859bd0cfdf3a7f71f2835370ee", "url": "https://github.com/palantir/atlasdb/commit/6b03c1e6872f3c859bd0cfdf3a7f71f2835370ee", "message": "Fix build", "committedDate": "2020-10-21T16:13:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyMjYxNg==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509422616", "bodyText": "This is empty if everyone is healthy. Is that by design? (If so that's fine, just make sure it is!)", "author": "jeremyk-91", "createdAt": "2020-10-21T16:17:43Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java", "diffHunk": "@@ -16,65 +16,74 @@\n \n package com.palantir.timelock.corruption.detection;\n \n-\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.collect.Iterables;\n import com.palantir.atlasdb.encoding.PtBytes;\n+import com.palantir.logsafe.Preconditions;\n import com.palantir.paxos.PaxosValue;\n import com.palantir.timelock.history.PaxosAcceptorData;\n import com.palantir.timelock.history.models.CompletePaxosHistoryForNamespaceAndUseCase;\n import com.palantir.timelock.history.models.ConsolidatedLearnerAndAcceptorRecord;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n public final class HistoryAnalyzer {\n \n-    public static boolean runCorruptionCheckOnHistory(CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return verifyLearnersHaveLearnedSameValues(history)\n-        && verifyLearnedValueWasAcceptedByQuorum(history)\n-        && verifyLearnedValueIsGreatestAcceptedValue(history);\n+    public static List<CorruptionStatus> corruptionStateForNamespaceAndUseCase(\n+            CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        return Stream.of(learnersHaveLearnedSameValues(history),\n+                learnedValueWasAcceptedByQuorum(history),\n+                learnedValueIsGreatestAcceptedValue(history))\n+                .filter(status -> status != CorruptionStatus.HEALTHY)\n+                .collect(Collectors.toList());", "originalCommit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MjY4Mw==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509442683", "bodyText": "Yes, as of now, the plan is to only react to health check violations. So, the list for healthy namespaceAndUse will be empty.", "author": "sudiksha27", "createdAt": "2020-10-21T16:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyMjYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "e447559bd5546a17f202d0b0138227904d29878f", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\nindex 26121f9f75..b119b6ba13 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/HistoryAnalyzer.java\n\n@@ -32,41 +32,55 @@ import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n public final class HistoryAnalyzer {\n+    private HistoryAnalyzer() {\n+        // do not create instance of this class\n+    }\n \n-    public static List<CorruptionStatus> corruptionStateForNamespaceAndUseCase(\n+    @VisibleForTesting\n+    static List<CorruptionCheckViolation> violatedCorruptionChecksForNamespaceAndUseCase(\n             CompletePaxosHistoryForNamespaceAndUseCase history) {\n-        return Stream.of(learnersHaveLearnedSameValues(history),\n-                learnedValueWasAcceptedByQuorum(history),\n-                learnedValueIsGreatestAcceptedValue(history))\n-                .filter(status -> status != CorruptionStatus.HEALTHY)\n+        return Stream.of(\n+                        divergedLearners(history),\n+                        learnedValueWithoutQuorum(history),\n+                        greatestAcceptedValueNotLearned(history))\n+                .filter(status -> status != CorruptionCheckViolation.HEALTHY)\n                 .collect(Collectors.toList());\n     }\n \n     @VisibleForTesting\n-    static CorruptionStatus learnersHaveLearnedSameValues(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionCheckViolation divergedLearners(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n-        return history.getAllSequenceNumbers()\n-                .stream()\n-                .allMatch(seq -> {\n+        return history.getAllSequenceNumbers().stream().allMatch(seq -> {\n                     Set<PaxosValue> learnedValuesForRound = getLearnedValuesForRound(records, seq);\n                     return learnedValuesForRound.size() <= 1;\n-                }) ? CorruptionStatus.HEALTHY : CorruptionStatus.DIVERGED_LEARNERS;\n+                })\n+                ? CorruptionCheckViolation.HEALTHY\n+                : CorruptionCheckViolation.DIVERGED_LEARNERS;\n     }\n \n     @VisibleForTesting\n-    static CorruptionStatus learnedValueWasAcceptedByQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n+    static CorruptionCheckViolation learnedValueWithoutQuorum(CompletePaxosHistoryForNamespaceAndUseCase history) {\n         List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n         int quorum = getQuorumSize(records);\n \n-        return history.getAllSequenceNumbers()\n-                .stream()\n-                .allMatch(seq -> isLearnedValueAcceptecByQuorum(records, quorum, seq))\n-                ? CorruptionStatus.HEALTHY : CorruptionStatus.VALUE_LEARNED_WITHOUT_QUORUM;\n+        return history.getAllSequenceNumbers().stream()\n+                        .allMatch(seq -> isLearnedValueAcceptedByQuorum(records, quorum, seq))\n+                ? CorruptionCheckViolation.HEALTHY\n+                : CorruptionCheckViolation.VALUE_LEARNED_WITHOUT_QUORUM;\n+    }\n+\n+    @VisibleForTesting\n+    static CorruptionCheckViolation greatestAcceptedValueNotLearned(\n+            CompletePaxosHistoryForNamespaceAndUseCase history) {\n+        List<ConsolidatedLearnerAndAcceptorRecord> records = history.localAndRemoteLearnerAndAcceptorRecords();\n+        return history.getAllSequenceNumbers().stream()\n+                        .allMatch(seq -> learnedValueIsGreatestAcceptedValue(records, seq))\n+                ? CorruptionCheckViolation.HEALTHY\n+                : CorruptionCheckViolation.ACCEPTED_VALUE_GREATER_THAN_LEARNED;\n     }\n \n-    private static boolean isLearnedValueAcceptecByQuorum(\n-            List<ConsolidatedLearnerAndAcceptorRecord> records,\n-            int quorum, Long seq) {\n+    private static boolean isLearnedValueAcceptedByQuorum(\n+            List<ConsolidatedLearnerAndAcceptorRecord> records, int quorum, Long seq) {\n         Optional<PaxosValue> optionalLearnedValue = getLearnedValue(records, seq);\n         if (!optionalLearnedValue.isPresent()) {\n             return true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQyNDYwOA==", "url": "https://github.com/palantir/atlasdb/pull/5057#discussion_r509424608", "bodyText": "The first 4 are one layer and the bottom 2 are another. I'd suggest having maybe a CorruptionCheckStatus that is one of HEALTHY, DIVERGED_LEARNERS ... and then a CorruptionStatus (this class) just has HEALTHY and the two DEFINITIVE_CORRUPTION ones", "author": "jeremyk-91", "createdAt": "2020-10-21T16:20:40Z", "path": "timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionStatus.java", "diffHunk": "@@ -17,16 +17,26 @@\n package com.palantir.timelock.corruption.detection;\n \n public enum CorruptionStatus {\n-    HEALTHY(false),\n-    CORRUPTION(true);\n+    HEALTHY(false, false),\n+    DIVERGED_LEARNERS(true, false), // this is false for now\n+    VALUE_LEARNED_WITHOUT_QUORUM(true, false),\n+    ACCEPTED_VALUE_GREATER_THAN_LEARNED(true, false),\n+    DEFINITIVE_CORRUPTION_DETECTED_BY_LOCAL(true, true),\n+    DEFINITIVE_CORRUPTION_DETECTED_BY_REMOTE(true, true);", "originalCommit": "267c859a3440507b06b3a6856f0f5cfc132f7c6d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e447559bd5546a17f202d0b0138227904d29878f", "chunk": "diff --git a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionStatus.java b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionStatus.java\nindex cff34a99a9..f3c324978b 100644\n--- a/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionStatus.java\n+++ b/timelock-corruption-detection/src/main/java/com/palantir/timelock/corruption/detection/CorruptionStatus.java\n\n@@ -17,26 +17,17 @@\n package com.palantir.timelock.corruption.detection;\n \n public enum CorruptionStatus {\n-    HEALTHY(false, false),\n-    DIVERGED_LEARNERS(true, false), // this is false for now\n-    VALUE_LEARNED_WITHOUT_QUORUM(true, false),\n-    ACCEPTED_VALUE_GREATER_THAN_LEARNED(true, false),\n-    DEFINITIVE_CORRUPTION_DETECTED_BY_LOCAL(true, true),\n-    DEFINITIVE_CORRUPTION_DETECTED_BY_REMOTE(true, true);\n+    HEALTHY(false),\n+    DEFINITIVE_CORRUPTION_DETECTED_BY_LOCAL(true),\n+    DEFINITIVE_CORRUPTION_DETECTED_BY_REMOTE(true);\n \n-    private final boolean shouldRaiseErrorAlert;\n     private final boolean shouldShootTimeLock;\n \n-    CorruptionStatus(boolean shouldRaiseErrorAlert, boolean shouldShootTimeLock) {\n-        this.shouldRaiseErrorAlert = shouldRaiseErrorAlert;\n+    CorruptionStatus(boolean shouldShootTimeLock) {\n         this.shouldShootTimeLock = shouldShootTimeLock;\n     }\n \n     public boolean shootTimeLock() {\n         return shouldShootTimeLock;\n     }\n-\n-    public boolean raiseErrorAlert() {\n-        return shouldRaiseErrorAlert;\n-    }\n }\n"}}, {"oid": "e447559bd5546a17f202d0b0138227904d29878f", "url": "https://github.com/palantir/atlasdb/commit/e447559bd5546a17f202d0b0138227904d29878f", "message": "Address comments", "committedDate": "2020-10-21T16:32:59Z", "type": "commit"}, {"oid": "6f961e5ea886a15822d0bcc47e0c940aaa1e5122", "url": "https://github.com/palantir/atlasdb/commit/6f961e5ea886a15822d0bcc47e0c940aaa1e5122", "message": "Refactor", "committedDate": "2020-10-21T16:36:09Z", "type": "commit"}, {"oid": "bc5da81bc43d5ca56b72da5701a205538bbf58d9", "url": "https://github.com/palantir/atlasdb/commit/bc5da81bc43d5ca56b72da5701a205538bbf58d9", "message": "Minor", "committedDate": "2020-10-21T16:37:17Z", "type": "commit"}]}