{"pr_number": 4735, "pr_title": "[PaxosLog] VerifyingPaxosStateLog", "pr_createdAt": "2020-04-27T13:49:43Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4735", "timeline": [{"oid": "6f5421d2fa3d0916419fadbfc3c34ac3f2c26d5f", "url": "https://github.com/palantir/atlasdb/commit/6f5421d2fa3d0916419fadbfc3c34ac3f2c26d5f", "message": "sqlite", "committedDate": "2020-04-20T14:01:50Z", "type": "commit"}, {"oid": "86033f658b5d4a0f152ffc4b5ffb11acc75a401d", "url": "https://github.com/palantir/atlasdb/commit/86033f658b5d4a0f152ffc4b5ffb11acc75a401d", "message": "Checkpoint", "committedDate": "2020-04-20T16:49:50Z", "type": "commit"}, {"oid": "51b97332a9bd115d6493103d1a51ef7478d802ea", "url": "https://github.com/palantir/atlasdb/commit/51b97332a9bd115d6493103d1a51ef7478d802ea", "message": "Clean up a bit and add tests", "committedDate": "2020-04-21T10:43:26Z", "type": "commit"}, {"oid": "2d1cb9a05eed2aeac89ab08fa9bdbdc20ba110a0", "url": "https://github.com/palantir/atlasdb/commit/2d1cb9a05eed2aeac89ab08fa9bdbdc20ba110a0", "message": "Improve test", "committedDate": "2020-04-21T12:11:25Z", "type": "commit"}, {"oid": "b1bff7c707b6519938cd5d4c0131dc4e5cfba4eb", "url": "https://github.com/palantir/atlasdb/commit/b1bff7c707b6519938cd5d4c0131dc4e5cfba4eb", "message": "MigrationPaxosStateLog and part of tests", "committedDate": "2020-04-21T13:40:41Z", "type": "commit"}, {"oid": "46bf4b15856aaece04d9806ea54faf150e3a1391", "url": "https://github.com/palantir/atlasdb/commit/46bf4b15856aaece04d9806ea54faf150e3a1391", "message": "Finish tests and be less bad", "committedDate": "2020-04-21T16:43:36Z", "type": "commit"}, {"oid": "9dd3d4ad19248854d2a037dbf8617ec776130df6", "url": "https://github.com/palantir/atlasdb/commit/9dd3d4ad19248854d2a037dbf8617ec776130df6", "message": "Merge with develop", "committedDate": "2020-04-27T12:35:59Z", "type": "commit"}, {"oid": "50056d89edf91394f6babee09094c35293d3eb38", "url": "https://github.com/palantir/atlasdb/commit/50056d89edf91394f6babee09094c35293d3eb38", "message": "Migration -> Verifying", "committedDate": "2020-04-27T13:45:02Z", "type": "commit"}, {"oid": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "url": "https://github.com/palantir/atlasdb/commit/0dcd2c47fc2b175b92a0affb9b978718a952d8af", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into psl/migration-log", "committedDate": "2020-04-27T13:45:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NjkwNA==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415976904", "bodyText": "discussed: This needs to be resilient to null results.", "author": "jeremyk-91", "createdAt": "2020-04-27T16:46:52Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        lock.readLock().lock();\n+        try {\n+            byte[] result = currentLog.readRound(seq);\n+            byte[] experimentalResult = experimentalLog.readRound(seq);\n+            if (!Arrays.equals(result, experimentalResult)) {\n+                log.error(\"Mismatch in reading round for sequence number {} between legacy and current \"\n+                        + \"implementations. Legacy result {}, current result {}.\",\n+                        SafeArg.of(\"sequence\", seq),\n+                        UnsafeArg.of(\"legacy\", hydrator.hydrateFromBytes(result)),\n+                        UnsafeArg.of(\"current\", hydrator.hydrateFromBytes(experimentalResult)));", "originalCommit": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\nindex d5f3b77848..7d4726fe03 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n\n@@ -18,6 +18,7 @@ package com.palantir.paxos;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Objects;\n import java.util.concurrent.locks.ReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.function.Function;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3Nzc2Nw==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415977767", "bodyText": "This is a bit nasty, but I'd prefer\nlock();\ntry {\n  current.write(seq, round);\n  try {\n    experiment.write(seq, round);\n  } catch (RuntimeException ex) {\n    log.warn(\"I wrote to current but not experimental, please be careful with future errors for sequence number {}\", SafeArg.of(seq), ex);\n     // intentionally succeed, because we don't want to degrade service\n  }\n} finally {\n  unlock();\n}", "author": "jeremyk-91", "createdAt": "2020-04-27T16:48:09Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {", "originalCommit": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\nindex d5f3b77848..7d4726fe03 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n\n@@ -18,6 +18,7 @@ package com.palantir.paxos;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Objects;\n import java.util.concurrent.locks.ReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.function.Function;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3OTIwNg==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415979206", "bodyText": "similar to above: should we try to maintain service if the experimental log throws stuff?", "author": "jeremyk-91", "createdAt": "2020-04-27T16:50:03Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        lock.readLock().lock();\n+        try {\n+            byte[] result = currentLog.readRound(seq);\n+            byte[] experimentalResult = experimentalLog.readRound(seq);", "originalCommit": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\nindex d5f3b77848..7d4726fe03 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n\n@@ -18,6 +18,7 @@ package com.palantir.paxos;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Objects;\n import java.util.concurrent.locks.ReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.function.Function;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3OTk2OA==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415979968", "bodyText": "and here for experimental protection", "author": "jeremyk-91", "createdAt": "2020-04-27T16:50:59Z", "path": "leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.Function;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.palantir.common.persist.Persistable;\n+import com.palantir.logsafe.SafeArg;\n+import com.palantir.logsafe.UnsafeArg;\n+\n+/**\n+ * This implementation of {@link PaxosStateLog} uses one delegate as the source of truth, but also delegates all calls\n+ * to the experimental delegate and verifies consistency.\n+ *\n+ * NOTE: while the read write lock guarantees atomicity in the absence of failures, the experimental log could still\n+ * get out of sync with the source of truth if a write operation is performed on only one of the logs. Write operations\n+ * have therefore been implemented to allow for simple re-hydration of the experimental log -- writes are performed on\n+ * the current log first, while truncates are performed on the experimental log first.\n+ */\n+public final class VerifyingPaxosStateLog<V extends Persistable & Versionable> implements PaxosStateLog<V> {\n+    private static final Logger log = LoggerFactory.getLogger(VerifyingPaxosStateLog.class);\n+\n+    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);\n+    private final PaxosStateLog<V> currentLog;\n+    private final PaxosStateLog<V> experimentalLog;\n+    private final Persistable.Hydrator<V> hydrator;\n+\n+    public VerifyingPaxosStateLog(Settings<V> settings) {\n+        this.currentLog = settings.currentLog();\n+        this.experimentalLog = settings.experimentalLog();\n+        this.hydrator = settings.hydrator();\n+    }\n+\n+    @Override\n+    public void writeRound(long seq, V round) {\n+        lock.writeLock().lock();\n+        try {\n+            currentLog.writeRound(seq, round);\n+            experimentalLog.writeRound(seq, round);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public byte[] readRound(long seq) throws IOException {\n+        lock.readLock().lock();\n+        try {\n+            byte[] result = currentLog.readRound(seq);\n+            byte[] experimentalResult = experimentalLog.readRound(seq);\n+            if (!Arrays.equals(result, experimentalResult)) {\n+                log.error(\"Mismatch in reading round for sequence number {} between legacy and current \"\n+                        + \"implementations. Legacy result {}, current result {}.\",\n+                        SafeArg.of(\"sequence\", seq),\n+                        UnsafeArg.of(\"legacy\", hydrator.hydrateFromBytes(result)),\n+                        UnsafeArg.of(\"current\", hydrator.hydrateFromBytes(experimentalResult)));\n+            }\n+            return result;\n+        } finally {\n+            lock.readLock().unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long getLeastLogEntry() {\n+        return getExtremeLogEntry(PaxosStateLog::getLeastLogEntry);\n+    }\n+\n+    @Override\n+    public long getGreatestLogEntry() {\n+        return getExtremeLogEntry(PaxosStateLog::getGreatestLogEntry);\n+    }\n+\n+    @Override\n+    public void truncate(long toDeleteInclusive) {\n+        lock.writeLock().lock();\n+        try {\n+            experimentalLog.truncate(toDeleteInclusive);\n+            currentLog.truncate(toDeleteInclusive);\n+        } finally {\n+            lock.writeLock().unlock();\n+        }\n+    }\n+\n+    private long getExtremeLogEntry(Function<PaxosStateLog<V>, Long> extractor) {\n+        lock.readLock().lock();\n+        try {\n+            long result = extractor.apply(currentLog);\n+            long experimentalResult = extractor.apply(experimentalLog);", "originalCommit": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "chunk": "diff --git a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\nindex d5f3b77848..7d4726fe03 100644\n--- a/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n+++ b/leader-election-impl/src/main/java/com/palantir/paxos/VerifyingPaxosStateLog.java\n\n@@ -18,6 +18,7 @@ package com.palantir.paxos;\n \n import java.io.IOException;\n import java.util.Arrays;\n+import java.util.Objects;\n import java.util.concurrent.locks.ReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.function.Function;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MTIyMA==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415981220", "bodyText": "Non-blocking: Consider InOrder?", "author": "jeremyk-91", "createdAt": "2020-04-27T16:52:36Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class VerifyingPaxosStateLogTest {\n+    private static final long LEAST_LOG_ENTRY = 3L;\n+    private static final long GREATEST_LOG_ENTRY = 20L;\n+    private static final byte[] CORRECT_VALUE_FOR_ROUND = valueForRound(10L).persistToBytes();\n+    private static final byte[] OTHER_VALUE_FOR_ROUND = valueForRound(5L).persistToBytes();\n+\n+    private final PaxosStateLog<PaxosValue> current = mock(PaxosStateLog.class);\n+    private final PaxosStateLog<PaxosValue> experimental = mock(PaxosStateLog.class);\n+    private final VerifyingPaxosStateLog.Settings<PaxosValue> settings = ImmutableSettings.<PaxosValue>builder()\n+            .currentLog(current)\n+            .experimentalLog(experimental)\n+            .hydrator(PaxosValue.BYTES_HYDRATOR)\n+            .build();\n+\n+    private final PaxosStateLog<PaxosValue> log = new VerifyingPaxosStateLog<>(settings);\n+\n+    @Before\n+    public void setupMocks() throws IOException {\n+        when(current.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY);\n+        when(current.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY);\n+        when(current.readRound(anyLong())).thenReturn(CORRECT_VALUE_FOR_ROUND);\n+\n+        when(experimental.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY + 1L);\n+        when(experimental.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY + 1L);\n+        when(experimental.readRound(anyLong())).thenReturn(OTHER_VALUE_FOR_ROUND);\n+    }\n+\n+    @After\n+    public void noMoreInteractions() {\n+        verifyNoMoreInteractions(current, experimental);\n+    }\n+\n+    @Test\n+    public void writeWritesToBoth() {\n+        long sequence = 15L;\n+        log.writeRound(sequence, valueForRound(sequence));\n+        verify(current).writeRound(sequence, valueForRound(sequence));\n+        verify(experimental).writeRound(sequence, valueForRound(sequence));", "originalCommit": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MjE1Mg==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415982152", "bodyText": "It looks something like\nMockito.inOrder(current, experimental)\n  .verify(current).write(bla);\n  .verify(experimental).write(bla);", "author": "jeremyk-91", "createdAt": "2020-04-27T16:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MTIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "chunk": "diff --git a/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java b/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java\nindex 7f774408e4..f7be22910f 100644\n--- a/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java\n+++ b/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java\n\n@@ -17,8 +17,13 @@\n package com.palantir.paxos;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.mockito.Mockito.when;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MjQ4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4735#discussion_r415982489", "bodyText": "Might want to add a few tests for the exception protection for experimental, once we've implemented that!", "author": "jeremyk-91", "createdAt": "2020-04-27T16:54:19Z", "path": "leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.paxos;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class VerifyingPaxosStateLogTest {\n+    private static final long LEAST_LOG_ENTRY = 3L;\n+    private static final long GREATEST_LOG_ENTRY = 20L;\n+    private static final byte[] CORRECT_VALUE_FOR_ROUND = valueForRound(10L).persistToBytes();\n+    private static final byte[] OTHER_VALUE_FOR_ROUND = valueForRound(5L).persistToBytes();\n+\n+    private final PaxosStateLog<PaxosValue> current = mock(PaxosStateLog.class);\n+    private final PaxosStateLog<PaxosValue> experimental = mock(PaxosStateLog.class);\n+    private final VerifyingPaxosStateLog.Settings<PaxosValue> settings = ImmutableSettings.<PaxosValue>builder()\n+            .currentLog(current)\n+            .experimentalLog(experimental)\n+            .hydrator(PaxosValue.BYTES_HYDRATOR)\n+            .build();\n+\n+    private final PaxosStateLog<PaxosValue> log = new VerifyingPaxosStateLog<>(settings);\n+\n+    @Before\n+    public void setupMocks() throws IOException {\n+        when(current.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY);\n+        when(current.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY);\n+        when(current.readRound(anyLong())).thenReturn(CORRECT_VALUE_FOR_ROUND);\n+\n+        when(experimental.getLeastLogEntry()).thenReturn(LEAST_LOG_ENTRY + 1L);\n+        when(experimental.getGreatestLogEntry()).thenReturn(GREATEST_LOG_ENTRY + 1L);\n+        when(experimental.readRound(anyLong())).thenReturn(OTHER_VALUE_FOR_ROUND);\n+    }\n+\n+    @After\n+    public void noMoreInteractions() {\n+        verifyNoMoreInteractions(current, experimental);\n+    }\n+\n+    @Test\n+    public void writeWritesToBoth() {\n+        long sequence = 15L;\n+        log.writeRound(sequence, valueForRound(sequence));\n+        verify(current).writeRound(sequence, valueForRound(sequence));\n+        verify(experimental).writeRound(sequence, valueForRound(sequence));\n+    }\n+\n+    @Test\n+    public void readFromBothReturnLegacy() throws IOException {\n+        long sequence = 10L;\n+        assertThat(log.readRound(sequence)).isEqualTo(CORRECT_VALUE_FOR_ROUND);\n+        verify(current).readRound(sequence);\n+        verify(experimental).readRound(sequence);\n+    }\n+\n+    @Test\n+    public void getLeastFromBothReturnLegacy() {\n+        assertThat(log.getLeastLogEntry()).isEqualTo(LEAST_LOG_ENTRY);\n+        verify(current).getLeastLogEntry();\n+        verify(experimental).getLeastLogEntry();\n+    }\n+\n+    @Test\n+    public void getGreatestFromBothReturnLegacy() {\n+        assertThat(log.getGreatestLogEntry()).isEqualTo(GREATEST_LOG_ENTRY);\n+        verify(current).getGreatestLogEntry();\n+        verify(experimental).getGreatestLogEntry();\n+    }\n+\n+    @Test\n+    public void truncateBoth() {\n+        log.truncate(7L);\n+        verify(current).truncate(7L);\n+        verify(experimental).truncate(7L);\n+    }\n+", "originalCommit": "0dcd2c47fc2b175b92a0affb9b978718a952d8af", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "chunk": "diff --git a/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java b/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java\nindex 7f774408e4..f7be22910f 100644\n--- a/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java\n+++ b/leader-election-impl/src/test/java/com/palantir/paxos/VerifyingPaxosStateLogTest.java\n\n@@ -17,8 +17,13 @@\n package com.palantir.paxos;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatCode;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.mockito.Mockito.when;\n"}}, {"oid": "4385bc68fc8a06503000e5ea01f60e5894b834a1", "url": "https://github.com/palantir/atlasdb/commit/4385bc68fc8a06503000e5ea01f60e5894b834a1", "message": "Address CR, add tests", "committedDate": "2020-04-28T10:55:37Z", "type": "commit"}, {"oid": "7e2d6480df01a93fd28af93cf50597394a091617", "url": "https://github.com/palantir/atlasdb/commit/7e2d6480df01a93fd28af93cf50597394a091617", "message": "Merge branch 'develop' of github.com:palantir/atlasdb into psl/migration-log", "committedDate": "2020-04-28T10:57:52Z", "type": "commit"}, {"oid": "9be5cc6cac5c52f87e1de554b44e3237ccac181c", "url": "https://github.com/palantir/atlasdb/commit/9be5cc6cac5c52f87e1de554b44e3237ccac181c", "message": "Checkstyle", "committedDate": "2020-04-28T12:42:01Z", "type": "commit"}]}