{"pr_number": 4490, "pr_title": "Batched off-heap timestamp cache implementation", "pr_createdAt": "2020-01-07T15:59:19Z", "pr_url": "https://github.com/palantir/atlasdb/pull/4490", "timeline": [{"oid": "0c81599960bf4a510431450704a868b4021d8ac2", "url": "https://github.com/palantir/atlasdb/commit/0c81599960bf4a510431450704a868b4021d8ac2", "message": "Multiput and multiget.", "committedDate": "2020-01-07T13:12:25Z", "type": "commit"}, {"oid": "f226f48b4a04797b82113da2f4d9fb92b81f4a5c", "url": "https://github.com/palantir/atlasdb/commit/f226f48b4a04797b82113da2f4d9fb92b81f4a5c", "message": "Batching timestamp cache.", "committedDate": "2020-01-07T15:00:35Z", "type": "commit"}, {"oid": "d3a33c8af992ee3c9097777f68d3216f77b6ce43", "url": "https://github.com/palantir/atlasdb/commit/d3a33c8af992ee3c9097777f68d3216f77b6ce43", "message": "Changes.", "committedDate": "2020-01-07T15:22:13Z", "type": "commit"}, {"oid": "429d45db40adaf6a5acbd8effba96e5954f96e8d", "url": "https://github.com/palantir/atlasdb/commit/429d45db40adaf6a5acbd8effba96e5954f96e8d", "message": "Added a clear.", "committedDate": "2020-01-07T15:29:18Z", "type": "commit"}, {"oid": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "url": "https://github.com/palantir/atlasdb/commit/87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "message": "Add multi tests.", "committedDate": "2020-01-07T15:51:51Z", "type": "commit"}, {"oid": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "url": "https://github.com/palantir/atlasdb/commit/ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "message": "Small refactor.", "committedDate": "2020-01-07T16:21:51Z", "type": "forcePushed"}, {"oid": "4546457e9bc9068359f771d9ecce8902590300ae", "url": "https://github.com/palantir/atlasdb/commit/4546457e9bc9068359f771d9ecce8902590300ae", "message": "Small refactor.", "committedDate": "2020-01-07T16:39:36Z", "type": "commit"}, {"oid": "4546457e9bc9068359f771d9ecce8902590300ae", "url": "https://github.com/palantir/atlasdb/commit/4546457e9bc9068359f771d9ecce8902590300ae", "message": "Small refactor.", "committedDate": "2020-01-07T16:39:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjExOA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826118", "bodyText": "It's probably enough to just return Map<Long, Long>", "author": "jeremyk-91", "createdAt": "2020-01-07T16:13:44Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -68,6 +78,39 @@ public Long get(StoreNamespace storeNamespace, @Nonnull Long startTs) {\n         return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n     }\n \n+    @Override\n+    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Mzk4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363853989", "bodyText": "Changed.", "author": "OStevan", "createdAt": "2020-01-07T17:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjExOA=="}], "type": "inlineReview", "revised_code": {"commit": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\nindex 0d880abefb..f93c0b37df 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\n\n@@ -72,14 +72,11 @@ public final class RocksDbPersistentTimestampStore implements PersistentTimestam\n         byte[] byteKeyValue = ValueType.VAR_LONG.convertFromJava(startTs);\n         byte[] value = getValueBytes(availableColumnFamilies.get(storeNamespace.uniqueName()), byteKeyValue);\n \n-        if (value == null) {\n-            return null;\n-        }\n-        return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n+        return deserializeValue(startTs, value);\n     }\n \n     @Override\n-    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n+    public Map<Long, Long> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n         Preconditions.checkArgument(\n                 availableColumnFamilies.containsKey(storeNamespace.uniqueName()),\n                 \"Store namespace does not exist\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjU4MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826581", "bodyText": "We could refactor this to a separate check?", "author": "jeremyk-91", "createdAt": "2020-01-07T16:14:42Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -68,6 +78,39 @@ public Long get(StoreNamespace storeNamespace, @Nonnull Long startTs) {\n         return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n     }\n \n+    @Override\n+    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n+        Preconditions.checkArgument(\n+                availableColumnFamilies.containsKey(storeNamespace.uniqueName()),\n+                \"Store namespace does not exist\");", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjY5MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852691", "bodyText": "Refactored.", "author": "OStevan", "createdAt": "2020-01-07T17:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjU4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\nindex 0d880abefb..f93c0b37df 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\n\n@@ -72,14 +72,11 @@ public final class RocksDbPersistentTimestampStore implements PersistentTimestam\n         byte[] byteKeyValue = ValueType.VAR_LONG.convertFromJava(startTs);\n         byte[] value = getValueBytes(availableColumnFamilies.get(storeNamespace.uniqueName()), byteKeyValue);\n \n-        if (value == null) {\n-            return null;\n-        }\n-        return startTs + (Long) ValueType.VAR_LONG.convertToJava(value, 0);\n+        return deserializeValue(startTs, value);\n     }\n \n     @Override\n-    public Set<Map.Entry<Long, Long>> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n+    public Map<Long, Long> multiGet(StoreNamespace storeNamespace, List<Long> keys) {\n         Preconditions.checkArgument(\n                 availableColumnFamilies.containsKey(storeNamespace.uniqueName()),\n                 \"Store namespace does not exist\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjg0Mg==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363826842", "bodyText": "as above, it may be easier to pass in Map<Long, Long>", "author": "jeremyk-91", "createdAt": "2020-01-07T16:15:14Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java", "diffHunk": "@@ -80,6 +123,13 @@ public void put(StoreNamespace storeNamespace, @Nonnull Long startTs, @Nonnull L\n         putEntry(availableColumnFamilies.get(storeNamespace.uniqueName()), key, value);\n     }\n \n+    @Override\n+    public void multiPut(StoreNamespace storeNamespace, Set<Map.Entry<Long, Long>> toWrite) {\n+        for (Map.Entry<Long, Long> entry : toWrite) {", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1Mjc0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852741", "bodyText": "Changed.", "author": "OStevan", "createdAt": "2020-01-07T17:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgyNjg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "251fc3cd16fca086c086b40bee40159a907273a3", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\nindex 0d880abefb..b7c0d5252f 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/offheap/rocksdb/RocksDbPersistentTimestampStore.java\n\n@@ -93,29 +86,21 @@ public final class RocksDbPersistentTimestampStore implements PersistentTimestam\n                 byteKeys);\n \n         if (byteValues.isEmpty()) {\n-            return ImmutableSet.of();\n+            return ImmutableMap.of();\n         }\n \n         return KeyedStream.ofEntries(\n                 Streams.zip(\n                         keys.stream(),\n                         byteValues.stream(),\n-                        (key, value) -> {\n-                            if (value == null) {\n-                                return Maps.immutableEntry(key, null);\n-                            }\n-                            return Maps.immutableEntry(\n-                                    key, key + (Long) ValueType.VAR_LONG.convertToJava(value, 0));\n-                        }))\n-                .collectToMap()\n-                .entrySet();\n+                        (key, value) -> Maps.immutableEntry(key, deserializeValue(key, value))))\n+                .filter(Objects::nonNull)\n+                .collectToMap();\n     }\n \n     @Override\n     public void put(StoreNamespace storeNamespace, @Nonnull Long startTs, @Nonnull Long commitTs) {\n-        Preconditions.checkArgument(\n-                availableColumnFamilies.containsKey(storeNamespace.uniqueName()),\n-                \"Store namespace does not exist\");\n+        checkNamespaceExists(storeNamespace);\n \n         byte[] key = ValueType.VAR_LONG.convertFromJava(startTs);\n         byte[] value = ValueType.VAR_LONG.convertFromJava(commitTs - startTs);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363830084", "bodyText": "nit: could we name this with what the autobatcher actually does? i.e. cellPutter or something like that", "author": "jeremyk-91", "createdAt": "2020-01-07T16:21:42Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;", "originalCommit": "87f9dfe7721ac76f74230c8a5351c89ba33a6e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MzU4OQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363843589", "bodyText": "similar with concurrentHashMap - maybe inflightRequests", "author": "jeremyk-91", "createdAt": "2020-01-07T16:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjM3Mw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852373", "bodyText": "Refactored.", "author": "OStevan", "createdAt": "2020-01-07T17:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgzMDA4NA=="}], "type": "inlineReview", "revised_code": {"commit": "ec8f05ebf5b3f6dbe7b16c489bc93b93b8f2a2a2", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex e27452d39b..6aac9f6c64 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -128,11 +128,11 @@ public final class OffHeapTimestampCache implements TimestampCache {\n             }\n             CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n             try {\n-                Set<Map.Entry<Long, Long>> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n                         cacheDescriptor.storeNamespace(),\n                         request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n \n-                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response);\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n                 offHeapTimestampCache.persistentTimestampStore.multiPut(\n                         cacheDescriptor.storeNamespace(),\n                         toWrite);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363841287", "bodyText": "How does this case arise? Might be worth a comment: it's not obvious how this happens", "author": "jeremyk-91", "createdAt": "2020-01-07T16:44:09Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NDgzNA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363844834", "bodyText": "Probably worth defensively logging what the exception is", "author": "jeremyk-91", "createdAt": "2020-01-07T16:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjYwMg==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852602", "bodyText": "Added a comment and logging the exception.", "author": "OStevan", "createdAt": "2020-01-07T17:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0MTI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "251fc3cd16fca086c086b40bee40159a907273a3", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex 6aac9f6c64..592078b43d 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -30,6 +30,7 @@ import org.immutables.value.Value;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.Futures;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NTc0NA==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363845744", "bodyText": "possible race condition here in that concurrentHashMap may have extra entries cleared, but this is OK as this is only used to skip reads for values that are about to be written", "author": "jeremyk-91", "createdAt": "2020-01-07T16:53:03Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {\n+        StoreNamespace proposal = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+        return ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(proposal)\n+                .build();\n+    }\n+\n+    private static class WriteBatcher\n+            implements CoalescingRequestFunction<Map.Entry<Long, Long>, Map.Entry<Long, Long>> {\n+        OffHeapTimestampCache offHeapTimestampCache;\n+\n+        WriteBatcher(OffHeapTimestampCache offHeapTimestampCache) {\n+            this.offHeapTimestampCache = offHeapTimestampCache;\n+        }\n+\n+        @Override\n+        public Map<Map.Entry<Long, Long>, Map.Entry<Long, Long>> apply(Set<Map.Entry<Long, Long>> request) {\n+            if (offHeapTimestampCache.cacheDescriptor.get().currentSize().get() >= offHeapTimestampCache.maxSize) {\n+                offHeapTimestampCache.clear();\n+            }\n+            CacheDescriptor cacheDescriptor = offHeapTimestampCache.cacheDescriptor.get();\n+            try {\n+                Map<Long, Long> response = offHeapTimestampCache.persistentTimestampStore.multiGet(\n+                        cacheDescriptor.storeNamespace(),\n+                        request.stream().map(Map.Entry::getKey).collect(Collectors.toList()));\n+\n+                Set<Map.Entry<Long, Long>> toWrite = Sets.difference(request, response.entrySet());\n+                offHeapTimestampCache.persistentTimestampStore.multiPut(\n+                        cacheDescriptor.storeNamespace(),\n+                        toWrite);\n+\n+                cacheDescriptor.currentSize().addAndGet(toWrite.size());\n+            } catch (SafeIllegalArgumentException exception) {\n+                log.warn(\"Clear called concurrently, writing failed\");\n+            } finally {\n+                offHeapTimestampCache.concurrentHashMap.clear();", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "251fc3cd16fca086c086b40bee40159a907273a3", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex 6aac9f6c64..592078b43d 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -30,6 +30,7 @@ import org.immutables.value.Value;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.Futures;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjQzNw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363846437", "bodyText": "nit: would suggest renaming, maybe to createNamespaceAndConstructCacheProposal since this has side effects", "author": "jeremyk-91", "createdAt": "2020-01-07T16:54:23Z", "path": "atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.Nullable;\n+\n+import org.immutables.value.Value;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.common.util.concurrent.Futures;\n+import com.palantir.atlasdb.autobatch.Autobatchers;\n+import com.palantir.atlasdb.autobatch.CoalescingRequestFunction;\n+import com.palantir.atlasdb.autobatch.DisruptorAutobatcher;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore.StoreNamespace;\n+import com.palantir.common.streams.KeyedStream;\n+import com.palantir.logsafe.exceptions.SafeIllegalArgumentException;\n+\n+public final class OffHeapTimestampCache implements TimestampCache {\n+    private static final String TIMESTAMP_CACHE_NAMESPACE = \"timestamp_cache\";\n+    private static final String BATCHER_PURPOSE = \"off-heap-timestamp-cache\";\n+    private static final Logger log = LoggerFactory.getLogger(OffHeapTimestampCache.class);\n+\n+    private final PersistentTimestampStore persistentTimestampStore;\n+    private final int maxSize;\n+    private final AtomicReference<CacheDescriptor> cacheDescriptor = new AtomicReference<>();\n+    private final ConcurrentMap<Long, Long> concurrentHashMap = new ConcurrentHashMap<>();\n+    private final DisruptorAutobatcher<Map.Entry<Long, Long>, Map.Entry<Long, Long>> autobatcher;\n+\n+    public static TimestampCache create(PersistentTimestampStore persistentTimestampStore, int maxSize) {\n+        StoreNamespace storeNamespace = persistentTimestampStore.createNamespace(TIMESTAMP_CACHE_NAMESPACE);\n+\n+        CacheDescriptor cacheDescriptor = ImmutableCacheDescriptor.builder()\n+                .currentSize(new AtomicInteger())\n+                .storeNamespace(storeNamespace)\n+                .build();\n+\n+        return new OffHeapTimestampCache(persistentTimestampStore, cacheDescriptor, maxSize);\n+    }\n+\n+    private OffHeapTimestampCache(\n+            PersistentTimestampStore persistentTimestampStore,\n+            CacheDescriptor cacheDescriptor,\n+            int maxSize) {\n+        this.persistentTimestampStore = persistentTimestampStore;\n+        this.cacheDescriptor.set(cacheDescriptor);\n+        this.maxSize = maxSize;\n+        this.autobatcher = Autobatchers.coalescing(new WriteBatcher(this))\n+                .safeLoggablePurpose(BATCHER_PURPOSE)\n+                .build();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        CacheDescriptor proposedCacheDescriptor = constructCacheProposal(persistentTimestampStore);\n+\n+        CacheDescriptor previous = cacheDescriptor.getAndUpdate(prev -> proposedCacheDescriptor);\n+        if (previous != null) {\n+            persistentTimestampStore.dropNamespace(previous.storeNamespace());\n+        }\n+    }\n+\n+\n+    @Override\n+    public void putAlreadyCommittedTransaction(Long startTimestamp, Long commitTimestamp) {\n+        if (concurrentHashMap.putIfAbsent(startTimestamp, commitTimestamp) != null) {\n+            return;\n+        }\n+        Futures.getUnchecked(autobatcher.apply(Maps.immutableEntry(startTimestamp, commitTimestamp)));\n+    }\n+\n+    @Nullable\n+    @Override\n+    public Long getCommitTimestampIfPresent(Long startTimestamp) {\n+        Long value = concurrentHashMap.get(startTimestamp);\n+        if (value != null) {\n+            return value;\n+        }\n+\n+        return persistentTimestampStore.get(cacheDescriptor.get().storeNamespace(), startTimestamp);\n+    }\n+\n+    private static CacheDescriptor constructCacheProposal(PersistentTimestampStore persistentTimestampStore) {", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjQ0MQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852441", "bodyText": "Renamed.", "author": "OStevan", "createdAt": "2020-01-07T17:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0NjQzNw=="}], "type": "inlineReview", "revised_code": {"commit": "251fc3cd16fca086c086b40bee40159a907273a3", "chunk": "diff --git a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\nindex 6aac9f6c64..592078b43d 100644\n--- a/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n+++ b/atlasdb-client/src/main/java/com/palantir/atlasdb/cache/OffHeapTimestampCache.java\n\n@@ -30,6 +30,7 @@ import org.immutables.value.Value;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.common.util.concurrent.Futures;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0ODExNQ==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363848115", "bodyText": "nit: cacheNukedWhenSizeLimitExceeded", "author": "jeremyk-91", "createdAt": "2020-01-07T16:57:44Z", "path": "atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * (c) Copyright 2020 Palantir Technologies Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.palantir.atlasdb.cache;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+\n+import com.palantir.atlasdb.offheap.PersistentTimestampStore;\n+import com.palantir.atlasdb.offheap.rocksdb.RocksDbPersistentTimestampStore;\n+\n+public final class OffHeapTimestampCacheIntegrationTests {\n+    @ClassRule\n+    public static final TemporaryFolder TEMPORARY_FOLDER = new TemporaryFolder();\n+    private static final int CACHE_SIZE = 2;\n+\n+    private TimestampCache offHeapTimestampCache;\n+    private PersistentTimestampStore persistentTimestampStore;\n+\n+    @Before\n+    public void before() throws RocksDBException, IOException {\n+        RocksDB rocksDb = RocksDB.open(TEMPORARY_FOLDER.newFolder().getAbsolutePath());\n+\n+        persistentTimestampStore = new RocksDbPersistentTimestampStore(rocksDb);\n+\n+        offHeapTimestampCache = OffHeapTimestampCache.create(persistentTimestampStore, CACHE_SIZE);\n+    }\n+\n+    @After\n+    public void after() throws Exception {\n+        persistentTimestampStore.close();\n+    }\n+\n+    @Test\n+    public void cachedEntry() {\n+        offHeapTimestampCache.putAlreadyCommittedTransaction(1L, 3L);\n+\n+        assertThat(offHeapTimestampCache.getCommitTimestampIfPresent(1L)).isEqualTo(3L);\n+    }\n+\n+    @Test\n+    public void nonCachedEntry() {\n+        assertThat(offHeapTimestampCache.getCommitTimestampIfPresent(1L)).isNull();\n+    }\n+\n+    @Test\n+    public void cacheNuked() {", "originalCommit": "4546457e9bc9068359f771d9ecce8902590300ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg1MjgyNw==", "url": "https://github.com/palantir/atlasdb/pull/4490#discussion_r363852827", "bodyText": "Renamed.", "author": "OStevan", "createdAt": "2020-01-07T17:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzg0ODExNQ=="}], "type": "inlineReview", "revised_code": {"commit": "251fc3cd16fca086c086b40bee40159a907273a3", "chunk": "diff --git a/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java b/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java\nindex 3bb27c3742..f6a7a88a7a 100644\n--- a/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java\n+++ b/atlasdb-client/src/test/java/com/palantir/atlasdb/cache/OffHeapTimestampCacheIntegrationTests.java\n\n@@ -66,7 +66,7 @@ public final class OffHeapTimestampCacheIntegrationTests {\n     }\n \n     @Test\n-    public void cacheNuked() {\n+    public void cacheNukedWhenSizeLimitExceeded() {\n         offHeapTimestampCache.putAlreadyCommittedTransaction(1L, 3L);\n         offHeapTimestampCache.putAlreadyCommittedTransaction(2L, 4L);\n         offHeapTimestampCache.putAlreadyCommittedTransaction(5L, 6L);\n"}}, {"oid": "251fc3cd16fca086c086b40bee40159a907273a3", "url": "https://github.com/palantir/atlasdb/commit/251fc3cd16fca086c086b40bee40159a907273a3", "message": "Comments.", "committedDate": "2020-01-07T17:09:22Z", "type": "commit"}, {"oid": "eece8a5d58d4ee46407e7ba904e418ecdeed92a1", "url": "https://github.com/palantir/atlasdb/commit/eece8a5d58d4ee46407e7ba904e418ecdeed92a1", "message": "Renamed a wrong change.", "committedDate": "2020-01-07T17:15:02Z", "type": "commit"}]}