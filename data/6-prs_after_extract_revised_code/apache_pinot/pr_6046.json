{"pr_number": 6046, "pr_title": "Deep Extraction Support for ORC, Thrift, and ProtoBuf Records", "pr_createdAt": "2020-09-22T17:16:21Z", "pr_url": "https://github.com/apache/pinot/pull/6046", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MDM0MQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493140341", "bodyText": "Recommend not adding this generic type V as in most cases it is Object (the field can be of lots of types for the same file format)", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:52:52Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -27,8 +28,9 @@\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n+ * @param <V> The input record's field to be converted", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxMzg5OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495613899", "bodyText": "Makes sense. Will remove the generic type V.", "author": "timsants", "createdAt": "2020-09-27T20:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MDM0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\nindex c1aa7b6762..ae25db9947 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n\n@@ -28,17 +28,16 @@ import javax.annotation.Nullable;\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n- * @param <V> The input record's field to be converted\n  */\n-public interface RecordExtractor<T, V> {\n+public interface RecordExtractor<T> {\n \n   /**\n    * Initialize the record extractor with its config\n    *\n-   * @param fields List of field names to extract from the provided input record. If blank, extracts all fields (only for AVRO/JSON currently)\n+   * @param fields List of field names to extract from the provided input record. If null or empty, extracts all fields.\n    * @param recordExtractorConfig The record extractor config\n    */\n-  void init(Set<String> fields, RecordExtractorConfig recordExtractorConfig);\n+  void init(@Nullable Set<String> fields, RecordExtractorConfig recordExtractorConfig);\n \n   /**\n    * Extracts fields as listed in the sourceFieldNames from the given input record and sets them into the GenericRow\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MTA4NA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493141084", "bodyText": "Put nullable annotation before fields", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:54:03Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -27,8 +28,9 @@\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n+ * @param <V> The input record's field to be converted\n  */\n-public interface RecordExtractor<T> {\n+public interface RecordExtractor<T, V> {\n \n   /**\n    * Initialize the record extractor with its config", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\nindex c1aa7b6762..ae25db9947 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n\n@@ -28,17 +28,16 @@ import javax.annotation.Nullable;\n  * 2) Collections become Object[] i.e. multi-value column\n  * 3) Nested/Complex fields (e.g. json maps, avro maps, avro records) become Map<Object, Object>\n  * @param <T> The format of the input record\n- * @param <V> The input record's field to be converted\n  */\n-public interface RecordExtractor<T, V> {\n+public interface RecordExtractor<T> {\n \n   /**\n    * Initialize the record extractor with its config\n    *\n-   * @param fields List of field names to extract from the provided input record. If blank, extracts all fields (only for AVRO/JSON currently)\n+   * @param fields List of field names to extract from the provided input record. If null or empty, extracts all fields.\n    * @param recordExtractorConfig The record extractor config\n    */\n-  void init(Set<String> fields, RecordExtractorConfig recordExtractorConfig);\n+  void init(@Nullable Set<String> fields, RecordExtractorConfig recordExtractorConfig);\n \n   /**\n    * Extracts fields as listed in the sourceFieldNames from the given input record and sets them into the GenericRow\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0MzQzOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493143439", "bodyText": "We should return byte[] instead of ByteBuffer", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:57:44Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\nindex c1aa7b6762..ae25db9947 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n\n@@ -51,13 +50,14 @@ public interface RecordExtractor<T, V> {\n \n   /**\n    * Converts a field of the given input record. The field value will be converted to either a single value\n-   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * (string, number, byte[]), multi value (Object[]) or a Map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    *\n    * @param value the field value to be converted\n-   * @return The converted field value\n+   * @return The converted field value. Returns null for empty array/collection/map.\n    */\n-  Object convert(@Nullable V value);\n+  @Nullable\n+  Object convert(@Nullable Object value);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493144557", "bodyText": "We might not want to pass null into the convert(). Check the value before calling convert()", "author": "Jackie-Jiang", "createdAt": "2020-09-23T01:59:24Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value\n+   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   *\n+   * @param value the field value to be converted\n+   * @return The converted field value\n+   */\n+  Object convert(@Nullable V value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxNDQwOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495614409", "bodyText": "I prefer handling null values in one place if we want consistent handling across all the extractors. But if you think that this treatment of null could differ across different data formats/types, we can put the null handling before calling convert().", "author": "timsants", "createdAt": "2020-09-27T20:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQzMTg2Mg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496431862", "bodyText": "I prefer handling null explicitly before calling the method for readability and slightly better performance (save a method call), while this is personal preference so either way is fine", "author": "Jackie-Jiang", "createdAt": "2020-09-29T05:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3MjAxMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r497972010", "bodyText": "That's a good point regarding performance. I can move the null handling before calling the method.", "author": "timsants", "createdAt": "2020-10-01T04:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NDU1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\nindex c1aa7b6762..ae25db9947 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n\n@@ -51,13 +50,14 @@ public interface RecordExtractor<T, V> {\n \n   /**\n    * Converts a field of the given input record. The field value will be converted to either a single value\n-   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * (string, number, byte[]), multi value (Object[]) or a Map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    *\n    * @param value the field value to be converted\n-   * @return The converted field value\n+   * @return The converted field value. Returns null for empty array/collection/map.\n    */\n-  Object convert(@Nullable V value);\n+  @Nullable\n+  Object convert(@Nullable Object value);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE0NTUyMQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493145521", "bodyText": "Are we returning null for empty array/collection/map? If so, let's add the behavior to the javadoc and annotate the return value as nullable", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:00:50Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java", "diffHunk": "@@ -46,4 +48,16 @@\n    * @return The output GenericRow\n    */\n   GenericRow extract(T from, GenericRow to);\n+\n+  /**\n+   * Converts a field of the given input record. The field value will be converted to either a single value\n+   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   *\n+   * @param value the field value to be converted\n+   * @return The converted field value\n+   */\n+  Object convert(@Nullable V value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\nindex c1aa7b6762..ae25db9947 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/RecordExtractor.java\n\n@@ -51,13 +50,14 @@ public interface RecordExtractor<T, V> {\n \n   /**\n    * Converts a field of the given input record. The field value will be converted to either a single value\n-   * (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * (string, number, byte[]), multi value (Object[]) or a Map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    *\n    * @param value the field value to be converted\n-   * @return The converted field value\n+   * @return The converted field value. Returns null for empty array/collection/map.\n    */\n-  Object convert(@Nullable V value);\n+  @Nullable\n+  Object convert(@Nullable Object value);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MjcxNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493152717", "bodyText": "Suggest renaming it to BaseRecordExtractor", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:12:43Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwNjA0Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495606046", "bodyText": "Good suggestion. Renamed.", "author": "timsants", "createdAt": "2020-09-27T19:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MjcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nsimilarity index 84%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex bcf3afaf60..452009249e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -27,17 +27,15 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n- * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n- *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the field value is {@code null}.\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null} or if the value is an empty array/collection/map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDUzNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493154537", "bodyText": "Not sure how much value this generic type V can provide. IMO convertRecord(Object value) should be good enough (similar to convertMap(Object value) etc.)", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:15:33Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwNzczOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495607739", "bodyText": "Yes I agree. The only use of the generic type V is for the Object conversion but this can easily be handled within the convertRecord implementation.", "author": "timsants", "createdAt": "2020-09-27T19:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDUzNw=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nsimilarity index 84%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex bcf3afaf60..452009249e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -27,17 +27,15 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n- * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n- *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the field value is {@code null}.\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null} or if the value is an empty array/collection/map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDkzOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493154939", "bodyText": "Return false for default implementation?", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:16:09Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxMzQ1NQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495613455", "bodyText": "Sounds good. This would help simplify the JSON extractor.", "author": "timsants", "createdAt": "2020-09-27T20:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NDkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nsimilarity index 84%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex bcf3afaf60..452009249e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -27,17 +27,15 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n- * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n- *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the field value is {@code null}.\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null} or if the value is an empty array/collection/map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTEzNg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493155136", "bodyText": "Throw UnsupportedOperationException for default implementation?", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:16:28Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format.\n+   */\n+  @Nullable\n+  protected abstract Object convertRecord(V value);", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nsimilarity index 84%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex bcf3afaf60..452009249e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -27,17 +27,15 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n- * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n- *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the field value is {@code null}.\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null} or if the value is an empty array/collection/map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTQyNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r493155427", "bodyText": "The argument will never be null", "author": "Jackie-Jiang", "createdAt": "2020-09-23T02:16:54Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n+ */\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord((V) value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type.\n+   */\n+  protected abstract boolean isInstanceOfRecord(Object value);\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format.\n+   */\n+  @Nullable\n+  protected abstract Object convertRecord(V value);\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = convert(element);\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      convertedMap.put(convertSingleValue(key), convert(map.get(key)));\n+    }\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values. Returns {@code null} for {@code null} input values.\n+   */\n+  @Nullable\n+  protected Object convertSingleValue(@Nullable Object value) {", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxNTM2MA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495615360", "bodyText": "This method is called for converting map keys without checking for null. I believe it is possible to have a null map key but do we want to accept this case?", "author": "timsants", "createdAt": "2020-09-27T20:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1NTQyNw=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nsimilarity index 84%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex bcf3afaf60..452009249e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -27,17 +27,15 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n- * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n- *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the field value is {@code null}.\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null} or if the value is an empty array/collection/map.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r494744256", "bodyText": "It'd be good to avoid using the non-functional way for performance concern. Please refer to the way that AvroRecordExtractor uses. Same to the other Extractors.", "author": "jackjlli", "createdAt": "2020-09-25T04:44:35Z", "path": "pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java", "diffHunk": "@@ -45,18 +45,32 @@ public void init(Set<String> fields, @Nullable RecordExtractorConfig recordExtra\n   @Override\n   public GenericRow extract(Map<String, Object> from, GenericRow to) {\n     if (_extractAll) {\n-      from.forEach((fieldName, value) -> to.putValue(fieldName, JSONRecordExtractorUtils.convertValue(value)));\n+      from.forEach((fieldName, value) -> to.putValue(fieldName, convert(value)));", "originalCommit": "893b3e12628b1005714f2bbb679bfc3689d7eeb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxMzQzNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495613434", "bodyText": "Sure I can do that. But do you have any resources showing evidence for this? I thought the underlying implementation for .forEach would be similar to for (T t : iterable) given that it is not performed on a java .stream().", "author": "timsants", "createdAt": "2020-09-27T20:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYxOTQ4OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r495619489", "bodyText": "We had an internal meeting to discuss about the performance between functional and procedural method a year ago.\nHere's a doc on the performance of using functional method:\nhttps://www.beyondjava.net/performance-java-8-lambdas", "author": "jackjlli", "createdAt": "2020-09-27T21:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDk0Mw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496140943", "bodyText": "I see. Thanks for the background info. I'll change the extractors such that they do not use the lambda expression then.", "author": "timsants", "createdAt": "2020-09-28T18:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NDI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java b/pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java\nindex 928116f21a..cde50b5119 100644\n--- a/pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java\n+++ b/pinot-plugins/pinot-input-format/pinot-json/src/main/java/org/apache/pinot/plugin/inputformat/json/JSONRecordExtractor.java\n\n@@ -57,20 +57,4 @@ public class JSONRecordExtractor extends AbstractDefaultRecordExtractor<Map<Stri\n     }\n     return to;\n   }\n-\n-  /**\n-   * JSON structures should be handled as a map or an ordered collection. Therefore this will always return false.\n-   */\n-  @Override\n-  protected boolean isInstanceOfRecord(Object value) {\n-    return false;\n-  }\n-\n-  /**\n-   * This method should not be called when converting JSON objects.\n-   */\n-  @Override\n-  protected Object convertRecord(Object record) {\n-    throw new UnsupportedOperationException(\"JSON structures should be handled as a map or an ordered collection.\");\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDEzNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310134", "bodyText": "You can still use the method you added such as isInstanceOfRecord here. So in the method:\n  protected boolean isInstanceOfRecord(Object value) {\n    return (TypeDescription.Category) value == TypeDescription.Category.STRUCT;\n  }", "author": "jackjlli", "createdAt": "2020-09-29T00:39:53Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMjAwNQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504422005", "bodyText": "Resolving since ORC extraction is different from the other extractors.", "author": "timsants", "createdAt": "2020-10-14T06:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "522005d39776d495a3427d60134bfde442c3c11a", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\nindex 5f5cc0a079..7eea428760 100644\n--- a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n+++ b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n\n@@ -209,22 +209,7 @@ public class ORCRecordReader implements RecordReader {\n   private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n     TypeDescription.Category category = fieldType.getCategory();\n \n-    if (category == TypeDescription.Category.STRUCT) {\n-      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n-      if (!structColumnVector.isNull[rowId]) {\n-        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n-        List<String> childrenFieldNames = fieldType.getFieldNames();\n-\n-        Map<Object, Object> convertedMap = new HashMap<>();\n-        for (int i = 0; i < childrenFieldNames.size(); i++) {\n-          convertedMap.put(childrenFieldNames.get(i),\n-              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n-        }\n-        return convertedMap;\n-      } else {\n-        return null;\n-      }\n-    } else if (category == TypeDescription.Category.LIST) {\n+    if (category == TypeDescription.Category.LIST) {\n       TypeDescription childType = fieldType.getChildren().get(0);\n       ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n       if (columnVector.isRepeating) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDE3OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310179", "bodyText": "Same here.", "author": "jackjlli", "createdAt": "2020-09-29T00:40:02Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {\n+      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n+      if (!structColumnVector.isNull[rowId]) {\n+        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n+        List<String> childrenFieldNames = fieldType.getFieldNames();\n+\n+        Map<Object, Object> convertedMap = new HashMap<>();\n+        for (int i = 0; i < childrenFieldNames.size(); i++) {\n+          convertedMap.put(childrenFieldNames.get(i),\n+              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n         }\n-      } else if (category == TypeDescription.Category.MAP) {\n-        // Map field\n-        List<TypeDescription> children = fieldType.getChildren();\n-        TypeDescription.Category keyCategory = children.get(0).getCategory();\n-        TypeDescription.Category valueCategory = children.get(1).getCategory();\n-        MapColumnVector mapColumnVector = (MapColumnVector) _rowBatch.cols[i];\n-        int rowId = mapColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((mapColumnVector.noNulls || !mapColumnVector.isNull[rowId])) {\n-          int offset = (int) mapColumnVector.offsets[rowId];\n-          int length = (int) mapColumnVector.lengths[rowId];\n-          Map<Object, Object> map = new HashMap<>();\n-          for (int j = 0; j < length; j++) {\n-            int childRowId = offset + j;\n-            Object key = extractSingleValue(field, mapColumnVector.keys, childRowId, keyCategory);\n-            Object value = extractSingleValue(field, mapColumnVector.values, childRowId, valueCategory);\n-            map.put(key, value);\n+        return convertedMap;\n+      } else {\n+        return null;\n+      }\n+    } else if (category == TypeDescription.Category.LIST) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMTkwNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504421904", "bodyText": "Resolving since ORC extraction is different from the other extractors.", "author": "timsants", "createdAt": "2020-10-14T06:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDE3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "522005d39776d495a3427d60134bfde442c3c11a", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\nindex 5f5cc0a079..7eea428760 100644\n--- a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n+++ b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n\n@@ -209,22 +209,7 @@ public class ORCRecordReader implements RecordReader {\n   private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n     TypeDescription.Category category = fieldType.getCategory();\n \n-    if (category == TypeDescription.Category.STRUCT) {\n-      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n-      if (!structColumnVector.isNull[rowId]) {\n-        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n-        List<String> childrenFieldNames = fieldType.getFieldNames();\n-\n-        Map<Object, Object> convertedMap = new HashMap<>();\n-        for (int i = 0; i < childrenFieldNames.size(); i++) {\n-          convertedMap.put(childrenFieldNames.get(i),\n-              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n-        }\n-        return convertedMap;\n-      } else {\n-        return null;\n-      }\n-    } else if (category == TypeDescription.Category.LIST) {\n+    if (category == TypeDescription.Category.LIST) {\n       TypeDescription childType = fieldType.getChildren().get(0);\n       ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n       if (columnVector.isRepeating) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDIyNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310227", "bodyText": "Same here.", "author": "jackjlli", "createdAt": "2020-09-29T00:40:13Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {\n+      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n+      if (!structColumnVector.isNull[rowId]) {\n+        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n+        List<String> childrenFieldNames = fieldType.getFieldNames();\n+\n+        Map<Object, Object> convertedMap = new HashMap<>();\n+        for (int i = 0; i < childrenFieldNames.size(); i++) {\n+          convertedMap.put(childrenFieldNames.get(i),\n+              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n         }\n-      } else if (category == TypeDescription.Category.MAP) {\n-        // Map field\n-        List<TypeDescription> children = fieldType.getChildren();\n-        TypeDescription.Category keyCategory = children.get(0).getCategory();\n-        TypeDescription.Category valueCategory = children.get(1).getCategory();\n-        MapColumnVector mapColumnVector = (MapColumnVector) _rowBatch.cols[i];\n-        int rowId = mapColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((mapColumnVector.noNulls || !mapColumnVector.isNull[rowId])) {\n-          int offset = (int) mapColumnVector.offsets[rowId];\n-          int length = (int) mapColumnVector.lengths[rowId];\n-          Map<Object, Object> map = new HashMap<>();\n-          for (int j = 0; j < length; j++) {\n-            int childRowId = offset + j;\n-            Object key = extractSingleValue(field, mapColumnVector.keys, childRowId, keyCategory);\n-            Object value = extractSingleValue(field, mapColumnVector.values, childRowId, valueCategory);\n-            map.put(key, value);\n+        return convertedMap;\n+      } else {\n+        return null;\n+      }\n+    } else if (category == TypeDescription.Category.LIST) {\n+      TypeDescription childType = fieldType.getChildren().get(0);\n+      ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n+      if (columnVector.isRepeating) {\n+        rowId = 0;\n+      }\n+      if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n+        int offset = (int) listColumnVector.offsets[rowId];\n+        int length = (int) listColumnVector.lengths[rowId];\n+        List<Object> values = new ArrayList<>(length);\n+        for (int j = 0; j < length; j++) {\n+          Object value = extractValue(field, listColumnVector.child, childType,offset + j);\n+          // NOTE: Only keep non-null values\n+          if (value != null) {\n+            values.add(value);\n           }\n-          reuse.putValue(field, map);\n+        }\n+        if (!values.isEmpty()) {\n+          return values.toArray();\n         } else {\n-          reuse.putValue(field, null);\n+          // NOTE: Treat empty list as null\n+          return null;\n         }\n       } else {\n-        // Single-value field\n-        reuse.putValue(field, extractSingleValue(field, _rowBatch.cols[i], _nextRowId, category));\n+        return null;\n       }\n-    }\n+    } else if (category == TypeDescription.Category.MAP) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQyMTkyOA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504421928", "bodyText": "Resolving since ORC extraction is different from the other extractors.", "author": "timsants", "createdAt": "2020-10-14T06:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDIyNw=="}], "type": "inlineReview", "revised_code": {"commit": "522005d39776d495a3427d60134bfde442c3c11a", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\nindex 5f5cc0a079..7eea428760 100644\n--- a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n+++ b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n\n@@ -209,22 +209,7 @@ public class ORCRecordReader implements RecordReader {\n   private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n     TypeDescription.Category category = fieldType.getCategory();\n \n-    if (category == TypeDescription.Category.STRUCT) {\n-      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n-      if (!structColumnVector.isNull[rowId]) {\n-        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n-        List<String> childrenFieldNames = fieldType.getFieldNames();\n-\n-        Map<Object, Object> convertedMap = new HashMap<>();\n-        for (int i = 0; i < childrenFieldNames.size(); i++) {\n-          convertedMap.put(childrenFieldNames.get(i),\n-              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n-        }\n-        return convertedMap;\n-      } else {\n-        return null;\n-      }\n-    } else if (category == TypeDescription.Category.LIST) {\n+    if (category == TypeDescription.Category.LIST) {\n       TypeDescription childType = fieldType.getChildren().get(0);\n       ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n       if (columnVector.isRepeating) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDcyNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496310727", "bodyText": "And pls adjust the sequence to make it consistent in all extractors (first check collection, then map, then record, and finally single value).", "author": "jackjlli", "createdAt": "2020-09-29T00:42:06Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -175,68 +186,102 @@ public GenericRow next(GenericRow reuse)\n       }\n       String field = _orcFields.get(i);\n       TypeDescription fieldType = _orcFieldTypes.get(i);\n-      TypeDescription.Category category = fieldType.getCategory();\n-      if (category == TypeDescription.Category.LIST) {\n-        // Multi-value field, extract to Object[]\n-        TypeDescription.Category childCategory = fieldType.getChildren().get(0).getCategory();\n-        ListColumnVector listColumnVector = (ListColumnVector) _rowBatch.cols[i];\n-        int rowId = listColumnVector.isRepeating ? 0 : _nextRowId;\n-        if ((listColumnVector.noNulls || !listColumnVector.isNull[rowId])) {\n-          int offset = (int) listColumnVector.offsets[rowId];\n-          int length = (int) listColumnVector.lengths[rowId];\n-          List<Object> values = new ArrayList<>(length);\n-          for (int j = 0; j < length; j++) {\n-            Object value = extractSingleValue(field, listColumnVector.child, offset + j, childCategory);\n-            // NOTE: Only keep non-null values\n-            // TODO: Revisit\n-            if (value != null) {\n-              values.add(value);\n-            }\n-          }\n-          if (!values.isEmpty()) {\n-            reuse.putValue(field, values.toArray());\n-          } else {\n-            // NOTE: Treat empty list as null\n-            // TODO: Revisit\n-            reuse.putValue(field, null);\n-          }\n-        } else {\n-          reuse.putValue(field, null);\n+      reuse.putValue(field, extractValue(field, _rowBatch.cols[i], fieldType, _nextRowId));\n+    }\n+\n+    if (++_nextRowId == _rowBatch.size) {\n+      _hasNext = _orcRecordReader.nextBatch(_rowBatch);\n+      _nextRowId = 0;\n+    }\n+    return reuse;\n+  }\n+\n+  /**\n+   * Extracts the values for a given column vector.\n+   *\n+   * @param field name of the field being extracted\n+   * @param columnVector contains values of the field and its sub-types\n+   * @param fieldType information about the field such as the category (STRUCT, LIST, MAP, INT, etc)\n+   * @param rowId the ID of the row value being extracted\n+   * @return extracted row value from the column\n+   */\n+  @Nullable\n+  private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n+    TypeDescription.Category category = fieldType.getCategory();\n+\n+    if (category == TypeDescription.Category.STRUCT) {", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "522005d39776d495a3427d60134bfde442c3c11a", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\nindex 5f5cc0a079..7eea428760 100644\n--- a/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n+++ b/pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java\n\n@@ -209,22 +209,7 @@ public class ORCRecordReader implements RecordReader {\n   private Object extractValue(String field, ColumnVector columnVector, TypeDescription fieldType, int rowId) {\n     TypeDescription.Category category = fieldType.getCategory();\n \n-    if (category == TypeDescription.Category.STRUCT) {\n-      StructColumnVector structColumnVector = (StructColumnVector) columnVector;\n-      if (!structColumnVector.isNull[rowId]) {\n-        List<TypeDescription> childrenFieldTypes = fieldType.getChildren();\n-        List<String> childrenFieldNames = fieldType.getFieldNames();\n-\n-        Map<Object, Object> convertedMap = new HashMap<>();\n-        for (int i = 0; i < childrenFieldNames.size(); i++) {\n-          convertedMap.put(childrenFieldNames.get(i),\n-              extractValue(childrenFieldNames.get(i), structColumnVector.fields[i], childrenFieldTypes.get(i), rowId));\n-        }\n-        return convertedMap;\n-      } else {\n-        return null;\n-      }\n-    } else if (category == TypeDescription.Category.LIST) {\n+    if (category == TypeDescription.Category.LIST) {\n       TypeDescription childType = fieldType.getChildren().get(0);\n       ListColumnVector listColumnVector = (ListColumnVector) columnVector;\n       if (columnVector.isRepeating) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMTQ1Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r496311456", "bodyText": "Can we have an extractor for ORC as the other RecordReaders do?", "author": "jackjlli", "createdAt": "2020-09-29T00:45:02Z", "path": "pinot-plugins/pinot-input-format/pinot-orc/src/main/java/org/apache/pinot/plugin/inputformat/orc/ORCRecordReader.java", "diffHunk": "@@ -72,7 +73,7 @@\n   private int _nextRowId;\n \n   @Override\n-  public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReaderConfig recordReaderConfig)\n+  public void init(File dataFile, @Nullable Set<String> fieldsToRead, @Nullable RecordReaderConfig recordReaderConfig)", "originalCommit": "f117705bb0c8d0e7fdd44361b109f6c86fa1311c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3MDU2Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r497970567", "bodyText": "I had the same initial thought and asked Neha the same thing.\nIts because ORC's columnar format doesn't quite fit the RecordExtractor interface. The method GenericRow extract(T from, GenericRow to) expects one record/row to be extracted but the ORC record reader is unique in how it reads rows in batches. In addition, ColumnVectors have an optimization in the case of repeating values in which the first row in the row batch contains the repeating value.", "author": "timsants", "createdAt": "2020-10-01T03:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMTQ1Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMjk2Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499902967", "bodyText": "Suggest renaming some methods:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Object convertedValue;\n          \n          \n            \n                if (isInstanceOfMultiValue(value)) {\n          \n          \n            \n                  convertedValue = convertMultiValue(value);\n          \n          \n            \n                } else if (isInstanceOfMap(value)) {\n          \n          \n            \n                  convertedValue = convertMap(value);\n          \n          \n            \n                } else if (isInstanceOfRecord(value)) {\n          \n          \n            \n                  convertedValue = convertRecord(value);\n          \n          \n            \n                } else {\n          \n          \n            \n                  convertedValue = convertSingleValue(value);\n          \n          \n            \n                }\n          \n          \n            \n                return convertedValue;\n          \n          \n            \n                if (isMultiValue(value)) {\n          \n          \n            \n                  return convertMultiValue(value);\n          \n          \n            \n                } else if (isMap(value)) {\n          \n          \n            \n                  return convertMap(value);\n          \n          \n            \n                } else if (isRecord(value)) {\n          \n          \n            \n                  return convertRecord(value);\n          \n          \n            \n                } else {\n          \n          \n            \n                  return convertSingleValue(value);\n          \n          \n            \n                }", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:18:10Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nsimilarity index 79%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nindex 8f5a527c3a..bcf3afaf60 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n\n@@ -27,28 +27,33 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the value is an empty array/collection/map.\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    */\n   @Nullable\n-  public Object convert(Object value) {\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n     Object convertedValue;\n     if (isInstanceOfMultiValue(value)) {\n       convertedValue = convertMultiValue(value);\n     } else if (isInstanceOfMap(value)) {\n       convertedValue = convertMap(value);\n     } else if (isInstanceOfRecord(value)) {\n-      convertedValue = convertRecord(value);\n+      convertedValue = convertRecord((V) value);\n     } else {\n       convertedValue = convertSingleValue(value);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTA3Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499905076", "bodyText": "Please double-check the current behavior of handling empty string. I think we should include them into the MV array", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:24:09Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU2NzEwMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502567100", "bodyText": "I believe this behavior is in line with the current. I checked AvroUtils, JsonRecordExtractorUtils and RecordReaderUtils, and they're all doing this same thing.", "author": "npawar", "createdAt": "2020-10-09T17:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nsimilarity index 79%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nindex 8f5a527c3a..bcf3afaf60 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n\n@@ -27,28 +27,33 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the value is an empty array/collection/map.\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    */\n   @Nullable\n-  public Object convert(Object value) {\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n     Object convertedValue;\n     if (isInstanceOfMultiValue(value)) {\n       convertedValue = convertMultiValue(value);\n     } else if (isInstanceOfMap(value)) {\n       convertedValue = convertMap(value);\n     } else if (isInstanceOfRecord(value)) {\n-      convertedValue = convertRecord(value);\n+      convertedValue = convertRecord((V) value);\n     } else {\n       convertedValue = convertSingleValue(value);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNTQ1NA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499905454", "bodyText": "Use map.entrySet() to avoid the unnecessary lookups", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:25:13Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nsimilarity index 79%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nindex 8f5a527c3a..bcf3afaf60 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n\n@@ -27,28 +27,33 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the value is an empty array/collection/map.\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    */\n   @Nullable\n-  public Object convert(Object value) {\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n     Object convertedValue;\n     if (isInstanceOfMultiValue(value)) {\n       convertedValue = convertMultiValue(value);\n     } else if (isInstanceOfMap(value)) {\n       convertedValue = convertMap(value);\n     } else if (isInstanceOfRecord(value)) {\n-      convertedValue = convertRecord(value);\n+      convertedValue = convertRecord((V) value);\n     } else {\n       convertedValue = convertSingleValue(value);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjEzNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906137", "bodyText": "We don't allow either key or value as null inside the map because we don't allow null inside the MV and map is handled with MV columns", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:27:15Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNzEwOA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503027108", "bodyText": "Makes sense. I'll add null checks for the map keys and values so that they are not inserted into the map.", "author": "timsants", "createdAt": "2020-10-12T04:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjEzNw=="}], "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nsimilarity index 79%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nindex 8f5a527c3a..bcf3afaf60 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n\n@@ -27,28 +27,33 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the value is an empty array/collection/map.\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    */\n   @Nullable\n-  public Object convert(Object value) {\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n     Object convertedValue;\n     if (isInstanceOfMultiValue(value)) {\n       convertedValue = convertMultiValue(value);\n     } else if (isInstanceOfMap(value)) {\n       convertedValue = convertMap(value);\n     } else if (isInstanceOfRecord(value)) {\n-      convertedValue = convertRecord(value);\n+      convertedValue = convertRecord((V) value);\n     } else {\n       convertedValue = convertSingleValue(value);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjQwMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906400", "bodyText": "Return null for empty map?", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:28:00Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);\n+    }\n+    return convertedMap;", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyNzg0Mg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503027842", "bodyText": "Yes I'll add that. It will be consistent with the handling of multi-values.", "author": "timsants", "createdAt": "2020-10-12T04:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nsimilarity index 79%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nindex 8f5a527c3a..bcf3afaf60 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n\n@@ -27,28 +27,33 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the value is an empty array/collection/map.\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    */\n   @Nullable\n-  public Object convert(Object value) {\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n     Object convertedValue;\n     if (isInstanceOfMultiValue(value)) {\n       convertedValue = convertMultiValue(value);\n     } else if (isInstanceOfMap(value)) {\n       convertedValue = convertMap(value);\n     } else if (isInstanceOfRecord(value)) {\n-      convertedValue = convertRecord(value);\n+      convertedValue = convertRecord((V) value);\n     } else {\n       convertedValue = convertSingleValue(value);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjY1NQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r499906655", "bodyText": "value should never be null here?", "author": "Jackie-Jiang", "createdAt": "2020-10-05T22:28:43Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isInstanceOfMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isInstanceOfMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isInstanceOfRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is an instance of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isInstanceOfMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isInstanceOfMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Object key : map.keySet()) {\n+      Object convertedValue = null;\n+      if (key != null) {\n+        convertedValue = convert(map.get(key));\n+      }\n+      convertedMap.put(convertSingleValue(key), convertedValue);\n+    }\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values. Returns {@code null} for {@code null} input values.\n+   */\n+  @Nullable\n+  protected Object convertSingleValue(@Nullable Object value) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyODE3Nw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503028177", "bodyText": "Yes, that is now true with the changes to map conversion.", "author": "timsants", "createdAt": "2020-10-12T04:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwNjY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nsimilarity index 79%\nrename from pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nrename to pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\nindex 8f5a527c3a..bcf3afaf60 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/AbstractDefaultRecordExtractor.java\n\n@@ -27,28 +27,33 @@ import javax.annotation.Nullable;\n \n \n /**\n- * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ * Abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n  *\n  * @param <T> the format of the input record\n+ * @param <V> value used for converting the nested/complex fields of the file format (e.g. GenericRecord for Avro).\n+ *            In most cases, this will be the same type as {@code T}.\n  */\n-public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+public abstract class AbstractDefaultRecordExtractor<T, V> implements RecordExtractor<T, Object> {\n \n   /**\n-   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n-   * Returns {@code null} if the value is an empty array/collection/map.\n+   * Converts the field value to either a single value (string, number, bytebuffer), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the field value is {@code null}.\n    *\n    * Natively Pinot only understands single values and multi values.\n    * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n    */\n   @Nullable\n-  public Object convert(Object value) {\n+  public Object convert(@Nullable Object value) {\n+    if (value == null) {\n+      return null;\n+    }\n     Object convertedValue;\n     if (isInstanceOfMultiValue(value)) {\n       convertedValue = convertMultiValue(value);\n     } else if (isInstanceOfMap(value)) {\n       convertedValue = convertMap(value);\n     } else if (isInstanceOfRecord(value)) {\n-      convertedValue = convertRecord(value);\n+      convertedValue = convertRecord((V) value);\n     } else {\n       convertedValue = convertSingleValue(value);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4ODgyNQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502588825", "bodyText": "For this method (and similarly all the ones in BaseRecordExtractor), please add a javadoc for value.\nPreviously we used to cast upfront and the param was directly the type (Collection, GenericRecord etc). But now, we are expecting the right type be provided in value, and casting here without any check. So it would be nice to have a description for the value for all the methods of this nature.", "author": "npawar", "createdAt": "2020-10-09T17:56:54Z", "path": "pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java", "diffHunk": "@@ -49,13 +51,53 @@ public GenericRow extract(GenericRecord from, GenericRow to) {\n       List<Schema.Field> fields = from.getSchema().getFields();\n       for (Schema.Field field : fields) {\n         String fieldName = field.name();\n-        to.putValue(fieldName, AvroUtils.convert(from.get(fieldName)));\n+        Object value = from.get(fieldName);\n+        if (value != null) {\n+          value = convert(value);\n+        }\n+        to.putValue(fieldName, value);\n       }\n     } else {\n       for (String fieldName : _fields) {\n-        to.putValue(fieldName, AvroUtils.convert(from.get(fieldName)));\n+        Object value = from.get(fieldName);\n+        if (value != null) {\n+          value = convert(value);\n+        }\n+        to.putValue(fieldName, value);\n       }\n     }\n     return to;\n   }\n+\n+  /**\n+   * Returns whether the object is an Avro GenericRecord.\n+   */\n+  @Override\n+  protected boolean isInstanceOfRecord(Object value) {\n+    return value instanceof GenericRecord;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the Avro GenericRecord.\n+   */\n+  @Override\n+  @Nullable\n+  protected Object convertRecord(Object value) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzOTczNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503039737", "bodyText": "That's a good idea. Adding a description to these javadocs.", "author": "timsants", "createdAt": "2020-10-12T05:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU4ODgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java b/pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java\nindex 32ef58bfcb..32998afdc2 100644\n--- a/pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java\n+++ b/pinot-plugins/pinot-input-format/pinot-avro-base/src/main/java/org/apache/pinot/plugin/inputformat/avro/AvroRecordExtractor.java\n\n@@ -51,19 +51,11 @@ public class AvroRecordExtractor extends BaseRecordExtractor<GenericRecord> {\n       List<Schema.Field> fields = from.getSchema().getFields();\n       for (Schema.Field field : fields) {\n         String fieldName = field.name();\n-        Object value = from.get(fieldName);\n-        if (value != null) {\n-          value = convert(value);\n-        }\n-        to.putValue(fieldName, value);\n+        to.putValue(fieldName, convert(from.get(fieldName)));\n       }\n     } else {\n       for (String fieldName : _fields) {\n-        Object value = from.get(fieldName);\n-        if (value != null) {\n-          value = convert(value);\n-        }\n-        to.putValue(fieldName, value);\n+        to.putValue(fieldName, convert(from.get(fieldName)));\n       }\n     }\n     return to;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTc4OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502591789", "bodyText": "I think you missed removing this code from extract and also calling convert  above in the extract.", "author": "npawar", "createdAt": "2020-10-09T18:03:02Z", "path": "pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java", "diffHunk": "@@ -69,4 +70,32 @@ public GenericRow extract(CSVRecord from, GenericRow to) {\n     }\n     return to;\n   }\n+\n+  @Override\n+  @Nullable\n+  public Object convert(@Nullable Object value) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyOTg2NQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503029865", "bodyText": "You're right, good catch.", "author": "timsants", "createdAt": "2020-10-12T04:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5MTc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6f17705d48d5dc1fade270134fd77c611c5c5343", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java b/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java\nindex 4eaa03b0a3..3344fc85c5 100644\n--- a/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java\n+++ b/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordExtractor.java\n\n@@ -73,15 +73,14 @@ public class CSVRecordExtractor implements RecordExtractor<CSVRecord> {\n \n   @Override\n   @Nullable\n-  public Object convert(@Nullable Object value) {\n-    String stringValue = (String) value;\n-    if (stringValue == null || StringUtils.isEmpty(stringValue)) {\n+  public Object convert(@Nullable String value) {\n+    if (value == null || StringUtils.isEmpty(value)) {\n       return null;\n       // NOTE about CSV behavior for empty string e.g. foo,bar,,zoo or foo,bar,\"\",zoo. These both are equivalent to a CSVParser\n       // Empty string has to be treated as null, as this could be a column of any data type.\n       // This could be incorrect for STRING dataType, as \"\" could be a legit entry, different than null.\n     } else {\n-      String[] stringValues = StringUtils.split(stringValue, _multiValueDelimiter);\n+      String[] stringValues = StringUtils.split(value, _multiValueDelimiter);\n       int numValues = stringValues.length;\n       // NOTE about CSV behavior for multi value column - cannot distinguish between multi value column with just 1 entry vs single value\n       // MV column with single value will be treated as single value until DataTypeTransformer.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502595891", "bodyText": "i see that in CSV case where fieldsToRead is null, we get fields to read in the RecordReader. Versus, in the JSON/AVRO case we used to make that decision inside the RecordExtractor.\nIs it possible to keep these consistent and always let the RecordExtractor make this decision?", "author": "npawar", "createdAt": "2020-10-09T18:11:25Z", "path": "pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java", "diffHunk": "@@ -95,8 +95,13 @@ public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReader\n     _recordExtractor = new CSVRecordExtractor();\n     CSVRecordExtractorConfig recordExtractorConfig = new CSVRecordExtractorConfig();\n     recordExtractorConfig.setMultiValueDelimiter(multiValueDelimiter);\n-    _recordExtractor.init(fieldsToRead, recordExtractorConfig);\n+\n     init();\n+\n+    if (fieldsToRead == null || fieldsToRead.isEmpty()) {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMTUwMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503031500", "bodyText": "I had the same thought and was debating whether or not to follow the same pattern as the other extractors. I eventually decided to put the \"read all fields\" in the CSVRecordReader because the field names are accessible only through the CSV header and not in the record object being passed to the extract method.\nThe alternate implementation I was thinking of would require that all the CSV column names would be set in a new variable within CSVRecordExtractorConfig. But if most of the time,fieldsToRead is being set, then there would be a duplicated unused Set of field names that will be sent to the `CSVRecordExtractor.", "author": "timsants", "createdAt": "2020-10-12T04:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDEzODgxMA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504138810", "bodyText": "I prefer the alternate implementation. Reason being, the RecordExtractor is a public API. They could be used in external applications. The external users should not have to know that all except CSVRecordExtractor expect fieldsToRead upfront.", "author": "npawar", "createdAt": "2020-10-13T17:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQxMTY0OQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r504411649", "bodyText": "After syncing over Slack, we decided to keep the decision to extract all fields within the extractor in case any other client directly calls the extractor.", "author": "timsants", "createdAt": "2020-10-14T05:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NTg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f528abdce161366cdc728e4032f2277463d26e14", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java b/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java\nindex cb413e7acf..48c9b00164 100644\n--- a/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java\n+++ b/pinot-plugins/pinot-input-format/pinot-csv/src/main/java/org/apache/pinot/plugin/inputformat/csv/CSVRecordReader.java\n\n@@ -93,14 +93,12 @@ public class CSVRecordReader implements RecordReader {\n       multiValueDelimiter = config.getMultiValueDelimiter();\n     }\n     _recordExtractor = new CSVRecordExtractor();\n-    CSVRecordExtractorConfig recordExtractorConfig = new CSVRecordExtractorConfig();\n-    recordExtractorConfig.setMultiValueDelimiter(multiValueDelimiter);\n \n     init();\n \n-    if (fieldsToRead == null || fieldsToRead.isEmpty()) {\n-      fieldsToRead = _parser.getHeaderMap().keySet();\n-    }\n+    CSVRecordExtractorConfig recordExtractorConfig = new CSVRecordExtractorConfig();\n+    recordExtractorConfig.setMultiValueDelimiter(multiValueDelimiter);\n+    recordExtractorConfig.setColumnNames(_parser.getHeaderMap().keySet());\n     _recordExtractor.init(fieldsToRead, recordExtractorConfig);\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNDc2Ng==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502624766", "bodyText": "if this is true for all extractor tests now, can we remove this method and just default to testing extractAll?", "author": "npawar", "createdAt": "2020-10-09T19:12:22Z", "path": "pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.plugin.inputformat.thrift;\n+\n+import com.google.common.collect.Sets;\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.pinot.spi.data.readers.AbstractRecordExtractorTest;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.thrift.TException;\n+import org.apache.thrift.protocol.TBinaryProtocol;\n+import org.apache.thrift.transport.TIOStreamTransport;\n+\n+\n+/**\n+ * Tests for the {@link ThriftRecordExtractor}\n+ */\n+public class ThriftRecordExtractorTest extends AbstractRecordExtractorTest {\n+\n+  private File _tempFile = new File(_tempDir, \"test_complex_thrift.data\");\n+\n+  private static final String INT_FIELD = \"intField\";\n+  private static final String LONG_FIELD = \"longField\";\n+  private static final String BOOL_FIELD = \"booleanField\";\n+  private static final String DOUBLE_FIELD = \"doubleField\";\n+  private static final String STRING_FIELD = \"stringField\";\n+  private static final String ENUM_FIELD = \"enumField\";\n+  private static final String OPTIONAL_STRING_FIELD = \"optionalStringField\";\n+  private static final String NESTED_STRUCT_FIELD = \"nestedStructField\";\n+  private static final String SIMPLE_LIST = \"simpleListField\";\n+  private static final String COMPLEX_LIST = \"complexListField\";\n+  private static final String SIMPLE_MAP = \"simpleMapField\";\n+  private static final String COMPLEX_MAP = \"complexMapField\";\n+  private static final String NESTED_STRING_FIELD = \"nestedStringField\";\n+  private static final String NESTED_INT_FIELD = \"nestedIntField\";\n+\n+  @Override\n+  protected List<Map<String, Object>> getInputRecords() {\n+    return Arrays.asList(createRecord1(), createRecord2());\n+  }\n+\n+  @Override\n+  protected Set<String> getSourceFields() {\n+    return Sets.newHashSet(INT_FIELD, LONG_FIELD, BOOL_FIELD, DOUBLE_FIELD, STRING_FIELD, ENUM_FIELD,\n+        OPTIONAL_STRING_FIELD, NESTED_STRUCT_FIELD, SIMPLE_LIST, COMPLEX_LIST, SIMPLE_MAP, COMPLEX_MAP);\n+  }\n+\n+  /**\n+   * Creates a ThriftRecordReader\n+   */\n+  @Override\n+  protected RecordReader createRecordReader(Set<String> fieldsToRead)\n+      throws IOException {\n+    ThriftRecordReader recordReader = new ThriftRecordReader();\n+    recordReader.init(_tempFile, getSourceFields(), getThriftRecordReaderConfig());\n+    return recordReader;\n+  }\n+\n+  private ThriftRecordReaderConfig getThriftRecordReaderConfig() {\n+    ThriftRecordReaderConfig config = new ThriftRecordReaderConfig();\n+    config.setThriftClass(\"org.apache.pinot.plugin.inputformat.thrift.ComplexTypes\");\n+    return config;\n+  }\n+\n+  /**\n+   * Create a data input file using input records containing various Thrift record types\n+   */\n+  @Override\n+  protected void createInputFile()\n+      throws IOException {\n+    List<ComplexTypes> thriftRecords = new ArrayList<>(2);\n+\n+    for (Map<String, Object> inputRecord : _inputRecords) {\n+      ComplexTypes thriftRecord = new ComplexTypes();\n+      thriftRecord.setIntField((int) inputRecord.get(INT_FIELD));\n+      thriftRecord.setLongField((long) inputRecord.get(LONG_FIELD));\n+\n+      Map<String, Object> nestedStructValues = (Map<String, Object>) inputRecord.get(NESTED_STRUCT_FIELD);\n+      thriftRecord.setNestedStructField(createNestedType(\n+          (String) nestedStructValues.get(NESTED_STRING_FIELD),\n+          (int) nestedStructValues.get(NESTED_INT_FIELD))\n+      );\n+\n+      thriftRecord.setSimpleListField((List<String>) inputRecord.get(SIMPLE_LIST));\n+\n+      List<NestedType> nestedTypeList = new ArrayList<>();\n+      for (Map element : (List<Map>) inputRecord.get(COMPLEX_LIST)) {\n+        nestedTypeList.add(createNestedType((String) element.get(NESTED_STRING_FIELD),\n+            (Integer) element.get(NESTED_INT_FIELD)));\n+      }\n+\n+      thriftRecord.setComplexListField(nestedTypeList);\n+      thriftRecord.setBooleanField(Boolean.valueOf((String) inputRecord.get(BOOL_FIELD)));\n+      thriftRecord.setDoubleField((Double) inputRecord.get(DOUBLE_FIELD));\n+      thriftRecord.setStringField((String) inputRecord.get(STRING_FIELD));\n+      thriftRecord.setEnumField(TestEnum.valueOf((String) inputRecord.get(ENUM_FIELD)));\n+      thriftRecord.setSimpleMapField((Map<String, Integer>) inputRecord.get(SIMPLE_MAP));\n+\n+      Map<String, NestedType> complexMap = new HashMap<>();\n+      for (Map.Entry<String, Map<String, Object>> entry :\n+          ((Map<String, Map<String, Object>>) inputRecord.get(COMPLEX_MAP)).entrySet()) {\n+        complexMap.put(entry.getKey(), createNestedType(\n+            (String) entry.getValue().get(NESTED_STRING_FIELD),\n+            (int) entry.getValue().get(NESTED_INT_FIELD)));\n+      }\n+      thriftRecord.setComplexMapField(complexMap);\n+      thriftRecords.add(thriftRecord);\n+    }\n+\n+    BufferedOutputStream bufferedOut = new BufferedOutputStream(new FileOutputStream(_tempFile));\n+    TBinaryProtocol binaryOut = new TBinaryProtocol(new TIOStreamTransport(bufferedOut));\n+    for (ComplexTypes record : thriftRecords) {\n+      try {\n+        record.write(binaryOut);\n+      } catch (TException e) {\n+        throw new IOException(e);\n+      }\n+    }\n+    bufferedOut.close();\n+  }\n+\n+  private Map<String, Object> createRecord1() {\n+    Map<String, Object> record = new HashMap<>();\n+    record.put(STRING_FIELD, \"hello\");\n+    record.put(INT_FIELD, 10);\n+    record.put(LONG_FIELD, 1000L);\n+    record.put(DOUBLE_FIELD, 1.0);\n+    record.put(BOOL_FIELD, \"false\");\n+    record.put(ENUM_FIELD, TestEnum.DELTA.toString());\n+    record.put(NESTED_STRUCT_FIELD, createNestedMap(NESTED_STRING_FIELD, \"ice cream\", NESTED_INT_FIELD, 5));\n+    record.put(SIMPLE_LIST, Arrays.asList(\"aaa\", \"bbb\", \"ccc\"));\n+    record.put(COMPLEX_LIST,\n+        Arrays.asList(\n+            createNestedMap(NESTED_STRING_FIELD, \"hows\", NESTED_INT_FIELD, 10),\n+            createNestedMap(NESTED_STRING_FIELD, \"it\", NESTED_INT_FIELD, 20),\n+            createNestedMap(NESTED_STRING_FIELD, \"going\", NESTED_INT_FIELD, 30)\n+        )\n+    );\n+    record.put(SIMPLE_MAP, createNestedMap(\"Tuesday\", 3, \"Wednesday\", 4));\n+    record.put(\n+        COMPLEX_MAP,\n+        createNestedMap(\n+            \"fruit1\", createNestedMap(NESTED_STRING_FIELD, \"apple\", NESTED_INT_FIELD, 1),\n+            \"fruit2\", createNestedMap(NESTED_STRING_FIELD, \"orange\", NESTED_INT_FIELD, 2)\n+        )\n+    );\n+    return record;\n+  }\n+\n+  private Map<String, Object> createRecord2() {\n+    Map<String, Object> record = new HashMap<>();\n+    record.put(STRING_FIELD, \"world\");\n+    record.put(INT_FIELD, 20);\n+    record.put(LONG_FIELD, 2000L);\n+    record.put(DOUBLE_FIELD, 2.0);\n+    record.put(BOOL_FIELD, \"false\");\n+    record.put(ENUM_FIELD, TestEnum.GAMMA.toString());\n+    record.put(NESTED_STRUCT_FIELD, createNestedMap(NESTED_STRING_FIELD, \"ice cream\", NESTED_INT_FIELD, 5));\n+    record.put(SIMPLE_LIST, Arrays.asList(\"aaa\", \"bbb\", \"ccc\"));\n+    record.put(COMPLEX_LIST,\n+        Arrays.asList(\n+            createNestedMap(NESTED_STRING_FIELD, \"hows\", NESTED_INT_FIELD, 10),\n+            createNestedMap(NESTED_STRING_FIELD, \"it\", NESTED_INT_FIELD, 20),\n+            createNestedMap(NESTED_STRING_FIELD, \"going\", NESTED_INT_FIELD, 30)\n+        )\n+    );\n+    record.put(SIMPLE_MAP, createNestedMap(\"Tuesday\", 3, \"Wednesday\", 4));\n+    record.put(\n+        COMPLEX_MAP,\n+        createNestedMap(\n+            \"fruit1\", createNestedMap(NESTED_STRING_FIELD, \"apple\", NESTED_INT_FIELD, 1),\n+            \"fruit2\", createNestedMap(NESTED_STRING_FIELD, \"orange\", NESTED_INT_FIELD, 2)\n+        )\n+    );\n+    return record;\n+  }\n+\n+  private Map<String, Object> createNestedMap(String key1, Object value1, String key2, Object value2) {\n+    Map<String, Object> nestedMap = new HashMap<>(2);\n+    nestedMap.put(key1, value1);\n+    nestedMap.put(key2, value2);\n+    return nestedMap;\n+  }\n+\n+  private NestedType createNestedType(String stringField, int intField) {\n+    NestedType nestedRecord = new NestedType();\n+    nestedRecord.setNestedStringField(stringField);\n+    nestedRecord.setNestedIntField(intField);\n+    return nestedRecord;\n+  }\n+\n+  @Override\n+  protected boolean testExtractAll() {", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzNDAyOA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503034028", "bodyText": "Good call. We can remove this method now and testing the extract all code path will be part of all the tests.", "author": "timsants", "createdAt": "2020-10-12T04:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNDc2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "chunk": "diff --git a/pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java b/pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java\nindex e29e3a5a8c..28d6c65b52 100644\n--- a/pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java\n+++ b/pinot-plugins/pinot-input-format/pinot-thrift/src/test/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordExtractorTest.java\n\n@@ -212,9 +212,4 @@ public class ThriftRecordExtractorTest extends AbstractRecordExtractorTest {\n     nestedRecord.setNestedIntField(intField);\n     return nestedRecord;\n   }\n-\n-  @Override\n-  protected boolean testExtractAll() {\n-    return true;\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjExNA==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r502626114", "bodyText": "I didn't follow this change, could you explain what's happening here?", "author": "npawar", "createdAt": "2020-10-09T19:15:34Z", "path": "pinot-plugins/pinot-input-format/pinot-thrift/src/main/java/org/apache/pinot/plugin/inputformat/thrift/ThriftRecordReader.java", "diffHunk": "@@ -61,12 +62,13 @@ public void init(File dataFile, Set<String> fieldsToRead, @Nullable RecordReader\n     } catch (Exception e) {\n       throw new RuntimeException(e);\n     }\n-    int index = 1;\n-    TFieldIdEnum tFieldIdEnum;\n-    while ((tFieldIdEnum = tObject.fieldForId(index)) != null) {\n-      _fieldIds.put(tFieldIdEnum.getFieldName(), index);\n-      index++;\n+", "originalCommit": "e139c6af2fd77cb617c00c2f83d79d860c1f3d92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzNTEwNg==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r503035106", "bodyText": "As discussed over Slack, there was a bug in how we were parsing Thrift fields. Thrift field IDs are not guaranteed to be consecutive, which was previous assumed. If a Thrift record did not have consecutive field IDs, the extractor would break/incorrectly extract values.", "author": "timsants", "createdAt": "2020-10-12T04:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjExNA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "6f17705d48d5dc1fade270134fd77c611c5c5343", "url": "https://github.com/apache/pinot/commit/6f17705d48d5dc1fade270134fd77c611c5c5343", "message": "Deep Extraction Support for ORC, Thrift, and ProtoBuf Records\n\n1. PR for issue #5507. ORC, Thrift, and ProtoBuf readers now convert:\n  - Nested structures to Map\n  - Collection to Object[]\n  - Number/String/bytebuffer to single value\n2. All extractors now support extracting all fields if fieldsToRead is null/empty (issue #5677). This support was\n   added to ORCRecordExtractor, ThriftRecordExtractor, ProtoBufRecordExtractor, and CSVRecordRecord.\n3. Extractor Util Cleanup:\n     There were duplicate implementations for extractors converters across RecordReaderUtils, JsonRecordExtractorUtils,\n     and AvroUtils. This PR adds a new method, \u201cObject convert(Object value)\u201d, to the RecordExtractor interface, as\n     this is a method that all extractors should implement to convert each field of the file format. A new abstract\n     class was created that extends RecordExtractor to contain the repeated logic across RecordReaderUtils,\n     JsonRecordExtractorUtils, and AvroUtils. The abstract class also defines the common methods for recursively\n     handling maps, collections, records and single values.", "committedDate": "2020-10-12T05:13:50Z", "type": "commit"}, {"oid": "d2c4a779e71e3d63d0bb18acf98b4ee5f730d3d0", "url": "https://github.com/apache/pinot/commit/d2c4a779e71e3d63d0bb18acf98b4ee5f730d3d0", "message": "Removed javax annotation from Thrift autogenerated Java files to be complaint with JDK11", "committedDate": "2020-10-12T05:13:50Z", "type": "commit"}, {"oid": "e1b352eb9c72d7cc9780e9953a13cb2db2248604", "url": "https://github.com/apache/pinot/commit/e1b352eb9c72d7cc9780e9953a13cb2db2248604", "message": "Changed name of AbstractDefaultRecordExtractor -> BaseRecordExtractor. Also removed unecessary generic type added to RecordExtractor.", "committedDate": "2020-10-12T05:13:50Z", "type": "commit"}, {"oid": "afa97cf21dafd8d3ea1136b4de85ed27271b7ec1", "url": "https://github.com/apache/pinot/commit/afa97cf21dafd8d3ea1136b4de85ed27271b7ec1", "message": "Removing the use of lambda expressions when extracting all fields", "committedDate": "2020-10-12T05:13:51Z", "type": "commit"}, {"oid": "522005d39776d495a3427d60134bfde442c3c11a", "url": "https://github.com/apache/pinot/commit/522005d39776d495a3427d60134bfde442c3c11a", "message": "Checking for null values before calling extractor convert. Also re-ordering the sequence of checks to be collection -> map -> record -> single-value in ORCRecordReader to be consistent with the other extractors.", "committedDate": "2020-10-12T05:13:51Z", "type": "commit"}, {"oid": "de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "url": "https://github.com/apache/pinot/commit/de8ad5e223e40aedec88ab8eab3a955e949c0b2e", "message": "Made handling of null map keys/values consistent with multi-value. Added documentation for the value passed to the map, multivalue, and record converters.", "committedDate": "2020-10-12T05:13:52Z", "type": "commit"}, {"oid": "f528abdce161366cdc728e4032f2277463d26e14", "url": "https://github.com/apache/pinot/commit/f528abdce161366cdc728e4032f2277463d26e14", "message": "Move read all fields responsibility from CSVRecordReader to CSVRecordExtractor. Also making CSVRecordExtractor extend BaseRecordExtractor", "committedDate": "2020-10-14T06:00:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkxODYyOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r505918629", "bodyText": "Shall we add some comments here about the behavior of the empty string?", "author": "Jackie-Jiang", "createdAt": "2020-10-15T23:22:56Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   *\n+   * @param value should be verified to be a record type prior to calling this method as it will be handled with this\n+   *              assumption\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   *\n+   * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n+   *              to a Collection without checking\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {", "originalCommit": "f528abdce161366cdc728e4032f2277463d26e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA0NjYzNQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r506046635", "bodyText": "I'll mention this nuance in the method's javadoc.", "author": "timsants", "createdAt": "2020-10-16T04:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkxODYyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "bd6618924809944ed92619fccef230ab1967c439", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex 2667f78080..87e3bd3d4e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -95,8 +95,10 @@ public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n    * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n    * {@code null}.\n    *\n-   * This implementation converts the Collection to an Object array. Override this method if the data format\n-   * requires a different conversion for its multi-value objects.\n+   * This implementation converts the Collection to an Object array. Any elements of the Collection that are\n+   * {@code null} or an empty string will be excluded from the returned multi-value object.\n+   *\n+   * Override this method if the data format requires a different conversion for its multi-value objects.\n    *\n    * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n    *              to a Collection without checking\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r505920319", "bodyText": "We should also preserve byte[]\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (value instanceof Number) {\n          \n          \n            \n                if (value instanceof Number || value instanceof byte[]) {", "author": "Jackie-Jiang", "createdAt": "2020-10-15T23:28:26Z", "path": "pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.spi.data.readers;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * Base abstract class for extracting and converting the fields of various data formats into supported Pinot data types.\n+ *\n+ * @param <T> the format of the input record\n+ */\n+public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n+\n+  /**\n+   * Converts the field value to either a single value (string, number, byte[]), multi value (Object[]) or a Map.\n+   * Returns {@code null} if the value is an empty array/collection/map.\n+   *\n+   * Natively Pinot only understands single values and multi values.\n+   * Map is useful only if some ingestion transform functions operates on it in the transformation layer.\n+   */\n+  @Nullable\n+  public Object convert(Object value) {\n+    Object convertedValue;\n+    if (isMultiValue(value)) {\n+      convertedValue = convertMultiValue(value);\n+    } else if (isMap(value)) {\n+      convertedValue = convertMap(value);\n+    } else if (isRecord(value)) {\n+      convertedValue = convertRecord(value);\n+    } else {\n+      convertedValue = convertSingleValue(value);\n+    }\n+    return convertedValue;\n+  }\n+\n+  /**\n+   * Returns whether the object is of the data format's base type. Override this method if the extractor\n+   * can handle the conversion of nested record types.\n+   */\n+  protected boolean isRecord(Object value) {\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a multi-value type. Override this method if the data format represents\n+   * multi-value objects differently.\n+   */\n+  protected boolean isMultiValue(Object value) {\n+    return value instanceof Collection;\n+  }\n+\n+  /**\n+   * Returns whether the object is of a map type. Override this method if the data format represents map objects\n+   * differently.\n+   */\n+  protected boolean isMap(Object value) {\n+    return value instanceof Map;\n+  }\n+\n+  /**\n+   * Handles the conversion of every field of the object for the particular data format. Override this method if the\n+   * extractor can convert nested record types.\n+   *\n+   * @param value should be verified to be a record type prior to calling this method as it will be handled with this\n+   *              assumption\n+   */\n+  @Nullable\n+  protected Object convertRecord(Object value) {\n+    throw new UnsupportedOperationException(\"Extractor cannot convert record type structures for this data format.\");\n+  }\n+\n+  /**\n+   * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n+   * {@code null}.\n+   *\n+   * This implementation converts the Collection to an Object array. Override this method if the data format\n+   * requires a different conversion for its multi-value objects.\n+   *\n+   * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n+   *              to a Collection without checking\n+   */\n+  @Nullable\n+  protected Object convertMultiValue(Object value) {\n+    Collection collection = (Collection) value;\n+    if (collection.isEmpty()) {\n+      return null;\n+    }\n+\n+    int numValues = collection.size();\n+    Object[] array = new Object[numValues];\n+    int index = 0;\n+    for (Object element : collection) {\n+      Object convertedValue = null;\n+      if (element != null) {\n+        convertedValue = convert(element);\n+      }\n+      if (convertedValue != null && !convertedValue.toString().equals(\"\")) {\n+        array[index++] = convertedValue;\n+      }\n+    }\n+\n+    if (index == numValues) {\n+      return array;\n+    } else if (index == 0) {\n+      return null;\n+    } else {\n+      return Arrays.copyOf(array, index);\n+    }\n+  }\n+\n+  /**\n+   * Handles the conversion of every value of the map. Note that map keys will be handled as a single-value type.\n+   * Returns {@code null} if the field value is {@code null}. This should be overridden if the data format requires\n+   * a different conversion for map values.\n+   *\n+   * @param value should be verified to be a Map type prior to calling this method as it will be casted to a Map\n+   *              without checking\n+   */\n+  @Nullable\n+  protected Object convertMap(Object value) {\n+    Map<Object, Object> map = (Map) value;\n+    if (map.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<Object, Object> convertedMap = new HashMap<>();\n+    for (Map.Entry<Object, Object> entry : map.entrySet()) {\n+      Object mapKey = entry.getKey();\n+      Object mapValue = entry.getValue();\n+      if (mapKey != null) {\n+        Object convertedMapValue = null;\n+        if (mapValue != null) {\n+          convertedMapValue = convert(mapValue);\n+        }\n+\n+        if (convertedMapValue != null) {\n+          convertedMap.put(convertSingleValue(entry.getKey()), convertedMapValue);\n+        }\n+      }\n+    }\n+\n+    if (convertedMap.isEmpty()) {\n+      return null;\n+    }\n+\n+    return convertedMap;\n+  }\n+\n+  /**\n+   * Converts single value types. This should be overridden if the data format requires\n+   * a different conversion for its single values.\n+   */\n+  protected Object convertSingleValue(Object value) {\n+    if (value instanceof ByteBuffer) {\n+      ByteBuffer byteBufferValue = (ByteBuffer) value;\n+\n+      // Use byteBufferValue.remaining() instead of byteBufferValue.capacity() so that it still works when buffer is\n+      // over-sized\n+      byte[] bytesValue = new byte[byteBufferValue.remaining()];\n+      byteBufferValue.get(bytesValue);\n+      return bytesValue;\n+    }\n+    if (value instanceof Number) {", "originalCommit": "f528abdce161366cdc728e4032f2277463d26e14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA0NTgxNw==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r506045817", "bodyText": "Yea that makes sense given that bytebuffer is converted to byte[].", "author": "timsants", "createdAt": "2020-10-16T04:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1MjM1MQ==", "url": "https://github.com/apache/pinot/pull/6046#discussion_r506052351", "bodyText": "I'll make this change although I don't see any data formats that use this method returning byte[].", "author": "timsants", "createdAt": "2020-10-16T04:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyMDMxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "bd6618924809944ed92619fccef230ab1967c439", "chunk": "diff --git a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\nindex 2667f78080..87e3bd3d4e 100644\n--- a/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n+++ b/pinot-spi/src/main/java/org/apache/pinot/spi/data/readers/BaseRecordExtractor.java\n\n@@ -95,8 +95,10 @@ public abstract class BaseRecordExtractor<T> implements RecordExtractor<T> {\n    * Handles the conversion of each element of a multi-value object. Returns {@code null} if the field value is\n    * {@code null}.\n    *\n-   * This implementation converts the Collection to an Object array. Override this method if the data format\n-   * requires a different conversion for its multi-value objects.\n+   * This implementation converts the Collection to an Object array. Any elements of the Collection that are\n+   * {@code null} or an empty string will be excluded from the returned multi-value object.\n+   *\n+   * Override this method if the data format requires a different conversion for its multi-value objects.\n    *\n    * @param value should be verified to be a Collection type prior to calling this method as it will be casted\n    *              to a Collection without checking\n"}}, {"oid": "bd6618924809944ed92619fccef230ab1967c439", "url": "https://github.com/apache/pinot/commit/bd6618924809944ed92619fccef230ab1967c439", "message": "Adding comment for how empty string is handled for multivalues. Also preserving byte[] in single value conversion.", "committedDate": "2020-10-16T05:01:22Z", "type": "commit"}]}