{"pr_number": 6120, "pr_title": "Add FST Index using lucene lib to speedup regexp queries", "pr_createdAt": "2020-10-08T16:50:29Z", "pr_url": "https://github.com/apache/pinot/pull/6120", "timeline": [{"oid": "ca17a6314c2b7d782f39238914a0a20ed39b3c74", "url": "https://github.com/apache/pinot/commit/ca17a6314c2b7d782f39238914a0a20ed39b3c74", "message": "cleanups of logs, unused headers and code", "committedDate": "2020-10-08T23:22:37Z", "type": "forcePushed"}, {"oid": "46fdd9a3fbd3e330dd84523ca4b648f2563b982c", "url": "https://github.com/apache/pinot/commit/46fdd9a3fbd3e330dd84523ca4b648f2563b982c", "message": "Remove preconditions check on bitmapbasedfilteroperation and return empty filter block when no matching dictionary items", "committedDate": "2020-10-14T21:52:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTkyNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515319926", "bodyText": "why null?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:09:56Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java", "diffHunk": "@@ -1063,12 +1072,14 @@ void updateMVEntry(int numValuesInMVEntry) {\n       _textIndex = textIndex;\n       _bloomFilter = bloomFilter;\n       _nullValueVector = nullValueVector;\n+      _fstIndexEnabled = fstIndexEnabled;\n     }\n \n     DataSource toDataSource() {\n       return new MutableDataSource(_fieldSpec, _numDocsIndexed, _numValuesInfo._numValues,\n-          _numValuesInfo._maxNumValuesPerMVEntry, _partitionFunction, _partitions, _minValue, _maxValue, _forwardIndex,\n-          _dictionary, _invertedIndex, _rangeIndex, _textIndex, _bloomFilter, _nullValueVector);\n+          _numValuesInfo._maxNumValuesPerMVEntry, _fstIndexEnabled, _partitionFunction, _partitions, _minValue, _maxValue, _forwardIndex,\n+          _dictionary, _invertedIndex, _rangeIndex, _textIndex, null,", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzNzQzMg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524437432", "bodyText": "FST Index is currently not built for consuming segment, only when the segment is rolled out FST index is\ngenerated", "author": "pradeepgv42", "createdAt": "2020-11-16T17:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTkyNg=="}], "type": "inlineReview", "revised_code": {"commit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java b/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\nindex be5e4f8ca1..fb839c275c 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/indexsegment/mutable/MutableSegmentImpl.java\n\n@@ -1076,10 +1075,12 @@ public class MutableSegmentImpl implements MutableSegment {\n     }\n \n     DataSource toDataSource() {\n+      // FST Index is currently not built for consuming segment, only when the segment is rolled out FST index is\n+      // generated.\n       return new MutableDataSource(_fieldSpec, _numDocsIndexed, _numValuesInfo._numValues,\n-          _numValuesInfo._maxNumValuesPerMVEntry, _fstIndexEnabled, _partitionFunction, _partitions, _minValue, _maxValue, _forwardIndex,\n-          _dictionary, _invertedIndex, _rangeIndex, _textIndex, null,\n-          _bloomFilter, _nullValueVector);\n+          _numValuesInfo._maxNumValuesPerMVEntry, _fstIndexEnabled, _partitionFunction, _partitions, _minValue,\n+          _maxValue, _forwardIndex, _dictionary, _invertedIndex, _rangeIndex, _textIndex, null, _bloomFilter,\n+          _nullValueVector);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk0OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515319948", "bodyText": "Why this change?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:00Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/BitmapBasedFilterOperator.java", "diffHunk": "@@ -66,8 +67,9 @@ protected FilterBlock getNextBlock() {\n \n     int[] dictIds = _exclusive ? _predicateEvaluator.getNonMatchingDictIds() : _predicateEvaluator.getMatchingDictIds();\n     int numDictIds = dictIds.length;\n-    // NOTE: PredicateEvaluator without matching/non-matching dictionary ids should not reach here.\n-    Preconditions.checkState(numDictIds > 0);\n+    if (numDictIds == 0) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzOTIxMw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524439213", "bodyText": "Without this precondition fails, I checked with Jackie who added this condition he mentioned it should be fine to remove this. Reason could be because I enabled regexp operator to use bitmap based filter when FST index is available.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk0OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515319993", "bodyText": "Please add javadocs", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:06Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter.predicate;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.core.segment.index.readers.TextIndexReader;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+\n+import static org.apache.pinot.core.query.request.context.predicate.Predicate.Type.REGEXP_LIKE;\n+\n+public class FSTBasedRegexpPredicateEvaluatorFactory {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQzOTYwMg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524439602", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T17:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMxOTk5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java\nindex 9d9d8de29b..63f881a733 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java\n\n@@ -29,21 +29,50 @@ import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n \n import static org.apache.pinot.core.query.request.context.predicate.Predicate.Type.REGEXP_LIKE;\n \n+\n+/**\n+ * Factory for REGEXP_LIKE predicate evaluators when FST index is enabled.\n+ */\n public class FSTBasedRegexpPredicateEvaluatorFactory {\n     public FSTBasedRegexpPredicateEvaluatorFactory() {}\n \n+    /**\n+     * Creates a predicate evaluator which matches the regexp query pattern using\n+     * FST Index available. FST Index is not yet present for consuming segments,\n+     * so use newAutomatonBasedEvaluator for consuming segments.\n+     *\n+     * @param fstIndexReader FST Index reader\n+     * @param dictionary Dictionary for the column\n+     * @param regexpQuery input query to match\n+     * @return Predicate evaluator\n+     */\n     public static BaseDictionaryBasedPredicateEvaluator newFSTBasedEvaluator(\n             TextIndexReader fstIndexReader, Dictionary dictionary, String regexpQuery) {\n         return new FSTBasedRegexpPredicateEvaluatorFactory.FSTBasedRegexpPredicateEvaluator(\n                 fstIndexReader, dictionary, regexpQuery);\n     }\n \n+    /**\n+     * Creates a predicate evaluator which uses regex matching logic which is similar to\n+     * FSTBasedRegexpPredicateEvaluator. This predicate evaluator is used for consuming\n+     * segments and is there to make sure results are consistent between consuming and\n+     * rolled out segments when FST index is enabled.\n+     *\n+     * @param dictionary Dictionary for the column\n+     * @param regexpQuery input query to match\n+     * @return Predicate evaluator\n+     */\n     public static BaseDictionaryBasedPredicateEvaluator newAutomatonBasedEvaluator(\n             Dictionary dictionary, String regexpQuery) {\n         return new FSTBasedRegexpPredicateEvaluatorFactory.AutomatonBasedRegexpPredicateEvaluator(\n                 regexpQuery, dictionary);\n     }\n \n+    /**\n+     * This predicate evaluator is created to be used for consuming segments. This evaluator\n+     * creates automaton following very similar logic to that of FSTBasedRegexpPredicateEvaluator,\n+     * so the results stay consistent across consuming and rolled out segments.\n+     */\n     private static class AutomatonBasedRegexpPredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {\n         private final RegexpMatcher _regexpMatcher;\n         private final Dictionary _dictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDAxNA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320014", "bodyText": "What's the difference between both predicate evaluators?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:10Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.operator.filter.predicate;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntArrayList;\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.pinot.core.query.request.context.predicate.Predicate;\n+import org.apache.pinot.core.segment.index.readers.Dictionary;\n+import org.apache.pinot.core.segment.index.readers.TextIndexReader;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+\n+import static org.apache.pinot.core.query.request.context.predicate.Predicate.Type.REGEXP_LIKE;\n+\n+public class FSTBasedRegexpPredicateEvaluatorFactory {\n+    public FSTBasedRegexpPredicateEvaluatorFactory() {}\n+\n+    public static BaseDictionaryBasedPredicateEvaluator newFSTBasedEvaluator(\n+            TextIndexReader fstIndexReader, Dictionary dictionary, String regexpQuery) {\n+        return new FSTBasedRegexpPredicateEvaluatorFactory.FSTBasedRegexpPredicateEvaluator(\n+                fstIndexReader, dictionary, regexpQuery);\n+    }\n+\n+    public static BaseDictionaryBasedPredicateEvaluator newAutomatonBasedEvaluator(\n+            Dictionary dictionary, String regexpQuery) {\n+        return new FSTBasedRegexpPredicateEvaluatorFactory.AutomatonBasedRegexpPredicateEvaluator(\n+                regexpQuery, dictionary);\n+    }\n+\n+    private static class AutomatonBasedRegexpPredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {\n+        private final RegexpMatcher _regexpMatcher;\n+        private final Dictionary _dictionary;\n+        int[] _matchingDictIds;\n+\n+        public AutomatonBasedRegexpPredicateEvaluator(String searchQuery, Dictionary dictionary) {\n+            _regexpMatcher = new RegexpMatcher(searchQuery, null);\n+            _dictionary = dictionary;\n+        }\n+\n+        @Override\n+        public Predicate.Type getPredicateType() {\n+            return REGEXP_LIKE;\n+        }\n+\n+        @Override\n+        public boolean applySV(int dictId) {\n+            return _regexpMatcher.match(_dictionary.getStringValue(dictId));\n+        }\n+\n+        @Override\n+        public int[] getMatchingDictIds() {\n+            if (_matchingDictIds == null) {\n+                IntList matchingDictIds = new IntArrayList();\n+                int dictionarySize = _dictionary.length();\n+                for (int dictId = 0; dictId < dictionarySize; dictId++) {\n+                    if (applySV(dictId)) {\n+                        matchingDictIds.add(dictId);\n+                    }\n+                }\n+                _matchingDictIds = matchingDictIds.toIntArray();\n+            }\n+            return _matchingDictIds;\n+        }\n+    }\n+\n+    private static class FSTBasedRegexpPredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0MjcxMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524442711", "bodyText": "FSTBasedRegexpPredicateEvaluator is used for rolled out segments and AutomatonBasedRegexpPredicateEvaluator for consuming segments. Reason for this is because java regexp matcher is much broader than the regexp matcher I am borrowing from lucene. So, to keep the results consistent between consuming and rolled out segments I am using similar matching logic when fst index is enabled.\nTo reduce complexity here we could either:\n\nswitch regexp_like to use this matching using lucene lib everywhere\nor\ncreate a new operator.\n\nMaybe in future if there is a native automaton building library, this will simplify things.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0Mjk4Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524442982", "bodyText": "Added comments too, let me know if I should expand more", "author": "pradeepgv42", "createdAt": "2020-11-16T17:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java\nindex 9d9d8de29b..63f881a733 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/operator/filter/predicate/FSTBasedRegexpPredicateEvaluatorFactory.java\n\n@@ -29,21 +29,50 @@ import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n \n import static org.apache.pinot.core.query.request.context.predicate.Predicate.Type.REGEXP_LIKE;\n \n+\n+/**\n+ * Factory for REGEXP_LIKE predicate evaluators when FST index is enabled.\n+ */\n public class FSTBasedRegexpPredicateEvaluatorFactory {\n     public FSTBasedRegexpPredicateEvaluatorFactory() {}\n \n+    /**\n+     * Creates a predicate evaluator which matches the regexp query pattern using\n+     * FST Index available. FST Index is not yet present for consuming segments,\n+     * so use newAutomatonBasedEvaluator for consuming segments.\n+     *\n+     * @param fstIndexReader FST Index reader\n+     * @param dictionary Dictionary for the column\n+     * @param regexpQuery input query to match\n+     * @return Predicate evaluator\n+     */\n     public static BaseDictionaryBasedPredicateEvaluator newFSTBasedEvaluator(\n             TextIndexReader fstIndexReader, Dictionary dictionary, String regexpQuery) {\n         return new FSTBasedRegexpPredicateEvaluatorFactory.FSTBasedRegexpPredicateEvaluator(\n                 fstIndexReader, dictionary, regexpQuery);\n     }\n \n+    /**\n+     * Creates a predicate evaluator which uses regex matching logic which is similar to\n+     * FSTBasedRegexpPredicateEvaluator. This predicate evaluator is used for consuming\n+     * segments and is there to make sure results are consistent between consuming and\n+     * rolled out segments when FST index is enabled.\n+     *\n+     * @param dictionary Dictionary for the column\n+     * @param regexpQuery input query to match\n+     * @return Predicate evaluator\n+     */\n     public static BaseDictionaryBasedPredicateEvaluator newAutomatonBasedEvaluator(\n             Dictionary dictionary, String regexpQuery) {\n         return new FSTBasedRegexpPredicateEvaluatorFactory.AutomatonBasedRegexpPredicateEvaluator(\n                 regexpQuery, dictionary);\n     }\n \n+    /**\n+     * This predicate evaluator is created to be used for consuming segments. This evaluator\n+     * creates automaton following very similar logic to that of FSTBasedRegexpPredicateEvaluator,\n+     * so the results stay consistent across consuming and rolled out segments.\n+     */\n     private static class AutomatonBasedRegexpPredicateEvaluator extends BaseDictionaryBasedPredicateEvaluator {\n         private final RegexpMatcher _regexpMatcher;\n         private final Dictionary _dictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA0Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320043", "bodyText": "Why is the formatting getting changed here?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -122,8 +127,29 @@ private BaseFilterOperator constructPhysicalOperator(FilterContext filter,\n           DataSource dataSource = _indexSegment.getDataSource(lhs.getIdentifier());\n           switch (predicate.getType()) {\n             case TEXT_MATCH:\n-              return new TextMatchFilterOperator(dataSource.getTextIndex(),\n-                  ((TextMatchPredicate) predicate).getValue(), _numDocs);\n+                return new TextMatchFilterOperator(", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0MzI1Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524443252", "bodyText": "restored.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java b/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java\nindex d9d335fd03..c677010f87 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java\n\n@@ -127,29 +132,34 @@ public class FilterPlanNode implements PlanNode {\n           DataSource dataSource = _indexSegment.getDataSource(lhs.getIdentifier());\n           switch (predicate.getType()) {\n             case TEXT_MATCH:\n-                return new TextMatchFilterOperator(\n-                        dataSource.getTextIndex(),\n-                        ((TextMatchPredicate) predicate).getValue(),\n-                        _numDocs);\n+              return new TextMatchFilterOperator(dataSource.getTextIndex(), ((TextMatchPredicate) predicate).getValue(),\n+                  _numDocs);\n             case REGEXP_LIKE:\n               PredicateEvaluator evaluator = null;\n+\n+              // FST Index is available only for rolled out segments. So, we use different\n+              // evaluator for rolled out and consuming segments.\n+              //\n+              // Rolled out segments (immutable): FST Index reader is available use FSTBasedEvaluator\n+              // else use regular flow of getting predicate evaluator.\n+              //\n+              // Consuming segments: when FSTIndex is enabled use AutomatonBasedEvaluator so that regexp\n+              // matching logic is similar to that of FSTBasedEvaluator else use regular flow of getting\n+              // predicate evaluator.\n               if (dataSource.getFSTIndex() != null) {\n-                evaluator = FSTBasedRegexpPredicateEvaluatorFactory.newFSTBasedEvaluator(\n-                        dataSource.getFSTIndex(),\n-                        dataSource.getDictionary(),\n+                evaluator = FSTBasedRegexpPredicateEvaluatorFactory\n+                    .newFSTBasedEvaluator(dataSource.getFSTIndex(), dataSource.getDictionary(),\n                         ((RegexpLikePredicate) predicate).getValue());\n-              } else if (dataSource instanceof MutableDataSource &&\n-                      ((MutableDataSource) dataSource).hasFSTIndexEnabled()) {\n-                evaluator = FSTBasedRegexpPredicateEvaluatorFactory.newAutomatonBasedEvaluator(\n-                        dataSource.getDictionary(),\n+              } else if (dataSource instanceof MutableDataSource && ((MutableDataSource) dataSource)\n+                  .hasFSTIndexEnabled()) {\n+                evaluator = FSTBasedRegexpPredicateEvaluatorFactory\n+                    .newAutomatonBasedEvaluator(dataSource.getDictionary(),\n                         ((RegexpLikePredicate) predicate).getValue());\n               } else {\n-                evaluator = PredicateEvaluatorProvider\n-                        .getPredicateEvaluator(predicate, dataSource.getDictionary(),\n-                                dataSource.getDataSourceMetadata().getDataType());\n+                evaluator = PredicateEvaluatorProvider.getPredicateEvaluator(predicate, dataSource.getDictionary(),\n+                    dataSource.getDataSourceMetadata().getDataType());\n               }\n-              return FilterOperatorUtils.getLeafFilterOperator(\n-                      evaluator, dataSource, _numDocs);\n+              return FilterOperatorUtils.getLeafFilterOperator(evaluator, dataSource, _numDocs);\n             case IS_NULL:\n               NullValueVectorReader nullValueVector = dataSource.getNullValueVector();\n               if (nullValueVector != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA3Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320072", "bodyText": "Why are we checking for the type of data source. getFSTIndex() should return a reader that could have come from a mutable or immutable data source", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java", "diffHunk": "@@ -122,8 +127,29 @@ private BaseFilterOperator constructPhysicalOperator(FilterContext filter,\n           DataSource dataSource = _indexSegment.getDataSource(lhs.getIdentifier());\n           switch (predicate.getType()) {\n             case TEXT_MATCH:\n-              return new TextMatchFilterOperator(dataSource.getTextIndex(),\n-                  ((TextMatchPredicate) predicate).getValue(), _numDocs);\n+                return new TextMatchFilterOperator(\n+                        dataSource.getTextIndex(),\n+                        ((TextMatchPredicate) predicate).getValue(),\n+                        _numDocs);\n+            case REGEXP_LIKE:\n+              PredicateEvaluator evaluator = null;\n+              if (dataSource.getFSTIndex() != null) {\n+                evaluator = FSTBasedRegexpPredicateEvaluatorFactory.newFSTBasedEvaluator(\n+                        dataSource.getFSTIndex(),\n+                        dataSource.getDictionary(),\n+                        ((RegexpLikePredicate) predicate).getValue());\n+              } else if (dataSource instanceof MutableDataSource &&", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0Mzc4NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524443785", "bodyText": "Added comments, also see my response on above comment (from FSTBasedRegexpPredicateEvaluatorFactory.java)", "author": "pradeepgv42", "createdAt": "2020-11-16T17:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDA3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java b/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java\nindex d9d335fd03..c677010f87 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/plan/FilterPlanNode.java\n\n@@ -127,29 +132,34 @@ public class FilterPlanNode implements PlanNode {\n           DataSource dataSource = _indexSegment.getDataSource(lhs.getIdentifier());\n           switch (predicate.getType()) {\n             case TEXT_MATCH:\n-                return new TextMatchFilterOperator(\n-                        dataSource.getTextIndex(),\n-                        ((TextMatchPredicate) predicate).getValue(),\n-                        _numDocs);\n+              return new TextMatchFilterOperator(dataSource.getTextIndex(), ((TextMatchPredicate) predicate).getValue(),\n+                  _numDocs);\n             case REGEXP_LIKE:\n               PredicateEvaluator evaluator = null;\n+\n+              // FST Index is available only for rolled out segments. So, we use different\n+              // evaluator for rolled out and consuming segments.\n+              //\n+              // Rolled out segments (immutable): FST Index reader is available use FSTBasedEvaluator\n+              // else use regular flow of getting predicate evaluator.\n+              //\n+              // Consuming segments: when FSTIndex is enabled use AutomatonBasedEvaluator so that regexp\n+              // matching logic is similar to that of FSTBasedEvaluator else use regular flow of getting\n+              // predicate evaluator.\n               if (dataSource.getFSTIndex() != null) {\n-                evaluator = FSTBasedRegexpPredicateEvaluatorFactory.newFSTBasedEvaluator(\n-                        dataSource.getFSTIndex(),\n-                        dataSource.getDictionary(),\n+                evaluator = FSTBasedRegexpPredicateEvaluatorFactory\n+                    .newFSTBasedEvaluator(dataSource.getFSTIndex(), dataSource.getDictionary(),\n                         ((RegexpLikePredicate) predicate).getValue());\n-              } else if (dataSource instanceof MutableDataSource &&\n-                      ((MutableDataSource) dataSource).hasFSTIndexEnabled()) {\n-                evaluator = FSTBasedRegexpPredicateEvaluatorFactory.newAutomatonBasedEvaluator(\n-                        dataSource.getDictionary(),\n+              } else if (dataSource instanceof MutableDataSource && ((MutableDataSource) dataSource)\n+                  .hasFSTIndexEnabled()) {\n+                evaluator = FSTBasedRegexpPredicateEvaluatorFactory\n+                    .newAutomatonBasedEvaluator(dataSource.getDictionary(),\n                         ((RegexpLikePredicate) predicate).getValue());\n               } else {\n-                evaluator = PredicateEvaluatorProvider\n-                        .getPredicateEvaluator(predicate, dataSource.getDictionary(),\n-                                dataSource.getDataSourceMetadata().getDataType());\n+                evaluator = PredicateEvaluatorProvider.getPredicateEvaluator(predicate, dataSource.getDictionary(),\n+                    dataSource.getDataSourceMetadata().getDataType());\n               }\n-              return FilterOperatorUtils.getLeafFilterOperator(\n-                      evaluator, dataSource, _numDocs);\n+              return FilterOperatorUtils.getLeafFilterOperator(evaluator, dataSource, _numDocs);\n             case IS_NULL:\n               NullValueVectorReader nullValueVector = dataSource.getNullValueVector();\n               if (nullValueVector != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDExNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320117", "bodyText": "Why do we need this method?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/realtime/impl/invertedindex/RealtimeLuceneTextIndexReader.java", "diffHunk": "@@ -89,6 +90,11 @@ public void add(String document) {\n     _indexCreator.add(document);\n   }\n \n+  @Override\n+  public ImmutableRoaringBitmap getDictIds(String searchQuery) {\n+    throw new UnsupportedOperationException();", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0ODI3OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524448278", "bodyText": "Yeah I agree this is not ideal, but since FST index stores key -> dictid mapping I created this overridable method.\nI moved the FSTIndexCreator to extend TextReader interface too since that looks more closer than inverted index.\nMaybe this could be moved to it's own interface if there are similar indicies in future.", "author": "pradeepgv42", "createdAt": "2020-11-16T17:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDExNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE0OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320148", "bodyText": "Please fix the message", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:26Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -129,6 +132,13 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n       _textIndexColumns.add(columnName);\n     }\n \n+    for (String columnName : config.getFSTIndexCreationColumns()) {\n+        Preconditions.checkState(\n+                schema.hasColumn(columnName),\n+                \"Cannot create text index for column: %s because it is not in schema\", columnName);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0ODc3MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524448770", "bodyText": "ah sorry for the messup on text/fst, should be fixed now", "author": "pradeepgv42", "createdAt": "2020-11-16T17:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\nindex 231759932b..ace8637e74 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n\n@@ -133,10 +133,9 @@ public class SegmentColumnarIndexCreator implements SegmentCreator {\n     }\n \n     for (String columnName : config.getFSTIndexCreationColumns()) {\n-        Preconditions.checkState(\n-                schema.hasColumn(columnName),\n-                \"Cannot create text index for column: %s because it is not in schema\", columnName);\n-        _fstIndexColumns.add(columnName);\n+      Preconditions.checkState(schema.hasColumn(columnName),\n+          \"Cannot create fst index for column: %s because it is not in schema\", columnName);\n+      _fstIndexColumns.add(columnName);\n     }\n \n     // Initialize creators for dictionary, forward index and inverted index\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE4MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320181", "bodyText": "This formatting seems weird", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:31Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -216,7 +226,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n       }\n \n-      _nullHandlingEnabled = config.isNullHandlingEnabled();\n+      if (_fstIndexColumns.contains(columnName) && indexCreationInfo.isCreateDictionary()) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0OTMxOA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524449318", "bodyText": "fixed", "author": "pradeepgv42", "createdAt": "2020-11-16T17:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDE4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\nindex 231759932b..ace8637e74 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n\n@@ -226,17 +225,18 @@ public class SegmentColumnarIndexCreator implements SegmentCreator {\n             .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n       }\n \n-      if (_fstIndexColumns.contains(columnName) && indexCreationInfo.isCreateDictionary()) {\n-        _fstIndexCreatorMap.put(\n-                columnName,\n-                new LuceneFSTIndexCreator(\n-                        _indexDir, columnName,\n-                        indexCreationInfo.getDistinctValueCount(),\n-                        (String[])indexCreationInfo.getSortedUniqueElementsArray()));\n+      if (_fstIndexColumns.contains(columnName)) {\n+        Preconditions.checkState(fieldSpec.isSingleValueField(),\n+            \"FST index is currently only supported on single-value columns\");\n+        Preconditions.checkState(fieldSpec.getDataType() == DataType.STRING,\n+            \"FST index is only supported on STRING type columns\");\n+        Preconditions.checkState(indexCreationInfo.isCreateDictionary(),\n+            \"FST index is currently only supported on dictionary columns\");\n+        _fstIndexCreatorMap.put(columnName, new LuceneFSTIndexCreator(_indexDir, columnName,\n+            (String[]) indexCreationInfo.getSortedUniqueElementsArray()));\n       }\n \n-\n-        _nullHandlingEnabled = config.isNullHandlingEnabled();\n+      _nullHandlingEnabled = config.isNullHandlingEnabled();\n       if (_nullHandlingEnabled) {\n         // Initialize Null value vector map\n         _nullValueVectorCreatorMap.put(columnName, new NullValueVectorCreator(_indexDir, columnName));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDI1MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320250", "bodyText": "Please add javadocs\nThe interface seems odd. The reader for FST index is using the TextIndexReader but writer/creator is using inverted index creator.\nAlso, this looks like an inverted index creator -- we are adding dictIDs to the FST Index?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:40Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1MDExNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524450116", "bodyText": "Added docs, switched this to TextIndexReader", "author": "pradeepgv42", "createdAt": "2020-11-16T17:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDI1MA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\nindex 1d70a7733d..c7ea4b5201 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n\n@@ -18,74 +18,86 @@\n  */\n package org.apache.pinot.core.segment.creator.impl.inv.text;\n \n-import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n import org.apache.lucene.store.OutputStreamDataOutput;\n import org.apache.lucene.util.fst.FST;\n-import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.TextIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n import org.apache.pinot.core.util.fst.FSTBuilder;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n-import java.util.Map;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n \n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.FST_INDEX_FILE_EXTENSION;\n \n-public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n-    private final File _fstIndexFile;\n-    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n-    private final FSTBuilder _fstBuilder;\n \n-    public LuceneFSTIndexCreator(\n-            File indexDir, String columnName,\n-            int cardinality, String[] sortedEntries) throws IOException {\n-        _fstIndexFile = new File(\n-                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n-\n-        _fstBuilder = new FSTBuilder();\n+/**\n+ * This index works only for dictionary enabled columns. It requires entries be added into this index in sorted\n+ * order and it creates a mapping from sorted entry to the index underneath.\n+ *\n+ */\n+public class LuceneFSTIndexCreator implements TextIndexCreator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+  private final File _fstIndexFile;\n+  private final FSTBuilder _fstBuilder;\n+  Integer _dictId;\n \n-        for (int dictId = 0; dictId < cardinality; dictId++) {\n-            if (sortedEntries != null) {\n-                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n-            }\n-        }\n-    }\n+  /**\n+   * This index requires values of the column be added in sorted order. Sorted entries could be passed in through\n+   * constructor or added through addSortedDictIds function. Index of the sorted entry should correspond to the\n+   * dictionary id.\n+   *\n+   * @param indexDir  Index directory\n+   * @param columnName Column name for which index is being created\n+   * @param sortedEntries Sorted entries of the unique values of the column.\n+   * @throws IOException\n+   */\n+  public LuceneFSTIndexCreator(File indexDir, String columnName, String[] sortedEntries)\n+      throws IOException {\n+    _fstIndexFile = new File(indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n \n-    // add SortedDicts should be called in sorted order.\n-    public void addSortedDictIds(String document, int dictId) throws IOException {\n-        _fstBuilder.addEntry(document, dictId);\n+    _fstBuilder = new FSTBuilder();\n+    _dictId = 0;\n+    if (sortedEntries != null) {\n+      for (_dictId = 0; _dictId < sortedEntries.length; _dictId++) {\n+        _fstBuilder.addEntry(sortedEntries[_dictId], _dictId);\n+      }\n     }\n+  }\n \n-    @Override\n-    public void add(int dictId) {\n-        // NOOP\n-    }\n+  // Add SortedDicts should be called in sorted order.\n+  public void addSortedDictIds(String document)\n+      throws IOException {\n+    _fstBuilder.addEntry(document, _dictId);\n+    _dictId++;\n+  }\n \n-    @Override\n-    public void add(int[] dictIds, int length) {\n-        throw new IllegalStateException(\n-                \"LuceneFSTIndexCreator does not support add interface\");\n-    }\n+  @Override\n+  public void add(String document) {\n+    // Entries into this index are added through constructor or addSortedDictIds interface.\n+    throw new IllegalStateException(\"LuceneFSTIndexCreator does not support add interface\");\n+  }\n \n-    @Override\n-    public void seal() throws IOException {\n-        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());\n-        FST<Long> fst = _fstBuilder.done();\n-        FileOutputStream fileOutputStream = new FileOutputStream(_fstIndexFile);\n-        OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n-        fst.save(d);\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    FileOutputStream fileOutputStream = null;\n+    try {\n+      fileOutputStream = new FileOutputStream(_fstIndexFile);\n+      FST<Long> fst = _fstBuilder.done();\n+      OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n+      fst.save(d);\n+    } finally {\n+      if (fileOutputStream != null) {\n         fileOutputStream.close();\n+      }\n     }\n+  }\n \n-    @Override\n-    public void close() throws IOException {\n-    }\n+  @Override\n+  public void close()\n+      throws IOException {\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDMxOA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320318", "bodyText": "Why NO-OP?\nI think you should explain the algorithm in javadoc", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:49Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+    private final File _fstIndexFile;\n+    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n+    private final FSTBuilder _fstBuilder;\n+\n+    public LuceneFSTIndexCreator(\n+            File indexDir, String columnName,\n+            int cardinality, String[] sortedEntries) throws IOException {\n+        _fstIndexFile = new File(\n+                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n+\n+        _fstBuilder = new FSTBuilder();\n+\n+        for (int dictId = 0; dictId < cardinality; dictId++) {\n+            if (sortedEntries != null) {\n+                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n+            }\n+        }\n+    }\n+\n+    // add SortedDicts should be called in sorted order.\n+    public void addSortedDictIds(String document, int dictId) throws IOException {\n+        _fstBuilder.addEntry(document, dictId);\n+    }\n+\n+    @Override\n+    public void add(int dictId) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NDE5Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524454192", "bodyText": "fixed it, added doc", "author": "pradeepgv42", "createdAt": "2020-11-16T17:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDMxOA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\nindex 1d70a7733d..c7ea4b5201 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n\n@@ -18,74 +18,86 @@\n  */\n package org.apache.pinot.core.segment.creator.impl.inv.text;\n \n-import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n import org.apache.lucene.store.OutputStreamDataOutput;\n import org.apache.lucene.util.fst.FST;\n-import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.TextIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n import org.apache.pinot.core.util.fst.FSTBuilder;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n-import java.util.Map;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n \n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.FST_INDEX_FILE_EXTENSION;\n \n-public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n-    private final File _fstIndexFile;\n-    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n-    private final FSTBuilder _fstBuilder;\n \n-    public LuceneFSTIndexCreator(\n-            File indexDir, String columnName,\n-            int cardinality, String[] sortedEntries) throws IOException {\n-        _fstIndexFile = new File(\n-                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n-\n-        _fstBuilder = new FSTBuilder();\n+/**\n+ * This index works only for dictionary enabled columns. It requires entries be added into this index in sorted\n+ * order and it creates a mapping from sorted entry to the index underneath.\n+ *\n+ */\n+public class LuceneFSTIndexCreator implements TextIndexCreator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+  private final File _fstIndexFile;\n+  private final FSTBuilder _fstBuilder;\n+  Integer _dictId;\n \n-        for (int dictId = 0; dictId < cardinality; dictId++) {\n-            if (sortedEntries != null) {\n-                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n-            }\n-        }\n-    }\n+  /**\n+   * This index requires values of the column be added in sorted order. Sorted entries could be passed in through\n+   * constructor or added through addSortedDictIds function. Index of the sorted entry should correspond to the\n+   * dictionary id.\n+   *\n+   * @param indexDir  Index directory\n+   * @param columnName Column name for which index is being created\n+   * @param sortedEntries Sorted entries of the unique values of the column.\n+   * @throws IOException\n+   */\n+  public LuceneFSTIndexCreator(File indexDir, String columnName, String[] sortedEntries)\n+      throws IOException {\n+    _fstIndexFile = new File(indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n \n-    // add SortedDicts should be called in sorted order.\n-    public void addSortedDictIds(String document, int dictId) throws IOException {\n-        _fstBuilder.addEntry(document, dictId);\n+    _fstBuilder = new FSTBuilder();\n+    _dictId = 0;\n+    if (sortedEntries != null) {\n+      for (_dictId = 0; _dictId < sortedEntries.length; _dictId++) {\n+        _fstBuilder.addEntry(sortedEntries[_dictId], _dictId);\n+      }\n     }\n+  }\n \n-    @Override\n-    public void add(int dictId) {\n-        // NOOP\n-    }\n+  // Add SortedDicts should be called in sorted order.\n+  public void addSortedDictIds(String document)\n+      throws IOException {\n+    _fstBuilder.addEntry(document, _dictId);\n+    _dictId++;\n+  }\n \n-    @Override\n-    public void add(int[] dictIds, int length) {\n-        throw new IllegalStateException(\n-                \"LuceneFSTIndexCreator does not support add interface\");\n-    }\n+  @Override\n+  public void add(String document) {\n+    // Entries into this index are added through constructor or addSortedDictIds interface.\n+    throw new IllegalStateException(\"LuceneFSTIndexCreator does not support add interface\");\n+  }\n \n-    @Override\n-    public void seal() throws IOException {\n-        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());\n-        FST<Long> fst = _fstBuilder.done();\n-        FileOutputStream fileOutputStream = new FileOutputStream(_fstIndexFile);\n-        OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n-        fst.save(d);\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    FileOutputStream fileOutputStream = null;\n+    try {\n+      fileOutputStream = new FileOutputStream(_fstIndexFile);\n+      FST<Long> fst = _fstBuilder.done();\n+      OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n+      fst.save(d);\n+    } finally {\n+      if (fileOutputStream != null) {\n         fileOutputStream.close();\n+      }\n     }\n+  }\n \n-    @Override\n-    public void close() throws IOException {\n-    }\n+  @Override\n+  public void close()\n+      throws IOException {\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM0Ng==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320346", "bodyText": "message seems misleading", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:53Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+    private final File _fstIndexFile;\n+    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n+    private final FSTBuilder _fstBuilder;\n+\n+    public LuceneFSTIndexCreator(\n+            File indexDir, String columnName,\n+            int cardinality, String[] sortedEntries) throws IOException {\n+        _fstIndexFile = new File(\n+                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n+\n+        _fstBuilder = new FSTBuilder();\n+\n+        for (int dictId = 0; dictId < cardinality; dictId++) {\n+            if (sortedEntries != null) {\n+                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n+            }\n+        }\n+    }\n+\n+    // add SortedDicts should be called in sorted order.\n+    public void addSortedDictIds(String document, int dictId) throws IOException {\n+        _fstBuilder.addEntry(document, dictId);\n+    }\n+\n+    @Override\n+    public void add(int dictId) {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public void add(int[] dictIds, int length) {\n+        throw new IllegalStateException(\n+                \"LuceneFSTIndexCreator does not support add interface\");\n+    }\n+\n+    @Override\n+    public void seal() throws IOException {\n+        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NDgyNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524454826", "bodyText": "fixed", "author": "pradeepgv42", "createdAt": "2020-11-16T17:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\nindex 1d70a7733d..c7ea4b5201 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n\n@@ -18,74 +18,86 @@\n  */\n package org.apache.pinot.core.segment.creator.impl.inv.text;\n \n-import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n import org.apache.lucene.store.OutputStreamDataOutput;\n import org.apache.lucene.util.fst.FST;\n-import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.TextIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n import org.apache.pinot.core.util.fst.FSTBuilder;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n-import java.util.Map;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n \n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.FST_INDEX_FILE_EXTENSION;\n \n-public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n-    private final File _fstIndexFile;\n-    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n-    private final FSTBuilder _fstBuilder;\n \n-    public LuceneFSTIndexCreator(\n-            File indexDir, String columnName,\n-            int cardinality, String[] sortedEntries) throws IOException {\n-        _fstIndexFile = new File(\n-                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n-\n-        _fstBuilder = new FSTBuilder();\n+/**\n+ * This index works only for dictionary enabled columns. It requires entries be added into this index in sorted\n+ * order and it creates a mapping from sorted entry to the index underneath.\n+ *\n+ */\n+public class LuceneFSTIndexCreator implements TextIndexCreator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+  private final File _fstIndexFile;\n+  private final FSTBuilder _fstBuilder;\n+  Integer _dictId;\n \n-        for (int dictId = 0; dictId < cardinality; dictId++) {\n-            if (sortedEntries != null) {\n-                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n-            }\n-        }\n-    }\n+  /**\n+   * This index requires values of the column be added in sorted order. Sorted entries could be passed in through\n+   * constructor or added through addSortedDictIds function. Index of the sorted entry should correspond to the\n+   * dictionary id.\n+   *\n+   * @param indexDir  Index directory\n+   * @param columnName Column name for which index is being created\n+   * @param sortedEntries Sorted entries of the unique values of the column.\n+   * @throws IOException\n+   */\n+  public LuceneFSTIndexCreator(File indexDir, String columnName, String[] sortedEntries)\n+      throws IOException {\n+    _fstIndexFile = new File(indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n \n-    // add SortedDicts should be called in sorted order.\n-    public void addSortedDictIds(String document, int dictId) throws IOException {\n-        _fstBuilder.addEntry(document, dictId);\n+    _fstBuilder = new FSTBuilder();\n+    _dictId = 0;\n+    if (sortedEntries != null) {\n+      for (_dictId = 0; _dictId < sortedEntries.length; _dictId++) {\n+        _fstBuilder.addEntry(sortedEntries[_dictId], _dictId);\n+      }\n     }\n+  }\n \n-    @Override\n-    public void add(int dictId) {\n-        // NOOP\n-    }\n+  // Add SortedDicts should be called in sorted order.\n+  public void addSortedDictIds(String document)\n+      throws IOException {\n+    _fstBuilder.addEntry(document, _dictId);\n+    _dictId++;\n+  }\n \n-    @Override\n-    public void add(int[] dictIds, int length) {\n-        throw new IllegalStateException(\n-                \"LuceneFSTIndexCreator does not support add interface\");\n-    }\n+  @Override\n+  public void add(String document) {\n+    // Entries into this index are added through constructor or addSortedDictIds interface.\n+    throw new IllegalStateException(\"LuceneFSTIndexCreator does not support add interface\");\n+  }\n \n-    @Override\n-    public void seal() throws IOException {\n-        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());\n-        FST<Long> fst = _fstBuilder.done();\n-        FileOutputStream fileOutputStream = new FileOutputStream(_fstIndexFile);\n-        OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n-        fst.save(d);\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    FileOutputStream fileOutputStream = null;\n+    try {\n+      fileOutputStream = new FileOutputStream(_fstIndexFile);\n+      FST<Long> fst = _fstBuilder.done();\n+      OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n+      fst.save(d);\n+    } finally {\n+      if (fileOutputStream != null) {\n         fileOutputStream.close();\n+      }\n     }\n+  }\n \n-    @Override\n-    public void close() throws IOException {\n-    }\n+  @Override\n+  public void close()\n+      throws IOException {\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM2NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320365", "bodyText": "outputstream.close() should be in finally", "author": "siddharthteotia", "createdAt": "2020-10-30T19:10:57Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.creator.impl.inv.text;\n+\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import org.apache.lucene.store.OutputStreamDataOutput;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n+import org.apache.pinot.core.util.fst.FSTBuilder;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+    private final File _fstIndexFile;\n+    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n+    private final FSTBuilder _fstBuilder;\n+\n+    public LuceneFSTIndexCreator(\n+            File indexDir, String columnName,\n+            int cardinality, String[] sortedEntries) throws IOException {\n+        _fstIndexFile = new File(\n+                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n+\n+        _fstBuilder = new FSTBuilder();\n+\n+        for (int dictId = 0; dictId < cardinality; dictId++) {\n+            if (sortedEntries != null) {\n+                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n+            }\n+        }\n+    }\n+\n+    // add SortedDicts should be called in sorted order.\n+    public void addSortedDictIds(String document, int dictId) throws IOException {\n+        _fstBuilder.addEntry(document, dictId);\n+    }\n+\n+    @Override\n+    public void add(int dictId) {\n+        // NOOP\n+    }\n+\n+    @Override\n+    public void add(int[] dictIds, int length) {\n+        throw new IllegalStateException(\n+                \"LuceneFSTIndexCreator does not support add interface\");\n+    }\n+\n+    @Override\n+    public void seal() throws IOException {\n+        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());\n+        FST<Long> fst = _fstBuilder.done();\n+        FileOutputStream fileOutputStream = new FileOutputStream(_fstIndexFile);\n+        OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n+        fst.save(d);\n+        fileOutputStream.close();", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NDg5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524454893", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T17:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\nindex 1d70a7733d..c7ea4b5201 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/inv/text/LuceneFSTIndexCreator.java\n\n@@ -18,74 +18,86 @@\n  */\n package org.apache.pinot.core.segment.creator.impl.inv.text;\n \n-import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n import org.apache.lucene.store.OutputStreamDataOutput;\n import org.apache.lucene.util.fst.FST;\n-import org.apache.pinot.core.segment.creator.DictionaryBasedInvertedIndexCreator;\n+import org.apache.pinot.core.segment.creator.TextIndexCreator;\n import org.apache.pinot.core.segment.creator.impl.SegmentColumnarIndexCreator;\n import org.apache.pinot.core.util.fst.FSTBuilder;\n-import org.roaringbitmap.buffer.MutableRoaringBitmap;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.io.BufferedOutputStream;\n-import java.io.DataOutputStream;\n import java.io.File;\n import java.io.FileOutputStream;\n import java.io.IOException;\n-import java.util.Map;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n \n+import static org.apache.pinot.core.segment.creator.impl.V1Constants.Indexes.FST_INDEX_FILE_EXTENSION;\n \n-public class LuceneFSTIndexCreator implements DictionaryBasedInvertedIndexCreator {\n-    private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n-    private final File _fstIndexFile;\n-    public static final String FST_INDEX_FILE_EXTENSION = \".lucene.fst\";\n-    private final FSTBuilder _fstBuilder;\n \n-    public LuceneFSTIndexCreator(\n-            File indexDir, String columnName,\n-            int cardinality, String[] sortedEntries) throws IOException {\n-        _fstIndexFile = new File(\n-                indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n-\n-        _fstBuilder = new FSTBuilder();\n+/**\n+ * This index works only for dictionary enabled columns. It requires entries be added into this index in sorted\n+ * order and it creates a mapping from sorted entry to the index underneath.\n+ *\n+ */\n+public class LuceneFSTIndexCreator implements TextIndexCreator {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(SegmentColumnarIndexCreator.class);\n+  private final File _fstIndexFile;\n+  private final FSTBuilder _fstBuilder;\n+  Integer _dictId;\n \n-        for (int dictId = 0; dictId < cardinality; dictId++) {\n-            if (sortedEntries != null) {\n-                _fstBuilder.addEntry(sortedEntries[dictId], dictId);\n-            }\n-        }\n-    }\n+  /**\n+   * This index requires values of the column be added in sorted order. Sorted entries could be passed in through\n+   * constructor or added through addSortedDictIds function. Index of the sorted entry should correspond to the\n+   * dictionary id.\n+   *\n+   * @param indexDir  Index directory\n+   * @param columnName Column name for which index is being created\n+   * @param sortedEntries Sorted entries of the unique values of the column.\n+   * @throws IOException\n+   */\n+  public LuceneFSTIndexCreator(File indexDir, String columnName, String[] sortedEntries)\n+      throws IOException {\n+    _fstIndexFile = new File(indexDir, columnName + FST_INDEX_FILE_EXTENSION);\n \n-    // add SortedDicts should be called in sorted order.\n-    public void addSortedDictIds(String document, int dictId) throws IOException {\n-        _fstBuilder.addEntry(document, dictId);\n+    _fstBuilder = new FSTBuilder();\n+    _dictId = 0;\n+    if (sortedEntries != null) {\n+      for (_dictId = 0; _dictId < sortedEntries.length; _dictId++) {\n+        _fstBuilder.addEntry(sortedEntries[_dictId], _dictId);\n+      }\n     }\n+  }\n \n-    @Override\n-    public void add(int dictId) {\n-        // NOOP\n-    }\n+  // Add SortedDicts should be called in sorted order.\n+  public void addSortedDictIds(String document)\n+      throws IOException {\n+    _fstBuilder.addEntry(document, _dictId);\n+    _dictId++;\n+  }\n \n-    @Override\n-    public void add(int[] dictIds, int length) {\n-        throw new IllegalStateException(\n-                \"LuceneFSTIndexCreator does not support add interface\");\n-    }\n+  @Override\n+  public void add(String document) {\n+    // Entries into this index are added through constructor or addSortedDictIds interface.\n+    throw new IllegalStateException(\"LuceneFSTIndexCreator does not support add interface\");\n+  }\n \n-    @Override\n-    public void seal() throws IOException {\n-        LOGGER.info(\"Sealing the segment for column: \" + _fstIndexFile.getAbsolutePath());\n-        FST<Long> fst = _fstBuilder.done();\n-        FileOutputStream fileOutputStream = new FileOutputStream(_fstIndexFile);\n-        OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n-        fst.save(d);\n+  @Override\n+  public void seal()\n+      throws IOException {\n+    FileOutputStream fileOutputStream = null;\n+    try {\n+      fileOutputStream = new FileOutputStream(_fstIndexFile);\n+      FST<Long> fst = _fstBuilder.done();\n+      OutputStreamDataOutput d = new OutputStreamDataOutput(fileOutputStream);\n+      fst.save(d);\n+    } finally {\n+      if (fileOutputStream != null) {\n         fileOutputStream.close();\n+      }\n     }\n+  }\n \n-    @Override\n-    public void close() throws IOException {\n-    }\n+  @Override\n+  public void close()\n+      throws IOException {\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM4Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320383", "bodyText": "Like the way it is done for other indexes, I don't think we check here if the index is existing or not.\nThe creation of the respective index reader will fail and the segment load will fail to let the user know that IndexLoadingConfig was incorrectly built from IndexingConfig", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:01Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java", "diffHunk": "@@ -142,6 +148,18 @@ public PhysicalColumnIndexContainer(SegmentDirectory.Reader segmentReader, Colum\n       } else {\n         _invertedIndex = null;\n       }\n+\n+\n+      if (loadFSTIndex) {\n+        if (segmentReader.hasIndexFor(columnName, ColumnIndexType.FST_INDEX)) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NTA0MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524455040", "bodyText": "fixed", "author": "pradeepgv42", "createdAt": "2020-11-16T17:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDM4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java\nindex 73650a8099..2aa6037587 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/PhysicalColumnIndexContainer.java\n\n@@ -151,11 +144,8 @@ public final class PhysicalColumnIndexContainer implements ColumnIndexContainer\n \n \n       if (loadFSTIndex) {\n-        if (segmentReader.hasIndexFor(columnName, ColumnIndexType.FST_INDEX)) {\n-          _fstIndex = new LuceneFSTIndexReader(segmentIndexDir, columnName);\n-        } else {\n-          _fstIndex = null;\n-        }\n+        _fstIndex = new LuceneFSTIndexReader(\n+            segmentReader.getIndexFor(columnName, ColumnIndexType.FST_INDEX));\n       } else {\n         _fstIndex = null;\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDQ4Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320483", "bodyText": "undo?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:14Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java", "diffHunk": "@@ -225,9 +227,26 @@ private void copyCreationMetadataIfExists(File currentDir, File v3Dir)\n     }\n   }\n \n+  private void copyLuceneFSTIndexFiles(File segmentDirectory, File v3Dir) throws IOException {\n+    File[] fstIndexFiles = segmentDirectory.listFiles(new FilenameFilter() {\n+      @Override\n+      public boolean accept(File dir, String name) {\n+        return name.endsWith(LuceneFSTIndexCreator.FST_INDEX_FILE_EXTENSION);\n+      }\n+    });\n+\n+    for (File fstIndexFile : fstIndexFiles) {\n+      File v3File = new File(v3Dir, fstIndexFile.getName());\n+      LOGGER.info(\"Copying {} to {}\", fstIndexFile.toPath(), v3File.toPath());\n+      Files.copy(fstIndexFile.toPath(), v3File.toPath());\n+    }\n+  }\n+\n   private void copyLuceneTextIndexIfExists(File segmentDirectory, File v3Dir)\n       throws IOException {\n     // TODO: see if this can be done by reusing some existing methods\n+", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1Nzc2MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524457761", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T17:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDQ4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java\nindex 1e3b2ea7a6..7e1659001d 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/converter/SegmentV1V2ToV3FormatConverter.java\n\n@@ -227,26 +238,10 @@ public class SegmentV1V2ToV3FormatConverter implements SegmentFormatConverter {\n     }\n   }\n \n-  private void copyLuceneFSTIndexFiles(File segmentDirectory, File v3Dir) throws IOException {\n-    File[] fstIndexFiles = segmentDirectory.listFiles(new FilenameFilter() {\n-      @Override\n-      public boolean accept(File dir, String name) {\n-        return name.endsWith(LuceneFSTIndexCreator.FST_INDEX_FILE_EXTENSION);\n-      }\n-    });\n-\n-    for (File fstIndexFile : fstIndexFiles) {\n-      File v3File = new File(v3Dir, fstIndexFile.getName());\n-      LOGGER.info(\"Copying {} to {}\", fstIndexFile.toPath(), v3File.toPath());\n-      Files.copy(fstIndexFile.toPath(), v3File.toPath());\n-    }\n-  }\n-\n   private void copyLuceneTextIndexIfExists(File segmentDirectory, File v3Dir)\n       throws IOException {\n     // TODO: see if this can be done by reusing some existing methods\n \n-\n     String suffix = LuceneTextIndexCreator.LUCENE_TEXT_INDEX_FILE_EXTENSION;\n     File[] textIndexFiles = segmentDirectory.listFiles(new FilenameFilter() {\n       @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDUyMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320521", "bodyText": "Why this method specifically on mutable data source?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:18Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/datasource/MutableDataSource.java", "diffHunk": "@@ -36,16 +36,26 @@\n  */\n @SuppressWarnings(\"rawtypes\")\n public class MutableDataSource extends BaseDataSource {\n+  final boolean _fstIndexEnabled;\n \n-  public MutableDataSource(FieldSpec fieldSpec, int numDocs, int numValues, int maxNumValuesPerMVEntry,\n+  public MutableDataSource(FieldSpec fieldSpec, int numDocs, int numValues, int maxNumValuesPerMVEntry, boolean fstIndexEnabled,\n       @Nullable PartitionFunction partitionFunction, @Nullable Set<Integer> partitions, @Nullable Comparable minValue,\n       @Nullable Comparable maxValue, ForwardIndexReader forwardIndex, @Nullable Dictionary dictionary,\n       @Nullable InvertedIndexReader invertedIndex, @Nullable InvertedIndexReader rangeIndex,\n-      @Nullable TextIndexReader textIndex, @Nullable BloomFilterReader bloomFilter,\n+      @Nullable TextIndexReader textIndex, @Nullable TextIndexReader fstIndex,\n+      @Nullable BloomFilterReader bloomFilter,\n       @Nullable NullValueVectorReader nullValueVector) {\n     super(new MutableDataSourceMetadata(fieldSpec, numDocs, numValues, maxNumValuesPerMVEntry, partitionFunction,\n-            partitions, minValue, maxValue), forwardIndex, dictionary, invertedIndex, rangeIndex, textIndex, bloomFilter,\n-        nullValueVector);\n+                    partitions, minValue, maxValue), forwardIndex, dictionary,\n+            invertedIndex, rangeIndex, textIndex, fstIndex,\n+            bloomFilter, nullValueVector);\n+    _fstIndexEnabled = fstIndexEnabled;\n+  }\n+\n+\n+  // Returns whether the current field has", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1ODY2MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524458661", "bodyText": "This is to keep the results consistent between consuming & rolled out segments (more details in comments above)", "author": "pradeepgv42", "createdAt": "2020-11-16T17:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDUyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/datasource/MutableDataSource.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/datasource/MutableDataSource.java\nindex 32885b5ab5..e9ae0dfb84 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/datasource/MutableDataSource.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/datasource/MutableDataSource.java\n\n@@ -52,8 +52,7 @@ public class MutableDataSource extends BaseDataSource {\n     _fstIndexEnabled = fstIndexEnabled;\n   }\n \n-\n-  // Returns whether the current field has\n+  // Returns whether the current field has fst index enabled.\n   public boolean hasFSTIndexEnabled() {\n     return _fstIndexEnabled;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU0NA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320544", "bodyText": "In the table config, you need to add a validator for FST index type for now since it is only supported on dictionary encoded columns. That way we can error out during table config creation itself if someone tries to enable this index  with encoding type as RAW", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:22Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/IndexLoadingConfig.java", "diffHunk": "@@ -173,6 +175,18 @@ private void extractTextIndexColumnsFromTableConfig(TableConfig tableConfig) {\n     }\n   }\n \n+  private void extractFSTIndexColumnsFromTableConfig(TableConfig tableConfig) {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Mjc0MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524472741", "bodyText": "Added validation config in TableConfigUtils PTAL.", "author": "pradeepgv42", "createdAt": "2020-11-16T18:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU0NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU2MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320561", "bodyText": "Please add javadoc", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:27Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzA2MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473060", "bodyText": "took over comment and reworded from textindexhandler", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\nindex a16e9f330b..64103f9580 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n\n@@ -19,8 +19,10 @@\n \n package org.apache.pinot.core.segment.index.loader.invertedindex;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.loader.LoaderUtils;\n import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU4MA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320580", "bodyText": "Fix the log", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:30Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {\n+    private static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexHandler.class);\n+\n+    private final File _indexDir;\n+    private final SegmentDirectory.Writer _segmentWriter;\n+    private final String _segmentName;\n+    private final SegmentVersion _segmentVersion;\n+    private final Set<ColumnMetadata> _fstIndexColumns = new HashSet<>();\n+\n+\n+    public LuceneFSTIndexHandler(\n+            File indexDir, SegmentMetadataImpl segmentMetadata, Set<String> fstIndexColumns,\n+            SegmentDirectory.Writer segmentWriter) {\n+        _indexDir = indexDir;\n+        _segmentWriter = segmentWriter;\n+        _segmentName = segmentMetadata.getName();\n+        _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+        for (String column : fstIndexColumns) {\n+            ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+            if (columnMetadata != null) {\n+                _fstIndexColumns.add(columnMetadata);\n+            }\n+        }\n+    }\n+\n+    private void checkUnsupportedOperationsForFSTIndex(ColumnMetadata columnMetadata) {\n+        String column = columnMetadata.getColumnName();\n+        if (columnMetadata.getDataType() != FieldSpec.DataType.STRING) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on STRING columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.hasDictionary()) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on dictionary encoded columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.isSingleValue()) {\n+            throw new UnsupportedOperationException(\n+                    \"Text index is currently not supported on multi-value columns: \" + column);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzEzMA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473130", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\nindex a16e9f330b..64103f9580 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n\n@@ -19,8 +19,10 @@\n \n package org.apache.pinot.core.segment.index.loader.invertedindex;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.loader.LoaderUtils;\n import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYwMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320601", "bodyText": "please fix the comment", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {\n+    private static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexHandler.class);\n+\n+    private final File _indexDir;\n+    private final SegmentDirectory.Writer _segmentWriter;\n+    private final String _segmentName;\n+    private final SegmentVersion _segmentVersion;\n+    private final Set<ColumnMetadata> _fstIndexColumns = new HashSet<>();\n+\n+\n+    public LuceneFSTIndexHandler(\n+            File indexDir, SegmentMetadataImpl segmentMetadata, Set<String> fstIndexColumns,\n+            SegmentDirectory.Writer segmentWriter) {\n+        _indexDir = indexDir;\n+        _segmentWriter = segmentWriter;\n+        _segmentName = segmentMetadata.getName();\n+        _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+        for (String column : fstIndexColumns) {\n+            ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+            if (columnMetadata != null) {\n+                _fstIndexColumns.add(columnMetadata);\n+            }\n+        }\n+    }\n+\n+    private void checkUnsupportedOperationsForFSTIndex(ColumnMetadata columnMetadata) {\n+        String column = columnMetadata.getColumnName();\n+        if (columnMetadata.getDataType() != FieldSpec.DataType.STRING) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on STRING columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.hasDictionary()) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on dictionary encoded columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.isSingleValue()) {\n+            throw new UnsupportedOperationException(\n+                    \"Text index is currently not supported on multi-value columns: \" + column);\n+        }\n+    }\n+\n+    public void createFSTIndexesOnSegmentLoad()\n+            throws Exception {\n+        for (ColumnMetadata columnMetadata : _fstIndexColumns) {\n+            checkUnsupportedOperationsForFSTIndex(columnMetadata);\n+            createFSTIndexForColumn(columnMetadata);\n+        }\n+    }\n+\n+    private BaseImmutableDictionary getDictionaryReader(ColumnMetadata columnMetadata)\n+            throws IOException {\n+        PinotDataBuffer dictionaryBuffer =\n+                _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.DICTIONARY);\n+        return new StringDictionary(dictionaryBuffer, columnMetadata.getCardinality(), columnMetadata.getColumnMaxLength(),\n+                (byte) columnMetadata.getPaddingCharacter());\n+    }\n+\n+    private void createFSTIndexForColumn(ColumnMetadata columnMetadata) throws IOException {\n+        String column = columnMetadata.getColumnName();\n+        boolean hasDictionary = columnMetadata.hasDictionary();\n+\n+        if (!hasDictionary) {\n+            return;\n+        }\n+\n+        if (_segmentWriter.hasIndexFor(column, ColumnIndexType.FST_INDEX)) {\n+            // Skip creating text index if already exists.", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzE5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473193", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\nindex a16e9f330b..64103f9580 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n\n@@ -19,8 +19,10 @@\n \n package org.apache.pinot.core.segment.index.loader.invertedindex;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.loader.LoaderUtils;\n import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYyNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320627", "bodyText": "please fix the log", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:36Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.pinot.core.segment.index.loader.invertedindex;\n+\n+import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n+import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n+import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n+import org.apache.pinot.core.segment.index.readers.StringDictionary;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.ColumnIndexType;\n+import org.apache.pinot.core.segment.store.SegmentDirectory;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class LuceneFSTIndexHandler {\n+    private static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexHandler.class);\n+\n+    private final File _indexDir;\n+    private final SegmentDirectory.Writer _segmentWriter;\n+    private final String _segmentName;\n+    private final SegmentVersion _segmentVersion;\n+    private final Set<ColumnMetadata> _fstIndexColumns = new HashSet<>();\n+\n+\n+    public LuceneFSTIndexHandler(\n+            File indexDir, SegmentMetadataImpl segmentMetadata, Set<String> fstIndexColumns,\n+            SegmentDirectory.Writer segmentWriter) {\n+        _indexDir = indexDir;\n+        _segmentWriter = segmentWriter;\n+        _segmentName = segmentMetadata.getName();\n+        _segmentVersion = SegmentVersion.valueOf(segmentMetadata.getVersion());\n+\n+        for (String column : fstIndexColumns) {\n+            ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(column);\n+            if (columnMetadata != null) {\n+                _fstIndexColumns.add(columnMetadata);\n+            }\n+        }\n+    }\n+\n+    private void checkUnsupportedOperationsForFSTIndex(ColumnMetadata columnMetadata) {\n+        String column = columnMetadata.getColumnName();\n+        if (columnMetadata.getDataType() != FieldSpec.DataType.STRING) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on STRING columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.hasDictionary()) {\n+            throw new UnsupportedOperationException(\"FST index is currently only supported on dictionary encoded columns: \" + column);\n+        }\n+\n+        if (!columnMetadata.isSingleValue()) {\n+            throw new UnsupportedOperationException(\n+                    \"Text index is currently not supported on multi-value columns: \" + column);\n+        }\n+    }\n+\n+    public void createFSTIndexesOnSegmentLoad()\n+            throws Exception {\n+        for (ColumnMetadata columnMetadata : _fstIndexColumns) {\n+            checkUnsupportedOperationsForFSTIndex(columnMetadata);\n+            createFSTIndexForColumn(columnMetadata);\n+        }\n+    }\n+\n+    private BaseImmutableDictionary getDictionaryReader(ColumnMetadata columnMetadata)\n+            throws IOException {\n+        PinotDataBuffer dictionaryBuffer =\n+                _segmentWriter.getIndexFor(columnMetadata.getColumnName(), ColumnIndexType.DICTIONARY);\n+        return new StringDictionary(dictionaryBuffer, columnMetadata.getCardinality(), columnMetadata.getColumnMaxLength(),\n+                (byte) columnMetadata.getPaddingCharacter());\n+    }\n+\n+    private void createFSTIndexForColumn(ColumnMetadata columnMetadata) throws IOException {\n+        String column = columnMetadata.getColumnName();\n+        boolean hasDictionary = columnMetadata.hasDictionary();\n+\n+        if (!hasDictionary) {\n+            return;\n+        }\n+\n+        if (_segmentWriter.hasIndexFor(column, ColumnIndexType.FST_INDEX)) {\n+            // Skip creating text index if already exists.\n+            LOGGER.info(\"Found text index for column: {}, in segment: {}\", column, _segmentName);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzMzNQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473335", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\nindex a16e9f330b..64103f9580 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/invertedindex/LuceneFSTIndexHandler.java\n\n@@ -19,8 +19,10 @@\n \n package org.apache.pinot.core.segment.index.loader.invertedindex;\n \n+import org.apache.commons.io.FileUtils;\n import org.apache.pinot.core.indexsegment.generator.SegmentVersion;\n import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.index.loader.LoaderUtils;\n import org.apache.pinot.core.segment.index.metadata.ColumnMetadata;\n import org.apache.pinot.core.segment.index.metadata.SegmentMetadataImpl;\n import org.apache.pinot.core.segment.index.readers.BaseImmutableDictionary;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDY2OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320668", "bodyText": "Please add javadoc explaining the algorithm how the index is read\nSince the writer is using inverted index creator interface, reader should use the inverted index reader interface", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:41Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.OffHeapFSTStore;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.apache.pinot.core.util.fst.PinotBufferIndexInput;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+\n+public class LuceneFSTIndexReader implements TextIndexReader {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzU3Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473573", "bodyText": "done, switched everything to TextIndexCreator/Reader", "author": "pradeepgv42", "createdAt": "2020-11-16T18:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java\nindex 80a3826ab0..7682044c18 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java\n\n@@ -21,9 +21,7 @@ package org.apache.pinot.core.segment.index.readers;\n import org.apache.lucene.util.fst.FST;\n import org.apache.lucene.util.fst.OffHeapFSTStore;\n import org.apache.lucene.util.fst.PositiveIntOutputs;\n-import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n-import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n import org.apache.pinot.core.util.fst.RegexpMatcher;\n import org.apache.pinot.core.util.fst.PinotBufferIndexInput;\n import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDcxNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320717", "bodyText": "It looks like on-disk FST index is in a single file which is mmaped upon load. I think we should try to combine this with other index files (dictionary, inverted, fwd) for v3 format into a single file.", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:48Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.segment.index.readers;\n+\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.OffHeapFSTStore;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n+import org.apache.pinot.core.util.fst.RegexpMatcher;\n+import org.apache.pinot.core.util.fst.PinotBufferIndexInput;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+\n+public class LuceneFSTIndexReader implements TextIndexReader {\n+    public static final Logger LOGGER =\n+            LoggerFactory.getLogger(LuceneFSTIndexReader.class);\n+\n+    private final PinotDataBuffer _dataBuffer;\n+    private final PinotBufferIndexInput _dataBufferIndexInput;\n+    private final FST<Long> readFST;\n+    private String dir;\n+\n+    public LuceneFSTIndexReader(\n+            File segmentIndexDir, String column) throws IOException {\n+        File segmentsV3Dir = SegmentDirectoryPaths.findSegmentDirectory(segmentIndexDir);\n+\n+        File fstFile = new File(segmentsV3Dir,\n+                column + LuceneFSTIndexCreator.FST_INDEX_FILE_EXTENSION);\n+        dir = segmentsV3Dir.getAbsolutePath();\n+\n+        this._dataBuffer = PinotDataBuffer.mapFile(", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MzcyOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473729", "bodyText": "Good point, combined it in v3 conversion.", "author": "pradeepgv42", "createdAt": "2020-11-16T18:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDcxNw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java\nindex 80a3826ab0..7682044c18 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/LuceneFSTIndexReader.java\n\n@@ -21,9 +21,7 @@ package org.apache.pinot.core.segment.index.readers;\n import org.apache.lucene.util.fst.FST;\n import org.apache.lucene.util.fst.OffHeapFSTStore;\n import org.apache.lucene.util.fst.PositiveIntOutputs;\n-import org.apache.pinot.core.segment.creator.impl.inv.text.LuceneFSTIndexCreator;\n import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n-import org.apache.pinot.core.segment.store.SegmentDirectoryPaths;\n import org.apache.pinot.core.util.fst.RegexpMatcher;\n import org.apache.pinot.core.util.fst.PinotBufferIndexInput;\n import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDc5Mw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320793", "bodyText": "I don't think this method is needed", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:55Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/TextIndexReader.java", "diffHunk": "@@ -19,11 +19,19 @@\n package org.apache.pinot.core.segment.index.readers;\n \n import java.io.Closeable;\n+\n+import org.apache.commons.lang.mutable.Mutable;\n+import org.roaringbitmap.buffer.ImmutableRoaringBitmap;\n import org.roaringbitmap.buffer.MutableRoaringBitmap;\n \n \n public interface TextIndexReader extends Closeable {\n \n+  /**\n+   * Returns the matching dictionary ids for the given search query.\n+   */\n+  ImmutableRoaringBitmap getDictIds(String searchQuery);", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Mzg5OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524473899", "bodyText": "see my previous comments", "author": "pradeepgv42", "createdAt": "2020-11-16T18:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/TextIndexReader.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/TextIndexReader.java\nindex d4849f3411..17dcf78195 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/TextIndexReader.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/TextIndexReader.java\n\n@@ -28,7 +28,7 @@ import org.roaringbitmap.buffer.MutableRoaringBitmap;\n public interface TextIndexReader extends Closeable {\n \n   /**\n-   * Returns the matching dictionary ids for the given search query.\n+   * Returns the matching dictionary ids for the given search query (optional).\n    */\n   ImmutableRoaringBitmap getDictIds(String searchQuery);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDgxNw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320817", "bodyText": "This change should not be needed", "author": "siddharthteotia", "createdAt": "2020-10-30T19:11:59Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/readers/text/LuceneTextIndexReader.java", "diffHunk": "@@ -116,6 +117,11 @@ private File getTextIndexFile(File segmentIndexDir) {\n     return file;\n   }\n \n+  @Override\n+  public ImmutableRoaringBitmap getDictIds(String searchQuery) {\n+    throw new UnsupportedOperationException(\"\");", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzgwNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203806", "bodyText": "Include a message in exception", "author": "siddharthteotia", "createdAt": "2020-12-19T07:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDgxNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg1NA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320854", "bodyText": "javadoc", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:05Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.fst.Builder;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+public class FSTBuilder {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NDAyMA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524474020", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java\nindex 6515952b3f..18fff3fb02 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java\n\n@@ -30,34 +30,36 @@ import java.io.IOException;\n import java.util.Map;\n import java.util.SortedMap;\n \n+\n+/**\n+ *  Builds FST using lucene org.apache.lucene.util.fst.Builder library. FSTBuilder requires all the key/values\n+ *  be added in sorted order.\n+ */\n public class FSTBuilder {\n-    public static final Logger LOGGER =\n-            LoggerFactory.getLogger(FSTBuilder.class);\n-    private Builder<Long> _builder = new Builder<>(\n-            FST.INPUT_TYPE.BYTE4, PositiveIntOutputs.getSingleton());\n-    private IntsRefBuilder _scratch = new IntsRefBuilder();\n-\n-    public void addEntry(String key, Integer value) throws IOException {\n-        _builder.add(\n-                Util.toUTF16(key, _scratch),\n-                value.longValue());\n-    }\n+  public static final Logger LOGGER = LoggerFactory.getLogger(FSTBuilder.class);\n+  private Builder<Long> _builder = new Builder<>(FST.INPUT_TYPE.BYTE4, PositiveIntOutputs.getSingleton());\n+  private IntsRefBuilder _scratch = new IntsRefBuilder();\n \n-    public FST done() throws IOException {\n-        return _builder.finish();\n-    }\n+  public static FST buildFST(SortedMap<String, Integer> input)\n+      throws IOException {\n+    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n+    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE4, fstOutput);\n \n-    public static FST buildFST(SortedMap<String, Integer> input) throws IOException {\n-        PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n-        Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE4, fstOutput);\n-\n-        IntsRefBuilder scratch = new IntsRefBuilder();\n-        for (Map.Entry<String, Integer> entry : input.entrySet()) {\n-            builder.add(\n-                    Util.toUTF16(entry.getKey(), scratch),\n-                    entry.getValue().longValue());\n-        }\n-        FST<Long> result = builder.finish();\n-        return result;\n+    IntsRefBuilder scratch = new IntsRefBuilder();\n+    for (Map.Entry<String, Integer> entry : input.entrySet()) {\n+      builder.add(Util.toUTF16(entry.getKey(), scratch), entry.getValue().longValue());\n     }\n+    FST<Long> result = builder.finish();\n+    return result;\n+  }\n+\n+  public void addEntry(String key, Integer value)\n+      throws IOException {\n+    _builder.add(Util.toUTF16(key, _scratch), value.longValue());\n+  }\n+\n+  public FST done()\n+      throws IOException {\n+    return _builder.finish();\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg3NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320875", "bodyText": "Explain the algorithm please", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:07Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.fst.Builder;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.PositiveIntOutputs;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+public class FSTBuilder {\n+    public static final Logger LOGGER =\n+            LoggerFactory.getLogger(FSTBuilder.class);\n+    private Builder<Long> _builder = new Builder<>(\n+            FST.INPUT_TYPE.BYTE4, PositiveIntOutputs.getSingleton());\n+    private IntsRefBuilder _scratch = new IntsRefBuilder();\n+\n+    public void addEntry(String key, Integer value) throws IOException {\n+        _builder.add(\n+                Util.toUTF16(key, _scratch),\n+                value.longValue());\n+    }\n+\n+    public FST done() throws IOException {\n+        return _builder.finish();\n+    }\n+\n+    public static FST buildFST(SortedMap<String, Integer> input) throws IOException {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NDM0Nw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524474347", "bodyText": "done, crux of the comments are in RegexpMatcher file", "author": "pradeepgv42", "createdAt": "2020-11-16T18:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java\nindex 6515952b3f..18fff3fb02 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/FSTBuilder.java\n\n@@ -30,34 +30,36 @@ import java.io.IOException;\n import java.util.Map;\n import java.util.SortedMap;\n \n+\n+/**\n+ *  Builds FST using lucene org.apache.lucene.util.fst.Builder library. FSTBuilder requires all the key/values\n+ *  be added in sorted order.\n+ */\n public class FSTBuilder {\n-    public static final Logger LOGGER =\n-            LoggerFactory.getLogger(FSTBuilder.class);\n-    private Builder<Long> _builder = new Builder<>(\n-            FST.INPUT_TYPE.BYTE4, PositiveIntOutputs.getSingleton());\n-    private IntsRefBuilder _scratch = new IntsRefBuilder();\n-\n-    public void addEntry(String key, Integer value) throws IOException {\n-        _builder.add(\n-                Util.toUTF16(key, _scratch),\n-                value.longValue());\n-    }\n+  public static final Logger LOGGER = LoggerFactory.getLogger(FSTBuilder.class);\n+  private Builder<Long> _builder = new Builder<>(FST.INPUT_TYPE.BYTE4, PositiveIntOutputs.getSingleton());\n+  private IntsRefBuilder _scratch = new IntsRefBuilder();\n \n-    public FST done() throws IOException {\n-        return _builder.finish();\n-    }\n+  public static FST buildFST(SortedMap<String, Integer> input)\n+      throws IOException {\n+    PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n+    Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE4, fstOutput);\n \n-    public static FST buildFST(SortedMap<String, Integer> input) throws IOException {\n-        PositiveIntOutputs fstOutput = PositiveIntOutputs.getSingleton();\n-        Builder<Long> builder = new Builder<Long>(FST.INPUT_TYPE.BYTE4, fstOutput);\n-\n-        IntsRefBuilder scratch = new IntsRefBuilder();\n-        for (Map.Entry<String, Integer> entry : input.entrySet()) {\n-            builder.add(\n-                    Util.toUTF16(entry.getKey(), scratch),\n-                    entry.getValue().longValue());\n-        }\n-        FST<Long> result = builder.finish();\n-        return result;\n+    IntsRefBuilder scratch = new IntsRefBuilder();\n+    for (Map.Entry<String, Integer> entry : input.entrySet()) {\n+      builder.add(Util.toUTF16(entry.getKey(), scratch), entry.getValue().longValue());\n     }\n+    FST<Long> result = builder.finish();\n+    return result;\n+  }\n+\n+  public void addEntry(String key, Integer value)\n+      throws IOException {\n+    _builder.add(Util.toUTF16(key, _scratch), value.longValue());\n+  }\n+\n+  public FST done()\n+      throws IOException {\n+    return _builder.finish();\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDkwOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320909", "bodyText": "Please add javadoc. Couple of other questions:\n\nWhy do we need a specialized Pinotbuffer extending lucene buffer\nWhat is the arrangement of FST index in pinot segment directory? Is it under separate sub-directory like lucene text index. If the on-disk index is in a single buffer, can we combine it with other buffers in v3", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:11Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/PinotBufferIndexInput.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.store.IndexInput;\n+import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n+\n+import java.io.IOException;\n+\n+public class PinotBufferIndexInput extends IndexInput {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NDk1MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524474951", "bodyText": "It's a wrapper so that lucene FST reader library could traverse over the buffer.\nv1 generates a fst index file, v3 merges into the single index file now", "author": "pradeepgv42", "createdAt": "2020-11-16T18:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDkwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/PinotBufferIndexInput.java b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/PinotBufferIndexInput.java\nindex 4e51c999b4..dcb85349c9 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/PinotBufferIndexInput.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/PinotBufferIndexInput.java\n\n@@ -23,6 +23,13 @@ import org.apache.pinot.core.segment.memory.PinotDataBuffer;\n \n import java.io.IOException;\n \n+\n+/**\n+ * PinotBufferIndexInput is a wrapper around PinotDataBuffer implementing IndexInput apis.\n+ * It acts as a bridge between lucene FST reader library and PinotDataBuffer, it lets FST index\n+ * load into PinotDataBuffer and helps in utilizing FST reader (org.apache.lucene.util.fst.FST).\n+ *\n+ */\n public class PinotBufferIndexInput extends IndexInput {\n     PinotDataBuffer pinotDataBuffer;\n     Long sliceOffset;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk1NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320955", "bodyText": "javadoc and explanation of the algorithm/ functionality", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:17Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.CharacterRunAutomaton;\n+import org.apache.lucene.util.automaton.RegExp;\n+import org.apache.lucene.util.automaton.Transition;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class RegexpMatcher {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NTA5OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524475098", "bodyText": "Added, let me know if should expand", "author": "pradeepgv42", "createdAt": "2020-11-16T18:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java\nindex 1f870fe437..76447adea9 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java\n\n@@ -33,106 +33,132 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n+\n+/**\n+ * RegexpMatcher is a helper to retrieve matching values for a given regexp query.\n+ * Regexp query is converted into an automaton and we run the matching algorithm on FST.\n+ *\n+ * Two main functions of this class are\n+ *   regexMatchOnFST() Function runs matching on FST (See function comments for more details)\n+ *   match(input) Function builds the automaton and matches given input.\n+ */\n public class RegexpMatcher {\n-    public static final Logger LOGGER =\n-            LoggerFactory.getLogger(FSTBuilder.class);\n+  public static final Logger LOGGER = LoggerFactory.getLogger(FSTBuilder.class);\n \n-    private final String _regexQuery;\n-    private final FST<Long> _fst;\n-    private final Automaton _automaton;\n+  private final String _regexQuery;\n+  private final FST<Long> _fst;\n+  private final Automaton _automaton;\n \n-    public RegexpMatcher(String regexQuery, FST<Long> fst) {\n-        _regexQuery = regexQuery;\n-        _fst = fst;\n-        _automaton = (new RegExp(_regexQuery)).toAutomaton();\n+  public RegexpMatcher(String regexQuery, FST<Long> fst) {\n+    _regexQuery = regexQuery;\n+    _fst = fst;\n+    _automaton = (new RegExp(_regexQuery)).toAutomaton();\n+  }\n \n+  public static List<Long> regexMatch(String regexQuery, FST<Long> fst)\n+      throws IOException {\n+    RegexpMatcher matcher = new RegexpMatcher(regexQuery, fst);\n+    return matcher.regexMatchOnFST();\n+  }\n+\n+  // Matches \"input\" string with _regexQuery Automaton.\n+  public boolean match(String input) {\n+    CharacterRunAutomaton characterRunAutomaton = new CharacterRunAutomaton(_automaton);\n+    return characterRunAutomaton.run(input);\n+  }\n+\n+  /**\n+   * This function runs matching on automaton built from regexQuery and the FST.\n+   * FST stores key (string) to a value (Long). Both are state machines and state transition is based on\n+   * a input character.\n+   *\n+   * This algorithm starts with Queue containing (Automaton Start Node, FST Start Node).\n+   * Each step an entry is popped from the queue:\n+   *    1) if the automaton state is accept and the FST Node is final (i.e. end node) then the value stored for that FST\n+   *       is added to the set of result.\n+   *    2) Else next set of transitions on automaton are gathered and for each transition target node for that character\n+   *       is figured out in FST Node, resulting pair of (automaton state, fst node) are added to the queue.\n+   *    3) This process is bound to complete since we are making progression on the FST (which is a DAG) towards final\n+   *       nodes.\n+   * @return\n+   * @throws IOException\n+   */\n+  public List<Long> regexMatchOnFST()\n+      throws IOException {\n+    final List<Path<Long>> queue = new ArrayList<>();\n+    final List<Path<Long>> endNodes = new ArrayList<>();\n+    if (_automaton.getNumStates() == 0) {\n+      return Collections.emptyList();\n     }\n \n-    public static final class Path<T> {\n-        public final int state;\n-        public final FST.Arc<T> fstNode;\n-        public final T output;\n-        public final IntsRefBuilder input;\n-\n-        public Path(int state, FST.Arc<T> fstNode, T output, IntsRefBuilder input) {\n-            this.state = state;\n-            this.fstNode = fstNode;\n-            this.output = output;\n-            this.input = input;\n+    // Automaton start state and FST start node is added to the queue.\n+    queue.add(new Path<>(0, _fst.getFirstArc(new FST.Arc<Long>()), _fst.outputs.getNoOutput(), new IntsRefBuilder()));\n+\n+    final FST.Arc<Long> scratchArc = new FST.Arc<>();\n+    final FST.BytesReader fstReader = _fst.getBytesReader();\n+\n+    Transition t = new Transition();\n+    while (queue.size() != 0) {\n+      final Path<Long> path = queue.remove(queue.size() - 1);\n+\n+      // If automaton is in accept state and the fstNode is final (i.e. end node) then add the entry to endNodes which\n+      // contains the result set.\n+      if (_automaton.isAccept(path.state)) {\n+        if (path.fstNode.isFinal()) {\n+          endNodes.add(path);\n         }\n-    }\n+      }\n \n-    // Matches \"input\" string with _regexQuery Automaton.\n-    public boolean match(String input) {\n-        CharacterRunAutomaton characterRunAutomaton =\n-                new CharacterRunAutomaton(_automaton);\n-        return characterRunAutomaton.run(input);\n+      // Gather next set of transitions on automaton and find target nodes in FST.\n+      IntsRefBuilder currentInput = path.input;\n+      int count = _automaton.initTransition(path.state, t);\n+      for (int i = 0; i < count; i++) {\n+        _automaton.getNextTransition(t);\n+        final int min = t.min;\n+        final int max = t.max;\n+        if (min == max) {\n+          final FST.Arc<Long> nextArc = _fst.findTargetArc(t.min, path.fstNode, scratchArc, fstReader);\n+          if (nextArc != null) {\n+            final IntsRefBuilder newInput = new IntsRefBuilder();\n+            newInput.copyInts(currentInput.get());\n+            newInput.append(t.min);\n+            queue.add(new Path<Long>(t.dest, new FST.Arc<Long>().copyFrom(nextArc),\n+                _fst.outputs.add(path.output, nextArc.output), newInput));\n+          }\n+        } else {\n+          FST.Arc<Long> nextArc = Util.readCeilArc(min, _fst, path.fstNode, scratchArc, fstReader);\n+          while (nextArc != null && nextArc.label <= max) {\n+            final IntsRefBuilder newInput = new IntsRefBuilder();\n+            newInput.copyInts(currentInput.get());\n+            newInput.append(nextArc.label);\n+            queue.add(\n+                new Path<>(t.dest, new FST.Arc<Long>().copyFrom(nextArc), _fst.outputs.add(path.output, nextArc.output),\n+                    newInput));\n+            nextArc = nextArc.isLast() ? null : _fst.readNextRealArc(nextArc, fstReader);\n+          }\n+        }\n+      }\n     }\n \n-    public static List<Long> regexMatch(String regexQuery, FST<Long> fst) throws IOException {\n-        RegexpMatcher matcher = new RegexpMatcher(regexQuery, fst);\n-        return matcher.regexMatchOnFST();\n+    // From the result set of matched entries gather the values stored and return.\n+    ArrayList<Long> matchedIds = new ArrayList<>();\n+    for (Path<Long> path : endNodes) {\n+      matchedIds.add(path.output);\n     }\n+    return matchedIds;\n+  }\n \n-    public List<Long> regexMatchOnFST() throws IOException {\n-        final List<Path<Long>> queue = new ArrayList<>();\n-        final List<Path<Long>> endNodes = new ArrayList<>();\n-        if (_automaton.getNumStates() == 0) {\n-            return Collections.emptyList();\n-        }\n+  public static final class Path<T> {\n+    public final int state;\n+    public final FST.Arc<T> fstNode;\n+    public final T output;\n+    public final IntsRefBuilder input;\n \n-        queue.add(new Path<>(0, _fst\n-                .getFirstArc(new FST.Arc<Long>()), _fst.outputs.getNoOutput(),\n-                new IntsRefBuilder()));\n-\n-        final FST.Arc<Long> scratchArc = new FST.Arc<>();\n-        final FST.BytesReader fstReader = _fst.getBytesReader();\n-\n-        Transition t = new Transition();\n-        while (queue.size() != 0) {\n-            final Path<Long> path = queue.remove(queue.size() - 1);\n-            if (_automaton.isAccept(path.state)) {\n-                if (path.fstNode.isFinal()) {\n-                    endNodes.add(path);\n-                }\n-            }\n-\n-            IntsRefBuilder currentInput = path.input;\n-            int count = _automaton.initTransition(path.state, t);\n-            for (int i = 0; i < count; i++) {\n-                _automaton.getNextTransition(t);\n-                final int min = t.min;\n-                final int max = t.max;\n-                if (min == max) {\n-                    final FST.Arc<Long> nextArc = _fst.findTargetArc(t.min,\n-                            path.fstNode, scratchArc, fstReader);\n-                    if (nextArc != null) {\n-                        final IntsRefBuilder newInput = new IntsRefBuilder();\n-                        newInput.copyInts(currentInput.get());\n-                        newInput.append(t.min);\n-                        queue.add(new Path<Long>(t.dest, new FST.Arc<Long>()\n-                                .copyFrom(nextArc), _fst.outputs.add(path.output, nextArc.output), newInput));\n-                    }\n-                } else {\n-                    FST.Arc<Long> nextArc = Util.readCeilArc(min, _fst, path.fstNode,\n-                            scratchArc, fstReader);\n-                    while (nextArc != null && nextArc.label <= max) {\n-                        final IntsRefBuilder newInput = new IntsRefBuilder();\n-                        newInput.copyInts(currentInput.get());\n-                        newInput.append(nextArc.label);\n-                        queue.add(new Path<>(t.dest, new FST.Arc<Long>()\n-                                .copyFrom(nextArc), _fst.outputs\n-                                .add(path.output, nextArc.output), newInput));\n-                        nextArc = nextArc.isLast() ? null : _fst.readNextRealArc(nextArc,\n-                                fstReader);\n-                    }\n-                }\n-            }\n-        }\n-        ArrayList<Long> matchedIds = new ArrayList<>();\n-        for (Path<Long> path : endNodes) {\n-            matchedIds.add(path.output);\n-        }\n-        return matchedIds;\n+    public Path(int state, FST.Arc<T> fstNode, T output, IntsRefBuilder input) {\n+      this.state = state;\n+      this.fstNode = fstNode;\n+      this.output = output;\n+      this.input = input;\n     }\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk3Nw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515320977", "bodyText": "Explanation of algorithm would be great", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.core.util.fst;\n+\n+import org.apache.lucene.util.IntsRefBuilder;\n+import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.CharacterRunAutomaton;\n+import org.apache.lucene.util.automaton.RegExp;\n+import org.apache.lucene.util.automaton.Transition;\n+import org.apache.lucene.util.fst.FST;\n+import org.apache.lucene.util.fst.Util;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public class RegexpMatcher {\n+    public static final Logger LOGGER =\n+            LoggerFactory.getLogger(FSTBuilder.class);\n+\n+    private final String _regexQuery;\n+    private final FST<Long> _fst;\n+    private final Automaton _automaton;\n+\n+    public RegexpMatcher(String regexQuery, FST<Long> fst) {\n+        _regexQuery = regexQuery;\n+        _fst = fst;\n+        _automaton = (new RegExp(_regexQuery)).toAutomaton();\n+\n+    }\n+\n+    public static final class Path<T> {\n+        public final int state;\n+        public final FST.Arc<T> fstNode;\n+        public final T output;\n+        public final IntsRefBuilder input;\n+\n+        public Path(int state, FST.Arc<T> fstNode, T output, IntsRefBuilder input) {\n+            this.state = state;\n+            this.fstNode = fstNode;\n+            this.output = output;\n+            this.input = input;\n+        }\n+    }\n+\n+    // Matches \"input\" string with _regexQuery Automaton.\n+    public boolean match(String input) {\n+        CharacterRunAutomaton characterRunAutomaton =\n+                new CharacterRunAutomaton(_automaton);\n+        return characterRunAutomaton.run(input);\n+    }\n+\n+    public static List<Long> regexMatch(String regexQuery, FST<Long> fst) throws IOException {\n+        RegexpMatcher matcher = new RegexpMatcher(regexQuery, fst);\n+        return matcher.regexMatchOnFST();\n+    }\n+\n+    public List<Long> regexMatchOnFST() throws IOException {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NTIxMw==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524475213", "bodyText": "Added, let me know if should expand", "author": "pradeepgv42", "createdAt": "2020-11-16T18:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMDk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java\nindex 1f870fe437..76447adea9 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/util/fst/RegexpMatcher.java\n\n@@ -33,106 +33,132 @@ import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n+\n+/**\n+ * RegexpMatcher is a helper to retrieve matching values for a given regexp query.\n+ * Regexp query is converted into an automaton and we run the matching algorithm on FST.\n+ *\n+ * Two main functions of this class are\n+ *   regexMatchOnFST() Function runs matching on FST (See function comments for more details)\n+ *   match(input) Function builds the automaton and matches given input.\n+ */\n public class RegexpMatcher {\n-    public static final Logger LOGGER =\n-            LoggerFactory.getLogger(FSTBuilder.class);\n+  public static final Logger LOGGER = LoggerFactory.getLogger(FSTBuilder.class);\n \n-    private final String _regexQuery;\n-    private final FST<Long> _fst;\n-    private final Automaton _automaton;\n+  private final String _regexQuery;\n+  private final FST<Long> _fst;\n+  private final Automaton _automaton;\n \n-    public RegexpMatcher(String regexQuery, FST<Long> fst) {\n-        _regexQuery = regexQuery;\n-        _fst = fst;\n-        _automaton = (new RegExp(_regexQuery)).toAutomaton();\n+  public RegexpMatcher(String regexQuery, FST<Long> fst) {\n+    _regexQuery = regexQuery;\n+    _fst = fst;\n+    _automaton = (new RegExp(_regexQuery)).toAutomaton();\n+  }\n \n+  public static List<Long> regexMatch(String regexQuery, FST<Long> fst)\n+      throws IOException {\n+    RegexpMatcher matcher = new RegexpMatcher(regexQuery, fst);\n+    return matcher.regexMatchOnFST();\n+  }\n+\n+  // Matches \"input\" string with _regexQuery Automaton.\n+  public boolean match(String input) {\n+    CharacterRunAutomaton characterRunAutomaton = new CharacterRunAutomaton(_automaton);\n+    return characterRunAutomaton.run(input);\n+  }\n+\n+  /**\n+   * This function runs matching on automaton built from regexQuery and the FST.\n+   * FST stores key (string) to a value (Long). Both are state machines and state transition is based on\n+   * a input character.\n+   *\n+   * This algorithm starts with Queue containing (Automaton Start Node, FST Start Node).\n+   * Each step an entry is popped from the queue:\n+   *    1) if the automaton state is accept and the FST Node is final (i.e. end node) then the value stored for that FST\n+   *       is added to the set of result.\n+   *    2) Else next set of transitions on automaton are gathered and for each transition target node for that character\n+   *       is figured out in FST Node, resulting pair of (automaton state, fst node) are added to the queue.\n+   *    3) This process is bound to complete since we are making progression on the FST (which is a DAG) towards final\n+   *       nodes.\n+   * @return\n+   * @throws IOException\n+   */\n+  public List<Long> regexMatchOnFST()\n+      throws IOException {\n+    final List<Path<Long>> queue = new ArrayList<>();\n+    final List<Path<Long>> endNodes = new ArrayList<>();\n+    if (_automaton.getNumStates() == 0) {\n+      return Collections.emptyList();\n     }\n \n-    public static final class Path<T> {\n-        public final int state;\n-        public final FST.Arc<T> fstNode;\n-        public final T output;\n-        public final IntsRefBuilder input;\n-\n-        public Path(int state, FST.Arc<T> fstNode, T output, IntsRefBuilder input) {\n-            this.state = state;\n-            this.fstNode = fstNode;\n-            this.output = output;\n-            this.input = input;\n+    // Automaton start state and FST start node is added to the queue.\n+    queue.add(new Path<>(0, _fst.getFirstArc(new FST.Arc<Long>()), _fst.outputs.getNoOutput(), new IntsRefBuilder()));\n+\n+    final FST.Arc<Long> scratchArc = new FST.Arc<>();\n+    final FST.BytesReader fstReader = _fst.getBytesReader();\n+\n+    Transition t = new Transition();\n+    while (queue.size() != 0) {\n+      final Path<Long> path = queue.remove(queue.size() - 1);\n+\n+      // If automaton is in accept state and the fstNode is final (i.e. end node) then add the entry to endNodes which\n+      // contains the result set.\n+      if (_automaton.isAccept(path.state)) {\n+        if (path.fstNode.isFinal()) {\n+          endNodes.add(path);\n         }\n-    }\n+      }\n \n-    // Matches \"input\" string with _regexQuery Automaton.\n-    public boolean match(String input) {\n-        CharacterRunAutomaton characterRunAutomaton =\n-                new CharacterRunAutomaton(_automaton);\n-        return characterRunAutomaton.run(input);\n+      // Gather next set of transitions on automaton and find target nodes in FST.\n+      IntsRefBuilder currentInput = path.input;\n+      int count = _automaton.initTransition(path.state, t);\n+      for (int i = 0; i < count; i++) {\n+        _automaton.getNextTransition(t);\n+        final int min = t.min;\n+        final int max = t.max;\n+        if (min == max) {\n+          final FST.Arc<Long> nextArc = _fst.findTargetArc(t.min, path.fstNode, scratchArc, fstReader);\n+          if (nextArc != null) {\n+            final IntsRefBuilder newInput = new IntsRefBuilder();\n+            newInput.copyInts(currentInput.get());\n+            newInput.append(t.min);\n+            queue.add(new Path<Long>(t.dest, new FST.Arc<Long>().copyFrom(nextArc),\n+                _fst.outputs.add(path.output, nextArc.output), newInput));\n+          }\n+        } else {\n+          FST.Arc<Long> nextArc = Util.readCeilArc(min, _fst, path.fstNode, scratchArc, fstReader);\n+          while (nextArc != null && nextArc.label <= max) {\n+            final IntsRefBuilder newInput = new IntsRefBuilder();\n+            newInput.copyInts(currentInput.get());\n+            newInput.append(nextArc.label);\n+            queue.add(\n+                new Path<>(t.dest, new FST.Arc<Long>().copyFrom(nextArc), _fst.outputs.add(path.output, nextArc.output),\n+                    newInput));\n+            nextArc = nextArc.isLast() ? null : _fst.readNextRealArc(nextArc, fstReader);\n+          }\n+        }\n+      }\n     }\n \n-    public static List<Long> regexMatch(String regexQuery, FST<Long> fst) throws IOException {\n-        RegexpMatcher matcher = new RegexpMatcher(regexQuery, fst);\n-        return matcher.regexMatchOnFST();\n+    // From the result set of matched entries gather the values stored and return.\n+    ArrayList<Long> matchedIds = new ArrayList<>();\n+    for (Path<Long> path : endNodes) {\n+      matchedIds.add(path.output);\n     }\n+    return matchedIds;\n+  }\n \n-    public List<Long> regexMatchOnFST() throws IOException {\n-        final List<Path<Long>> queue = new ArrayList<>();\n-        final List<Path<Long>> endNodes = new ArrayList<>();\n-        if (_automaton.getNumStates() == 0) {\n-            return Collections.emptyList();\n-        }\n+  public static final class Path<T> {\n+    public final int state;\n+    public final FST.Arc<T> fstNode;\n+    public final T output;\n+    public final IntsRefBuilder input;\n \n-        queue.add(new Path<>(0, _fst\n-                .getFirstArc(new FST.Arc<Long>()), _fst.outputs.getNoOutput(),\n-                new IntsRefBuilder()));\n-\n-        final FST.Arc<Long> scratchArc = new FST.Arc<>();\n-        final FST.BytesReader fstReader = _fst.getBytesReader();\n-\n-        Transition t = new Transition();\n-        while (queue.size() != 0) {\n-            final Path<Long> path = queue.remove(queue.size() - 1);\n-            if (_automaton.isAccept(path.state)) {\n-                if (path.fstNode.isFinal()) {\n-                    endNodes.add(path);\n-                }\n-            }\n-\n-            IntsRefBuilder currentInput = path.input;\n-            int count = _automaton.initTransition(path.state, t);\n-            for (int i = 0; i < count; i++) {\n-                _automaton.getNextTransition(t);\n-                final int min = t.min;\n-                final int max = t.max;\n-                if (min == max) {\n-                    final FST.Arc<Long> nextArc = _fst.findTargetArc(t.min,\n-                            path.fstNode, scratchArc, fstReader);\n-                    if (nextArc != null) {\n-                        final IntsRefBuilder newInput = new IntsRefBuilder();\n-                        newInput.copyInts(currentInput.get());\n-                        newInput.append(t.min);\n-                        queue.add(new Path<Long>(t.dest, new FST.Arc<Long>()\n-                                .copyFrom(nextArc), _fst.outputs.add(path.output, nextArc.output), newInput));\n-                    }\n-                } else {\n-                    FST.Arc<Long> nextArc = Util.readCeilArc(min, _fst, path.fstNode,\n-                            scratchArc, fstReader);\n-                    while (nextArc != null && nextArc.label <= max) {\n-                        final IntsRefBuilder newInput = new IntsRefBuilder();\n-                        newInput.copyInts(currentInput.get());\n-                        newInput.append(nextArc.label);\n-                        queue.add(new Path<>(t.dest, new FST.Arc<Long>()\n-                                .copyFrom(nextArc), _fst.outputs\n-                                .add(path.output, nextArc.output), newInput));\n-                        nextArc = nextArc.isLast() ? null : _fst.readNextRealArc(nextArc,\n-                                fstReader);\n-                    }\n-                }\n-            }\n-        }\n-        ArrayList<Long> matchedIds = new ArrayList<>();\n-        for (Path<Long> path : endNodes) {\n-            matchedIds.add(path.output);\n-        }\n-        return matchedIds;\n+    public Path(int state, FST.Arc<T> fstNode, T output, IntsRefBuilder input) {\n+      this.state = state;\n+      this.fstNode = fstNode;\n+      this.output = output;\n+      this.input = input;\n     }\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA0OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321049", "bodyText": "I think you should add another test for enabling FST on raw column (both new and existing) and verify SegmentPreprocessor fails.\nAlso, add tests in LoaderTest similar to text index tests.", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:29Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzEzOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477139", "bodyText": "done, let me know if i missed something", "author": "pradeepgv42", "createdAt": "2020-11-16T18:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\nindex 70d14d3e95..325a17e875 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n\n@@ -207,13 +206,28 @@ public class SegmentPreProcessorTest {\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnRaw()\n+      throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+    _indexLoadingConfig.getNoDictionaryColumns().add(EXISTING_STRING_COL_RAW);\n+    constructV3Segment();\n+    SegmentPreProcessor v3Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v3Processor.process());\n+\n+    constructV1Segment();\n+    SegmentPreProcessor v1Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v1Processor.process());\n+  }\n+\n   @Test\n   public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n     Set<String> fstColumns = new HashSet<>();\n     fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n     _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n \n-    // Create a segment in V3, add a new dict encoded column with text index enabled\n     constructV3Segment();\n     checkFSTIndexCreation(\n             NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA4OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321088", "bodyText": "fix the comment", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:34Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzUwNA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477504", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA4OA=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\nindex 70d14d3e95..325a17e875 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n\n@@ -207,13 +206,28 @@ public class SegmentPreProcessorTest {\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnRaw()\n+      throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+    _indexLoadingConfig.getNoDictionaryColumns().add(EXISTING_STRING_COL_RAW);\n+    constructV3Segment();\n+    SegmentPreProcessor v3Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v3Processor.process());\n+\n+    constructV1Segment();\n+    SegmentPreProcessor v1Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v1Processor.process());\n+  }\n+\n   @Test\n   public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n     Set<String> fstColumns = new HashSet<>();\n     fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n     _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n \n-    // Create a segment in V3, add a new dict encoded column with text index enabled\n     constructV3Segment();\n     checkFSTIndexCreation(\n             NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA5OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321099", "bodyText": "fix the comment?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:36Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled\n+    constructV3Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true, 4);\n+\n+    constructV1Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true,4);\n+  }\n+\n+\n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzU4MQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477581", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTA5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\nindex 70d14d3e95..325a17e875 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n\n@@ -207,13 +206,28 @@ public class SegmentPreProcessorTest {\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnRaw()\n+      throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+    _indexLoadingConfig.getNoDictionaryColumns().add(EXISTING_STRING_COL_RAW);\n+    constructV3Segment();\n+    SegmentPreProcessor v3Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v3Processor.process());\n+\n+    constructV1Segment();\n+    SegmentPreProcessor v1Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v1Processor.process());\n+  }\n+\n   @Test\n   public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n     Set<String> fstColumns = new HashSet<>();\n     fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n     _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n \n-    // Create a segment in V3, add a new dict encoded column with text index enabled\n     constructV3Segment();\n     checkFSTIndexCreation(\n             NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTExMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321111", "bodyText": "fix the comment?", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:39Z", "path": "pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java", "diffHunk": "@@ -198,6 +207,51 @@ public void testEnableTextIndexOnNewColumnRaw()\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled\n+    constructV3Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true, 4);\n+\n+    constructV1Segment();\n+    checkFSTIndexCreation(\n+            NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n+            true, true,4);\n+  }\n+\n+\n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnDictEncoded() throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_DICT);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+\n+    // Create a segment in V3, add a new dict encoded column with text index enabled\n+    constructV3Segment();\n+    SegmentMetadataImpl segmentMetadata = new SegmentMetadataImpl(_indexDir);\n+    ColumnMetadata columnMetadata = segmentMetadata.getColumnMetadataFor(\n+            EXISTING_STRING_COL_DICT);\n+    // column exists and does not have text index enabled", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzY2OA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477668", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-11-16T18:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTExMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\nindex 70d14d3e95..325a17e875 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/core/segment/index/loader/SegmentPreProcessorTest.java\n\n@@ -207,13 +206,28 @@ public class SegmentPreProcessorTest {\n     checkTextIndexCreation(NEWLY_ADDED_STRING_COL_RAW, 1, 1, _newColumnsSchemaWithText, true, true, true, 4);\n   }\n \n+  @Test\n+  public void testEnableFSTIndexOnExistingColumnRaw()\n+      throws Exception {\n+    Set<String> fstColumns = new HashSet<>();\n+    fstColumns.add(EXISTING_STRING_COL_RAW);\n+    _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n+    _indexLoadingConfig.getNoDictionaryColumns().add(EXISTING_STRING_COL_RAW);\n+    constructV3Segment();\n+    SegmentPreProcessor v3Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v3Processor.process());\n+\n+    constructV1Segment();\n+    SegmentPreProcessor v1Processor = new SegmentPreProcessor(_indexDir, _indexLoadingConfig, _newColumnsSchema4);\n+    Assert.expectThrows(UnsupportedOperationException.class, () -> v1Processor.process());\n+  }\n+\n   @Test\n   public void testEnableFSTIndexOnNewColumnDictEncoded() throws Exception {\n     Set<String> fstColumns = new HashSet<>();\n     fstColumns.add(NEWLY_ADDED_FST_COL_DICT);\n     _indexLoadingConfig.setFSTIndexColumns(fstColumns);\n \n-    // Create a segment in V3, add a new dict encoded column with text index enabled\n     constructV3Segment();\n     checkFSTIndexCreation(\n             NEWLY_ADDED_FST_COL_DICT, 1, 1, _newColumnsSchema4,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTIwMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321201", "bodyText": "I suggest adding tests for both aggregation and selection queries.\nAlso, test both segment level and inter segment execution. I initially didn't add text index tests for inter segment and there were few multi-threading related bugs in how I was using lucene parser.\nTest both PQL and SQL. You may want to see example tests in TextSearchQueriesTest.java for sample tests.", "author": "siddharthteotia", "createdAt": "2020-10-30T19:12:50Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Operator;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.AggregationGroupByOperator;\n+import org.apache.pinot.core.query.aggregation.groupby.AggregationGroupByResult;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupKeyGenerator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.config.table.FieldConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.pinot.spi.utils.builder.TableConfigBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class FSTBasedRegexpLikeQueriesTest extends BaseQueriesTest {\n+    private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"TextSearchQueriesTest\");\n+    private static final String TABLE_NAME = \"MyTable\";\n+    private static final String SEGMENT_NAME = \"testSegment\";\n+    private static final String DOMAIN_NAMES_COL = \"DOMAIN_NAMES\";\n+    private static final String URL_COL = \"URL_COL\";\n+    private static final String INT_COL_NAME = \"INT_COL\";\n+    private static final Integer INT_BASE_VALUE = 1000;\n+    private static final Integer NUM_ROWS = 1024;\n+\n+    private final List<GenericRow> _rows = new ArrayList<>();\n+\n+    private IndexSegment _indexSegment;\n+    private List<IndexSegment> _indexSegments;\n+\n+    @Override\n+    protected String getFilter() {\n+        return \"\";\n+    }\n+\n+    @Override\n+    protected IndexSegment getIndexSegment() {\n+        return _indexSegment;\n+    }\n+\n+    @Override\n+    protected List<IndexSegment> getIndexSegments() {\n+        return _indexSegments;\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+            throws Exception {\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+\n+        buildSegment();\n+        IndexLoadingConfig indexLoadingConfig = new IndexLoadingConfig();\n+        Set<String> fstIndexCols = new HashSet<>();\n+        fstIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setFSTIndexColumns(fstIndexCols);\n+\n+        Set<String> invertedIndexCols = new HashSet<>();\n+        invertedIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setInvertedIndexColumns(invertedIndexCols);\n+        ImmutableSegment immutableSegment =\n+                ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), indexLoadingConfig);\n+        _indexSegment = immutableSegment;\n+        _indexSegments = Arrays.asList(immutableSegment, immutableSegment);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        _indexSegment.destroy();\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+    }\n+\n+    private List<String> getURLSufficies() {\n+        return Arrays.asList(\n+                \"/a\", \"/b\", \"/c\", \"/d\"\n+        );\n+    }\n+\n+    private List<String> getDomainNames() {\n+        return Arrays.asList(\n+                \"www.domain1.com\", \"www.domain1.co.ab\", \"www.domain1.co.bc\", \"www.domain1.co.cd\",\n+                \"www.sd.domain1.com\", \"www.sd.domain1.co.ab\", \"www.sd.domain1.co.bc\", \"www.sd.domain1.co.cd\",\n+                \"www.domain2.com\", \"www.domain2.co.ab\", \"www.domain2.co.bc\", \"www.domain2.co.cd\",\n+                \"www.sd.domain2.com\", \"www.sd.domain2.co.ab\", \"www.sd.domain2.co.bc\", \"www.sd.domain2.co.cd\"\n+        );\n+    }\n+\n+    private List<GenericRow> createTestData(int numRows) throws Exception {\n+        List<GenericRow> rows = new ArrayList<>();\n+        List<String> domainNames = getDomainNames();\n+        List<String> urlSufficies = getURLSufficies();\n+        for (int i = 0; i < numRows; i++) {\n+            String domain = domainNames.get(i % domainNames.size());\n+            String url = domain + urlSufficies.get(i % urlSufficies.size());\n+\n+            GenericRow row = new GenericRow();\n+            row.putField(INT_COL_NAME, INT_BASE_VALUE + i);\n+            row.putField(DOMAIN_NAMES_COL, domain);\n+            row.putField(URL_COL, url);\n+            rows.add(row);\n+        }\n+        return rows;\n+    }\n+\n+    private void buildSegment()\n+            throws Exception {\n+        List<GenericRow> rows = createTestData(NUM_ROWS);\n+        List<FieldConfig> fieldConfigs = new ArrayList<>();\n+        fieldConfigs.add(new FieldConfig(\n+                DOMAIN_NAMES_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+        fieldConfigs.add(new FieldConfig(\n+                URL_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+\n+        TableConfig tableConfig = new TableConfigBuilder(TableType.OFFLINE).setTableName(TABLE_NAME)\n+                .setInvertedIndexColumns(Arrays.asList(DOMAIN_NAMES_COL))\n+                .setFieldConfigList(fieldConfigs).build();\n+        Schema schema = new Schema.SchemaBuilder().setSchemaName(TABLE_NAME)\n+                .addSingleValueDimension(DOMAIN_NAMES_COL, FieldSpec.DataType.STRING)\n+                .addSingleValueDimension(URL_COL, FieldSpec.DataType.STRING)\n+                .addMetric(INT_COL_NAME, FieldSpec.DataType.INT).build();\n+        SegmentGeneratorConfig config = new SegmentGeneratorConfig(tableConfig, schema);\n+        config.setOutDir(INDEX_DIR.getPath());\n+        config.setTableName(TABLE_NAME);\n+        config.setSegmentName(SEGMENT_NAME);\n+\n+        SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+        try (RecordReader recordReader = new GenericRowRecordReader(rows)) {\n+            driver.init(config, recordReader);\n+            driver.build();\n+        }\n+    }\n+\n+    private void testSelectionResults(String query, int expectedResultSize)\n+            throws Exception {\n+        Operator<IntermediateResultsBlock> operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock operatorResult = operator.nextBlock();\n+        List<Object[]> resultset = (List<Object[]>) operatorResult.getSelectionResult();\n+        Assert.assertNotNull(resultset);\n+        Assert.assertEquals(resultset.size(), expectedResultSize);\n+    }\n+\n+    private AggregationGroupByResult getGroupByResults(String query)\n+            throws Exception {\n+        AggregationGroupByOperator operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock resultsBlock = operator.nextBlock();\n+        return resultsBlock.getAggregationGroupByResult();\n+    }\n+\n+    private void matchGroupResult(AggregationGroupByResult result, String key, long count) {\n+        Iterator<GroupKeyGenerator.GroupKey> groupKeyIterator = result.getGroupKeyIterator();\n+        while (groupKeyIterator.hasNext()) {\n+            GroupKeyGenerator.GroupKey groupKey = groupKeyIterator.next();\n+            Assert.assertEquals(((Number)result.getResultForKey(groupKey, 0)).longValue(), count);\n+        }\n+    }\n+\n+    @Test\n+    public void testFSTBasedRegexpLike() throws Exception {", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3NzkyMQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524477921", "bodyText": "done, let me know if I should add more tests.", "author": "pradeepgv42", "createdAt": "2020-11-16T18:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTIwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java b/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java\nindex 58af0cba68..8516dd8d06 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java\n\n@@ -18,7 +18,13 @@\n  */\n package org.apache.pinot.queries;\n \n+import java.io.Serializable;\n import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.common.response.broker.AggregationResult;\n+import org.apache.pinot.common.response.broker.BrokerResponseNative;\n+import org.apache.pinot.common.response.broker.ResultTable;\n+import org.apache.pinot.common.response.broker.SelectionResults;\n+import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.core.common.Operator;\n import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n import org.apache.pinot.core.indexsegment.IndexSegment;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTI3NQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r515321275", "bodyText": "You should also add tests for queries where REGEXP_LIKE filter is combined with another filter(s) using AND/OR to ensure the docID intersection/union is working fine.\nAlso combine multiple REGEXP_LIKE using a mix of FST index and no FST index.\nSee tests in TextSearchQueriesTest for examples", "author": "siddharthteotia", "createdAt": "2020-10-30T19:13:00Z", "path": "pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pinot.queries;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.core.common.Operator;\n+import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n+import org.apache.pinot.core.indexsegment.IndexSegment;\n+import org.apache.pinot.core.indexsegment.generator.SegmentGeneratorConfig;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegment;\n+import org.apache.pinot.core.indexsegment.immutable.ImmutableSegmentLoader;\n+import org.apache.pinot.core.operator.blocks.IntermediateResultsBlock;\n+import org.apache.pinot.core.operator.query.AggregationGroupByOperator;\n+import org.apache.pinot.core.query.aggregation.groupby.AggregationGroupByResult;\n+import org.apache.pinot.core.query.aggregation.groupby.GroupKeyGenerator;\n+import org.apache.pinot.core.segment.creator.impl.SegmentIndexCreationDriverImpl;\n+import org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\n+import org.apache.pinot.spi.config.table.FieldConfig;\n+import org.apache.pinot.spi.config.table.TableConfig;\n+import org.apache.pinot.spi.config.table.TableType;\n+import org.apache.pinot.spi.data.FieldSpec;\n+import org.apache.pinot.spi.data.Schema;\n+import org.apache.pinot.spi.data.readers.GenericRow;\n+import org.apache.pinot.spi.data.readers.RecordReader;\n+import org.apache.pinot.spi.utils.builder.TableConfigBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+public class FSTBasedRegexpLikeQueriesTest extends BaseQueriesTest {\n+    private static final File INDEX_DIR = new File(FileUtils.getTempDirectory(), \"TextSearchQueriesTest\");\n+    private static final String TABLE_NAME = \"MyTable\";\n+    private static final String SEGMENT_NAME = \"testSegment\";\n+    private static final String DOMAIN_NAMES_COL = \"DOMAIN_NAMES\";\n+    private static final String URL_COL = \"URL_COL\";\n+    private static final String INT_COL_NAME = \"INT_COL\";\n+    private static final Integer INT_BASE_VALUE = 1000;\n+    private static final Integer NUM_ROWS = 1024;\n+\n+    private final List<GenericRow> _rows = new ArrayList<>();\n+\n+    private IndexSegment _indexSegment;\n+    private List<IndexSegment> _indexSegments;\n+\n+    @Override\n+    protected String getFilter() {\n+        return \"\";\n+    }\n+\n+    @Override\n+    protected IndexSegment getIndexSegment() {\n+        return _indexSegment;\n+    }\n+\n+    @Override\n+    protected List<IndexSegment> getIndexSegments() {\n+        return _indexSegments;\n+    }\n+\n+    @BeforeClass\n+    public void setUp()\n+            throws Exception {\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+\n+        buildSegment();\n+        IndexLoadingConfig indexLoadingConfig = new IndexLoadingConfig();\n+        Set<String> fstIndexCols = new HashSet<>();\n+        fstIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setFSTIndexColumns(fstIndexCols);\n+\n+        Set<String> invertedIndexCols = new HashSet<>();\n+        invertedIndexCols.add(DOMAIN_NAMES_COL);\n+        indexLoadingConfig.setInvertedIndexColumns(invertedIndexCols);\n+        ImmutableSegment immutableSegment =\n+                ImmutableSegmentLoader.load(new File(INDEX_DIR, SEGMENT_NAME), indexLoadingConfig);\n+        _indexSegment = immutableSegment;\n+        _indexSegments = Arrays.asList(immutableSegment, immutableSegment);\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        _indexSegment.destroy();\n+        FileUtils.deleteQuietly(INDEX_DIR);\n+    }\n+\n+    private List<String> getURLSufficies() {\n+        return Arrays.asList(\n+                \"/a\", \"/b\", \"/c\", \"/d\"\n+        );\n+    }\n+\n+    private List<String> getDomainNames() {\n+        return Arrays.asList(\n+                \"www.domain1.com\", \"www.domain1.co.ab\", \"www.domain1.co.bc\", \"www.domain1.co.cd\",\n+                \"www.sd.domain1.com\", \"www.sd.domain1.co.ab\", \"www.sd.domain1.co.bc\", \"www.sd.domain1.co.cd\",\n+                \"www.domain2.com\", \"www.domain2.co.ab\", \"www.domain2.co.bc\", \"www.domain2.co.cd\",\n+                \"www.sd.domain2.com\", \"www.sd.domain2.co.ab\", \"www.sd.domain2.co.bc\", \"www.sd.domain2.co.cd\"\n+        );\n+    }\n+\n+    private List<GenericRow> createTestData(int numRows) throws Exception {\n+        List<GenericRow> rows = new ArrayList<>();\n+        List<String> domainNames = getDomainNames();\n+        List<String> urlSufficies = getURLSufficies();\n+        for (int i = 0; i < numRows; i++) {\n+            String domain = domainNames.get(i % domainNames.size());\n+            String url = domain + urlSufficies.get(i % urlSufficies.size());\n+\n+            GenericRow row = new GenericRow();\n+            row.putField(INT_COL_NAME, INT_BASE_VALUE + i);\n+            row.putField(DOMAIN_NAMES_COL, domain);\n+            row.putField(URL_COL, url);\n+            rows.add(row);\n+        }\n+        return rows;\n+    }\n+\n+    private void buildSegment()\n+            throws Exception {\n+        List<GenericRow> rows = createTestData(NUM_ROWS);\n+        List<FieldConfig> fieldConfigs = new ArrayList<>();\n+        fieldConfigs.add(new FieldConfig(\n+                DOMAIN_NAMES_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+        fieldConfigs.add(new FieldConfig(\n+                URL_COL,\n+                FieldConfig.EncodingType.DICTIONARY,\n+                FieldConfig.IndexType.FST, null));\n+\n+        TableConfig tableConfig = new TableConfigBuilder(TableType.OFFLINE).setTableName(TABLE_NAME)\n+                .setInvertedIndexColumns(Arrays.asList(DOMAIN_NAMES_COL))\n+                .setFieldConfigList(fieldConfigs).build();\n+        Schema schema = new Schema.SchemaBuilder().setSchemaName(TABLE_NAME)\n+                .addSingleValueDimension(DOMAIN_NAMES_COL, FieldSpec.DataType.STRING)\n+                .addSingleValueDimension(URL_COL, FieldSpec.DataType.STRING)\n+                .addMetric(INT_COL_NAME, FieldSpec.DataType.INT).build();\n+        SegmentGeneratorConfig config = new SegmentGeneratorConfig(tableConfig, schema);\n+        config.setOutDir(INDEX_DIR.getPath());\n+        config.setTableName(TABLE_NAME);\n+        config.setSegmentName(SEGMENT_NAME);\n+\n+        SegmentIndexCreationDriverImpl driver = new SegmentIndexCreationDriverImpl();\n+        try (RecordReader recordReader = new GenericRowRecordReader(rows)) {\n+            driver.init(config, recordReader);\n+            driver.build();\n+        }\n+    }\n+\n+    private void testSelectionResults(String query, int expectedResultSize)\n+            throws Exception {\n+        Operator<IntermediateResultsBlock> operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock operatorResult = operator.nextBlock();\n+        List<Object[]> resultset = (List<Object[]>) operatorResult.getSelectionResult();\n+        Assert.assertNotNull(resultset);\n+        Assert.assertEquals(resultset.size(), expectedResultSize);\n+    }\n+\n+    private AggregationGroupByResult getGroupByResults(String query)\n+            throws Exception {\n+        AggregationGroupByOperator operator = getOperatorForPqlQuery(query);\n+        IntermediateResultsBlock resultsBlock = operator.nextBlock();\n+        return resultsBlock.getAggregationGroupByResult();\n+    }\n+\n+    private void matchGroupResult(AggregationGroupByResult result, String key, long count) {\n+        Iterator<GroupKeyGenerator.GroupKey> groupKeyIterator = result.getGroupKeyIterator();\n+        while (groupKeyIterator.hasNext()) {\n+            GroupKeyGenerator.GroupKey groupKey = groupKeyIterator.next();\n+            Assert.assertEquals(((Number)result.getResultForKey(groupKey, 0)).longValue(), count);\n+        }\n+    }\n+\n+    @Test\n+    public void testFSTBasedRegexpLike() throws Exception {\n+        // Select queries on col with FST + inverted index.\n+        String query =\n+                \"SELECT INT_COL, DOMAIN_NAMES FROM MyTable WHERE REGEXP_LIKE(DOMAIN_NAMES, 'www.domain1.*') LIMIT 50000\";\n+        testSelectionResults(query, 256);\n+", "originalCommit": "cfd1d2f0123e08b767aaae9612deac2c4eb11eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3ODAxNA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r524478014", "bodyText": "done, ptal", "author": "pradeepgv42", "createdAt": "2020-11-16T18:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMyMTI3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "chunk": "diff --git a/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java b/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java\nindex 58af0cba68..8516dd8d06 100644\n--- a/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java\n+++ b/pinot-core/src/test/java/org/apache/pinot/queries/FSTBasedRegexpLikeQueriesTest.java\n\n@@ -18,7 +18,13 @@\n  */\n package org.apache.pinot.queries;\n \n+import java.io.Serializable;\n import org.apache.commons.io.FileUtils;\n+import org.apache.pinot.common.response.broker.AggregationResult;\n+import org.apache.pinot.common.response.broker.BrokerResponseNative;\n+import org.apache.pinot.common.response.broker.ResultTable;\n+import org.apache.pinot.common.response.broker.SelectionResults;\n+import org.apache.pinot.common.utils.DataSchema;\n import org.apache.pinot.core.common.Operator;\n import org.apache.pinot.core.data.readers.GenericRowRecordReader;\n import org.apache.pinot.core.indexsegment.IndexSegment;\n"}}, {"oid": "4af2204937dfbf93a01fb939d84c3d11344f0d81", "url": "https://github.com/apache/pinot/commit/4af2204937dfbf93a01fb939d84c3d11344f0d81", "message": "Add some more comments", "committedDate": "2020-11-16T09:17:30Z", "type": "forcePushed"}, {"oid": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "url": "https://github.com/apache/pinot/commit/d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "message": "fix some more review comment", "committedDate": "2020-11-16T18:09:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzEzOQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203139", "bodyText": "isCreateDictionaryForColumn() is the correct method to be used for checking if dictionary is to be created or not. indexCreationInfo.isCreateDictionary() will always return true currently", "author": "siddharthteotia", "createdAt": "2020-12-19T06:59:38Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -216,6 +225,17 @@ public void init(SegmentGeneratorConfig segmentCreationSpec, SegmentIndexCreatio\n             .put(columnName, new LuceneTextIndexCreator(columnName, _indexDir, true /* commitOnClose */));\n       }\n \n+      if (_fstIndexColumns.contains(columnName)) {\n+        Preconditions.checkState(fieldSpec.isSingleValueField(),\n+            \"FST index is currently only supported on single-value columns\");\n+        Preconditions.checkState(fieldSpec.getDataType() == DataType.STRING,\n+            \"FST index is only supported on STRING type columns\");\n+        Preconditions.checkState(indexCreationInfo.isCreateDictionary(),", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0Mzc5Mg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546543792", "bodyText": "Done", "author": "pradeepgv42", "createdAt": "2020-12-21T07:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzEzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "74bda88d3ad0c1cc2d1c4d06888171713181ba7f", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\nindex ace8637e74..e388a37bcb 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java\n\n@@ -230,7 +233,7 @@ public class SegmentColumnarIndexCreator implements SegmentCreator {\n             \"FST index is currently only supported on single-value columns\");\n         Preconditions.checkState(fieldSpec.getDataType() == DataType.STRING,\n             \"FST index is only supported on STRING type columns\");\n-        Preconditions.checkState(indexCreationInfo.isCreateDictionary(),\n+        Preconditions.checkState(dictEnabledColumn,\n             \"FST index is currently only supported on dictionary columns\");\n         _fstIndexCreatorMap.put(columnName, new LuceneFSTIndexCreator(_indexDir, columnName,\n             (String[]) indexCreationInfo.getSortedUniqueElementsArray()));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQxNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203416", "bodyText": "This is probably not needed right? In fact, may be should add a new enum to TEXT_INDEX_TYPE to something like LUCENE_FST. TEXT_INDEX_TYPE is already serialized in on-disk metadata so just extend it to capture FST", "author": "siddharthteotia", "createdAt": "2020-12-19T07:03:33Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/creator/impl/SegmentColumnarIndexCreator.java", "diffHunk": "@@ -515,6 +540,7 @@ public static void addColumnMetadataInfo(PropertiesConfiguration properties, Str\n     properties.setProperty(getKeyFor(column, HAS_DICTIONARY), String.valueOf(hasDictionary));\n     properties.setProperty(getKeyFor(column, TEXT_INDEX_TYPE), textIndexType.name());\n     properties.setProperty(getKeyFor(column, HAS_INVERTED_INDEX), String.valueOf(hasInvertedIndex));\n+    properties.setProperty(getKeyFor(column, HAS_FST_INDEX), String.valueOf(hasFSTIndex));", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0Njg4OQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546546889", "bodyText": "Wouldn't this make only one of the indicies be available?", "author": "pradeepgv42", "createdAt": "2020-12-21T07:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQxNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQ4Ng==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203486", "bodyText": "Add javadoc", "author": "siddharthteotia", "createdAt": "2020-12-19T07:04:04Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/ColumnIndexContainer.java", "diffHunk": "@@ -52,6 +52,8 @@\n    */\n   TextIndexReader getTextIndex();\n \n+  TextIndexReader getFSTIndex();", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjU0MzgzNQ==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546543835", "bodyText": "done", "author": "pradeepgv42", "createdAt": "2020-12-21T07:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "74bda88d3ad0c1cc2d1c4d06888171713181ba7f", "chunk": "diff --git a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/ColumnIndexContainer.java b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/ColumnIndexContainer.java\nindex ec773109d2..11e7b9ac7b 100644\n--- a/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/ColumnIndexContainer.java\n+++ b/pinot-core/src/main/java/org/apache/pinot/core/segment/index/column/ColumnIndexContainer.java\n\n@@ -52,6 +52,9 @@ public interface ColumnIndexContainer extends Closeable {\n    */\n   TextIndexReader getTextIndex();\n \n+  /**\n+   * Returns the fst index for the column, or {@code null} if it does not exist.\n+   */\n   TextIndexReader getFSTIndex();\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIwMzYyMA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r546203620", "bodyText": "hasFSTIndex is not needed", "author": "siddharthteotia", "createdAt": "2020-12-19T07:05:39Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/loader/defaultcolumn/BaseDefaultColumnHandler.java", "diffHunk": "@@ -411,6 +411,7 @@ protected void createColumnV1Indices(String column)\n     // Add the column metadata information to the metadata properties.\n     SegmentColumnarIndexCreator\n         .addColumnMetadataInfo(_segmentProperties, column, columnIndexCreationInfo, totalDocs, fieldSpec,\n-            true/*hasDictionary*/, dictionaryElementSize, true/*hasInvertedIndex*/, TextIndexType.NONE);\n+            true/*hasDictionary*/, dictionaryElementSize, true/*hasInvertedIndex*/,\n+            false/*hasFSTIndex*/, TextIndexType.NONE);", "originalCommit": "d14596e98662ec1c8779fee809b94d2cb1fc9ecc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "74bda88d3ad0c1cc2d1c4d06888171713181ba7f", "url": "https://github.com/apache/pinot/commit/74bda88d3ad0c1cc2d1c4d06888171713181ba7f", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-21T07:10:09Z", "type": "forcePushed"}, {"oid": "e18bedaa199ab6f4b4a3cfea1a40d28121de16ab", "url": "https://github.com/apache/pinot/commit/e18bedaa199ab6f4b4a3cfea1a40d28121de16ab", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-23T02:15:28Z", "type": "forcePushed"}, {"oid": "d0405e711f490214a9da9d6bc9e437d5b849305f", "url": "https://github.com/apache/pinot/commit/d0405e711f490214a9da9d6bc9e437d5b849305f", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-24T02:37:39Z", "type": "commit"}, {"oid": "d0405e711f490214a9da9d6bc9e437d5b849305f", "url": "https://github.com/apache/pinot/commit/d0405e711f490214a9da9d6bc9e437d5b849305f", "message": "Add FST index which works on top of REGEXP_LIKE operator.\nThis index is set to enable only on dictionary encoded string column.", "committedDate": "2020-12-24T02:37:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjQxNg==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r556852416", "bodyText": "HAS_FST_INDEX", "author": "xiangfu0", "createdAt": "2021-01-13T21:35:20Z", "path": "pinot-core/src/main/java/org/apache/pinot/core/segment/index/metadata/ColumnMetadata.java", "diffHunk": "@@ -97,6 +98,7 @@ public static ColumnMetadata fromPropertiesConfiguration(String column, Properti\n     builder.setContainsNulls(config.getBoolean(getKeyFor(column, HAS_NULL_VALUE)));\n     builder.setHasDictionary(config.getBoolean(getKeyFor(column, HAS_DICTIONARY), true));\n     builder.setHasInvertedIndex(config.getBoolean(getKeyFor(column, HAS_INVERTED_INDEX)));\n+    builder.setHasFSTIndex(config.getBoolean(getKeyFor(column, HAS_INVERTED_INDEX), false));", "originalCommit": "d0405e711f490214a9da9d6bc9e437d5b849305f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NTMxOA==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r556865318", "bodyText": "ah yup that's correct, let me fix it", "author": "pradeepgv42", "createdAt": "2021-01-13T21:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUyNzY5Ng==", "url": "https://github.com/apache/pinot/pull/6120#discussion_r557527696", "bodyText": "Here is the fix: #6441", "author": "pradeepgv42", "createdAt": "2021-01-14T16:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjQxNg=="}], "type": "inlineReview", "revised_code": null}]}